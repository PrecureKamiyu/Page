<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 9. Process Credentials</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch08.html" title="Chapter 8. Users and Groups"/><link rel="next" href="ch10.html" title="Chapter 10. Time"/></head><body><section class="chapter" title="Chapter 9. Process Credentials" epub:type="chapter" id="process_credentials"><div class="titlepage"><div><div><h2 class="title">Chapter 9. Process Credentials</h2></div></div></div><p>Every process has a set of associated numeric user identifiers (UIDs) and group
            identifiers (GIDs). Sometimes, these are referred to as process credentials. These
            identifiers are as follows:<a id="IDX-CHP-9-1164" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>real user ID and group ID;<a id="IDX-CHP-9-1165" class="indexterm"/></p></li><li class="listitem"><p>effective user ID and group ID;</p></li><li class="listitem"><p>saved set-user-ID and saved set-group-ID;</p></li><li class="listitem"><p>file-system user ID and group ID (Linux-specific); and</p></li><li class="listitem"><p>supplementary group IDs.</p></li></ul></div><p>In this chapter, we look in detail at the purpose of these process identifiers and
            describe the system calls and library functions that can be used to retrieve and change
            them. We also discuss the notion of privileged and unprivileged processes, and the use
            of the set-user-ID and set-group-ID mechanisms, which allow the creation of programs
            that run with the privileges of a specified user or group.</p><div class="sect1" title="Real User ID and Real Group ID"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="real_user_id_and_real_group_id">Real User ID and Real Group ID</h2></div></div></div><p>The real user ID and group ID identify the user and group to which the process
                belongs. As part of the login process, a login shell gets its real user and group
                IDs from the third and fourth fields of the user’s password record in the <code class="literal">/etc/passwd</code> file (<a class="xref" href="ch08.html#the_password_file_colon__solidus_etc_sol" title="The Password File: /etc/passwd">The Password File: <code class="literal">/etc/passwd</code></a>). When a new process is
                created (e.g., when the shell executes a program), it inherits these identifiers
                from its parent.<a id="IDX-CHP-9-1166" class="indexterm"/></p></div><div class="sect1" title="Effective User ID and Effective Group ID"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="effective_user_id_and_effective_group_id">Effective User ID and Effective Group ID</h2></div></div></div><p>On most UNIX implementations (Linux is a little different, as explained in <a class="xref" href="ch09.html#file-system_user_id_and_file-system_grou" title="File-System User ID and File-System Group ID">File-System User ID and File-System Group ID</a>), the effective user ID and
                group ID, in conjunction with the supplementary group IDs, are used to determine the
                permissions granted to a process when it tries to perform various operations (i.e.,
                system calls). For example, these identifiers determine the permissions granted to a
                process when it accesses resources such as files and System V interprocess
                communication (IPC) objects, which themselves have associated user and group IDs
                determining to whom they belong. As we’ll see in <a class="xref" href="ch20.html#sending_signals_colon_kill_open_parenthe" title="Sending Signals: kill()">Sending Signals: <span class="emphasis"><em>kill()</em></span></a>, the effective user ID is
                also used by the kernel to determine whether one process can send a signal to
                    another.<a id="IDX-CHP-9-1167" class="indexterm"/><a id="IDX-CHP-9-1168" class="indexterm"/></p><p>A process whose effective user ID is 0 (the user ID of <span class="emphasis"><em>root</em></span>)
                has all of the privileges of the superuser. Such a process is referred to as a
                    <span class="emphasis"><em>privileged process</em></span>. Certain system calls can be executed
                only by privileged processes.<a id="IDX-CHP-9-1169" class="indexterm"/><a id="IDX-CHP-9-1170" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In <a class="xref" href="ch39.html" title="Chapter 39. Capabilities">Chapter 39</a>, we describe Linux’s implementation of
                    capabilities, a scheme that divides the privileges granted to the superuser into
                    a number of distinct units that can be independently enabled and
                    disabled.</p></div><p>Normally, the effective user and group IDs have the same values as the
                corresponding real IDs, but there are two ways in which the effective IDs can assume
                different values. One way is through the use of system calls that we discuss in
                Section 9.7. The second way is through the execution of set-user-ID and set-group-ID
                programs.</p></div><div class="sect1" title="Set-User-ID and Set-Group-ID Programs"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="set-user-id_and_set-group-id_programs">Set-User-ID and Set-Group-ID Programs</h2></div></div></div><p>A set-user-ID program allows a process to gain privileges it would not normally
                have, by setting the process’s effective user ID to the same value as the user ID
                (owner) of the executable file. A set-group-ID program performs the analogous task
                for the process’s effective group ID. (The terms <span class="emphasis"><em>set-user-ID
                    program</em></span> and <span class="emphasis"><em>set-group-ID</em></span> program are sometimes
                abbreviated as <span class="emphasis"><em>set-UID program</em></span> and <span class="emphasis"><em>set-GID
                    program</em></span>.)<a id="IDX-CHP-9-1171" class="indexterm"/><a id="IDX-CHP-9-1172" class="indexterm"/><a id="IDX-CHP-9-1173" class="indexterm"/><a id="IDX-CHP-9-1174" class="indexterm"/><a id="IDX-CHP-9-1175" class="indexterm"/><a id="IDX-CHP-9-1176" class="indexterm"/><a id="IDX-CHP-9-1177" class="indexterm"/><a id="IDX-CHP-9-1178" class="indexterm"/><a id="IDX-CHP-9-1179" class="indexterm"/><a id="IDX-CHP-9-1180" class="indexterm"/></p><p>Like any other file, an executable program file has an associated user ID and
                group ID that define the ownership of the file. In addition, an executable file has
                two special permission bits: the set-user-ID and set-group-ID bits. (In fact, every
                file has these two permission bits, but it is their use with executable files that
                interests us here.) These permission bits are set using the
                    <span class="emphasis"><em>chmod</em></span> command. An unprivileged user can set these bits for
                files that they own. A privileged user (<code class="literal">CAP_FOWNER</code>) can set these bits for any file. Here’s an
                example:</p><a id="I_programlisting9_d1e19759"/><pre class="programlisting">$ <strong class="userinput"><code>su</code></strong>

Password:
# <strong class="userinput"><code>ls -l prog</code></strong>

-rwxr-xr-x    1 root     root       302585 Jun 26 15:05 prog
# <strong class="userinput"><code>chmod u+s prog</code></strong>                        <em class="lineannotation"><span class="lineannotation">Turn on set-user-ID permission bit</span></em>

# <strong class="userinput"><code>chmod g+s prog</code></strong>
                        <em class="lineannotation"><span class="lineannotation">Turn on set-group-ID permission bit</span></em></pre><p>As shown in this example, it is possible for a program to have both of these bits
                set, although this is uncommon. When <span class="emphasis"><em>ls -l</em></span> is used to list the
                permissions for a program that has the set-user-ID or set-group-ID permission bit
                set, then the <span class="emphasis"><em>x</em></span> that is normally used to indicate that execute
                permission is set is replaced by an <span class="emphasis"><em>s</em></span>:<a id="IDX-CHP-9-1181" class="indexterm"/><a id="IDX-CHP-9-1182" class="indexterm"/></p><a id="I_programlisting9_d1e19796"/><pre class="programlisting"># <strong class="userinput"><code>ls -l prog</code></strong>

-rwsr-sr-x    1 root     root       302585 Jun 26 15:05 prog</pre><p>When a set-user-ID program is run (i.e., loaded into a process’s memory by an
                    <span class="emphasis"><em>exec()</em></span>), the kernel sets the effective user ID of the
                process to be the same as the user ID of the executable file. Running a set-group-ID
                program has an analogous effect for the effective group ID of the process. Changing
                the effective user or group ID in this way gives a process (in other words, the user
                executing the program) privileges it would not normally have. For example, if an
                executable file is owned by <span class="emphasis"><em>root</em></span> (superuser) and has the
                set-user-ID permission bit enabled, then the process gains superuser privileges when
                that program is run.</p><p>Set-user-ID and set-group-ID programs can also be designed to change the effective
                IDs of a process to something other than <span class="emphasis"><em>root</em></span>. For example, to
                provide access to a protected file (or other system resource), it may suffice to
                create a special-purpose user (group) ID that has the privileges required to access
                the file, and create a set-user-ID (set-group-ID) program that changes the effective
                user (group) ID of a process to that ID. This permits the program to access the file
                without allowing it all of the privileges of the superuser.</p><p>Sometimes, we’ll use the term set-user-ID-<span class="emphasis"><em>root</em></span> to distinguish
                a set-user-ID program that is owned by <span class="emphasis"><em>root</em></span> from one owned by
                another user, which merely gives a process the privileges accorded to that
                user.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>We have now started using the term <span class="emphasis"><em>privileged</em></span> in two
                    different senses. One is the sense defined earlier: a process with an effective
                    user ID of 0, which has all of the privileges accorded to
                        <span class="emphasis"><em>root</em></span>. However, when we are talking about a set-user-ID
                    program owned by a user other than <span class="emphasis"><em>root</em></span>, we’ll sometimes
                    refer to a process as gaining the privileges accorded to the user ID of the
                    set-user-ID program. Which sense of the term <span class="emphasis"><em>privileged</em></span> we
                    mean in each case should be clear from the context.</p><p>For reasons that we explain in <a class="xref" href="ch38.html#be_careful_when_executing_a_program" title="Be Careful When Executing a Program">Be Careful When Executing a Program</a>, the set-user-ID and
                    set-group-ID permission bits don’t have any effect for shell scripts on
                    Linux.</p></div><p>Examples of commonly used set-user-ID programs on Linux include:
                    <span class="emphasis"><em>passwd(1)</em></span>, which changes a user’s password;
                    <span class="emphasis"><em>mount(8)</em></span> and <span class="emphasis"><em>umount(8)</em></span>, which mount
                and unmount file systems; and <span class="emphasis"><em>su(1)</em></span>, which allows a user to run
                a shell under a different user ID. An example of a set-group-ID program is
                    <span class="emphasis"><em>wall(1)</em></span>, which writes a message to all terminals owned by
                the <span class="emphasis"><em>tty</em></span> group (normally, every terminal is owned by this
                    group).<a id="IDX-CHP-9-1183" class="indexterm"/></p><p>In <a class="xref" href="ch08.html#password_encryption_and_user_authenticat" title="Password Encryption and User Authentication">Password Encryption and User Authentication</a>, we noted that the
                program in <a class="xref" href="ch08.html#authenticating_a_user_against_the_shadow" title="Example 8-2. Authenticating a user against the shadow password file">Example 8-2</a> needed to be
                run from a <span class="emphasis"><em>root</em></span> login so that it could access the <code class="literal">/etc/shadow</code> file. We could make this program runnable
                by any user by making it a set-user-ID-<span class="emphasis"><em>root</em></span> program, as
                follows:</p><a id="I_programlisting9_d1e19883"/><pre class="programlisting">$ <strong class="userinput"><code>su</code></strong>

Password:
# <strong class="userinput"><code>chown root check_password</code></strong>             <em class="lineannotation"><span class="lineannotation">Make this program owned by root</span></em>

# <strong class="userinput"><code>chmod u+s check_password</code></strong>              <em class="lineannotation"><span class="lineannotation">With the set-user-ID bit enabled</span></em>
# <strong class="userinput"><code>ls -l check_password</code></strong>

-rwsr-xr-x    1 root   users    18150 Oct 28 10:49 check_password
# <strong class="userinput"><code>exit</code></strong>

$ <strong class="userinput"><code>whoami</code></strong>                                <em class="lineannotation"><span class="lineannotation">This is an unprivileged login</span></em>

mtk
$ <strong class="userinput"><code>./check_password</code></strong>                      <em class="lineannotation"><span class="lineannotation">But we can now access the shadow</span></em>

Username: <strong class="userinput"><code>avr</code></strong>                           <em class="lineannotation"><span class="lineannotation">password file using this program</span></em>

Password:
Successfully authenticated: UID=1001</pre><p>The set-user-ID/set-group-ID technique is a useful and powerful tool, but one that
                can result in security breaches in applications that are poorly designed. In <a class="xref" href="ch38.html" title="Chapter 38. Writing Secure Privileged Programs">Chapter 38</a>, we list a set of good practices
                that should be observed when writing set-user-ID and set-group-ID programs.</p></div><div class="sect1" title="Saved Set-User-ID and Saved Set-Group-ID"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="saved_set-user-id_and_saved_set-group-id">Saved Set-User-ID and Saved Set-Group-ID</h2></div></div></div><p>The saved set-user-ID and saved set-group-ID are designed for use with set-user-ID
                and set-group-ID programs. When a program is executed, the following steps (among
                many others) occur:<a id="IDX-CHP-9-1184" class="indexterm"/><a id="IDX-CHP-9-1185" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>If the set-user-ID (set-group-ID) permission bit is enabled on the
                        executable, then the effective user (group) ID of the process is made the
                        same as the owner of the executable. If the set-user-ID (set-group-ID) bit
                        is not set, then no change is made to the effective user (group) ID of the
                        process.</p></li><li class="listitem"><p>The values for the saved set-user-ID and saved set-group-ID are copied
                        from the corresponding effective IDs. This copying occurs regardless of
                        whether the set-user-ID or set-group-ID bit is set on the file being
                        executed.</p></li></ol></div><p>As an example of the effect of the above steps, suppose that a process whose real
                user ID, effective user ID, and saved set-user-ID are all 1000 execs a set-user-ID
                program owned by <span class="emphasis"><em>root</em></span> (user ID 0). After the exec, the user IDs
                of the process will be changed as follows:</p><a id="I_programlisting9_d1e19953"/><pre class="programlisting">real=1000 effective=0 saved=0</pre><p>Various system calls allow a set-user-ID program to switch its effective user ID
                between the values of the real user ID and the saved set-user-ID. Analogous system
                calls allow a set-group-ID program to modify its effective group ID. In this manner,
                the program can temporarily drop and regain whatever privileges are associated with
                the user (group) ID of the execed file. (In other words, the program can move
                between the states of potentially being privileged and actually operating with
                privilege.) As we’ll elaborate in <a class="xref" href="ch38.html#operate_with_least_privilege" title="Operate with Least Privilege">Operate with Least Privilege</a>, it
                is secure programming practice for set-user-ID and set-group-ID programs to operate
                under the unprivileged (i.e., real) ID whenever the program doesn’t actually need to
                perform any operations associated with the privileged (i.e., saved set) ID.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The saved set-user-ID and saved set-group-ID are sometimes synonymously
                    referred to as the <span class="emphasis"><em>saved user ID</em></span> and <span class="emphasis"><em>saved group
                        ID</em></span>.</p><p>The saved set IDs are a System V invention adopted by POSIX. They were not
                    provided on releases of BSD prior to 4.4. The initial POSIX.1 standard made
                    support for these IDs optional, but later standards (starting with FIPS 151-1 in
                    1988) made support mandatory.</p></div></div><div class="sect1" title="File-System User ID and File-System Group ID"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="file-system_user_id_and_file-system_grou">File-System User ID and File-System Group ID</h2></div></div></div><p>On Linux, it is the file-system user and group IDs, rather than the effective user
                and group IDs, that are used (in conjunction with the supplementary group IDs) to
                determine permissions when performing file-system operations such as opening files,
                changing file ownership, and modifying file permissions. (The effective IDs are
                still used, as on other UNIX implementations, for the other purposes described
                    earlier.)<a id="IDX-CHP-9-1186" class="indexterm"/><a id="IDX-CHP-9-1187" class="indexterm"/></p><p>Normally, the file-system user and group IDs have the same values as the
                corresponding effective IDs (and thus typically are the same as the corresponding
                real IDs). Furthermore, whenever the effective user or group ID is changed, either
                by a system call or by execution of a set-user-ID or set-group-ID program, the
                corresponding file-system ID is also changed to the same value. Since the
                file-system IDs follow the effective IDs in this way, this means that Linux
                effectively behaves just like any other UNIX implementation when privileges and
                permissions are being checked. The file-system IDs differ from the corresponding
                effective IDs, and hence Linux differs from other UNIX implementations, only when we
                use two Linux-specific system calls, <span class="emphasis"><em>setfsuid()</em></span> and
                    <span class="emphasis"><em>setfsgid()</em></span>, to explicitly make them different.</p><p>Why does Linux provide the file-system IDs and in what circumstances would we want
                the effective and file-system IDs to differ? The reasons are primarily historical.
                The file-system IDs first appeared in Linux 1.2. In that kernel version, one process
                could send a signal to another if the effective user ID of the sender matched the
                real or effective user ID of the target process. This affected certain programs such
                as the Linux NFS (Network File System) server program, which needed to be able to
                access files as though it had the effective IDs of the corresponding client process.
                However, if the NFS server changed its effective user ID, it would be vulnerable to
                signals from unprivileged user processes. To prevent this possibility, the separate
                file-system user and group IDs were devised. By leaving its effective IDs unchanged,
                but changing its file-system IDs, the NFS server could masquerade as another user
                for the purpose of accessing files without being vulnerable to signals from user
                processes.</p><p>From kernel 2.0 onward, Linux adopted the SUSv3-mandated rules regarding
                permission for sending signals, and these rules don’t involve the effective user ID
                of the target process (refer to <a class="xref" href="ch20.html#sending_signals_colon_kill_open_parenthe" title="Sending Signals: kill()">Sending Signals: <span class="emphasis"><em>kill()</em></span></a>). Thus, the file-system ID
                feature is no longer strictly necessary (a process can nowadays achieve the desired
                results by making judicious use of the system calls described later in this chapter
                to change the value of the effective user ID to and from an unprivileged value, as
                required), but it remains for compatibility with existing software.</p><p>Since the file-system IDs are something of an oddity, and they normally have the
                same values as the corresponding effective IDs, in the remainder of this book, we’ll
                generally describe various file permission checks, as well as the setting of the
                ownership of new files, in terms of the effective IDs of a process. Even though the
                process’s file-system IDs are really used for these purposes on Linux, in practice,
                their presence seldom makes an effective difference.</p></div><div class="sect1" title="Supplementary Group IDs"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="supplementary_group_ids">Supplementary Group IDs</h2></div></div></div><p>The supplementary group IDs are a set of additional groups to which a process
                belongs. A new process inherits these IDs from its parent. A login shell obtains its
                supplementary group IDs from the system group file. As noted above, these IDs are
                used in conjunction with the effective and file-system IDs to determine permissions
                for accessing files, System V IPC objects, and other system resources.<a id="IDX-CHP-9-1188" class="indexterm"/><a id="IDX-CHP-9-1189" class="indexterm"/><a id="IDX-CHP-9-1190" class="indexterm"/></p></div><div class="sect1" title="Retrieving and Modifying Process Credentials"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="retrieving_and_modifying_process_credent">Retrieving and Modifying Process Credentials</h2></div></div></div><p>Linux provides a range of system calls and library functions for retrieving and
                changing the various user and group IDs that we have described in this chapter. Only
                some of these APIs are specified in SUSv3. Of the remainder, several are widely
                available on other UNIX implementations and a few are Linux-specific. We note
                portability issues as we describe each interface. Toward the end of this chapter,
                    <a class="xref" href="ch09.html#summary_of_interfaces_used_to_change_pro" title="Table 9-1. Summary of interfaces used to change process credentials">Table 9-1</a> summarizes the
                operation of all of the interfaces used to change process credentials.</p><p>As an alternative to using the system calls described in the following pages, the
                credentials of any process can be found by examining the <code class="literal">Uid</code>, <code class="literal">Gid</code>, and <code class="literal">Groups</code> lines provided in the Linux-specific <code class="literal">/proc/</code><em class="replaceable"><code>PID</code></em><code class="literal">/status</code> file. The <code class="literal">Uid</code> and <code class="literal">Gid</code> lines list the
                identifiers in the order real, effective, saved set, and file system.</p><p>In the following sections, we use the traditional definition of a privileged
                process as one whose effective user ID is 0. However, Linux divides the notion of
                superuser privileges into distinct capabilities, as described in <a class="xref" href="ch39.html" title="Chapter 39. Capabilities">Chapter 39</a>. Two capabilities are relevant for our discussion
                of all of the system calls used to change process user and group IDs:<a id="IDX-CHP-9-1191" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">CAP_SETUID</code> capability allows a
                        process to make arbitrary changes to its user IDs.<a id="IDX-CHP-9-1192" class="indexterm"/></p></li><li class="listitem"><p>The <code class="literal">CAP_SETGID</code> capability allows a
                        process to make arbitrary changes to its group IDs.<a id="IDX-CHP-9-1193" class="indexterm"/></p></li></ul></div><div class="sect2" title="Retrieving and Modifying Real, Effective, and Saved Set IDs"><div class="titlepage"><div><div><h3 class="title" id="retrieving_and_modifying_real_comma_effe">Retrieving and Modifying Real, Effective, and Saved Set IDs</h3></div></div></div><p>In the following paragraphs, we describe the system calls that retrieve and
                    modify the real, effective, and saved set IDs. There are several system calls
                    that perform these tasks, and in some cases their functionality overlaps,
                    reflecting the fact that the various system calls originated on different UNIX
                    implementations.</p><div class="sect3" title="Retrieving real and effective IDs"><div class="titlepage"><div><div><h4 class="title" id="retrieving_real_and_effective_ids">Retrieving real and effective IDs</h4></div></div></div><p>The <span class="emphasis"><em>getuid()</em></span> and <span class="emphasis"><em>getgid()</em></span> system
                        calls return, respectively, the real user ID and real group ID of the
                        calling process. The <span class="emphasis"><em>geteuid()</em></span> and
                            <span class="emphasis"><em>getegid()</em></span> system calls perform the corresponding
                        tasks for the effective IDs. These system calls are always
                            successful.<a id="IDX-CHP-9-1194" class="indexterm"/><a id="IDX-CHP-9-1195" class="indexterm"/><a id="IDX-CHP-9-1196" class="indexterm"/></p><a id="I_programlisting9_d1e20112"/><pre class="programlisting">#include &lt;unistd.h&gt;

uid_t <strong class="userinput"><code>getuid</code></strong>(void);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns real user ID of calling process<a id="IDX-CHP-9-1197" class="indexterm"/></p></div><a id="I_programlisting9_d1e20123"/><pre class="programlisting">uid_t <strong class="userinput"><code>geteuid</code></strong>(void);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns effective user ID of calling process</p></div><a id="I_programlisting9_d1e20131"/><pre class="programlisting">gid_t <strong class="userinput"><code>getgid</code></strong>(void);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns real group ID of calling process<a id="IDX-CHP-9-1198" class="indexterm"/></p></div><a id="I_programlisting9_d1e20142"/><pre class="programlisting">gid_t <strong class="userinput"><code>getegid</code></strong>(void);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns effective group ID of calling process<a id="IDX-CHP-9-1199" class="indexterm"/></p></div></div><div class="sect3" title="Modifying effective IDs"><div class="titlepage"><div><div><h4 class="title" id="modifying_effective_ids">Modifying effective IDs</h4></div></div></div><p>The <span class="emphasis"><em>setuid()</em></span> system call changes the effective user
                        ID—and possibly the real user ID and the saved set-user-ID—of the calling
                        process to the value given by the <span class="emphasis"><em>uid</em></span> argument. The
                            <span class="emphasis"><em>setgid()</em></span> system call performs the analogous task
                        for the corresponding group IDs.<a id="IDX-CHP-9-1200" class="indexterm"/><a id="IDX-CHP-9-1201" class="indexterm"/><a id="IDX-CHP-9-1202" class="indexterm"/><a id="IDX-CHP-9-1203" class="indexterm"/><a id="IDX-CHP-9-1204" class="indexterm"/><a id="IDX-CHP-9-1205" class="indexterm"/><a id="IDX-CHP-9-1206" class="indexterm"/><a id="IDX-CHP-9-1207" class="indexterm"/><a id="IDX-CHP-9-1208" class="indexterm"/><a id="IDX-CHP-9-1209" class="indexterm"/><a id="IDX-CHP-9-1210" class="indexterm"/><a id="IDX-CHP-9-1211" class="indexterm"/><a id="IDX-CHP-9-1212" class="indexterm"/><a id="IDX-CHP-9-1213" class="indexterm"/><a id="IDX-CHP-9-1214" class="indexterm"/><a id="IDX-CHP-9-1215" class="indexterm"/></p><a id="I_programlisting9_d1e20264"/><pre class="programlisting">#include &lt;unistd.h&gt;

int <strong class="userinput"><code>setuid</code></strong>(uid_t <span class="emphasis"><em>uid</em></span>);
int <strong class="userinput"><code>setgid</code></strong>(gid_t <span class="emphasis"><em>gid</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Both return 0 on success, or -1 on error</p></div><p>The rules about what changes a process can make to its credentials using
                            <span class="emphasis"><em>setuid()</em></span> and <span class="emphasis"><em>setgid()</em></span> depend
                        on whether the process is privileged (i.e., has an effective user ID equal
                        to 0). The following rules apply to <span class="emphasis"><em>setuid()</em></span>:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>When an unprivileged process calls <span class="emphasis"><em>setuid()</em></span>,
                                only the effective user ID of the process is changed. Furthermore,
                                it can be changed only to the same value as either the real user ID
                                or saved set-user-ID. (Attempts to violate this constraint yield the
                                error <code class="literal">EPERM</code>.) This means that,
                                for unprivileged users, this call is useful only when executing a
                                set-user-ID program, since, for the execution of normal programs,
                                the process’s real user ID, effective user ID, and saved set-user-ID
                                all have the same value. On some BSD-derived implementations, calls
                                to <span class="emphasis"><em>setuid()</em></span> or <span class="emphasis"><em>setgid()</em></span> by
                                an unprivileged process have different semantics from other UNIX
                                implementations: the calls change the real, effective, and saved set
                                IDs (to the value of the current real or effective ID).</p></li><li class="listitem"><p>When a privileged process executes <span class="emphasis"><em>setuid()</em></span>
                                with a nonzero argument, then the real user ID, effective user ID,
                                and saved set-user-ID are all set to the value specified in the
                                    <span class="emphasis"><em>uid</em></span> argument. This is a one-way trip, in
                                that once a privileged process has changed its identifiers in this
                                way, it loses all privileges and therefore can’t subsequently use
                                    <span class="emphasis"><em>setuid()</em></span> to reset the identifiers back to
                                0. If this is not desired, then either
                                    <span class="emphasis"><em>seteuid()</em></span> or
                                    <span class="emphasis"><em>setreuid()</em></span>, which we describe shortly,
                                should be used instead of <span class="emphasis"><em>setuid()</em></span>.</p></li></ol></div><p>The rules governing the changes that may be made to group IDs using
                            <span class="emphasis"><em>setgid()</em></span> are similar, but with
                            <span class="emphasis"><em>setgid()</em></span> substituted for
                            <span class="emphasis"><em>setuid()</em></span> and <span class="emphasis"><em>group</em></span> for
                            <span class="emphasis"><em>user</em></span>. With these changes, rule 1 applies exactly as
                        stated. In rule 2, since changing the group IDs doesn’t cause a process to
                        lose privileges (which are determined by the effective
                            <span class="emphasis"><em>user</em></span> ID), privileged programs can use
                            <span class="emphasis"><em>setgid()</em></span> to freely change the group IDs to any
                        desired values.</p><p>The following call is the preferred method for a
                            set-user-ID-<span class="emphasis"><em>root</em></span> program whose effective user ID is
                        currently 0 to irrevocably drop all privileges (by setting both the
                        effective user ID and saved set-user-ID to the same value as the real user
                            ID):<a id="IDX-CHP-9-1216" class="indexterm"/></p><a id="I_programlisting9_d1e20362"/><pre class="programlisting">if (setuid(getuid()) == -1)
    errExit("setuid");</pre><p>A set-user-ID program owned by a user other than <span class="emphasis"><em>root</em></span>
                        can use <span class="emphasis"><em>setuid()</em></span> to switch the effective user ID
                        between the values of the real user ID and saved set-user-ID for the
                        security reasons described in Section 9.4. However,
                            <span class="emphasis"><em>seteuid()</em></span> is preferable for this purpose, since it
                        has the same effect, regardless of whether the set-user-ID program is owned
                        by <span class="emphasis"><em>root</em></span>.<a id="IDX-CHP-9-1217" class="indexterm"/></p><p>A process can use <span class="emphasis"><em>seteuid()</em></span> to change its effective
                        user ID (to the value specified by <span class="emphasis"><em>euid</em></span>), and
                            <span class="emphasis"><em>setegid()</em></span> to change its effective group ID (to the
                        value specified by <span class="emphasis"><em>egid</em></span>).<a id="IDX-CHP-9-1218" class="indexterm"/></p><a id="I_programlisting9_d1e20401"/><pre class="programlisting">#include &lt;unistd.h&gt;

int <strong class="userinput"><code>seteuid</code></strong>(uid_t <span class="emphasis"><em>euid</em></span>);
int <strong class="userinput"><code>setegid</code></strong>(gid_t <span class="emphasis"><em>egid</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Both return 0 on success, or -1 on error</p></div><p>The following rules govern the changes that a process may make to its
                        effective IDs using <span class="emphasis"><em>seteuid()</em></span> and
                            <span class="emphasis"><em>setegid()</em></span>:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>An unprivileged process can change an effective ID only to the
                                same value as the corresponding real or saved set ID. (In other
                                words, for an unprivileged process, <span class="emphasis"><em>seteuid()</em></span>
                                and <span class="emphasis"><em>setegid()</em></span> have the same effect as
                                    <span class="emphasis"><em>setuid()</em></span> and <span class="emphasis"><em>setgid()</em></span>,
                                respectively, except for the BSD portability issues noted
                                earlier.)</p></li><li class="listitem"><p>A privileged process can change an effective ID to any value. If a
                                privileged process uses <span class="emphasis"><em>seteuid()</em></span> to change its
                                effective user ID to a nonzero value, then it ceases to be
                                privileged (but may be able to regain privilege via the previous
                                rule).</p></li></ol></div><p>Using <span class="emphasis"><em>seteuid()</em></span> is the preferred method for
                        set-user-ID and set-group-ID programs to temporarily drop and later regain
                        privileges. Here’s an example:</p><a id="I_programlisting9_d1e20453"/><pre class="programlisting">euid = geteuid();               /* Save initial effective user ID (which
                                   is same as saved set-user-ID) */
if (seteuid(getuid()) == -1)    /* Drop privileges */
    errExit("seteuid");
if (seteuid(euid) == -1)        /* Regain privileges */
    errExit("seteuid");</pre><p>Originally derived from BSD, <span class="emphasis"><em>seteuid()</em></span> and
                            <span class="emphasis"><em>setegid()</em></span> are now specified in SUSv3 and appear on
                        most UNIX implementations.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In older versions of the GNU C library (<span class="emphasis"><em>glibc</em></span> 2.0
                            and earlier), <span class="emphasis"><em>seteuid(euid)</em></span> is implemented as
                                <span class="emphasis"><em>setreuid(-1, euid)</em></span>. In modern versions of
                                <span class="emphasis"><em>glibc, seteuid(euid)</em></span> is implemented as
                                <span class="emphasis"><em>setresuid(-1, euid, -1)</em></span>. (We describe
                                <span class="emphasis"><em>setreuid()</em></span>, <span class="emphasis"><em>setresuid()</em></span>,
                            and their group analogs shortly.) Both implementations permit us to
                            specify <span class="emphasis"><em>euid</em></span> as the same value as the current
                            effective user ID (i.e., no change). However, SUSv3 doesn’t specify this
                            behavior for <span class="emphasis"><em>seteuid()</em></span>, and it is not possible on
                            some other UNIX implementations. Generally, this potential variation
                            across implementations is not apparent, since, in normal circumstances,
                            the effective user ID has the same value as either the real user ID or
                            the saved set-user-ID. (The only way in which we can make the effective
                            user ID differ from both the real user ID and the saved set-user-ID on
                            Linux is via the use of the nonstandard <span class="emphasis"><em>setresuid()</em></span>
                            system call.)<a id="IDX-CHP-9-1219" class="indexterm"/><a id="IDX-CHP-9-1220" class="indexterm"/><a id="IDX-CHP-9-1221" class="indexterm"/></p><p>In all versions of <span class="emphasis"><em>glibc</em></span> (including modern ones),
                                <span class="emphasis"><em>setegid(egid)</em></span> is implemented as
                                <span class="emphasis"><em>setregid(-1, egid)</em></span>. As with
                                <span class="emphasis"><em>seteuid()</em></span>, this means that we can specify
                                <span class="emphasis"><em>egid</em></span> as the same value as the current effective
                            group ID, although this behavior is not specified in SUSv3. It also
                            means that <span class="emphasis"><em>setegid()</em></span> changes the saved set-group-ID
                            if the effective group ID is set to a value other than the current real
                            group ID. (A similar remark applies for the older implementation of
                                <span class="emphasis"><em>seteuid()</em></span> using
                            <span class="emphasis"><em>setreuid()</em></span>.) Again, this behavior is not specified
                            in SUSv3.<a id="IDX-CHP-9-1222" class="indexterm"/><a id="IDX-CHP-9-1223" class="indexterm"/></p></div></div><div class="sect3" title="Modifying real and effective IDs"><div class="titlepage"><div><div><h4 class="title" id="modifying_real_and_effective_ids">Modifying real and effective IDs</h4></div></div></div><p>The <span class="emphasis"><em>setreuid()</em></span> system call allows the calling process
                        to independently change the values of its real and effective user IDs. The
                            <span class="emphasis"><em>setregid()</em></span> system call performs the analogous task
                        for the real and effective group IDs.<a id="IDX-CHP-9-1224" class="indexterm"/><a id="IDX-CHP-9-1225" class="indexterm"/><a id="IDX-CHP-9-1226" class="indexterm"/><a id="IDX-CHP-9-1227" class="indexterm"/><a id="IDX-CHP-9-1228" class="indexterm"/></p><a id="I_programlisting9_d1e20580"/><pre class="programlisting">#include &lt;unistd.h&gt;

int <strong class="userinput"><code>setreuid</code></strong>(uid_t <span class="emphasis"><em>ruid</em></span>, uid_t <span class="emphasis"><em>euid</em></span>);
int <strong class="userinput"><code>setregid</code></strong>(gid_t <span class="emphasis"><em>rgid</em></span>, gid_t <span class="emphasis"><em>egid</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Both return 0 on success, or -1 on error</p></div><p>The first argument to each of these system calls is the new real ID. The
                        second argument is the new effective ID. If we want to change only one of
                        the identifiers, then we can specify -1 for the other argument.</p><p>Originally derived from BSD, <span class="emphasis"><em>setreuid()</em></span> and
                            <span class="emphasis"><em>setregid()</em></span> are now specified in SUSv3 and are
                        available on most UNIX implementations.</p><p>As with the other system calls described in this section, rules govern the
                        changes that we can make using <span class="emphasis"><em>setreuid()</em></span> and
                            <span class="emphasis"><em>setregid()</em></span>. We describe these rules from the point
                        of view of <span class="emphasis"><em>setreuid()</em></span>, with the understanding that
                            <span class="emphasis"><em>setregid()</em></span> is similar, except as noted:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>An unprivileged process can set the real user ID only to the
                                current value of the real (i.e., no change) or effective user ID.
                                The effective user ID can be set only to the current value of the
                                real user ID, effective user ID (i.e., no change), or saved
                                set-user-ID.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 says that it is unspecified whether an unprivileged
                                    process can use <span class="emphasis"><em>setreuid()</em></span> to change the
                                    value of the real user ID to the current value of the real user
                                    ID, effective user ID, or saved set-user-ID, and the details of
                                    precisely what changes can be made to the real user ID vary
                                    across implementations.</p><p>SUSv3 describes slightly different behavior for
                                        <span class="emphasis"><em>setregid()</em></span>: an unprivileged process can
                                    set the real group ID to the current value of the saved
                                    set-group-ID or set the effective group ID to the current value
                                    of either the real group ID or the saved set-group-ID. Again,
                                    the details of precisely what changes can be made vary across
                                    implementations.</p></div></li><li class="listitem"><p>A privileged process can make any changes to the IDs.</p></li><li class="listitem"><p>For both privileged and unprivileged processes, the saved
                                set-user-ID is also set to the same value as the (new) effective
                                user ID if either of the following is true:</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p><span class="emphasis"><em>ruid</em></span> is not -1 (i.e., the real user
                                        ID is being set, even to the same value it already had),
                                        or</p></li><li class="listitem"><p>the effective user ID is being set to a value other than
                                        the value of the real user ID prior to the call.</p></li></ol></div><p>Put conversely, if a process uses <span class="emphasis"><em>setreuid()</em></span>
                                only to change the effective user ID to the same value as the
                                current real user ID, then the saved set-user-ID is left unchanged,
                                and a later call to <span class="emphasis"><em>setreuid()</em></span> (or
                                    <span class="emphasis"><em>seteuid()</em></span>) can restore the effective user
                                ID to the saved set-user-ID value. (SUSv3 doesn’t specify the effect
                                of <span class="emphasis"><em>setreuid()</em></span> and
                                    <span class="emphasis"><em>setregid()</em></span> on the saved set IDs, but SUSv4
                                specifies the behavior described here.)</p></li></ol></div><p>The third rule provides a way for a set-user-ID program to permanently
                        drop its privilege, using a call such as the following:</p><a id="I_programlisting9_d1e20677"/><pre class="programlisting">setreuid(getuid(), getuid());</pre><p>A set-user-ID-<span class="emphasis"><em>root</em></span> process that wants to change both
                        its user and group credentials to arbitrary values should first call
                            <span class="emphasis"><em>setregid()</em></span> and then call
                            <span class="emphasis"><em>setreuid()</em></span>. If the calls are made in the opposite
                        order, then the <span class="emphasis"><em>setregid()</em></span> call will fail, because the
                        program will no longer be privileged after the call to
                            <span class="emphasis"><em>setreuid()</em></span>. Similar remarks apply if we are using
                            <span class="emphasis"><em>setresuid()</em></span> and <span class="emphasis"><em>setresgid()</em></span>
                        (described below) for this purpose.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>BSD releases up to and including 4.3BSD did not have the saved
                            set-user-ID and saved set-group-ID (which are nowadays mandated by
                            SUSv3). Instead, on BSD, <span class="emphasis"><em>setreuid()</em></span> and
                                <span class="emphasis"><em>setregid()</em></span> permitted a process to drop and
                            regain privilege by swapping the values of the real and effective IDs
                            back and forth. This had the undesirable side effect of changing the
                            real user ID in order to change the effective user ID.</p></div></div><div class="sect3" title="Retrieving real, effective, and saved set IDs"><div class="titlepage"><div><div><h4 class="title" id="retrieving_real_comma_effective_comma_an">Retrieving real, effective, and saved set IDs</h4></div></div></div><p>On most UNIX implementations, a process can’t directly retrieve (or
                        update) its saved set-user-ID and saved set-group-ID. However, Linux
                        provides two (nonstandard) system calls allowing us to do just that:
                            <span class="emphasis"><em>getresuid()</em></span> and
                            <span class="emphasis"><em>getresgid()</em></span>.<a id="IDX-CHP-9-1229" class="indexterm"/><a id="IDX-CHP-9-1230" class="indexterm"/></p><a id="I_programlisting9_d1e20732"/><pre class="programlisting">#define _GNU_SOURCE
#include &lt;unistd.h&gt;

int <strong class="userinput"><code>getresuid</code></strong>(uid_t *<span class="emphasis"><em>ruid</em></span>, uid_t *<span class="emphasis"><em>euid</em></span>, uid_t *<span class="emphasis"><em>suid</em></span>);
int <strong class="userinput"><code>getresgid</code></strong>(gid_t *<span class="emphasis"><em>rgid</em></span>, gid_t *<span class="emphasis"><em>egid</em></span>, gid_t *<span class="emphasis"><em>sgid</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Both return 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>getresuid()</em></span> system call returns the current
                        values of the calling process’s real user ID, effective user ID, and saved
                        set-user-ID in the locations pointed by its three arguments. The
                            <span class="emphasis"><em>getresgid()</em></span> system call does the same for the
                        corresponding group IDs.<a id="IDX-CHP-9-1231" class="indexterm"/><a id="IDX-CHP-9-1232" class="indexterm"/><a id="IDX-CHP-9-1233" class="indexterm"/></p></div><div class="sect3" title="Modifying real, effective, and saved set IDs"><div class="titlepage"><div><div><h4 class="title" id="modifying_real_comma_effective_comma_and">Modifying real, effective, and saved set IDs</h4></div></div></div><p>The <span class="emphasis"><em>setresuid()</em></span> system call allows the calling
                        process to independently change the values of all three of its user IDs. The
                        new values for each of the user IDs are specified by the three arguments to
                        the system call. The <span class="emphasis"><em>setresgid()</em></span> system call performs
                        the analogous task for the group IDs.<a id="IDX-CHP-9-1234" class="indexterm"/><a id="IDX-CHP-9-1235" class="indexterm"/><a id="IDX-CHP-9-1236" class="indexterm"/><a id="IDX-CHP-9-1237" class="indexterm"/><a id="IDX-CHP-9-1238" class="indexterm"/><a id="IDX-CHP-9-1239" class="indexterm"/><a id="IDX-CHP-9-1240" class="indexterm"/><a id="IDX-CHP-9-1241" class="indexterm"/><a id="IDX-CHP-9-1242" class="indexterm"/><a id="IDX-CHP-9-1243" class="indexterm"/><a id="IDX-CHP-9-1244" class="indexterm"/></p><a id="I_programlisting9_d1e20846"/><pre class="programlisting">#define _GNU_SOURCE
#include &lt;unistd.h&gt;

int <strong class="userinput"><code>setresuid</code></strong>(uid_t <span class="emphasis"><em>ruid</em></span>, uid_t <span class="emphasis"><em>euid</em></span>, uid_t <span class="emphasis"><em>suid</em></span>);
int <strong class="userinput"><code>setresgid</code></strong>(gid_t <span class="emphasis"><em>rgid</em></span>, gid_t <span class="emphasis"><em>egid</em></span>, gid_t <span class="emphasis"><em>sgid</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Both return 0 on success, or -1 on error</p></div><p>If we don’t want to change all of the identifiers, then specifying -1 for
                        an argument leaves the corresponding identifier unchanged. For example, the
                        following call is equivalent to <span class="emphasis"><em>seteuid(x)</em></span>:</p><a id="I_programlisting9_d1e20881"/><pre class="programlisting">setresuid(-1, x, -1);</pre><p>The rules about what changes may be made by
                            <span class="emphasis"><em>setresuid()</em></span> (<span class="emphasis"><em>setresgid()</em></span> is
                        similar) are as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>An unprivileged process can set any of its real user ID, effective
                                user ID, and saved set-user-ID to any of the values currently in its
                                current real user ID, effective user ID, or saved
                                set-user-ID.</p></li><li class="listitem"><p>A privileged process can make arbitrary changes to its real user
                                ID, effective user ID, and saved set-user-ID.</p></li><li class="listitem"><p>Regardless of whether the call makes any changes to other IDs, the
                                file-system user ID is always set to the same value as the (possibly
                                new) effective user ID.</p></li></ol></div><p>Calls to <span class="emphasis"><em>setresuid()</em></span> and
                            <span class="emphasis"><em>setresgid()</em></span> have an all-or-nothing effect. Either
                        all of the requested identifiers are successfully changed or none are
                        changed. (The same comment applies with respect to the other system calls
                        described in this chapter that change multiple identifiers.)</p><p>Although <span class="emphasis"><em>setresuid()</em></span> and
                            <span class="emphasis"><em>setresgid()</em></span> provide the most straightforward API
                        for changing process credentials, we can’t portably employ them in
                        applications; they are not specified in SUSv3 and are available on only a
                        few other UNIX implementations.</p></div></div><div class="sect2" title="Retrieving and Modifying File-System IDs"><div class="titlepage"><div><div><h3 class="title" id="retrieving_and_modifying_file-system_ids">Retrieving and Modifying File-System IDs</h3></div></div></div><p>All of the previously described system calls that change the process’s
                    effective user or group ID also always change the corresponding file-system ID.
                    To change the file-system IDs independently of the effective IDs, we must employ
                    two Linux-specific system calls: <span class="emphasis"><em>setfsuid()</em></span> and
                        <span class="emphasis"><em>setfsgid()</em></span>.<a id="IDX-CHP-9-1245" class="indexterm"/><a id="IDX-CHP-9-1246" class="indexterm"/><a id="IDX-CHP-9-1247" class="indexterm"/><a id="IDX-CHP-9-1248" class="indexterm"/><a id="IDX-CHP-9-1249" class="indexterm"/><a id="IDX-CHP-9-1250" class="indexterm"/><a id="IDX-CHP-9-1251" class="indexterm"/></p><a id="I_programlisting9_d1e20964"/><pre class="programlisting">#include &lt;sys/fsuid.h&gt;

int <strong class="userinput"><code>setfsuid</code></strong>(uid_t <span class="emphasis"><em>fsuid</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Always returns the previous file-system user ID<a id="IDX-CHP-9-1252" class="indexterm"/></p></div><a id="I_programlisting9_d1e20978"/><pre class="programlisting">int <strong class="userinput"><code>setfsgid</code></strong>(gid_t <span class="emphasis"><em>fsgid</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Always returns the previous file-system group ID<a id="IDX-CHP-9-1253" class="indexterm"/></p></div><p>The <span class="emphasis"><em>setfsuid()</em></span> system call changes the file-system user
                    ID of a process to the value specified by <span class="emphasis"><em>fsuid</em></span>. The
                        <span class="emphasis"><em>setfsgid()</em></span> system call changes the file system group ID
                    to the value specified by <span class="emphasis"><em>fsgid</em></span>.</p><p>Again, there are rules about the kind of changes that can be made. The rules
                    for <span class="emphasis"><em>setfsgid()</em></span> are similar to the rules for
                        <span class="emphasis"><em>setfsuid()</em></span>, which are as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>An unprivileged process can set the file-system user ID to the current
                            value of the real user ID, effective user ID, file-system user ID (i.e.,
                            no change), or saved set-user-ID.</p></li><li class="listitem"><p>A privileged process can set the file-system user ID to any
                            value.</p></li></ol></div><p>The implementation of these calls is somewhat unpolished. To begin with, there
                    are no corresponding system calls that retrieve the current value of the
                    file-system IDs. In addition, the system calls do no error checking; if an
                    unprivileged process attempts to set its file-system ID to an unacceptable
                    value, the attempt is silently ignored. The return value from each of these
                    system calls is the previous value of the corresponding file-system ID,
                        <span class="emphasis"><em>whether the call succeeds or fails</em></span>. Thus, we do have a
                    way of finding out the current values of the file-system IDs, but only at the
                    same time as we try (either successfully or unsuccessfully) to change
                    them.</p><p>Use of the <span class="emphasis"><em>setfsuid()</em></span> and <span class="emphasis"><em>setfsgid()</em></span>
                    system calls is no longer necessary on Linux and should be avoided in
                    applications designed to be ported to other UNIX implementations.</p></div><div class="sect2" title="Retrieving and Modifying Supplementary Group IDs"><div class="titlepage"><div><div><h3 class="title" id="retrieving_and_modifying_supplementary_g">Retrieving and Modifying Supplementary Group IDs</h3></div></div></div><p>The <span class="emphasis"><em>getgroups()</em></span> system call returns the set of groups of
                    which the calling process is currently a member, in the array pointed to by
                        <span class="emphasis"><em>grouplist</em></span>.<a id="IDX-CHP-9-1254" class="indexterm"/><a id="IDX-CHP-9-1255" class="indexterm"/><a id="IDX-CHP-9-1256" class="indexterm"/><a id="IDX-CHP-9-1257" class="indexterm"/><a id="IDX-CHP-9-1258" class="indexterm"/><a id="IDX-CHP-9-1259" class="indexterm"/><a id="IDX-CHP-9-1260" class="indexterm"/><a id="IDX-CHP-9-1261" class="indexterm"/></p><a id="I_programlisting9_d1e21092"/><pre class="programlisting">#include &lt;unistd.h&gt;

int <strong class="userinput"><code>getgroups</code></strong>(int <span class="emphasis"><em>gidsetsize</em></span>, gid_t <span class="emphasis"><em>grouplist</em></span>[]);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns number of group IDs placed in <span class="emphasis"><em>grouplist</em></span> on
                        success, or -1 on error</p></div><p>On Linux, as on most UNIX implementations, <span class="emphasis"><em>getgroups()</em></span>
                    simply returns the calling process’s supplementary group IDs. However, SUSv3
                    also allows an implementation to include the calling process’s effective group
                    ID in the returned <span class="emphasis"><em>grouplist</em></span>.<a id="IDX-CHP-9-1262" class="indexterm"/></p><p>The calling program must allocate the <span class="emphasis"><em>grouplist</em></span> array and
                    specify its length in the argument <span class="emphasis"><em>gidsetsize</em></span>. On
                    successful completion, <span class="emphasis"><em>getgroups()</em></span> returns the number of
                    group IDs placed in <span class="emphasis"><em>grouplist</em></span>.</p><p>If the number of groups of which a process is a member exceeds
                        <span class="emphasis"><em>gidsetsize</em></span>, <span class="emphasis"><em>getgroups()</em></span> returns an
                    error (<code class="literal">EINVAL</code>). To avoid this possibility, we
                    can size the <span class="emphasis"><em>grouplist</em></span> array to be one greater (to portably
                    allow for the possible inclusion of the effective group ID) than the constant
                        <code class="literal">NGROUPS_MAX</code> (defined in <code class="literal">&lt;limits.h&gt;</code>), which defines the
                    maximum number of supplementary groups of which a process may be a member. Thus,
                    we could declare <span class="emphasis"><em>grouplist</em></span> as follows:</p><a id="I_programlisting9_d1e21159"/><pre class="programlisting">gid_t grouplist[NGROUPS_MAX + 1];</pre><p>In Linux kernels prior to 2.6.4, <code class="literal">NGROUPS_MAX</code> has the value 32. From kernel 2.6.4 onward, <code class="literal">NGROUPS_MAX</code> has the value 65,536.</p><p>An application can also determine the <code class="literal">NGROUPS_MAX</code> limit at run time in the following ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Call <span class="emphasis"><em>sysconf(_SC_NGROUPS_MAX)</em></span>. (We explain the
                            use of <span class="emphasis"><em>sysconf ()</em></span> in Section 11.2.)</p></li><li class="listitem"><p>Read the limit from the read-only, Linux-specific <code class="literal">/proc/sys/kernel/ngroups_max</code> file. This
                            file is provided since kernel 2.6.4.<a id="IDX-CHP-9-1263" class="indexterm"/></p></li></ul></div><p>Alternatively, an application can make a call to
                        <span class="emphasis"><em>getgroups()</em></span> specifying <span class="emphasis"><em>gidtsetsize</em></span>
                    as 0. In this case, <span class="emphasis"><em>grouplist</em></span> is not modified, but the
                    return value of the call gives the number of groups of which the process is a
                    member.</p><p>The value obtained by any of these run-time techniques can then be used to
                    dynamically allocate a <span class="emphasis"><em>grouplist</em></span> array for a future
                        <span class="emphasis"><em>getgroups()</em></span> call.</p><p>A privileged process can use <span class="emphasis"><em>setgroups()</em></span> and
                        <span class="emphasis"><em>initgroups()</em></span> to change its set of supplementary group
                        IDs.<a id="IDX-CHP-9-1264" class="indexterm"/><a id="IDX-CHP-9-1265" class="indexterm"/></p><a id="I_programlisting9_d1e21231"/><pre class="programlisting">#define _BSD_SOURCE
#include &lt;grp.h&gt;

int <strong class="userinput"><code>setgroups</code></strong>(size_t <span class="emphasis"><em>gidsetsize</em></span>, const gid_t *<span class="emphasis"><em>grouplist</em></span>);
int <strong class="userinput"><code>initgroups</code></strong>(const char *<span class="emphasis"><em>user</em></span>, gid_t <span class="emphasis"><em>group</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Both return 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>setgroups()</em></span> system call replaces the calling
                    process’s supplementary group IDs with the set given in the array
                        <span class="emphasis"><em>grouplist</em></span>. The <span class="emphasis"><em>gidsetsize</em></span> argument
                    specifies the number of group IDs in the array argument
                        <span class="emphasis"><em>grouplist</em></span>.</p><p>The <span class="emphasis"><em>initgroups()</em></span> function initializes the calling
                    process’s supplementary group IDs by scanning <code class="literal">/etc/groups</code> and building a list of all groups of which the named
                        <span class="emphasis"><em>user</em></span> is a member. In addition, the group ID specified
                    in <span class="emphasis"><em>group</em></span> is also added to the process’s set of
                    supplementary group IDs.</p><p>The primary users of <span class="emphasis"><em>initgroups()</em></span> are programs that
                    create login sessions—for example, <span class="emphasis"><em>login(1)</em></span>, which sets
                    various process attributes prior to executing the user’s login shell. Such
                    programs typically obtain the value to be used for the
                        <span class="emphasis"><em>group</em></span> argument by reading the group ID field from the
                    user’s record in the password file. This is slightly confusing, since the group
                    ID from the password file is not really a supplementary group, Instead, it
                    defines the initial real group ID, effective group ID, and saved set-group-ID of
                    the login shell. Nevertheless, this is how <span class="emphasis"><em>initgroups()</em></span> is
                    usually employed.</p><p>Although not part of SUSv3, <span class="emphasis"><em>setgroups()</em></span> and
                        <span class="emphasis"><em>initgroups()</em></span> are available on all UNIX
                    implementations.</p></div><div class="sect2" title="Summary of Calls for Modifying Process Credentials"><div class="titlepage"><div><div><h3 class="title" id="summary_of_calls_for_modifying_process_c">Summary of Calls for Modifying Process Credentials</h3></div></div></div><p><a class="xref" href="ch09.html#summary_of_interfaces_used_to_change_pro" title="Table 9-1. Summary of interfaces used to change process credentials">Table 9-1</a> summarizes the
                    effects of the various system calls and library functions used to change process
                    credentials.</p><p><a class="xref" href="ch09.html#effect_of_credential-changing_functions" title="Figure 9-1. Effect of credential-changing functions on process user IDs">Figure 9-1</a> provides a graphical
                    overview of the same information given in <a class="xref" href="ch09.html#summary_of_interfaces_used_to_change_pro" title="Table 9-1. Summary of interfaces used to change process credentials">Table 9-1</a>. This diagram shows
                    things from the perspective of the calls that change the user IDs, but the rules
                    for changes to the group IDs are similar.</p><div class="figure"><a id="effect_of_credential-changing_functions"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject9_d1e21319"/><img src="figs/web/09-1_PROCCRED-uid-functions.png.jpg" alt="Effect of credential-changing functions on process user IDs"/></div></div><div class="figure-title">Figure 9-1. Effect of credential-changing functions on process user IDs</div></div><div class="table"><a id="summary_of_interfaces_used_to_change_pro"/><div class="table-title">Table 9-1. Summary of interfaces used to change process credentials</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><thead><tr><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; " rowspan="2">
                                    <p>Interface</p>
                                </td><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " colspan="2">
                                    <p>Purpose and effect within:</p>
                                </td><td style="text-align: center; vertical-align: bottom; " rowspan="2">
                                    <p>Portability</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>unprivileged process</p>
                                </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>privileged process</p>
                                </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <span class="emphasis"><em>setuid(u) setgid(g)</em></span>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Change effective ID to the same value as current real or
                                        saved set ID</p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Change real, effective, and saved set IDs to any (single)
                                        value</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Specified in SUSv3; BSD derivatives have different
                                        semantics</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <span class="emphasis"><em>seteuid(e) setegid(e)</em></span>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Change effective ID to the same value as current real or
                                        saved set ID</p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Change effective ID to any value</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Specified in SUSv3</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <span class="emphasis"><em>setreuid(r, e) setregid(r, e)</em></span>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>(Independently) change real ID to same value as current
                                        real or effective ID, and effective ID to same value as
                                        current real, effective, or saved set ID</p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>(Independently) change real and effective IDs to any
                                        values</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Specified in SUSv3, but operation varies across
                                        implementations</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <span class="emphasis"><em>setresuid(r, e, s) setresgid(r, e, s)</em></span>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>(Independently) change real, effective, and saved set IDs
                                        to same value as current real, effective, or saved set
                                        ID</p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>(Independently) change real, effective, and saved set IDs
                                        to any values</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Not in SUSv3 and present on few other UNIX
                                        implementations</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <span class="emphasis"><em>setfsuid(u) setfsgid(u)</em></span>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Change file-system ID to same value as current real,
                                        effective, file system, or saved set ID</p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Change file-system ID to any value</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Linux-specific</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                    <p>
                                        <span class="emphasis"><em>setgroups(n, l)</em></span>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                    <p>Can’t be called from an unprivileged process</p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                    <p>Set supplementary group IDs to any values</p>
                                </td><td style="text-align: left; vertical-align: top; ">
                                    <p>Not in SUSv3, but available on all UNIX
                                        implementations</p>
                                </td></tr></tbody></table></div></div><p>Note the following supplementary information to <a class="xref" href="ch09.html#summary_of_interfaces_used_to_change_pro" title="Table 9-1. Summary of interfaces used to change process credentials">Table 9-1</a>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>glibc</em></span> implementations of
                                <span class="emphasis"><em>seteuid()</em></span> (as <span class="emphasis"><em>setresuid(-1, e,
                                -1)</em></span>) and <span class="emphasis"><em>setegid()</em></span> (as
                                <span class="emphasis"><em>setregid(-1, e)</em></span>) also allow the effective ID to
                            be set to the same value it already has, but this is not specified in
                            SUSv3. The <span class="emphasis"><em>setegid()</em></span> implementation also changes
                            the saved set-group-ID if the effective group ID is set to a value other
                            than that of the current real group ID. (SUSv3 doesn’t specify that
                                <span class="emphasis"><em>setegid()</em></span> makes changes to the saved
                                set-group-ID.)<a id="IDX-CHP-9-1266" class="indexterm"/><a id="IDX-CHP-9-1267" class="indexterm"/></p></li><li class="listitem"><p>For calls to <span class="emphasis"><em>setreuid()</em></span> and
                                <span class="emphasis"><em>setregid()</em></span> by both privileged and unprivileged
                            processes, if <span class="emphasis"><em>r</em></span> is not -1, or
                                <span class="emphasis"><em>e</em></span> is specified as a value different from the
                            real ID prior to the call, then the saved set-user-ID or saved
                            set-group-ID is also set to the same value as the (new) effective ID.
                            (SUSv3 doesn’t specify that <span class="emphasis"><em>setreuid()</em></span> and
                                <span class="emphasis"><em>setregid()</em></span> make changes to the saved set
                                IDs.)<a id="IDX-CHP-9-1268" class="indexterm"/><a id="IDX-CHP-9-1269" class="indexterm"/></p></li><li class="listitem"><p>Whenever the effective user (group) ID is changed, the Linux-specific
                            file-system user (group) ID is changed to the same value.</p></li><li class="listitem"><p>Calls to <span class="emphasis"><em>setresuid()</em></span> always modify the
                            file-system user ID to have the same value as the effective user ID,
                            regardless of whether the effective user ID is changed by the call.
                            Calls to <span class="emphasis"><em>setresgid()</em></span> have an analogous effect on
                            the file-system group ID.<a id="IDX-CHP-9-1270" class="indexterm"/><a id="IDX-CHP-9-1271" class="indexterm"/></p></li></ul></div></div><div class="sect2" title="Example: Displaying Process Credentials"><div class="titlepage"><div><div><h3 class="title" id="example_colon_displaying_process_credent">Example: Displaying Process Credentials</h3></div></div></div><p>The program in <a class="xref" href="ch09.html#display_all_process_user_and_group_ids" title="Example 9-1. Display all process user and group IDs">Example 9-1</a> uses
                    the system calls and library functions described in the preceding pages to
                    retrieve all of the process’s user and group IDs, and then displays
                        them.<a id="IDX-CHP-9-1272" class="indexterm"/><a id="IDX-CHP-9-1273" class="indexterm"/><a id="IDX-CHP-9-1274" class="indexterm"/><a id="IDX-CHP-9-1275" class="indexterm"/></p><div class="example"><a id="display_all_process_user_and_group_ids"/><div class="example-title">Example 9-1. Display all process user and group IDs</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>proccred/idshow.c</code></strong>
#define _GNU_SOURCE
#include &lt;unistd.h&gt;
#include &lt;sys/fsuid.h&gt;
#include &lt;limits.h&gt;
#include "ugid_functions.h"   /* userNameFromId() &amp; groupNameFromId() */
#include "tlpi_hdr.h"

#define SG_SIZE (NGROUPS_MAX + 1)

int
main(int argc, char *argv[])
{
    uid_t ruid, euid, suid, fsuid;
    gid_t rgid, egid, sgid, fsgid;
    gid_t suppGroups[SG_SIZE];
    int numGroups, j;
    char *p;

    if (getresuid(&amp;ruid, &amp;euid, &amp;suid) == -1)
        errExit("getresuid");
    if (getresgid(&amp;rgid, &amp;egid, &amp;sgid) == -1)
        errExit("getresgid");

    /* Attempts to change the file-system IDs are always ignored
       for unprivileged processes, but even so, the following
       calls return the current file-system IDs */

    fsuid = setfsuid(0);
    fsgid = setfsgid(0);

    printf("UID: ");
    p = userNameFromId(ruid);
    printf("real=%s (%ld); ", (p == NULL) ? "???" : p, (long) ruid);
    p = userNameFromId(euid);
    printf("eff=%s (%ld); ", (p == NULL) ? "???" : p, (long) euid);
    p = userNameFromId(suid);
    printf("saved=%s (%ld); ", (p == NULL) ? "???" : p, (long) suid);
    p = userNameFromId(fsuid);
    printf("fs=%s (%ld); ", (p == NULL) ? "???" : p, (long) fsuid);
    printf("\n");

    printf("GID: ");
    p = groupNameFromId(rgid);
    printf("real=%s (%ld); ", (p == NULL) ? "???" : p, (long) rgid);
    p = groupNameFromId(egid);
    printf("eff=%s (%ld); ", (p == NULL) ? "???" : p, (long) egid);
    p = groupNameFromId(sgid);
    printf("saved=%s (%ld); ", (p == NULL) ? "???" : p, (long) sgid);
    p = groupNameFromId(fsgid);
    printf("fs=%s (%ld); ", (p == NULL) ? "???" : p, (long) fsgid);
    printf("\n");

    numGroups = getgroups(SG_SIZE, suppGroups);
    if (numGroups == -1)
        errExit("getgroups");

    printf("Supplementary groups (%d): ", numGroups);
    for (j = 0; j &lt; numGroups; j++) {
        p = groupNameFromId(suppGroups[j]);
        printf("%s (%ld) ", (p == NULL) ? "???" : p, (long) suppGroups[j]);
    }
    printf("\n");

    exit(EXIT_SUCCESS);
}
     <strong class="userinput"><code>proccred/idshow.c</code></strong></pre></div></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id8">Summary</h2></div></div></div><p>Each process has a number of associated user and group IDs (credentials). The real
                IDs define the ownership of the process. On most UNIX implementations, the effective
                IDs are used to determine a process’s permissions when accessing resources such as
                files. On Linux, however, the file-system IDs are used for determining permissions
                for accessing files, while the effective IDs are used for other permission checks.
                (Because the file-system IDs normally have the same values as the corresponding
                effective IDs, Linux behaves in the same way as other UNIX implementations when
                checking file permissions.) A process’s supplementary group IDs are a further set of
                groups of which the process is considered to be a member for the purpose of
                permission checking. Various system calls and library functions allow a process to
                retrieve and change its user and group IDs.<a id="IDX-CHP-9-1276" class="indexterm"/></p><p>When a set-user-ID program is run, the effective user ID of the process is set to
                that of the owner of the file. This mechanism allows a user to assume the identity,
                and thus the privileges, of another user while running a particular program.
                Correspondingly, set-group-ID programs change the effective group ID of the process
                running a program. The saved set-user-ID and saved set-group-ID allow set-user-ID
                and set-group-ID programs to temporarily drop and then later reassume
                privileges.</p><p>The user ID 0 is special. Normally, a single user account, named
                    <span class="emphasis"><em>root</em></span>, has this user ID. Processes with an effective user ID
                of 0 are privileged—that is, they are exempt from many of the permission checks
                normally performed when a process makes various system calls (such as those used to
                arbitrarily change the various process user and group IDs).</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id6">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Assume in each of the following cases that the initial set of process user
                        IDs is <span class="emphasis"><em>real=1000 effective=0 saved=0 file-system=0</em></span>.
                        What would be the state of the user IDs after the following calls?</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
                                <span class="emphasis"><em>setuid(2000);</em></span>
                            </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>setreuid(-1, 2000);</em></span>
                            </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>seteuid(2000);</em></span>
                            </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>setfsuid(2000);</em></span>
                            </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>setresuid(-1, 2000, 3000);</em></span>
                            </p></li></ol></div></li><li class="listitem"><p>Is a process with the following user IDs privileged? Explain your
                        answer.</p><a id="I_programlisting9_d1e21618"/><pre class="programlisting">real=0 effective=1000 saved=1000 file-system=1000</pre></li><li class="listitem"><p>Implement <span class="emphasis"><em>initgroups()</em></span> using
                            <span class="emphasis"><em>setgroups()</em></span> and library functions for retrieving
                        information from the password and group files (<a class="xref" href="ch08.html#retrieving_user_and_group_information" title="Retrieving User and Group Information">Retrieving User and Group Information</a>). Remember that a
                        process must be privileged in order to be able to call
                            <span class="emphasis"><em>setgroups()</em></span>.</p></li><li class="listitem"><p>If a process whose user IDs all have the value <span class="emphasis"><em>X</em></span>
                        executes a set-user-ID program whose user ID, <span class="emphasis"><em>Y</em></span>, is
                        nonzero, then the process credentials are set as follows:</p><a id="I_programlisting9_d1e21643"/><pre class="programlisting">real=X effective=Y saved=Y</pre><p>(We ignore the file-system user ID, since it tracks the effective user
                        ID.) Show the <span class="emphasis"><em>setuid()</em></span>, <span class="emphasis"><em>seteuid()</em></span>,
                            <span class="emphasis"><em>setreuid()</em></span>, and <span class="emphasis"><em>setresuid()</em></span>
                        calls, respectively, that would be used to perform the following
                        operations:</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>Suspend and resume the set-user-ID identity (i.e., switch the
                                effective user ID to the value of the real user ID and then back to
                                the saved set-user-ID).</p></li><li class="listitem"><p>Permanently drop the set-user-ID identity (i.e., ensure that the
                                effective user ID and the saved set-user-ID are set to the value of
                                the real user ID).</p></li></ol></div><p>(This exercise also requires the use of <span class="emphasis"><em>getuid()</em></span> and
                            <span class="emphasis"><em>geteuid()</em></span> to retrieve the process’s real and
                        effective user IDs.) Note that for certain of the system calls listed above,
                        some of these operations can’t be performed.</p></li><li class="listitem"><p>Repeat the previous exercise for a process executing a
                            set-user-ID-<span class="emphasis"><em>root</em></span> program, which has the following
                        initial set of process credentials:</p><a id="I_programlisting9_d1e21680"/><pre class="programlisting">real=X effective=0 saved=0</pre></li></ol></div></div></section></body></html>
