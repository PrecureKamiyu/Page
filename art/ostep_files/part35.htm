<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>The Abstraction: The Process</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part34.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part36.htm">下一个 &gt;</a></p><p class="s8" style="padding-top: 2pt;padding-left: 139pt;text-indent: 0pt;text-align: left;">The Abstraction: The Process</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">In this note, we discuss one of the most fundamental abstractions that the OS provides to users: the <b>process</b>. The definition of a process, informally, is quite simple: it is a <b>running program </b>[V+65,B70]. The program itself is a lifeless thing: it just sits there on the disk, a bunch of instructions (and maybe some static data), waiting to spring into action. It is the operating system that takes these bytes and gets them running, transforming the program into something useful.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">It turns out that one often wants to run more than one program at once; for example, consider your desktop or laptop where you might like to run a web browser, mail program, a game, a music player, and so forth. In fact, a typical system may be seemingly running tens or even hundreds of processes at the same time. Doing so makes the system easy to use, as one never need be concerned with whether a CPU is available; one simply runs programs. Hence our challenge:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">HE </span>C<span class="s7">RUX OF THE </span>P<span class="s7">ROBLEM</span>:</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 10pt;text-align: center;">H<span class="s7">OW </span>T<span class="s7">O </span>P<span class="s7">ROVIDE </span>T<span class="s7">HE </span>I<span class="s7">LLUSION </span>O<span class="s7">F </span>M<span class="s7">ANY </span>CPU<span class="s7">S</span>?</p><p style="padding-left: 9pt;text-indent: 11pt;line-height: 89%;text-align: left;">Although there are only a few physical CPUs available, how can the OS provide the illusion of a nearly-endless supply of said CPUs?</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The OS creates this illusion by <b>virtualizing </b>the CPU. By running one process, then stopping it and running another, and so forth, the OS can promote the illusion that many virtual CPUs exist when in fact there is only one physical CPU (or a few). This basic technique, known as <b>time sharing </b>of the CPU, allows users to run as many concurrent processes as they would like; the potential cost is performance, as each will run more slowly if the CPU(s) must be shared.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To implement virtualization of the CPU, and to implement it well, the OS will need both some low-level machinery as well as some high-level intelligence. We call the low-level machinery <b>mechanisms</b>; mechanisms are low-level methods or protocols that implement a needed piece of</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 55pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: U<span class="s7">SE </span>T<span class="s7">IME </span>S<span class="s7">HARING </span>(<span class="s7">AND </span>S<span class="s7">PACE </span>S<span class="s7">HARING</span>)</p><p class="s27" style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Time sharing <span class="p">is one of the most basic techniques used by an OS to share a resource. By allowing the resource to be used for a little while by one entity, and then a little while by another, and so forth, the resource in question (e.g., the CPU, or a network link) can be shared by many. The natural counterpart of time sharing is </span>space sharing<span class="p">, where a resource is divided (in space) among those who wish to use it. For example, disk space is naturally a space-shared resource, as once a block is assigned to a file, it is not likely to be assigned to another file until the user deletes it.</span></p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">functionality. For example, we’ll learn below how to implement a <b>con- text switch</b>, which gives the OS the ability to stop running one program and start running another on a given CPU; this <b>time-sharing </b>mechanism is employed by all modern OSes.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">On top of these mechanisms resides some of the intelligence in the OS, in the form of <b>policies</b>. Policies are algorithms for making some kind of decision within the OS. For example, given a number of possi- ble programs to run on a CPU, which program should the OS run? A <b>scheduling policy </b>in the OS will make this decision, likely using histori- cal information (e.g., which program has run more over the last minute?), workload knowledge (e.g., what types of programs are run), and perfor- mance metrics (e.g., is the system optimizing for interactive performance, or throughput?) to make its decision.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part36.htm">4.1 The Abstraction: A Process</a><a class="toc0" href="part37.htm">4.2 Process API</a><a class="toc0" href="part38.htm">4.3 Process Creation: A Little More Detail</a><a class="toc0" href="part39.htm">4.4 Process States</a><a class="toc0" href="part40.htm">4.5 Data Structures</a><a class="toc0" href="part41.htm">4.6 Summary</a><a class="toc0" href="part42.htm">References</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part34.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part36.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
