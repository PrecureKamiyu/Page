<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:mml="http://www.w3.org/1998/Math/MathML" lang="EN" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="default-style"/><title>The Art of Multiprocessor Programming</title><link href="Elsevier_eBook.css" rel="stylesheet" type="text/css"/><link href="math.css" rel="stylesheet" type="text/css"/><link href="media.css" media="only screen" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4f1c4a5b-a3e2-48ff-98f3-ff17812cd57a" name="Adept.expected.resource"/></head><body><section epub:type="chapter" role="doc-chapter"><div aria-label="Page 335" epub:type="pagebreak" id="page_335" role="doc-pagebreak"/><div id="CN"><a id="c0010tit1"/></div><header><hgroup><h1 class="chaptitle" id="c0010tit">Chapter 14: Skiplists and balanced search</h1></hgroup><section epub:type="preamble"><div class="abstract"><h2 class="h1hd" id="ab0010"><a id="st0010"/>Abstract</h2><p class="abspara">This chapter presents two implementations of concurrent skiplists, one lock-based and the other lock-free. Skip lists are a probabilistic data structure that provides logarithmic search (with high probability). Although balanced search trees guarantee logarthmic search, the rebalancing they require can cause contention, which cause poor performance. Skiplists are simpler data structures to implement and maintain. Our implementations are build directly on list algorithms of Chapter <a href="B9780124159501000197.xhtml">9</a>. They are typically free of contention, support wait-free searches, and have been successfully used in practical and highly scalable programs.</p></div></section><section id="ks0010"><h3 class="h2hd" id="st0015">Keywords</h3><p class="keywords">search; skiplist; probabilistic guarantees; wait-freedom; lock-freedom; fine-grained locking; lazy synchronization; linearizability</p></section></header><section><h2 class="h1hd" id="s0010"><a id="st0020"/>14.1 Introduction</h2><p class="textfl" id="p0010">We have seen several concurrent implementations of sets based on linked lists and on hash tables. We now turn our attention to concurrent search structures with logarithmic depth. There are many concurrent logarithmic search structures in the literature. Here, we are interested in search structures intended for in-memory data, as opposed to data residing on outside storage such as disks.</p><p class="text" id="p0015">Many popular sequential search structures, such as red-black trees or AVL trees, require periodic <i>rebalancing</i> to maintain the structure's logarithmic depth. Rebalancing works well for sequential tree-based search structures, but for concurrent structures, rebalancing may cause bottlenecks and contention. Instead, we focus here on concurrent implementations of a proved data structure that provides expected logarithmic-time search without the need to rebalance: the <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/>. In the following sections, we present two <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> implementations. The <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/> class is a lock-based implementation, while the <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> class is not. In both algorithms, the typically most frequent method, <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>(), which searches for an item, is wait-free. These constructions follow the design patterns outlined earlier in Chapter <a href="B9780124159501000197.xhtml">9</a>.<span aria-label="Page 336" epub:type="pagebreak" id="page_336" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0015"><a id="st0025"/>14.2 Sequential skiplists</h2><p class="textfl" id="p0020">For simplicity, we treat the list as a set, meaning that keys are unique. A <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> is a collection of sorted linked lists, which mimics, in a subtle way, a balanced search tree. Nodes in a <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> are ordered by key. Each node is linked into a subset of the lists. Each list has a <i>level</i>, ranging from 0 to a maximum. The bottom-level list contains all the nodes, and each higher-level list is a sublist of the lower-level lists. <a href="#f0010" id="cf0010">Fig. 14.1</a> shows a <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> with integer keys. The higher-level lists are <i>shortcuts</i> into the lower-level lists, because, roughly speaking, each link at level <i>i</i> skips over about <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000240/si4.png" style="vertical-align:middle" width="14"/></span> nodes in the lowest-level list, (e.g., in the <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> shown in <a href="#f0010" id="cf0015">Fig. 14.1</a>, each reference at level 3 skips over 2<sup>3</sup> nodes). Between any two nodes at a given level, the number of nodes in the level immediately below it is effectively constant, so the total height of the <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> is roughly logarithmic in the number of nodes. One can find a node with a given key by searching first through the lists in higher levels, skipping over large numbers of lower nodes, and progressively descending until a node with the target key is found (or not) at the bottom level.</p><div class="pageavoid"><figure class="fig" id="f0010"><img alt="Image" height="120" src="images/B9780124159501000240/gr001.jpg" width="310"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.1</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> class: This example has four levels of lists. Each node has a key, and the <img alt="Image" height="9" src="images/B9780124159501000240/fx005.jpg" width="25"/> and <img alt="Image" height="9" src="images/B9780124159501000240/fx006.jpg" width="23"/> sentinels have ±∞ keys. The list at level <i>i</i> is a shortcut where each reference skips over 2<span class="hiddenClass"><mml:math><mml:msup><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">i</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000240/si1.png" style="vertical-align:middle" width="6"/></span> nodes of the next lower level list. For example, at level 3, references skip <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="sans-serif">2</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="sans-serif">3</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000240/si2.png" style="vertical-align:middle" width="19"/></span> nodes; at level 2, <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="sans-serif">2</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="sans-serif">2</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000240/si3.png" style="vertical-align:middle" width="19"/></span> nodes, and so on.</div></figcaption></figure></div><p class="text" id="p0025">The <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> is a <i>probabilistic</i> data structure. (No one knows how to provide this kind of performance without randomization.) Each node is created with a random top level (<img alt="Image" height="11" src="images/B9780124159501000240/fx007.jpg" width="50"/>) and belongs to all lists up to that level. Top levels are chosen so that the expected number of nodes in each level's list decreases exponentially. Let <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>p</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000240/si5.png" style="vertical-align:middle" width="66"/></span> be the conditional probability that a node at level <i>i</i> also appears at level <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000240/si6.png" style="vertical-align:middle" width="33"/></span>. All nodes appear at level 0. The probability that a node at level 0 also appears at level <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000240/si7.png" style="vertical-align:middle" width="35"/></span> is <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000240/si8.png" style="vertical-align:middle" width="16"/></span>. For example, with <span class="hiddenClass"><mml:math><mml:mi>p</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000240/si9.png" style="vertical-align:middle" width="55"/></span>, 1/2 of the nodes are expected to appear at level 1, 1/4 at level 2, and so on, providing a <i>balancing</i> property like the classical sequential tree-based search structures, but without the need for complex global restructuring.</p><p class="text" id="p0030">We put <img alt="Image" height="9" src="images/B9780124159501000240/fx005.jpg" width="25"/> and <img alt="Image" height="9" src="images/B9780124159501000240/fx006.jpg" width="23"/> sentinel nodes at the beginning and end of the lists with the maximum allowed height. Initially, when the <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> is empty, the <img alt="Image" height="9" src="images/B9780124159501000240/fx005.jpg" width="25"/> (left sentinel) is the predecessor of the <img alt="Image" height="9" src="images/B9780124159501000240/fx006.jpg" width="23"/> (right sentinel) at every level. The <img alt="Image" height="9" src="images/B9780124159501000240/fx005.jpg" width="25"/>'s key is less than any key that may be added to the set, and the <img alt="Image" height="9" src="images/B9780124159501000240/fx006.jpg" width="23"/>'s key is greater.</p><p class="text" id="p0035">Each <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> node's <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> field is an array of references, one for each list to which it belongs, and so finding a node means finding its predecessors and successors. Searching the <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> always begins at the <img alt="Image" height="9" src="images/B9780124159501000240/fx005.jpg" width="25"/>. The <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method proceeds down the levels one after the other, and traverses each level as in the <img alt="Image" height="11" src="images/B9780124159501000240/fx010.jpg" width="51"/> using references to a predecessor node <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> and a current node <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/>. Whenever it finds a node with a greater or matching key, it records the <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> and <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> as the predecessor and successor of a node in arrays called <img alt="Image" height="10" src="images/B9780124159501000240/fx013.jpg" width="29"/>[] and <img alt="Image" height="6" src="images/B9780124159501000240/fx014.jpg" width="29"/>[], and continues to the next lower level. The traversal ends at the bottom level. <a href="#f0015" id="cf0020">Fig. 14.2</a>(a) shows a sequential <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() call.</p><div class="pageavoid"><figure class="fig" id="f0015"><img alt="Image" height="163" src="images/B9780124159501000240/gr002.jpg" width="498"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.2</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> class: <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() and <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() methods. In part (a), <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() traverses at each level, starting at the highest level, for as long as <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> is less than or equal to the target key 12. Otherwise, it stores <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> and <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> in the <img alt="Image" height="10" src="images/B9780124159501000240/fx013.jpg" width="29"/>[] and <img alt="Image" height="6" src="images/B9780124159501000240/fx014.jpg" width="29"/>[] arrays at each level and descends to the next level. For example, the node with key 9 is <img alt="Image" height="10" src="images/B9780124159501000240/fx013.jpg" width="29"/>[2] and <img alt="Image" height="10" src="images/B9780124159501000240/fx013.jpg" width="29"/>[1], while <img alt="Image" height="9" src="images/B9780124159501000240/fx006.jpg" width="23"/> is <img alt="Image" height="6" src="images/B9780124159501000240/fx014.jpg" width="29"/>[2] and the node with key 18 is <img alt="Image" height="6" src="images/B9780124159501000240/fx014.jpg" width="29"/>[1]. Here, <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() returns <i>false</i> since the node with key 12 was not found in the lowest-level list, and so an <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>(12) call in part (b) can proceed. In part (b), a new node is created with a random <img alt="Image" height="11" src="images/B9780124159501000240/fx007.jpg" width="50"/><span class="hiddenClass"><mml:math><mml:mrow><mml:mspace width="0.20em"/><mml:mtext mathvariant="sans-serif">=</mml:mtext><mml:mspace width="0.20em"/></mml:mrow></mml:math></span><span><img alt="Image" height="4" src="images/B9780124159501000240/si10.png" style="vertical-align:middle" width="12"/></span>2. The new node's <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> references are redirected to the corresponding <img alt="Image" height="6" src="images/B9780124159501000240/fx014.jpg" width="29"/>[] nodes, and each predecessor node's <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> reference is redirected to the new node.</div></figcaption></figure></div><p class="text" id="p0040">To add a node to a skiplist, a <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() call fills in the <img alt="Image" height="10" src="images/B9780124159501000240/fx013.jpg" width="29"/>[] and <img alt="Image" height="6" src="images/B9780124159501000240/fx014.jpg" width="29"/>[] arrays. The new node is created and linked between its predecessors and successors. <a href="#f0015" id="cf0025">Fig. 14.2</a>(b) shows an <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>(12) call.</p><p class="text" id="p0045">To remove a victim node from the skiplist, the <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method initializes the victim's <img alt="Image" height="10" src="images/B9780124159501000240/fx013.jpg" width="29"/>[] and <img alt="Image" height="6" src="images/B9780124159501000240/fx014.jpg" width="29"/>[] arrays. The victim is then removed from the list at all levels by redirecting each predecessor's <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> reference to the victim's successor.<span aria-label="Page 337" epub:type="pagebreak" id="page_337" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0020"><a id="st0030"/>14.3 A lock-based concurrent skiplist</h2><p class="textfl" id="p0050">We now describe the first concurrent skiplist design, the <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/> class. This class builds on the <img alt="Image" height="11" src="images/B9780124159501000240/fx010.jpg" width="51"/> algorithm of Chapter <a href="B9780124159501000197.xhtml">9</a>: Each level of the <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> structure is a <img alt="Image" height="11" src="images/B9780124159501000240/fx010.jpg" width="51"/>, and as in the <img alt="Image" height="11" src="images/B9780124159501000240/fx010.jpg" width="51"/> algorithm, the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() methods use optimistic fine-grained locking, while the <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() method is wait-free.</p><section><h3 class="h2hd" id="s0025"><a id="st0035"/>14.3.1 A bird's-eye view</h3><p class="textfl" id="p0055">Here is a bird's-eye view of the <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/> class. Start with <a href="#f0020" id="cf0030">Fig. 14.3</a>. As in the <img alt="Image" height="11" src="images/B9780124159501000240/fx010.jpg" width="51"/> class, each node has its own lock and a <img alt="Image" height="9" src="images/B9780124159501000240/fx017.jpg" width="39"/> field indicating whether it is in the abstract set, or has been logically removed. All along, the algorithm maintains the <i>skiplist property</i>: Higher-level lists are always contained in lower-level lists.</p><div class="pageavoid"><figure class="fig" id="f0020"><img alt="Image" height="181" src="images/B9780124159501000240/gr003.jpg" width="497"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.3</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/> class: failed and successful <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() calls. In part (a), the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>(18) call finds the node with key 18 unmarked but not yet <img alt="Image" height="11" src="images/B9780124159501000240/fx018.jpg" width="72"/>. It spins waiting for the node to become <img alt="Image" height="11" src="images/B9780124159501000240/fx018.jpg" width="72"/> in part (b), at which point it returns <i>false</i>. In part (a), the <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>(8) call finds the node with key 8 unmarked and fully linked, which means that it can acquire the node's lock in part (b). It then sets the mark bit, and proceeds to lock the node's predecessors, in this case, the node with key 5. Once the predecessor is locked, it physically removes the node from the list by redirecting the bottom-level reference of the node with key 5, completing the successful <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>(). In part (a), a <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>(18) fails, because it found the node not fully linked. The same <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>(18) call succeeds in part (b) because it found that the node is fully linked.</div></figcaption></figure></div><p class="text" id="p0060">The skiplist property is maintained using locks to prevent structural changes in the vicinity of a node while it is being added or removed, and by delaying any access to a node until it has been inserted into all levels of the list.</p><p class="text" id="p0065">To add a node, it must be linked into the list at several levels. Every <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() call calls <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>(), which traverses the skiplist and returns the node's predecessors and successors at all levels. To prevent changes to the node's predecessors while the node is being added, <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() locks the predecessors, validates that the locked predecessors still refer to their successors, and then adds the node in a manner similar to the sequential <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() shown in <a href="#f0015" id="cf0035">Fig. 14.2</a>. To maintain the skiplist property, a node is not considered to be logically in the set until all references to it at all levels have been properly set. Each node has an additional flag, <img alt="Image" height="11" src="images/B9780124159501000240/fx018.jpg" width="72"/>, set to <i>true</i> once <span aria-label="Page 338" epub:type="pagebreak" id="page_338" role="doc-pagebreak"/>it has been linked in all its levels. We do not allow access to a node until it is fully linked, so for example, the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() method, when trying to determine whether the node it wishes to add is already in the list, must spin waiting for it to become fully linked. <a href="#f0020" id="cf0040">Fig. 14.3</a> shows a call to <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>(18) that spins waiting until the node with key 18 becomes fully linked.</p><p class="text" id="p0070">To remove a node from the list, <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() uses <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() to check whether a victim node with the target key is already in the list. If so, it checks whether the victim is ready to be deleted, that is, is fully linked and unmarked. In part (a) of <a href="#f0020" id="cf0045">Fig. 14.3</a>, <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>(8) finds the node with key 8 unmarked and fully linked, which means that it can remove it. The <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>(18) call fails, because it found that the victim is not fully linked. The same <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>(18) call succeeds in part (b) because it found that the victim is fully linked.</p><p class="text" id="p0075">If the victim can be removed, <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() logically removes it by setting its mark bit. It completes the physical deletion of the victim by locking its predecessors at all levels and then the victim node itself, validating that the predecessors are unmarked and still refer to the victim, and then splicing out the victim node one level at a time. To maintain the skiplist property, the victim is spliced out from top to bottom.</p><p class="text" id="p0080">For example, in part (b) of <a href="#f0020" id="cf0050">Fig. 14.3</a>, <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>(8) locks the predecessor node with key 5. Once this predecessor is locked, <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() physically removes the node from the list by redirecting the bottom-level reference of the node with key 5 to refer to the node with key 9.</p><p class="text" id="p0085"><span aria-label="Page 339" epub:type="pagebreak" id="page_339" role="doc-pagebreak"/>In both the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() methods, if validation fails, <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() is called again to find the newly changed set of predecessors, and the attempt to complete the method resumes.</p><p class="text" id="p0090">The wait-free <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() method calls <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() to locate the node containing the target key. If it finds a node, it determines whether the node is in the set by checking whether it is unmarked and fully linked. This method, like the <img alt="Image" height="11" src="images/B9780124159501000240/fx010.jpg" width="51"/> class's <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>(), is wait-free because it ignores any locks or concurrent changes in the <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> structure.</p><p class="text" id="p0095">To summarize, the <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/> class uses a technique familiar from earlier algorithms: It holds locks on all locations to be modified, validates that nothing important has changed, completes the modifications, and releases the locks (in this context, the <img alt="Image" height="11" src="images/B9780124159501000240/fx018.jpg" width="72"/> flag acts like a lock).</p></section><section><h3 class="h2hd" id="s0030"><a id="st0040"/>14.3.2 The algorithm</h3><p class="textfl" id="p0100"><a href="#f0025" id="cf0055">Fig. 14.4</a> shows the <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/>'s <img alt="Image" height="9" src="images/B9780124159501000240/fx019.jpg" width="25"/> class. A key is in the set if and only if the list contains an unmarked, fully linked node with that key. Key 8 in part (a) of <a href="#f0020" id="cf0060">Fig. 14.3</a> is an example of such a key.</p><div class="pageavoid"><figure class="fig" id="f0025"><img alt="Image" height="618" src="images/B9780124159501000240/gr004.jpg" width="352"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.4</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/> class: constructor, fields, and <img alt="Image" height="9" src="images/B9780124159501000240/fx019.jpg" width="25"/> class.</div></figcaption></figure></div><p class="text" id="p0105"><a href="#f0030" id="cf0065">Fig. 14.5</a> shows the skiplist <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method. (The same method works in both the sequential and concurrent algorithms.) The <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method returns −1 if the item is not found. It traverses the <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> using <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> and <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> references starting at the <img alt="Image" height="9" src="images/B9780124159501000240/fx005.jpg" width="25"/> and at the highest level.<sup><a epub:type="noteref" href="#fn001" id="cf0070" role="doc-noteref">1</a></sup> This highest level can be maintained dynamically to reflect the highest level actually in the <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/>, but for brevity, we do not do so here. The <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method goes down the levels one after the other. At each level, it sets <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> to be the <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> node's successor. If it finds a node with a matching key, it records the level (line 48). If it does not find a node with a matching key, then <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() records the <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> and <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> as the predecessor and successor at that level in the <img alt="Image" height="10" src="images/B9780124159501000240/fx013.jpg" width="29"/>[] and <img alt="Image" height="6" src="images/B9780124159501000240/fx014.jpg" width="29"/>[] arrays (lines 51–52), continuing to the next lower level starting from the current <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> node. Part (a) of <a href="#f0015" id="cf0080">Fig. 14.2</a> shows how <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() traverses a <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/>. Part (b) shows how <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() results would be used to <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() a new item to a <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/>.</p><div class="pageavoid"><figure class="fig" id="f0030"><img alt="Image" height="273" src="images/B9780124159501000240/gr005.jpg" width="345"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.5</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/> class: the wait-free <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method. This algorithm is the same as in the sequential <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> implementation. The <img alt="Image" height="10" src="images/B9780124159501000240/fx013.jpg" width="29"/>[] and <img alt="Image" height="6" src="images/B9780124159501000240/fx014.jpg" width="29"/>[] arrays are filled from the maximum level to level 0 with the predecessor and successor references for the given key.</div></figcaption></figure></div><p class="text" id="p0110">Because we start with <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> at the <img alt="Image" height="9" src="images/B9780124159501000240/fx005.jpg" width="25"/> sentinel node and always advance the window only if <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> is less than the target key, <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> is always a predecessor of the target key, and never refers to the node with the key itself. The <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method returns the <img alt="Image" height="10" src="images/B9780124159501000240/fx013.jpg" width="29"/>[] and <img alt="Image" height="6" src="images/B9780124159501000240/fx014.jpg" width="29"/>[] arrays as well as the level at which the node with a matching key was found.</p><p class="text" id="p0115">The <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>(<i>k</i>) method, shown in <a href="#f0035" id="cf0085">Fig. 14.6</a>, uses <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() (<a href="#f0030" id="cf0090">Fig. 14.5</a>) to determine whether a node with the target key <i>k</i> is already in the list (line 43). If an unmarked node with the key is found (lines 62–67), then <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>(<i>k</i>) returns <i>false</i>, indicating that the key <i>k</i> is already in the set. However, if that node is not yet fully linked (indicated by the <img alt="Image" height="11" src="images/B9780124159501000240/fx018.jpg" width="72"/> field), then the thread waits until it is linked (because the key <i>k</i> is not in the abstract set until the node is fully linked). <span aria-label="Page 340" epub:type="pagebreak" id="page_340" role="doc-pagebreak"/>If the node found is marked, then some other thread is in the process of deleting it, so the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() call simply retries. Otherwise, it checks whether the node is unmarked and fully linked, indicating that the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() call should return <i>false</i>. It is safe to check if the node is unmarked before the node is fully linked, because <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() methods do not mark <span aria-label="Page 341" epub:type="pagebreak" id="page_341" role="doc-pagebreak"/>nodes unless they are fully linked. If a node is unmarked and not yet fully linked, it must become unmarked and fully linked before it can become marked (see <a href="#f0040" id="cf0095">Fig. 14.7</a>). This step is the linearization point (line 66) of an unsuccessful <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() method call.</p><div class="pageavoid"><figure class="fig" id="f0035"><img alt="Image" height="635" src="images/B9780124159501000240/gr006.jpg" width="458"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.6</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/> class: the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() method.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0040"><img alt="Image" height="667" src="images/B9780124159501000240/gr007.jpg" width="403"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.7</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/> class: the <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() method.</div></figcaption></figure></div><p class="text" id="p0120">The <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() method calls <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() to initialize the <img alt="Image" height="10" src="images/B9780124159501000240/fx013.jpg" width="29"/>[] and <img alt="Image" height="6" src="images/B9780124159501000240/fx014.jpg" width="29"/>[] arrays to hold the ostensible predecessor and successor nodes of the node to be added. These references are unreliable, because they may no longer be accurate by the time the nodes are accessed. If no unmarked fully linked node was found with key <i>k</i>, then the thread proceeds to lock and validate each of the predecessors returned by <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() from level 0 up to the <img alt="Image" height="11" src="images/B9780124159501000240/fx007.jpg" width="50"/> of the new node (lines 74–80). To avoid deadlocks, both <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() acquire locks in ascending order. The <img alt="Image" height="11" src="images/B9780124159501000240/fx007.jpg" width="50"/> value is determined at the very beginning of the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() method using the <img alt="Image" height="9" src="images/B9780124159501000240/fx020.jpg" width="70"/>() method.<sup><a epub:type="noteref" href="#fn002" id="cf0100" role="doc-noteref">2</a></sup> The validation (line 79) at each level checks that the predecessor is still adjacent to the successor and that neither is marked. If validation fails, the thread must have encountered the effects of a conflicting method, so it releases (in the <img alt="Image" height="11" src="images/B9780124159501000240/fx021.jpg" width="46"/> block on line 87) the locks it acquired and retries.</p><p class="text" id="p0125">If the thread successfully locks and validates the results of <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() up to the <img alt="Image" height="11" src="images/B9780124159501000240/fx007.jpg" width="50"/> of the new node, then the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() call <span aria-label="Page 342" epub:type="pagebreak" id="page_342" role="doc-pagebreak"/>will succeed because the thread holds all the locks it needs. The thread then allocates a new node with the appropriate key and randomly chosen <img alt="Image" height="11" src="images/B9780124159501000240/fx007.jpg" width="50"/>, links it in, and sets the new node's <img alt="Image" height="11" src="images/B9780124159501000240/fx018.jpg" width="72"/> flag. Setting this flag is the linearization point of a successful <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() method <span aria-label="Page 343" epub:type="pagebreak" id="page_343" role="doc-pagebreak"/>(line 87). It then releases all its locks and returns <i>true</i> (line 89). The only time a thread modifies an unlocked node's <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> field is when it initializes the new node's <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> references (line 83). This initialization is safe because it occurs before the new node is accessible.</p><p class="text" id="p0130">The <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() method appears in <a href="#f0040" id="cf0105">Fig. 14.7</a>. It calls <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() to determine whether a node with the appropriate key is in the list. If so, the thread checks whether the node is ready to be deleted (line 104), meaning it is fully linked, unmarked, and at its top level. A node found below its top level was either not yet fully linked (see the node with key 18 in part (a) of <a href="#f0020" id="cf0110">Fig. 14.3</a>) or marked and already partially unlinked by a concurrent <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() method call (the <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() method could continue, but the subsequent validation would fail).</p><p class="text" id="p0135">If the node is ready to be deleted, the thread locks the node (line 109) and verifies that it is still not marked. If it is still not marked, the thread marks the node, logically deleting that item. This step (line 114) is the linearization point of a successful <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() call. If the node was marked, then the thread returns <i>false</i> since the node was already deleted. This step is one linearization point of an unsuccessful <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>(). Another occurs when <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() does not find a node with a matching key, or when the node with the matching key was marked, or not fully linked, or not found at its top level (line 104).</p><p class="text" id="p0140">The rest of the method completes the physical deletion of the <img alt="Image" height="9" src="images/B9780124159501000240/fx022.jpg" width="39"/> node. To remove the victim from the list, the <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() method first locks (in ascending order, to avoid deadlock) the victim's predecessors at all levels up to the victim's <img alt="Image" height="11" src="images/B9780124159501000240/fx007.jpg" width="50"/> (lines 120–124). After locking each predecessor, it validates that the predecessor is still unmarked and still refers to the victim. It then splices out the victim one level at a time (line 128). To maintain the skiplist property, that any node reachable at a given level is reachable at lower levels, the victim is spliced out from top to bottom. If the validation fails at any level, then the thread releases the locks for the predecessors (but not the victim) and calls <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() to acquire the new set of predecessors. Because it has already set the victim's <img alt="Image" height="9" src="images/B9780124159501000240/fx023.jpg" width="51"/> field, it does not try to mark the node again. After successfully removing the victim node from the list, the thread releases all its locks and returns <i>true</i>.</p><p class="text" id="p0145">Finally, we recall that if no node was found, or the node found was marked, or not fully linked, or not found at its top level, then the method simply returns <i>false</i>. It is easy to see that it is correct to return <i>false</i> if the node is not marked, because for any key, there can at any time be at most one node with this key in the <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> (i.e., reachable from the <img alt="Image" height="9" src="images/B9780124159501000240/fx005.jpg" width="25"/>). Moreover, once a node is entered into the list (which must have occurred before it is found by <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>()), it cannot be removed until it is marked. It follows that if the node is not marked, and not all its links are in place, it must be in the process of being added into the <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/>, but the adding method has not reached the linearization point (see the node with key 18 in part (a) of <a href="#f0020" id="cf0115">Fig. 14.3</a>).</p><p class="text" id="p0150">If the node is marked at the time it is found, it might not be in the list, and some unmarked node with the same key may be in the list. However, in that case, just like for the <img alt="Image" height="11" src="images/B9780124159501000240/fx010.jpg" width="51"/> <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() method, there must have been some point during the <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() call when the key was not in the abstract <span aria-label="Page 344" epub:type="pagebreak" id="page_344" role="doc-pagebreak"/>set.<span aria-label="Page 345" epub:type="pagebreak" id="page_345" role="doc-pagebreak"/></p><p class="text" id="p0155">The wait-free <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() method (<a href="#f0045" id="cf0120">Fig. 14.8</a>) calls <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() to locate the node containing the target key. If it finds a node it checks whether it is unmarked and fully linked. This method, like that of the <img alt="Image" height="11" src="images/B9780124159501000240/fx010.jpg" width="51"/> class of Chapter <a href="B9780124159501000197.xhtml">9</a>, is wait-free, ignoring any locks or concurrent changes in the <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> list structure. A successful <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() call's linearization point occurs when the predecessor's <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> reference is traversed, having been observed to be unmarked and fully linked. An unsuccessful <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() call, like the <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() call, occurs if the method finds a node that is marked. Care is needed, because at the time the node is found, it might not be in the list, while an unmarked node with the same key may be in the list. As with <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>(), however, there must have been some point during the <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() call when the key was not in the abstract set.</p><div class="pageavoid"><figure class="fig" id="f0045"><img alt="Image" height="125" src="images/B9780124159501000240/gr008.jpg" width="378"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.8</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/> class: the wait-free <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() method.</div></figcaption></figure></div></section></section><section><h2 class="h1hd" id="s0035"><a id="st0045"/>14.4 A lock-free concurrent skiplist</h2><p class="textfl" id="p0160">The basis of our <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> implementation is the <img alt="Image" height="9" src="images/B9780124159501000240/fx024.jpg" width="78"/> algorithm of Chapter <a href="B9780124159501000197.xhtml">9</a>: Each level of the <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> structure is a <img alt="Image" height="9" src="images/B9780124159501000240/fx024.jpg" width="78"/>, each <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> reference in a node is an <img alt="Image" height="9" src="images/B9780124159501000240/fx025.jpg" width="194"/>, and list manipulations are performed using <img alt="Image" height="12" src="images/B9780124159501000240/fx026.jpg" width="97"/>.</p><section><h3 class="h2hd" id="s0040"><a id="st0050"/>14.4.1 A bird's-eye view</h3><p class="textfl" id="p0165">Here is a bird's-eye view of the of the <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> class.</p><p class="text" id="p0170">Because we cannot use locks to manipulate references at all levels at the same time, the <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> cannot maintain the skiplist property that each list is a sublist of the list at levels below it.</p><p class="text" id="p0175">Since we cannot maintain the skiplist property, we take the approach that the abstract set is defined by the bottom-level list: A key is in the set if there is a node with that key whose <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> reference is unmarked in the bottom-level list. Nodes in higher-level lists in the skiplist serve only as shortcuts to the bottom level. There is no need for a <img alt="Image" height="11" src="images/B9780124159501000240/fx018.jpg" width="72"/> flag as in the <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/>.<span aria-label="Page 346" epub:type="pagebreak" id="page_346" role="doc-pagebreak"/></p><p class="text" id="p0180">How do we add or remove a node? We treat each level of the list as a <img alt="Image" height="9" src="images/B9780124159501000240/fx024.jpg" width="78"/>. We use <img alt="Image" height="12" src="images/B9780124159501000240/fx026.jpg" width="97"/> to insert a node at a given level, and we mark the <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> references of a node to remove it.</p><p class="text" id="p0185">As in the <img alt="Image" height="9" src="images/B9780124159501000240/fx024.jpg" width="78"/>, the <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method cleans up marked nodes. The method traverses the skiplist, proceeding down each list at each level. As in the <img alt="Image" height="9" src="images/B9780124159501000240/fx024.jpg" width="78"/> class's <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method, it repeatedly snips out marked nodes as they are encountered, so that it never looks at a marked node's key. Unfortunately, this means that a node may be physically removed while it is in the process of being linked at the higher levels. A <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() call that passes through a node's middle-level references may remove these references, so, as noted earlier, the skiplist property is not maintained.<span aria-label="Page 347" epub:type="pagebreak" id="page_347" role="doc-pagebreak"/></p><p class="text" id="p0190">The <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() method calls <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() to determine whether a node is already in the list and to find its set of predecessors and successors. A new node is prepared with a randomly chosen <img alt="Image" height="11" src="images/B9780124159501000240/fx007.jpg" width="50"/>, and its <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> references are directed to the potential successors returned by the <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() call. The next step is to try to logically add the new node to the abstract set by linking it into the bottom-level list, using the same approach as in the <img alt="Image" height="9" src="images/B9780124159501000240/fx024.jpg" width="78"/>. If the addition succeeds, the item is logically in the set. The <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() call then links the node in at higher levels (up to its top level).</p><p class="text" id="p0195"><a href="#f0050" id="cf0125">Fig. 14.9</a> shows the <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> class. In part (a), <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>(12) calls <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>(12) while there are three ongoing <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() calls. Part (b) shows the results of redirecting the dashed links. Part (c) shows the subsequent addition of the new node with key 12. Part (d) shows an alternate addition scenario that would occur if the node with key 11 were removed before the addition of the node with key 12.</p><div class="pageavoid"><figure class="fig" id="f0050"><img alt="Image" height="302" src="images/B9780124159501000240/gr009.jpg" width="497"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.9</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> class: an <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() call. Each node consists of links that are unmarked (a 0) or marked (a 1). In part (a), <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>(12) calls <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>(12) while there are three ongoing <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() calls. The <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method “cleans” the marked links (denoted by 1s) as it traverses the skiplist. The traversal is not the same as a sequential <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>(12), because marked nodes are unlinked whenever they are encountered. The path in the figure shows the nodes traversed by the <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> reference, which always refers to unmarked nodes with keys less than the target key. Part (b) shows the result of redirecting the dashed links. We denote bypassing a node by placing the link in front of it. Node 15, whose bottom-level <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> reference was marked, is removed from the skiplist. Part (c) shows the subsequent addition of the new node with key 12. Part (d) shows an alternate addition scenario that would occur if the node with key 11 were removed before the addition of the node with key 12. The bottom-level <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> reference of the node with key 9 is not yet marked, and so the bottom-level predecessor node, whose <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> reference is marked, is redirected by the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() method to the new node. Once thread <i>C</i> completes marking this reference, the node with key 9 is removed and the node with key 5 becomes the immediate predecessor of the newly added node.</div></figcaption></figure></div><p class="text" id="p0200">The <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() method calls <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() to determine whether an unmarked node with the target key is in the bottom-level list. If an unmarked node is found, it is marked starting from the <img alt="Image" height="11" src="images/B9780124159501000240/fx007.jpg" width="50"/>. All <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> references up to but not including the bottom-level reference are logically removed from their appropriate level list by marking them. Once all levels but the bottom one have been marked, the method marks the bottom-level's <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> reference. This marking, if successful, removes the item from the abstract set. The physical removal of the node is the result of its physical removal from the lists at all levels by the <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() method itself and the <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() methods of other threads that access it while traversing the skiplist. In both <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>(), if at any point a <img alt="Image" height="12" src="images/B9780124159501000240/fx026.jpg" width="97"/> fails, the set of predecessors and successors might have changed, and so <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() must be called again.</p><p class="text" id="p0205">The key to the interaction between the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>(), <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>(), and <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() methods is the order in which list manipulations take place. The <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() method sets its <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> references to the successors before it links the node into the bottom-level list, meaning that a node is ready to be removed from the moment it is logically added to the list. Similarly, the <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() method marks the <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> references top-down, so that once a node is logically removed, it is not traversed by a <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method call.</p><p class="text" id="p0210">As noted, in most applications, calls to <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() usually outnumber calls to other methods. As a result <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() should not call <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>(). While it may be effective to have individual <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() calls physically remove logically deleted nodes, contention results if too many concurrent <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() calls try to clean up the same nodes at the same time. This kind of contention is much more likely with frequent <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() calls than with calls to the other methods.</p><p class="text" id="p0215">However, <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() cannot use the approach taken by the <img alt="Image" height="9" src="images/B9780124159501000240/fx024.jpg" width="78"/>'s wait-free <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>(): Look at the keys of all reachable nodes independently of whether they are marked or not. The problem is that <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() may violate the skiplist property. It is possible for a marked node to be reachable in a higher-level list after being physically deleted from the lowest-level list. Ignoring the mark could lead to skipping over nodes reachable in the lowest level.</p><p class="text" id="p0220">Note, however, that the <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method of the <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> is not subject to this problem because it never looks at keys of marked nodes, removing them instead. We will have the <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() method mimic this <span aria-label="Page 348" epub:type="pagebreak" id="page_348" role="doc-pagebreak"/>behavior, but without cleaning up marked nodes. Instead, <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() traverses the skiplist, ignoring the keys of marked nodes, and skipping over them instead of physically removing them. Avoiding the physical removal allows the method to be wait-free.</p></section><section><h3 class="h2hd" id="s0045"><a id="st0055"/>14.4.2 The algorithm in detail</h3><p class="textfl" id="p0225">As we present the algorithmic details, the reader should keep in mind that the abstract set is defined only by the bottom-level list. Nodes in the higher-level lists are used only as shortcuts into the bottom-level list. <a href="#f0055" id="cf0130">Fig. 14.10</a> shows the structure of the list's nodes.</p><div class="pageavoid"><figure class="fig" id="f0055"><img alt="Image" height="533" src="images/B9780124159501000240/gr010.jpg" width="430"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.10</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> class: fields and constructor.</div></figcaption></figure></div><p class="text" id="p0230">The <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() method, shown in <a href="#f0060" id="cf0135">Fig. 14.11</a>, uses <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>(), shown in <a href="#f0070" id="cf0140">Fig. 14.13</a>, to determine whether a node with key <i>k</i> is already in the list (line 61). As in the <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/>, <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() calls <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() to initialize the <img alt="Image" height="10" src="images/B9780124159501000240/fx013.jpg" width="29"/>[] and <img alt="Image" height="6" src="images/B9780124159501000240/fx014.jpg" width="29"/>[] arrays to hold the new node's ostensible predecessors and successors.</p><div class="pageavoid"><figure class="fig" id="f0060"><img alt="Image" height="553" src="images/B9780124159501000240/gr011.jpg" width="473"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.11</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> class: the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() method.</div></figcaption></figure></div><p class="text" id="p0235">If an unmarked node with the target key is found in the bottom-level list, <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() returns <i>true</i> and the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() method returns <i>false</i>, indicating that the key is already in the set. The unsuccessful <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>()'s linearization point is the same as the successful <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>()'s (line 43). If no node is found, then the next step is to try to add a new node with the key into the structure.</p><p class="text" id="p0240">A new node is created with a randomly chosen <img alt="Image" height="11" src="images/B9780124159501000240/fx007.jpg" width="50"/>. The node's <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> references are unmarked and set to the successors returned by the <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method (lines 47–50).</p><p class="text" id="p0245">The next step is to try to add the new node by linking it into the bottom-level list between the <img alt="Image" height="10" src="images/B9780124159501000240/fx013.jpg" width="29"/>[0] and <img alt="Image" height="6" src="images/B9780124159501000240/fx014.jpg" width="29"/>[0] nodes returned by <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>(). As in the <img alt="Image" height="9" src="images/B9780124159501000240/fx024.jpg" width="78"/>, we use <img alt="Image" height="12" src="images/B9780124159501000240/fx026.jpg" width="97"/> to set the reference while validating that these nodes still refer one to the other and have not been removed from the list (line 55). If the <img alt="Image" height="12" src="images/B9780124159501000240/fx026.jpg" width="97"/> fails, something has changed and the call restarts. If the <img alt="Image" height="12" src="images/B9780124159501000240/fx026.jpg" width="97"/> succeeds, the item is added, and line 55 is the call's linearization point.</p><p class="text" id="p0250">The <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() then links the node in at higher levels (line 58). For each level, it attempts to splice the node in by setting the predecessor, if it refers to the valid successor, to the new node (line 62). If successful, it breaks and moves on to the next level. If unsuccessful, the node referenced by the predecessor must have changed, and <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() is called again to find a new valid set of predecessors and successors. We discard the result of calling <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() (line 64) because we care only about recomputing the ostensible predecessors and successors on the remaining unlinked levels. Once all levels are linked, the method returns <i>true</i> (line 67).</p><p class="text" id="p0255">The <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() method, shown in <a href="#f0065" id="cf0145">Fig. 14.12</a>, calls <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() to determine whether an unmarked node with a matching key is in the bottom-level list. If no node is found in the bottom-level list, or the node with a matching key is marked, the method returns <i>false</i>. The linearization point of the unsuccessful <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() is that of the <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method called on line 77. If an unmarked node is found, then the method logically removes the associated key from the abstract set, and prepares it for physical removal. This step uses the set of ostensible predecessors (stored by <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() in <span aria-label="Page 349" epub:type="pagebreak" id="page_349" role="doc-pagebreak"/><img alt="Image" height="10" src="images/B9780124159501000240/fx013.jpg" width="29"/>[]) and the <span class="inlinecode">nodeToRemove</span> (returned from <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() in <img alt="Image" height="6" src="images/B9780124159501000240/fx014.jpg" width="29"/>[]). First, starting from the <img alt="Image" height="11" src="images/B9780124159501000240/fx007.jpg" width="50"/>, all links up to and not including the bottom-level link are marked (lines 83–89) by repeatedly reading <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> and its mark and applying a <img alt="Image" height="12" src="images/B9780124159501000240/fx026.jpg" width="97"/>. If the link is found to be marked (either because it was already marked or because the attempt succeeded), the method moves on to the next-level link. Otherwise, the current level's link is reread since it must have been changed by another concurrent thread, so the marking attempt must be repeated. Once all levels but the bottom one have been marked, the method marks the bottom-level's <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> reference. This marking (line 96), if successful, is the linearization point of a successful <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>(). The <span aria-label="Page 350" epub:type="pagebreak" id="page_350" role="doc-pagebreak"/><img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() method tries to mark the <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> field using <img alt="Image" height="12" src="images/B9780124159501000240/fx026.jpg" width="97"/>. If successful, it can determine that it was the thread that changed the mark from <i>false</i> to <i>true</i>. Before returning <i>true</i>, the <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method is called again. This call is an optimization: As a side effect, <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() physically removes all links to the node it is searching for if that node is already logically removed.</p><div class="pageavoid"><figure class="fig" id="f0065"><img alt="Image" height="586" src="images/B9780124159501000240/gr012.jpg" width="476"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.12</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> class: the <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() method.</div></figcaption></figure></div><p class="text" id="p0260">On the other hand, if the <img alt="Image" height="12" src="images/B9780124159501000240/fx026.jpg" width="97"/> call failed, but the <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> reference is marked, then another thread must have concurrently removed it, so <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() returns <i>false</i>. The linearization point of this unsuccessful <span aria-label="Page 351" epub:type="pagebreak" id="page_351" role="doc-pagebreak"/><img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() is the linearization point of the <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() method by the thread that successfully marked the <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> field. Note that this linearization point must occur during the <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() call because the <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() call found the node unmarked before it found it marked.</p><p class="text" id="p0265">Finally, if the <img alt="Image" height="12" src="images/B9780124159501000240/fx026.jpg" width="97"/> fails and the node is unmarked, then the <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> node must have changed concurrently. Since the <span class="inlinecode">nodeToRemove</span> is known, there is no need to call <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() again, and <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() simply uses the new value read from <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> to retry the marking.</p><p class="text" id="p0270"><span aria-label="Page 352" epub:type="pagebreak" id="page_352" role="doc-pagebreak"/>As noted, both the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() methods rely on <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>(). This method searches the <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/>, returning <i>true</i> if and only if a node with the target key is in the set. It fills in the <img alt="Image" height="10" src="images/B9780124159501000240/fx013.jpg" width="29"/>[] and <img alt="Image" height="6" src="images/B9780124159501000240/fx014.jpg" width="29"/>[] arrays with the target node's ostensible predecessors and successors at each level. It maintains the following two properties:</p><div><ul><li class="bulllist" id="u0010">•  It never traverses a marked link. Instead, it removes the node referred to by a marked link from the list at that level.</li><li class="bulllist" id="u0015">•  Every <img alt="Image" height="10" src="images/B9780124159501000240/fx013.jpg" width="29"/>[] reference is to a node with a key strictly less than the target.</li></ul></div><p class="textfl"/><p class="text" id="p0285">The <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method in <a href="#f0070" id="cf0150">Fig. 14.13</a> proceeds as follows: It starts traversing the <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> from the <img alt="Image" height="11" src="images/B9780124159501000240/fx007.jpg" width="50"/> of the <span aria-label="Page 353" epub:type="pagebreak" id="page_353" role="doc-pagebreak"/><img alt="Image" height="9" src="images/B9780124159501000240/fx005.jpg" width="25"/> sentinel, which has the maximal allowed node level. It then proceeds in each level down the list, filling in <span class="inlinecode">preds</span> and <span class="inlinecode">succs</span> nodes that are repeatedly advanced until <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> refers to a node with the largest value on that level that is strictly less than the target key (lines 118–132). As in the <img alt="Image" height="9" src="images/B9780124159501000240/fx024.jpg" width="78"/>, it repeatedly snips out marked nodes from the given level as they are encountered (lines 120–126) using a <img alt="Image" height="12" src="images/B9780124159501000240/fx026.jpg" width="97"/>. Note that the <img alt="Image" height="12" src="images/B9780124159501000240/fx026.jpg" width="97"/> validates that the <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> field of the predecessor references the current node. Once an unmarked <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> is found (line 127), it is tested to see if its key is less than the target key. If so, <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> is advanced to <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/>. Otherwise, <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/>'s key is greater than or equal to the target's, so the current value of <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> is the target node's immediate predecessor. The <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method breaks out of the current level search loop, saving the current values of <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> and <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> (line 133).</p><div class="pageavoid"><figure class="fig" id="f0070"><img alt="Image" height="520" src="images/B9780124159501000240/gr013.jpg" width="430"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.13</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> class: a more complex <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() than in <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/>.</div></figcaption></figure></div><p class="text" id="p0290">The <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method proceeds this way until it reaches the bottom level. Here is an important point: The traversal at each level maintains the two properties described earlier. In particular, if a node with the target key is in the list, it will be found at the bottom level even if traversed nodes are removed at higher levels. When the traversal stops, <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> refers to a predecessor of the target node. The method descends to each next lower level without skipping over the target node. If the node is in the list, it will be found at the bottom level. Moreover, if <span aria-label="Page 354" epub:type="pagebreak" id="page_354" role="doc-pagebreak"/>the node is found, it cannot be marked because if it were marked, it would have been snipped out on lines 120–126. Therefore, the test on line 136 need only check if the key of <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> is equal to the target key to determine if the target is in the set.</p><p class="text" id="p0295">The linearization points of both successful and unsuccessful calls to the <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() methods occur when the <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> reference at the bottom-level list is set, at either line 117 or 124, for the last time before the <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() call's success or failure is determined on line 136. <a href="#f0050" id="cf0155">Fig. 14.9</a> shows how a node is successfully added to the <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/>.</p><p class="text" id="p0300">The wait-free <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() method appears in <a href="#f0075" id="cf0160">Fig. 14.14</a>. It traverses the <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> in the same way as the <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method, descending level-by-level from the <img alt="Image" height="9" src="images/B9780124159501000240/fx005.jpg" width="25"/>. Like <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>(), <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() ignores keys of marked nodes. Unlike <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>(), it does not try to remove marked nodes. Instead, it simply jumps over them (lines 148–151). For an example execution, see <a href="#f0080" id="cf0165">Fig. 14.15</a>.</p><div class="pageavoid"><figure class="fig" id="f0075"><img alt="Image" height="372" src="images/B9780124159501000240/gr014.jpg" width="408"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.14</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> class: the wait-free <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() method.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0080"><img alt="Image" height="203" src="images/B9780124159501000240/gr015.jpg" width="385"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.15</span> Thread <i>A</i> calls <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>(18), which traverses the list starting from the top level of the <img alt="Image" height="9" src="images/B9780124159501000240/fx005.jpg" width="25"/> node. The dotted line marks the traversal by the <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> field, and the sparse dotted line marks the path of the <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> field. The <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> field is advanced to <img alt="Image" height="9" src="images/B9780124159501000240/fx006.jpg" width="23"/> on level 3. Since its key is greater than 18, <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> descends to level 2. The <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> field advances past the marked reference in the node with key 9, again reaching <img alt="Image" height="9" src="images/B9780124159501000240/fx006.jpg" width="23"/>, which is greater than 18, so <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> descends to level 1. Here <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> is advanced to the unmarked node with key 5, and <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> advances past the marked node with key 9 to reach the unmarked node with key 18, at which point <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> is no longer advanced. Though 18 is the target key, the method continues to descend with <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> to the bottom level, advancing <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> to the node with key 8. From this point, <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> traverses past marked Nodes 9 and 15 and Node 11 whose key is smaller than 18. Eventually <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> reaches the unmarked node with key 18, returning <i>true</i>.</div></figcaption></figure></div><p class="text" id="p0305">The method is correct because <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() preserves the same properties as <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>(), among them, that <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/>, in any level, never refers to an unmarked node whose key is greater than or equal to the target key. The <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> variable arrives at the bottom-level list at a node before, and never after, the target node. If the node is added before the <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() method call starts, then it will be found. Moreover, recall that <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() calls <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>(), which unlinks marked nodes from the bottom-level list before adding the new node. It follows that if <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() does not find the desired node, or finds the desired node at the bottom level but <span aria-label="Page 355" epub:type="pagebreak" id="page_355" role="doc-pagebreak"/>marked, then any concurrently added node that was not found must have been added to the bottom level after the start of the <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() call, so it is correct to return <i>false</i> on line 160.</p><p class="text" id="p0310"><a href="#f0085" id="cf0170">Fig. 14.16</a> shows<span style="display:inline-block; width: 0.20em;"/>an<span style="display:inline-block; width: 0.20em;"/>execution<span style="display:inline-block; width: 0.20em;"/>of the<span style="display:inline-block; width: 0.20em;"/><img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() method. In<span style="display:inline-block; width: 0.20em;"/>part<span style="display:inline-block; width: 0.20em;"/>(a), a<span style="display:inline-block; width: 0.20em;"/><img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>(18) call traverses the list starting from the top level of the <img alt="Image" height="9" src="images/B9780124159501000240/fx005.jpg" width="25"/> node. In part (b), the <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>(18) call traverses the list after the node with key 18 has been logically removed.</p><div class="pageavoid"><figure class="fig" id="f0085"><img alt="Image" height="141" src="images/B9780124159501000240/gr016.jpg" width="497"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.16</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> class: a <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() call. In part (a), <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>(18) traverses the list starting from the top level of the <img alt="Image" height="9" src="images/B9780124159501000240/fx005.jpg" width="25"/> node. The dotted line marks the traversal by the <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> field. The <img alt="Image" height="11" src="images/B9780124159501000240/fx011.jpg" width="25"/> field eventually reaches Node 8 at the bottom level and we show the path of <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> from that point on using a sparser dotted line. The <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> traverses past Node 9 and reaches the marked Node 15. In part (b), a new node with key 18 is added to the list by a thread <i>E</i>. Thread <i>E</i>, as part of its <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>(18) call, physically removes the old nodes with keys 9, 15, and 18. Now thread <i>A</i> continues its traversal with the <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> field from the removed node with key 15 (the nodes with keys 15 and 18 are not recycled since they are reachable by thread <i>A</i>). Thread <i>A</i> reaches the node with key 25, which is greater than 18, returning <i>false</i>. Even though at this point there is an unmarked node with key 18 in the <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/>, this node was inserted by <i>E</i> concurrently with <i>A</i>'s traversal and is linearized after <i>A</i>'s <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>(18).</div></figcaption></figure></div></section></section><section><h2 class="h1hd" id="s0050"><a id="st0060"/>14.5 Concurrent skiplists</h2><p class="textfl" id="p0315">We have seen two highly concurrent <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> implementations, each providing logarithmic search without the need to rebalance. In the <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/> class, the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() methods use optimistic fine-grained locking, meaning that the method searches for its target node without locking, and acquires locks and validates only when it discovers the target. The <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() method, usually the most common, is wait-free. In the <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> class, the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() methods are lock-free, building on the <img alt="Image" height="9" src="images/B9780124159501000240/fx024.jpg" width="78"/> class of Chapter <a href="B9780124159501000197.xhtml">9</a>. In this class too, the <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() method is wait-free.</p><p class="text" id="p0320">In Chapter <a href="B9780124159501000252.xhtml">15</a>, we see how one can build highly concurrent priority queues based on the concurrent <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> we presented here.<span aria-label="Page 356" epub:type="pagebreak" id="page_356" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0055"><a id="st0065"/>14.6 Chapter notes</h2><p class="textfl" id="p0325">Bill Pugh invented skiplists, both sequential <a epub:type="noteref" href="#br0710" id="cf0175" role="doc-noteref">[142]</a> and concurrent <a epub:type="noteref" href="#br0705" id="cf0180" role="doc-noteref">[141]</a>. The <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/> is by Maurice Herlihy, Yossi Lev, Victor Luchangco, and Nir Shavit <a epub:type="noteref" href="#br0330" id="cf0185" role="doc-noteref">[66]</a>. The <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> presented here is credited to Maurice Herlihy, Yossi Lev, and Nir Shavit <a epub:type="noteref" href="#br0350" id="cf0190" role="doc-noteref">[70]</a>. It is partly based on an earlier lock-free skiplist algorithm developed by to Kier Fraser <a epub:type="noteref" href="#br0240" id="cf0195" role="doc-noteref">[48]</a>, a variant of which was incorporated into the <span class="sans-serif">java.util.concurrent</span> package by Doug Lea <a epub:type="noteref" href="#br0545" id="cf0200" role="doc-noteref">[109]</a>.</p></section><section><h2 class="h1hd" id="s0060"><a id="st0070"/>14.7 Exercises</h2><p class="textfl" id="p0330"/><div class="boxg1" id="enun0010"><p class="b1num">Exercise 14.1 </p><div><p class="b1textfl" id="p0335">Recall that a skiplist is a <i>probabilistic</i> data structure. Although the expected performance of a <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() call is <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000240/si15.png" style="vertical-align:middle" width="57"/></span>, where <i>n</i> is the number of items in the list, the worst-case performance could be <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000240/si16.png" style="vertical-align:middle" width="35"/></span>. Draw a picture of an eight-element skiplist with worst-case performance, and explain how it got that way.</p></div></div><p class="textfl"/><p class="text" id="p0340"/><div class="boxg1" id="enun0015"><p class="b1num">Exercise 14.2 </p><div><p class="b1textfl" id="p0345">You are given a skiplist with probability <i>p</i> and <img alt="Image" height="13" src="images/B9780124159501000240/fx027.jpg" width="59"/> <i>M</i>. If the list contains <i>N</i> nodes, what is the expected number of nodes at each level from 0 to <span class="hiddenClass"><mml:math><mml:mi>M</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000240/si17.png" style="vertical-align:middle" width="43"/></span>?</p></div></div><p class="textfl"/><p class="text" id="p0350"/><div class="boxg1" id="enun0020"><p class="b1num">Exercise 14.3 </p><div><p class="b1textfl" id="p0355">Modify the <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/> class so <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() starts at the level of the highest node currently in the structure, instead of the highest level possible (<img alt="Image" height="13" src="images/B9780124159501000240/fx027.jpg" width="59"/>).</p></div></div><p class="textfl"/><p class="text" id="p0360"/><div class="boxg1" id="enun0025"><p class="b1num">Exercise 14.4 </p><div><p class="b1textfl" id="p0365">Modify the <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/> to support multiple items with the same key.</p></div></div><p class="textfl"/><p class="text" id="p0370"/><div class="boxg1" id="enun0030"><p class="b1num">Exercise 14.5 </p><div><p class="b1textfl" id="p0375">Suppose we modify the <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> class so that on line 102 of <a href="#f0065" id="cf0205">Fig. 14.12</a>, <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() restarts the main loop instead of returning <i>false</i>.</p><p class="b1text" id="p0380">Is the algorithm still correct? Address both safety and liveness issues. That is, what is an unsuccessful <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() call's new linearization point, and is the class still lock-free?</p></div></div><p class="textfl"/><p class="text" id="p0385"/><div class="boxg1" id="enun0035"><p class="b1num">Exercise 14.6 </p><div><p class="b1textfl" id="p0390">Explain how in the <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> class a node might end up in the list at levels 0 and 2, but not at level 1. Draw pictures.</p></div></div><p class="textfl"/><p class="text" id="p0395"/><div class="boxg1" id="enun0040"><p class="b1num">Exercise 14.7 </p><div><p class="b1textfl" id="p0400">Modify the <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> so that the <img alt="Image" height="9" src="images/B9780124159501000240/fx009.jpg" width="25"/>() method snips out a sequence of marked nodes with a single <img alt="Image" height="12" src="images/B9780124159501000240/fx026.jpg" width="97"/>. Explain why your implementation cannot remove a concurrently inserted unmarked node.</p></div></div><p class="textfl"/><p class="text" id="p0405"/><div class="boxg1" id="enun0045"><p class="b1num">Exercise 14.8 </p><div><p class="b1textfl" id="p0410">Will the <img alt="Image" height="9" src="images/B9780124159501000240/fx015.jpg" width="18"/>() method of the <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> work even if the bottom level is linked and then all other levels are linked in some arbitrary order? Is the same true for the marking of the <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> references in the <img alt="Image" height="6" src="images/B9780124159501000240/fx016.jpg" width="38"/>() method; the bottom level <img alt="Image" height="8" src="images/B9780124159501000240/fx008.jpg" width="25"/> reference is marked last, but references at all other levels are marked in an arbitrary order?</p></div></div><p class="textfl"/><p class="text" id="p0415"/><div class="boxg1" id="enun0050"><p class="b1num">Exercise 14.9 </p><div><p class="b1textfl" id="p0420">(Hard) Modify the <img alt="Image" height="11" src="images/B9780124159501000240/fx002.jpg" width="78"/> so that the list at each level is bidirectional, and allows threads to add and remove items in parallel by traversing from either the <img alt="Image" height="9" src="images/B9780124159501000240/fx005.jpg" width="25"/> or the <img alt="Image" height="9" src="images/B9780124159501000240/fx006.jpg" width="23"/>.</p></div></div><p class="textfl"/><p class="text" id="p0425"><span aria-label="Page 357" epub:type="pagebreak" id="page_357" role="doc-pagebreak"/></p><div class="boxg1" id="enun0055"><p class="b1num">Exercise 14.10 </p><div><p class="b1textfl" id="p0430"><a href="#f0090" id="cf0210">Fig. 14.17</a> shows a buggy <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>() method for the <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> class. Give a scenario where this method returns a wrong answer. Hint: The reason this method is wrong is that it takes into account keys of nodes that have been removed.</p><div class="pageavoid"><figure class="fig" id="f0090"><img alt="Image" height="224" src="images/B9780124159501000240/gr017.jpg" width="404"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 14.17</span> The <img alt="Image" height="11" src="images/B9780124159501000240/fx003.jpg" width="105"/> class: an <i>incorrect</i> <img alt="Image" height="9" src="images/B9780124159501000240/fx004.jpg" width="51"/>().</div></figcaption></figure></div></div></div><p class="textfl"/></section><footer><section epub:type="bibliography" role="doc-bibliography"><div id="bl0445"><h2 class="reftitle" id="st0075">Bibliography</h2><p class="reflist1" epub:type="biblioentry footnote" id="br0240" role="doc-biblioentry">[48] K. Fraser,  <i>Practical Lock-Freedom</i>. [Ph.D. dissertation] Cambridge, England: Kings College, University of Cambridge; September 2003.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0330" role="doc-biblioentry">[66] M. Herlihy, Y. Lev, V. Luchangco, N. Shavit,  A provably correct scalable skiplist (brief announcement),   <i>Proc. of the 10th International Conference on Principles of Distributed Systems</i>.  <i>OPODIS 2006</i>.  2006.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0350" role="doc-biblioentry">[70] Maurice Herlihy, Yossi Lev, Nir Shavit,  <i>A lock-free concurrent skiplist with wait-free search</i>. 2007.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0545" role="doc-biblioentry">[109] Doug Lea,   <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentSkipListMap.html">http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentSkipListMap.html</a>; 2007.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0705" role="doc-biblioentry">[141] W. Pugh,  <i>Concurrent maintenance of skip lists</i>. [Technical Report CS-TR-2222.1] Institute for Advanced Computer Studies, Department of Computer Science, University of Maryland; 1989.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0710" role="doc-biblioentry">[142] W. Pugh,  Skip lists: a probabilistic alternative to balanced trees,   <cite><i>ACM Transactions on Database Systems</i></cite> 1990;33(6):668–676.</p></div></section><section epub:type="rearnotes"><div class="ftnote"><hr/><p class="ftnote1" epub:type="footnote" id="fn001" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0070" role="doc-noteref">1 </a></sup> <a id="np0010"/>“In <a href="#f0030" id="cf0075">Fig. 14.5</a>, we make the <img alt="Image" height="6" src="images/B9780124159501000240/fx012.jpg" width="25"/> field volatile to prevent compiler optimizations of the loop on line 44. Recall that making the node array volatile does not make the array entries volatile.”</p><p class="ftnote1" epub:type="footnote" id="fn002" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0100" role="doc-noteref">2 </a></sup> <a id="np0015"/>“The <img alt="Image" height="9" src="images/B9780124159501000240/fx020.jpg" width="70"/>() method is designed based on empirical measurements to maintain the skiplist property. For example, in the <span class="sans-serif">java.util.concurrent</span> package, for a maximal <img alt="Image" height="11" src="images/B9780124159501000240/fx001.jpg" width="52"/> level of 31, <img alt="Image" height="9" src="images/B9780124159501000240/fx020.jpg" width="70"/>() returns 0 with probability <span class="hiddenClass"><mml:math><mml:mfrac><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:math></span><span><img alt="Image" height="20" src="images/B9780124159501000240/si11.png" style="vertical-align:middle" width="9"/></span>, <i>i</i> with probability <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000240/si12.png" style="vertical-align:middle" width="48"/></span> for <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>30</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000240/si13.png" style="vertical-align:middle" width="66"/></span>, and 31 with probability <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>32</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000240/si14.png" style="vertical-align:middle" width="32"/></span>.”</p></div></section></footer></section></body></html>