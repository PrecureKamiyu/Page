<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mbp="Kindle">
  <head>
    <title>C++ Concurrency in Action, Second Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h2 class="part" id="lof">List of Figures</h2>
      <p class="noind">Chapter 1. Hello, world of concurrency in C++!</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_011.html#ch01fig01" class="calibre4">Figure 1.1. Two approaches to concurrency: parallel execution on a dual-core machine versus task switching on a single-core
               machine</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_011.html#ch01fig02" class="calibre4">Figure 1.2. Task switching of four tasks on two cores</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_011.html#ch01fig03" class="calibre4">Figure 1.3. Communication between a pair of processes running concurrently</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_011.html#ch01fig04" class="calibre4">Figure 1.4. Communication between a pair of threads running concurrently in a single process</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 3. Sharing data between threads</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_013.html#ch03fig01" class="calibre4">Figure 3.1. Deleting a node from a doubly linked list</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_013.html#ch03fig02" class="calibre4">Figure 3.2. Deadlock with threads traversing a list in opposite orders</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 4. Synchronizing concurrent operations</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_014.html#ch04fig01" class="calibre4">Figure 4.1. Using multiple std::shared_future objects to avoid data races</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04fig02" class="calibre4">Figure 4.2. FP-style recursive sorting</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04fig03" class="calibre4">Figure 4.3. A simple state machine model for an ATM</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 5. The C++ memory model and operations on atomic types</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_015.html#ch05fig01" class="calibre4">Figure 5.1. The division of a struct into objects and memory locations</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05fig02" class="calibre4">Figure 5.2. Enforcing an ordering between non-atomic operations using atomic operations</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05fig03" class="calibre4">Figure 5.3. Sequential consistency and happens-before</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05fig04" class="calibre4">Figure 5.4. Relaxed atomics and happens-before</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05fig05" class="calibre4">Figure 5.5. The notebook for the man in the cubicle</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05fig06" class="calibre4">Figure 5.6. Acquire-release and happens-before</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05fig07" class="calibre4">Figure 5.7. The release sequence for the queue operations from listing 5.11</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 6. Designing lock-based concurrent data structures</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_016.html#ch06fig01" class="calibre4">Figure 6.1. A queue represented using a single-linked list</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 7. Designing lock-free concurrent data structures</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_017.html#ch07fig01" class="calibre4">Figure 7.1. Three threads call pop() concurrently, showing why you must check threads_in_pop after claiming the nodes to be
               deleted in try_reclaim().</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 8. Designing concurrent code</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_018.html#ch08fig01" class="calibre4">Figure 8.1. Distributing consecutive chunks of data between threads</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_018.html#ch08fig02" class="calibre4">Figure 8.2. Recursively dividing data</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_018.html#ch08fig03" class="calibre4">Figure 8.3. Matrix multiplication</a><br class="calibre15"/></p>
      </blockquote>
      </body></html>
