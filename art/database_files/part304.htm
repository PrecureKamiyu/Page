<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Practice Exercises</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part303.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part305.htm">下一个 &gt;</a></p><p class="s45" style="padding-top: 4pt;padding-left: 73pt;text-indent: 0pt;text-align: left;">Practice Exercises</p><p style="padding-top: 12pt;padding-left: 155pt;text-indent: -29pt;text-align: justify;"><b>16.1  </b>Download the university database schema and the large university dataset from <span class="s49">dbbook.com</span>. Create the university schema on your favorite database, and load the large university dataset. Use the <b>explain </b>feature described in Note 16.1 on page 746 to view the plan chosen by the database, in diﬀerent cases as detailed below.</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -18pt;text-align: left;">a. Write a query with an equality condition on <i>student</i>.<i>name </i>(which does not have an index), and view the plan chosen.</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -19pt;text-align: left;">b.  Create an index on the attribute <i>student</i>.<i>name</i>, and view the plan chosen for the above query.</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -18pt;text-align: left;">c.  Create simple queries joining two relations, or three relations, and view the plans chosen.</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -19pt;text-align: left;">d. Create a query that computes an aggregate with grouping, and view the plan chosen.</p><p style="padding-top: 6pt;padding-left: 163pt;text-indent: 0pt;text-align: left;">e. Create an <span class="s44">SQL </span>query whose chosen plan uses a semijoin operation.</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -17pt;text-align: justify;">f. Create an <span class="s44">SQL </span>query that uses a <b>not in </b>clause, with a subquery using aggregation. Observe what plan is chosen.</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -18pt;text-align: justify;">g.  Create a query for which the chosen plan uses correlated evaluation (the way correlated evaluation is represented varies by database, but most databases would show a ﬁlter or a project operator with a subplan or subquery).</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -19pt;text-align: justify;">h.  Create an <span class="s44">SQL </span>update query that updates a single row in a relation. View the plan chosen for the update query.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 150pt;text-indent: -16pt;text-align: justify;">i.  Create an <span class="s44">SQL </span>update query that updates a large number of rows in a re- lation, using a subquery to compute the new value. View the plan chosen for the update query.</p><p class="s46" style="padding-top: 8pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;">16.2 <span class="p">Show that the following equivalences hold. Explain how you can apply them to improve the eﬃciency of certain queries:</span></p><p class="s13" style="padding-top: 6pt;padding-left: 131pt;text-indent: 0pt;text-align: left;"><span class="p">a. </span>E<span class="s130">1 </span><span class="s86">⋈</span><span class="s136">θ </span><span class="p">(</span>E<span class="s130">2 </span><span class="s15">− </span>E<span class="s130">3</span><span class="s94">) </span><span class="s86">≡ </span><span class="p">(</span>E<span class="s130">1 </span><span class="s86">⋈</span><span class="s136">θ </span>E<span class="s130">2 </span><span class="s15">− </span>E<span class="s130">1 </span><span class="s86">⋈</span><span class="s136">θ </span>E<span class="s130">3</span><span class="s94">).</span></p><p style="padding-top: 2pt;padding-left: 130pt;text-indent: 0pt;text-align: left;">b.  <span class="s15">σ</span><span class="s137">θ</span>( <span class="s169">A</span><span class="s15">γ</span><i>F</i><i> </i>(<i>E</i>)) <span class="s86">≡ </span><span class="s169">A</span><span class="s15">γ</span><i>F</i><i> </i>(<span class="s15">σ</span><span class="s137">θ</span>(<i>E</i>)), where <span class="s15">θ </span>uses only attributes from <i>A</i>.</p><p class="s15" style="padding-top: 2pt;padding-left: 131pt;text-indent: 0pt;text-align: left;"><span class="p">c.  </span>σ<span class="s137">θ</span><span class="p">(</span><span class="s13">E</span><span class="s93">1 </span>⟕ <span class="s13">E</span><span class="s93">2</span><span class="s94">) </span><span class="s86">≡ </span>σ<span class="s137">θ</span><span class="p">(</span><span class="s13">E</span><span class="s93">1</span><span class="s94">) </span>⟕ <span class="s13">E</span><span class="s93">2</span><span class="s94">, where </span>θ <span class="p">uses only attributes from </span><span class="s13">E</span><span class="s93">1</span><span class="s94">.</span></p><p class="s46" style="padding-top: 5pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;">16.3  <span class="p">For each of the following pairs of expressions, give instances of relations that show the expressions are not equivalent.</span></p><p style="padding-top: 7pt;padding-left: 131pt;text-indent: 0pt;text-align: left;">a.  <span class="s15">Π</span><i>A</i>(<i>r </i><span class="s15">− </span><i>s</i>) and <span class="s15">Π</span><i>A</i>(<i>r</i>) <span class="s15">− Π</span><i>A</i>(<i>s</i>).</p><p class="s109" style="padding-top: 5pt;padding-left: 130pt;text-indent: 0pt;text-align: left;"><span class="s122">b.  </span><span class="s117">σ</span>B<span class="s126">&lt;</span><span class="s119">4</span><span class="s120">( </span>A<span class="s117">γ</span>max<span class="s119">(</span>B<span class="s119">) </span><b>as </b>B<span class="s122">(</span><span class="s121">r</span><span class="s122">)) and </span>A<span class="s117">γ</span>max<span class="s119">(</span>B<span class="s119">) </span><b>as </b>B<span class="s122">(</span><span class="s117">σ</span>B<span class="s126">&lt;</span><span class="s119">4</span><span class="s120">(</span><span class="s121">r</span><span class="s122">)).</span></p><p style="padding-left: 150pt;text-indent: -18pt;text-align: left;">c.  In the preceding expressions, if both occurrences of <i>max </i>were replaced by <i>min</i>, would the expressions be equivalent?</p><p class="s13" style="padding-top: 6pt;padding-left: 130pt;text-indent: 0pt;text-align: left;"><span class="p">d.  (</span>r <span class="s15">⟖ </span>s<span class="p">) </span><span class="s15">⟖ </span>t <span class="p">and </span>r <span class="s15">⟖</span><span class="p">(</span>s <span class="s15">⟖ </span>t<span class="p">)</span></p><p style="padding-left: 150pt;text-indent: 0pt;text-align: left;">In other words, the natural right outer join is not associative.</p><p class="s13" style="padding-top: 6pt;padding-left: 131pt;text-indent: 0pt;text-align: left;"><span class="p">e.  </span><span class="s15">σ</span><span class="s137">θ</span><span class="p">(</span>E<span class="s93">1 </span><span class="s15">⟕ </span>E<span class="s93">2</span><span class="s94">) and </span>E<span class="s93">1 </span><span class="s15">⟕ σ</span><span class="s137">θ</span><span class="p">(</span>E<span class="s93">2</span><span class="s94">), where </span><span class="s15">θ </span><span class="p">uses only attributes from </span>E<span class="s93">2</span><span class="s94">.</span></p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;">16.4  <span class="s42">SQL </span><span class="s43">allows relations with duplicates (Chapter 3), and the multiset version of the relational algebra is deﬁned in Note 3.1 on page 80, Note 3.2 on page 97, and Note 3.3 on page 108. Check which of the equivalence rules 1 through 7.b hold for the multiset version of the relational algebra.</span></p><p class="s13" style="padding-top: 6pt;padding-left: 124pt;text-indent: -30pt;line-height: 92%;text-align: justify;"><b>16.5  </b><span class="p">Consider the relations </span>r<span class="s98">1</span><span class="p">(</span>A<span class="p">, </span>B<span class="p">, </span>C<span class="p">), </span>r<span class="s98">2</span><span class="p">(</span>C<span class="p">, </span>D<span class="p">, </span>E<span class="p">), and </span>r<span class="s98">3</span><span class="p">(</span>E<span class="p">, </span>F <span class="p">), with primary keys </span>A<span class="p">, </span>C<span class="p">, and </span>E<span class="p">, respectively. Assume that </span>r<span class="s98">1</span><span class="p"> has 1000 tuples, </span>r<span class="s98">2</span><span class="p"> has 1500 tuples, and </span>r<span class="s130">3 </span><span class="s94">has 750 tuples. Estimate the size of </span>r<span class="s130">1 </span><span class="s86">⋈ </span>r<span class="s130">2 </span><span class="s86">⋈ </span>r<span class="s130">3</span><span class="s94">, and give an eﬃcient strategy for computing the join.</span></p><p class="s13" style="padding-top: 7pt;padding-left: 124pt;text-indent: -30pt;line-height: 93%;text-align: justify;"><b>16.6 </b><span class="p">Consider the relations </span>r<span class="s98">1</span><span class="p">(</span>A<span class="p">, </span>B<span class="p">, </span>C<span class="p">), </span>r<span class="s98">2</span><span class="p">(</span>C<span class="p">, </span>D<span class="p">, </span>E<span class="p">), and </span>r<span class="s98">3</span><span class="p">(</span>E<span class="p">, </span>F <span class="p">) of Practice Exer- cise 16.5. Assume that there are no primary keys, except the entire schema. Let </span>V <span class="p">(</span>C<span class="p">, </span>r<span class="s93">1</span><span class="s94">) be 900, </span>V <span class="p">(</span>C<span class="p">, </span>r<span class="s93">2</span><span class="s94">) be 1100, </span>V <span class="p">(</span>E<span class="p">, </span>r<span class="s93">2</span><span class="s94">) be 50, and </span>V <span class="p">(</span>E<span class="p">, </span>r<span class="s93">3</span><span class="s94">) be 100. Assume that </span>r<span class="s98">1</span><span class="p"> has 1000 tuples, </span>r<span class="s98">2</span><span class="p"> has 1500 tuples, and </span>r<span class="s98">3</span><span class="p"> has 750 tuples. Es- timate the size of </span>r<span class="s130">1 </span><span class="s86">⋈ </span>r<span class="s130">2 </span><span class="s86">⋈ </span>r<span class="s130">3 </span><span class="s94">and give an eﬃcient strategy for computing the join.</span></p><p style="padding-top: 6pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;"><b>16.7  </b>Suppose that a B<span class="s181">+</span>-tree index on <i>building </i>is available on relation <i>department </i>and that no other index is available. What would be the best way to handle the following selections that involve negation?</p><p class="s119" style="padding-top: 7pt;padding-left: 131pt;text-indent: 0pt;text-align: left;"><span class="s122">a. </span><span class="s117">σ</span><span class="s370">¬ </span>(<i>building </i><span class="s126">&lt; </span>“Watson”)<span class="s120">(</span><span class="s121">department</span><span class="s122">)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s119" style="padding-top: 5pt;padding-left: 162pt;text-indent: 0pt;text-align: left;"><span class="s129">b. </span><span class="s125">σ</span><span class="s370">¬ </span>(<i>building </i><span class="s118">= </span>“Watson”)<span class="s127">(</span><span class="s128">department</span><span class="s129">)</span></p><p class="s119" style="padding-top: 3pt;padding-left: 162pt;text-indent: 0pt;text-align: left;"><span class="s122">c. </span><span class="s117">σ</span><span class="s370">¬ </span>(<i>building </i><span class="s126">&lt; </span>“Watson” <span class="s118">∨ </span><i>budget </i><span class="s126">&lt; </span>50000)<span class="s120">(</span><span class="s121">department</span><span class="s122">)</span></p><p class="s46" style="padding-left: 125pt;text-indent: 0pt;line-height: 11pt;text-align: left;">16.8 <span class="p">Consider the query:</span></p><p class="s46" style="padding-left: 258pt;text-indent: 0pt;line-height: 12pt;text-align: left;">select <span class="p">*</span></p><p class="s13" style="padding-left: 258pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><b>from </b>r<span class="p">, </span>s</p><p class="s13" style="padding-left: 258pt;text-indent: 0pt;line-height: 20pt;text-align: left;"><b>where </b><span class="p">upper(</span>r<span class="s83">.</span>A<span class="p">) = upper(</span>s<span class="s83">.</span>A<span class="p">);</span></p><p style="padding-top: 1pt;padding-left: 155pt;text-indent: 0pt;text-align: left;">where “upper” is a function that returns its input argument with all lowercase letters replaced by the corresponding uppercase letters.</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -18pt;text-align: justify;">a. Find out what plan is generated for this query on the database system you use.</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -19pt;text-align: justify;">b. Some database systems would use a (block) nested-loop join for this query, which can be very ineﬃcient. Brieﬂy explain how hash-join or merge-join can be used for this query.</p><p class="s46" style="padding-top: 6pt;padding-left: 125pt;text-indent: 0pt;text-align: justify;">16.9  <span class="p">Give conditions under which the following expressions are equivalent:</span></p><p class="s119" style="padding-top: 4pt;padding-left: 219pt;text-indent: 0pt;text-align: left;"><i>A</i>,<i>B</i><span class="s117">γ</span><span class="s111">agg</span>(<i>C</i>)<span class="s120">(</span><span class="s121">E</span>1 <span class="s138">⋈ </span><span class="s121">E</span>2<span class="s120">)  and  (</span><i>A</i><span class="s117">γ</span><span class="s111">agg</span>(<i>C</i>)<span class="s120">(</span><span class="s121">E</span>1<span class="s120">)) </span><span class="s138">⋈ </span><span class="s121">E</span>2</p><p style="padding-top: 4pt;padding-left: 155pt;text-indent: 0pt;text-align: justify;">where <i>agg </i>denotes any aggregation operation. How can the above conditions be relaxed if <i>agg </i>is one of <b>min </b>or <b>max</b>?</p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: -34pt;text-align: justify;"><b>16.10  </b>Consider the issue of interesting orders in optimization. Suppose you are given a query that computes the natural join of a set of relations <i>S</i>. Given a subset <i>S</i>1 of <i>S</i>, what are the interesting orders of <i>S</i>1?</p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: -34pt;text-align: justify;"><b>16.11 </b>Modify the FindBestPlan(<i>S</i>) function to create a function FindBestPlan(<i>S</i>, <i>O</i>), where <i>O </i>is a desired sort order for <i>S</i>, and which considers interesting sort orders. A <i>null </i>order indicates that the order is not relevant. <i>Hints</i>: An algorithm <i>A </i>may give the desired order <i>O</i>; if not a sort operation may need to be added to get the desired order. If <i>A </i>is a merge-join, FindBestPlan must be invoked on the two inputs with the desired orders for the inputs.</p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: -35pt;text-align: justify;"><b>16.12  </b>Show that, with <i>n </i>relations, there are (2(<i>n </i><span class="s15">− </span>1))<span class="s15">!∕</span>(<i>n </i><span class="s15">− </span>1)<span class="s15">! </span>diﬀerent join orders. <i>Hint: </i>A <span class="s63">complete binary tree </span>is one where every internal node has exactly two children. Use the fact that the number of diﬀerent complete binary trees with</p><p class="s13" style="padding-left: 155pt;text-indent: 0pt;line-height: 2pt;text-align: justify;">n <span class="p">leaf nodes is:</span></p><p style="padding-left: 159pt;text-indent: 0pt;text-align: center;"><u>1</u> <span class="s421">(</span>2(<i>n </i><span class="s15">− </span>1)<span class="s421">)</span></p><p class="s13" style="text-indent: 0pt;line-height: 12pt;text-align: left;">n</p><p style="text-indent: 0pt;text-align: left;">(<i>n </i><span class="s15">− </span>1)</p><p style="padding-left: 293pt;text-indent: 0pt;text-align: left;"><span style=" color: black; font-family:Cambria, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 1pt;">	</span></p><p style="padding-top: 1pt;padding-left: 155pt;text-indent: 0pt;text-align: justify;">If you wish, you can derive the formula for the number of complete binary trees with <i>n </i>nodes from the formula for the number of binary trees with <i>n </i>nodes. The number of binary trees with <i>n </i>nodes is:</p><p style="padding-left: 116pt;text-indent: 0pt;text-align: center;"><u> 1 </u> <span class="s421">(</span>2<i>n</i><span class="s421">)</span></p><p class="s13" style="text-indent: 0pt;text-align: left;">n <span class="s15">+ </span><span class="p">1</span></p><p class="s13" style="text-indent: 0pt;line-height: 12pt;text-align: left;">n</p><p style="padding-left: 297pt;text-indent: 0pt;text-align: left;"><span style=" color: black; font-family:Cambria, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt;">	</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 124pt;text-indent: 0pt;text-align: justify;">This number is known as the <span class="s63">Catalan number</span>, and its derivation can be found in any standard textbook on data structures or algorithms.</p><p style="padding-top: 6pt;padding-left: 124pt;text-indent: -35pt;text-align: justify;"><b>16.13  </b>Show that the lowest-cost join order can be computed in time <i>O</i>(3<i>n</i>). Assume that you can store and look up information about a set of relations (such as the optimal join order for the set, and the cost of that join order) in constant time. (If you ﬁnd this exercise diﬃcult, at least show the looser time bound of <i>O</i>(2<span class="s76">2</span><i>n</i>).)</p><p style="padding-top: 6pt;padding-left: 124pt;text-indent: -34pt;text-align: justify;"><b>16.14  </b>Show that, if only left-deep join trees are considered, as in the System R opti- mizer, the time taken to ﬁnd the most eﬃcient join order is around <i>n</i>2<i>n</i>. Assume that there is only one interesting sort order.</p><p style="padding-top: 6pt;padding-left: 124pt;text-indent: -35pt;text-align: justify;"><b>16.15  </b>Consider the bank database of Figure 16.9, where the primary keys are under- lined. Construct the following <span class="s44">SQL </span>queries for this relational database.</p><p style="padding-top: 7pt;padding-left: 150pt;text-indent: -18pt;text-align: justify;">a.  Write a nested query on the relation <i>account </i>to ﬁnd, for each branch with name starting with B, all accounts with the maximum balance at the branch.</p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: -19pt;text-align: justify;">b. Rewrite the preceding query without using a nested subquery; in other words, decorrelate the query, but in <span class="s44">SQL</span>.</p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: -18pt;text-align: justify;">c. Give a relational algebra expression using semijoin equivalent to the query.</p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: -19pt;text-align: justify;">d.  Give a procedure (similar to that described in Section 16.4.4) for decor- relating such queries.</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part303.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part305.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
