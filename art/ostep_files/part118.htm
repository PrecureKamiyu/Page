<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>13.2 Multiprogramming and Time Sharing</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part117.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part119.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">13.2 Multiprogramming and Time Sharing</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">After a time, because machines were expensive, people began to share machines more effectively. Thus the era of <b>multiprogramming </b>was born [DV66], in which multiple processes were ready to run at a given time, and the OS would switch between them, for example when one decided to perform an I/O. Doing so increased the effective <b>utilization </b>of the CPU. Such increases in <b>efficiency </b>were particularly important in those days where each machine cost hundreds of thousands or even millions of dollars (and you thought your Mac was expensive!).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: right;">Soon enough, however, people began demanding more of machines, and the era of <b>time sharing </b>was born [S59, L60, M62, M83]. Specifically, many realized the limitations of batch computing, particularly on pro- grammers themselves [CV65], who were tired of long (and hence ineffec- tive) program-debug cycles. The notion of <b>interactivity </b>became impor- tant, as many users might be concurrently using a machine, each waiting for (or hoping for) a timely response from their currently-executing tasks.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">One way to implement time sharing would be to run one process for a short while, giving it full access to all memory (as in Figure <span style=" color: #00AEEF;">13.1</span>), then stop it, save all of its state to some kind of disk (including all of physical memory), load some other process’s state, run it for a while, and thus implement some kind of crude sharing of the machine [M+63].</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Unfortunately, this approach has a big problem: it is way too slow, par- ticularly as memory grew. While saving and restoring register-level state (e.g., the PC, general-purpose registers, etc.) is relatively fast, saving the entire contents of memory to disk is brutally non-performant. Thus, what we’d rather do is leave processes in memory while switching between them, allowing the OS to implement time sharing efficiently (Figure <span style=" color: #00AEEF;">13.2</span>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: right;">0KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: right;">1KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: right;">2KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">15KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: right;">16KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 72pt;text-indent: 0pt;text-align: center;">the code segment: where instructions live</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="80" height="120" alt="image" src="Image_129.png"/></span></p><p class="s65" style="text-indent: 0pt;line-height: 6pt;text-align: left;">(free)</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 21pt;text-indent: 0pt;text-align: center;">Stack</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 21pt;text-indent: 0pt;text-align: center;">Heap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">Program Code</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="padding-left: 70pt;text-indent: 0pt;text-align: center;">the heap segment: contains malloc’d data dynamic data structures (it grows downward)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-top: 2pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">(it grows upward) the stack segment:</p><p class="s84" style="padding-left: 54pt;text-indent: 0pt;text-align: center;">contains local variables arguments to routines, return values, etc.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">Figure 13.3: <b>An Example Address Space</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: right;">In the diagram, there are three processes (A, B, and C) and each of them have a small part of the 512-KB physical memory carved out for them. Assuming a single CPU, the OS chooses to run one of the processes (say A), while the others (B and C) sit in the ready queue waiting to run. As time sharing became more popular, you can probably guess that new demands were placed on the operating system. In particular, allow- ing multiple programs to reside concurrently in memory makes <b>protec- tion </b>an important issue; you don’t want a process to be able to read, or</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 10pt;text-align: left;">worse, write some other process’s memory.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part117.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part119.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
