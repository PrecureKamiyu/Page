<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Example Translations</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part143.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part145.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">Example Translations</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">To understand address translation via base-and-bounds in more detail, let’s take a look at an example. Imagine a process with an address space of size 4 KB (yes, unrealistically small) has been loaded at physical address 16 KB. Here are the results of a number of address translations:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 54pt;text-indent: 0pt;line-height: 11pt;text-align: left;">• <span class="p">Virtual Address 0 </span>→ <span class="p">Physical Address 16 KB</span></p><p class="s4" style="padding-left: 54pt;text-indent: 0pt;line-height: 10pt;text-align: left;">• <span class="p">VA 1 KB </span>→ <span class="p">PA 17 KB</span></p><p class="s4" style="padding-left: 54pt;text-indent: 0pt;line-height: 10pt;text-align: left;">• <span class="p">VA 3000 </span>→ <span class="p">PA 19384</span></p><p class="s4" style="padding-left: 54pt;text-indent: 0pt;line-height: 11pt;text-align: left;">• <span class="p">VA 4400 </span>→ <span class="p">Fault (out of bounds)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 63pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>D<span class="s45">ATA </span>S<span class="s45">TRUCTURE </span>– T<span class="s45">HE </span>F<span class="s45">REE </span>L<span class="s45">IST</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">The OS must track which parts of free memory are not in use, so as to be able to allocate memory to processes. Many different data structures can of course be used for such a task; the simplest (which we will assume here) is a <b>free list</b>, which simply is a list of the ranges of the physical memory which are not currently in use.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">As you can see from the example, it is easy for you to simply add the base address to the virtual address (which can rightly be viewed as an <i>offset </i>into the address space) to get the resulting physical address. Only if the virtual address is “too big” or negative will the result be a fault (e.g., 4400 is greater than the 4 KB bounds), causing an exception to be raised and the process to be terminated.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part143.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part145.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
