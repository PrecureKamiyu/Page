#+HTML_HEAD: <link rel = "stylesheet" type="text/css" href ="style_for_org.css"/>
#+OPTIONS: html-style:nil
#+TITLE: Chapter 12: Network

* 网络通信

** IP 

IP 地址是 Internet Protocol Address 的缩写，指的是网络中设备的标识符。
它是一个由 32 位二进制数字组成的地址，在人类可读的形式下被表示为 4 个
十进制数（每个数在 0-255 之间），用点号分隔开来。

IP 地址分为两种类型：IPv4 和 IPv6。IPv4 地址由 32 位二进制数字组成，而
IPv6 地址则由 128 位二进制数字组成。目前，IPv4 地址仍然是互联网上最常
用的地址类型。IPv4 地址共有 4294967296 个，但由于一些保留地址和私有地
址的存在，实际可用的公共 IPv4 地址数量要少得多。

IP 地址的作用是唯一地标识连接到 Internet 上的设备，并且它是 Internet
通信过程中的基本单元。每次从一台计算机向另一台计算机发送数据时，数据包
都会携带源 IP 地址和目标 IP 地址，以确保数据传输到正确的设备上。

本机地址为: 127.0.0.1

** 域名系统 (DNS)

DNS 代表域名系统（Domain Name System），是一个用于将易于记忆的域名转换
为 IP 地址的分布式数据库系统。因为互联网上存在数以亿计的设备和计算机，
用 IP 地址来访问它们是不方便的，而且很难记住众多的数字地址。DNS 解决了
这个问题，它允许我们使用易于记忆的域名，例如 ~www.example.com~ ，而不是记
住其对应的 IP 地址。

当您在浏览器中输入 URL 或域名时，DNS 服务器会将该域名映射到相应的 IP
地址，并将其返回给您的计算机，然后您的计算机可以使用该地址连接到目标服
务器。DNS 系统是一个分层的系统，由许多不同的 DNS 服务器组成，每个 DNS
服务器都存储了一部分域名和 IP 地址的映射关系。当一个 DNS 服务器无法找
到所请求的域名和 IP 地址的映射时，它会向其他 DNS 服务器发送请求，直到
找到匹配的映射为止。

** 网络协议层级

TCP/IP 是一个网络通信协议族，它包含了许多不同的协议，按照功能可以分为四个层级：

1. *应用层* ：应用层协议处理特定应用程序之间的通信，例如 Web 浏览器、电子
   邮件客户端和文件传输协议（FTP）客户端等。常见的应用层协议包括 HTTP、
   SMTP、POP3、FTP 等。

2. *传输层* ：传输层协议负责在源和目标设备之间提供端到端的可靠数据传输服
   务。TCP 是最常用的传输层协议，它提供流控制、拥塞控制和错误检测等功
   能。另一个传输层协议是用户数据报协议（UDP），它提供无连接的数据传输
   服务。

3. *网络层* ：网络层协议负责在互联网上路由数据包，确保它们到达正确的目标。
   IP协议是最常用的网络层协议，它定义了网络地址和路由选择，并将传输层
   的数据封装在 IP 数据包中以进行传输。

4. *链路层(网络接口层)* ：链路层协议负责在物理网络上传输数据帧。它确保
   数据从一个网络节点传输到下一个网络节点，并提供对物理层面的控制和管
   理。常见的链路层协议包括以太网和 Wi-Fi。

总之，TCP/IP 协议族是一个四层网络通信协议体系结构，它包括了应用层、传
输层、网络层和链路层。不同层级的协议协同工作，为数据在网络中的传输提供
了完整的解决方案。

** TCP 和 UDP

TCP 是在传输层的东西. TCP 是最常用的传输层协议，它提供 *流控制、拥塞控制 和错误检测* 等功能。另一个传输层协议是用户数据报协议（UDP），它提供无连
接的数据传输服务.

UDP 是用户数据报协议（User Datagram Protocol）的缩写。它是一种无连接协
议，用于在计算机网络上发送数据包。相对于 TCP 协议，UDP 协议具有更快的
传输速度，但是不保证数据包的 *可靠性和顺序性* 。因此，在某些应用场景中，如
实时音视频传输、在线游戏等，UDP 协议更为适用。

** Socket

Socket（套接字）是一种在计算机网络中进行进程间通信或传输数据的机制。它
提供了一种标准的接口，使得应用程序能够通过网络协议与其他应用程序进行通
信。

Socket 有两个部分组成, 1. _IP地址_; 2. _端口号_.

Socket 通常被用于实现客户端 / 服务器模型，其中服务器监听来自客户端的连
接请求，并向客户端提供服务。客户端则通过 Socket 与服务器建立连接并发送
请求，以获取服务响应。

在编程中，Socket 可以使用各种编程语言和网络库进行实现。常见的 Socket
类型有 TCP Socket 和 UDP Socket。




在局域网中 *多* 台计算机可能共享同一个公网IP地址，这是通过网络地址转换
技术（NAT）实现的。NAT技术允许多台计算机共享同一个公网IP地址，从而节省
了有限的IPv4地址资源。当使用NAT技术时， *路由器* 会在转发数据包时修改
数据包中的源IP地址和源端口号，以便外部网络可以正确地将响应数据发送回路
由器。

当路由器接收到来自外部网络的响应数据时，它会根据之前保存的NAT映射表，
将数据包中的目的IP地址和目的端口号修改为内部网络中计算机的IP地址和端口
号，然后将数据包 *转发* 给内部网络中的计算机。因此，在使用NAT技术时，
外部网络无法直接根据IP地址和端口号确定数据来自或发送给内部网络中的哪台
计算机。只有路由器才能根据NAT映射表确定数据来自或发送给内部网络中的哪
台计算机

** Socket 客户端和服务器

当然可以，以下是一个简单的 Java Socket 客户端和服务器端通信的例子：

Server.java:

#+BEGIN_SRC java
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    public static void main(String[] args) throws IOException {
        int port = 12345;
        ServerSocket serverSocket = new ServerSocket(port);
        System.out.println("Server started on port " + port);

        while (true) {
            Socket socket = serverSocket.accept();
            System.out.println("New client connected: " + socket.getInetAddress().getHostAddress());

            ClientHandler clientHandler = new ClientHandler(socket);
            clientHandler.start();
        }
    }
}
#+END_SRC
ClientHandler.java:
#+BEGIN_SRC java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;

public class ClientHandler extends Thread {
    private final Socket socket;
    private BufferedReader input;
    private PrintWriter output;

    public ClientHandler(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        try {
            input = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            output = new PrintWriter(socket.getOutputStream(), true);

            String message;
            while ((message = input.readLine()) != null) {
                System.out.println("Received message from client: " + message);
                output.println("Echo: " + message);
            }
        } catch (IOException e) {
            System.err.println("Error handling client: " + e.getMessage());
        } finally {
            try {
                socket.close();
            } catch (IOException e) {
                System.err.println("Error closing socket: " + e.getMessage());
            }
        }
    }
}
#+END_SRC

Client.java:

#+BEGIN_SRC java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;

public class Client {
    public static void main(String[] args) throws IOException {
        String host = "localhost";
        int port = 12345;

        Socket socket = new Socket(host, port);
        System.out.println("Connected to server on " + host + ":" + port);

        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
        BufferedReader serverInput = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        PrintWriter output = new PrintWriter(socket.getOutputStream(), true);

        String message;
        while ((message = input.readLine()) != null) {
            output.println(message);
            System.out.println("Received from server: " + serverInput.readLine());
        }

        socket.close();
    }
}
#+END_SRC

这个例子中，服务器程序在端口 12345 上监听客户端连接请求。每当有一个新
的客户端连接时，它会启动一个新的线程来处理该客户端的请求。客户端程序通
过 IP 地址和端口号连接到服务器，并输入要发送的消息。在服务器程序中，新
的线程接收到客户端发送的消息并将其打印到控制台上，然后将其作为回显发送
给客户端。


** socket 流

~sock.getInputStream();~ 就能够得到一个 input 流, 这是用来从服务器处读
取数据用的. 然后又, ~sock.getOutputStream()~ 能够到的一个 output 流,
用来向 socket 里面写数据的.

我们常用 BufferedReader 来封装这个 input, 使用 PrintWriter 来封装这个
output 流.