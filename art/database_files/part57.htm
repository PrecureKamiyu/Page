<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>1.6   Database Engine</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part56.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part58.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">1.6   <span style=" color: #00AEEF;">Database Engine</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">A database system is partitioned into modules that deal with each of the responsibilities of the overall system. The functional components of a database system can be broadly divided into the storage manager, the <span class="s63">query processor </span>components, and the transaction management component.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The storage manager is important because databases typically require a large amount of storage space. Corporate databases commonly range in size from hundreds of gigabytes to terabytes of data. A gigabyte is approximately 1 billion bytes, or 1000 megabytes (more precisely, 1024 megabytes), while a terabyte is approximately 1 tril- lion bytes or 1 million megabytes (more precisely, 1024 gigabytes). The largest enter- prises have databases that reach into the multi-petabyte range (a petabyte is 1024 ter- abytes). Since the main memory of computers cannot store this much information, and since the contents of main memory are lost in a system crash, the information is stored on disks. Data are moved between disk storage and main memory as needed. Since the movement of data to and from disk is slow relative to the speed of the central process- ing unit, it is imperative that the database system structure the data so as to minimize the need to move data between disk and main memory. Increasingly, solid-state disks (<span class="s44">SSDs</span>) are being used for database storage. <span class="s44">SSDs </span>are faster than traditional disks but also more costly.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The query processor is important because it helps the database system to simplify and facilitate access to data. The query processor allows database users to obtain good performance while being able to work at the view level and not be burdened with un- derstanding the physical-level details of the implementation of the system. It is the job of the database system to translate updates and queries written in a nonprocedural language, at the logical level, into an eﬃcient sequence of operations at the physical level.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The transaction manager is important because it allows application developers to treat a sequence of database accesses as if they were a single unit that either happens in its entirety or not at all. This permits application developers to think at a higher level of</p><p class="s66" style="padding-top: 3pt;padding-left: 372pt;text-indent: 0pt;text-align: left;">1.6 <span style=" color: #00AEEF;">Database Engine</span><span class="s67">  </span><span class="s20">19</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: right;">abstraction about the application without needing to be concerned with the lower-level details of managing the eﬀects of concurrent access to the data and of system failures. While database engines were traditionally centralized computer systems, today parallel processing is key for handling very large amounts of data eﬃciently. Modern database engines pay a lot of attention to parallel data storage and parallel query pro-</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">cessing.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">1.6.1 Storage Manager</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The <span class="s63">storage manager </span>is the component of a database system that provides the interface between the low-level data stored in the database and the application programs and queries submitted to the system. The storage manager is responsible for the interaction with the ﬁle manager. The raw data are stored on the disk using the ﬁle system provided by the operating system. The storage manager translates the various <span class="s44">DML </span>statements into low-level ﬁle-system commands. Thus, the storage manager is responsible for stor- ing, retrieving, and updating data in the database.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">The storage manager components include:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Authorization and integrity manager</span><span class="p">, which tests for the satisfaction of integrity constraints and checks the authority of users to access data.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Transaction manager</span><span class="p">, which ensures that the database remains in a consistent (cor- rect) state despite system failures, and that concurrent transaction executions pro- ceed without conﬂicts.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s63">File manager</span><span class="p">, which manages the allocation of space on disk storage and the data structures used to represent information stored on disk.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Buﬀer manager</span><span class="p">, which is responsible for fetching data from disk storage into main memory, and deciding what data to cache in main memory. The buﬀer manager is a critical part of the database system, since it enables the database to handle data sizes that are much larger than the size of main memory.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: left;">The storage manager implements several data structures as part of the physical system implementation:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 123pt;text-indent: 0pt;text-align: justify;">• <span class="s63">Data ﬁles</span><span class="p">, which store the database itself.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Data dictionary</span><span class="p">, which stores metadata about the structure of the database, in particular the schema of the database.</span></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s63">Indices</span>, which can provide fast access to data items. Like the index in this textbook, a database index provides pointers to those data items that hold a particular value. For example, we could use an index to ﬁnd the <i>instructor </i>record with a particular <span class="s69">ID</span>, or all <i>instructor </i>records with a particular <i>name</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">We discuss storage media, ﬁle structures, and buﬀer management in Chapter 12 and Chapter 13. Methods of accessing data eﬃciently are discussed in Chapter 14.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">1.6.2 The Query Processor</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The query processor components include:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s64">DDL </span><span class="s84">interpreter</span>, which interprets <span class="s44">DDL </span>statements and records the deﬁnitions in the data dictionary.</p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s63">DML compiler</span>, which translates <span class="s44">DML </span>statements in a query language into an eval- uation plan consisting of low-level instructions that the query-evaluation engine understands.</p><p style="padding-left: 107pt;text-indent: 15pt;text-align: justify;">A query can usually be translated into any of a number of alternative evalua- tion plans that all give the same result. The <span class="s44">DML </span>compiler also performs <span class="s63">query optimization</span>; that is, it picks the lowest cost evaluation plan from among the alter- natives.</p><p class="s39" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 15pt;text-align: left;">• <span class="s63">Query evaluation engine</span><span class="p">, which executes low-level instructions generated by the</span></p><p class="s42" style="padding-left: 107pt;text-indent: 0pt;line-height: 13pt;text-align: left;">DML <span class="s43">compiler.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">Query evaluation is covered in Chapter 15, while the methods by which the query opti- mizer chooses from among the possible evaluation strategies are discussed in Chapter 16.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">1.6.3 Transaction Management</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Often, several operations on the database form a single logical unit of work. An exam- ple is a funds transfer, as in Section 1.2, in which one account <i>A </i>is debited and another account <i>B </i>is credited. Clearly, it is essential that either both the credit and debit occur, or that neither occur. That is, the funds transfer must happen in its entirety or not at all. This all-or-none requirement is called <span class="s63">atomicity</span>. In addition, it is essential that the execution of the funds transfer preserves the consistency of the database. That is, the value of the sum of the balances of <i>A </i>and <i>B </i>must be preserved. This correctness require- ment is called <span class="s63">consistency</span>. Finally, after the successful execution of a funds transfer, the new values of the balances of accounts <i>A </i>and <i>B </i>must persist, despite the possibility of system failure. This persistence requirement is called <span class="s63">durability</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A <span class="s63">transaction </span>is a collection of operations that performs a single logical function in a database application. Each transaction is a unit of both atomicity and consistency. Thus, we require that transactions do not violate any database-consistency constraints. That is, if the database was consistent when a transaction started, the database must be consistent when the transaction successfully terminates. However, during the exe- cution of a transaction, it may be necessary temporarily to allow inconsistency, since</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><a name="bookmark15">either the debit of </a><i>A </i>or the credit of <i>B </i>must be done before the other. This temporary inconsistency, although necessary, may lead to diﬃculty if a failure occurs.<a name="bookmark27">&zwnj;</a></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">It is the programmer’s responsibility to properly deﬁne the various transactions so that each preserves the consistency of the database. For example, the transaction to transfer funds from account <i>A </i>to account <i>B </i>could be deﬁned to be composed of two separate programs: one that debits account <i>A </i>and another that credits account <i>B</i>. The execution of these two programs one after the other will indeed preserve consistency. However, each program by itself does not transform the database from a consistent state to a new consistent state. Thus, those programs are not transactions.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Ensuring the atomicity and durability properties is the responsibility of the database system itself— speciﬁcally, of the <span class="s63">recovery manager</span>. In the absence of failures, all transactions complete successfully, and atomicity is achieved easily. However, be- cause of various types of failure, a transaction may not always complete its execution successfully. If we are to ensure the atomicity property, a failed transaction must have no eﬀect on the state of the database. Thus, the database must be restored to the state in which it was before the transaction in question started executing. The database sys- tem must therefore perform <span class="s63">failure recovery</span>, that is, it must detect system failures and restore the database to the state that existed prior to the occurrence of the failure.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Finally, when several transactions update the database concurrently, the consis- tency of data may no longer be preserved, even though each individual transaction is correct. It is the responsibility of the <span class="s63">concurrency-control manager </span>to control the inter- action among the concurrent transactions, to ensure the consistency of the database. The <span class="s63">transaction manager </span>consists of the concurrency-control manager and the recovery manager.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The basic concepts of transaction processing are covered in Chapter 17. The man- agement of concurrent transactions is covered in Chapter 18. Chapter 19 covers failure recovery in detail.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The concept of a transaction has been applied broadly in database systems and applications. While the initial use of transactions was in ﬁnancial applications, the concept is now used in real-time applications in telecommunication, as well as in the management of long-duration activities such as product design or administrative work- ﬂows.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part56.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part58.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
