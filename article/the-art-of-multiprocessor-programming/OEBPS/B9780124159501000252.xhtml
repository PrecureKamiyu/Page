<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:mml="http://www.w3.org/1998/Math/MathML" lang="EN" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="default-style"/><title>The Art of Multiprocessor Programming</title><link href="Elsevier_eBook.css" rel="stylesheet" type="text/css"/><link href="math.css" rel="stylesheet" type="text/css"/><link href="media.css" media="only screen" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4f1c4a5b-a3e2-48ff-98f3-ff17812cd57a" name="Adept.expected.resource"/></head><body><section epub:type="chapter" role="doc-chapter"><div aria-label="Page 359" epub:type="pagebreak" id="page_359" role="doc-pagebreak"/><div id="CN"><a id="c0010tit1"/></div><header><hgroup><h1 class="chaptitle" id="c0010tit">Chapter 15: Priority queues</h1></hgroup><section epub:type="preamble"><div class="abstract"><h2 class="h1hd" id="ab0010"><a id="st0010"/>Abstract</h2><p class="abspara">This chapter presents several concurrent priority queue implementations. A priority queue is a multiset of items, each with an associated priority; items are processed (i.e., removed from the queue) in order of their priority. Priority queues play a vital role in many applications, which have different requirements for their priority queues. For example, some applications require linearizable priority queues, while others are satisfied with quiescently consistent ones. Some assign priorities from a small bounded range, while others have an unbounded (or at least very large) range. The algorithms presented here vary in the properties they provide, with simpler and more efficient implementations for priority queues with less stringent requirements.</p></div></section><section id="ks0010"><h3 class="h2hd" id="st0015">Keywords</h3><p class="keywords">Quiescent consistency; linearizability; contention; priority queue; skiplist</p></section></header><section><h2 class="h1hd" id="s0010"><a id="st0020"/>15.1 Introduction</h2><p class="textfl" id="p0010">A <i>priority queue</i> is a multiset of <i>items</i>, where each item has an associated <i>priority</i>, a score that indicates its importance (by convention, smaller scores are more important, indicating a higher priority). A priority queue typically provides an <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() method to add an item to the set, and a <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method to remove and return the item of minimal score (highest priority). Priority queues appear everywhere, from high-level applications to low-level operating system kernels.</p><p class="text" id="p0015">A <i>bounded-range</i> priority queue is one where each item's score is taken from a discrete set of items, while an <i>unbounded-range</i> priority queue is one where scores are taken from a very large set, say, 32-bit integers, or floating-point values. Not surprisingly, bounded-range priority queues are generally more efficient, but many applications require unbounded ranges. <a href="#f0010" id="cf0010">Fig. 15.1</a> shows the priority queue interface.</p><div class="pageavoid"><figure class="fig" id="f0010"><img alt="Image" height="60" src="images/B9780124159501000252/gr001.jpg" width="178"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.1</span> Priority queue interface.</div></figcaption></figure></div><section><h3 class="h2hd" id="s0015"><a id="st0025"/>15.1.1 Concurrent priority queues</h3><p class="textfl" id="p0020">In a concurrent setting, where <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() and <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method calls can overlap, what does it mean for an item to be in the set?</p><p class="text" id="p0025">We consider two alternative consistency conditions, both introduced in Chapter <a href="B9780124159501000124.xhtml">3</a>. First, <i>linearizability</i>, requires that each method call appear to take effect at some instant between its invocation and its response. Second, <i>quiescent consistency</i>, is a weaker condition that requires that in any execution, at any point, if no additional method calls are introduced, then when all pending method calls complete, the values they return are consistent with some valid sequential execution of the object. If an application does not require its priority queues to be linearizable, then it is usually more efficient to require them to be quiescently consistent. Careful thought is usually required to decide which approach is correct for a particular application.<span aria-label="Page 360" epub:type="pagebreak" id="page_360" role="doc-pagebreak"/></p></section></section><section><h2 class="h1hd" id="s0020"><a id="st0030"/>15.2 An array-based bounded priority queue</h2><p class="textfl" id="p0030">A bounded-range priority queue has <i>range m</i> if its priorities are taken from the range <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000252/si1.png" style="vertical-align:middle" width="84"/></span>. For now, we consider bounded priority queue algorithms that use two component data structures: <img alt="Image" height="9" src="images/B9780124159501000252/fx003.jpg" width="46"/> and <img alt="Image" height="9" src="images/B9780124159501000252/fx004.jpg" width="18"/>. A <img alt="Image" height="9" src="images/B9780124159501000252/fx003.jpg" width="46"/> (see Chapter <a href="B9780124159501000227.xhtml">12</a>) holds an integer value, and supports <img alt="Image" height="11" src="images/B9780124159501000252/fx005.jpg" width="99"/>() and <img alt="Image" height="11" src="images/B9780124159501000252/fx006.jpg" width="99"/>() methods that atomically increment and decrement the counter value and return the counter's prior value. These methods may optionally be <i>bounded</i>, meaning they do not advance the counter value beyond some specified bound.</p><p class="text" id="p0035">A <img alt="Image" height="9" src="images/B9780124159501000252/fx004.jpg" width="18"/> is a pool that holds arbitrary items, and supports a <img alt="Image" height="11" src="images/B9780124159501000252/fx008.jpg" width="18"/>(<i>x</i>) method for inserting an item <i>x</i> and a <img alt="Image" height="11" src="images/B9780124159501000252/fx009.jpg" width="19"/>() method for removing and returning an arbitrary item, returning <i>null</i> if the bin is empty. Bins can be implemented using locks or in a lock-free manner using the stack algorithms of Chapter <a href="B9780124159501000215.xhtml">11</a>.</p><p class="text" id="p0040"><a href="#f0015" id="cf0015">Fig. 15.2</a> shows the <img alt="Image" height="11" src="images/B9780124159501000252/fx007.jpg" width="79"/> class, which maintains an array of bins. To add an item with score <i>i</i>, a thread simply places the item in the <i>i</i>th bin. The <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method scans the bins in decreasing priority and returns the first item it successfully removes. If no item is found it returns <i>null</i>. If the bins are quiescently consistent, so is <img alt="Image" height="11" src="images/B9780124159501000252/fx007.jpg" width="79"/>. The <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() and <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() methods are lock-free if the <img alt="Image" height="9" src="images/B9780124159501000252/fx004.jpg" width="18"/> methods are lock-free.<span aria-label="Page 361" epub:type="pagebreak" id="page_361" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0015"><img alt="Image" height="372" src="images/B9780124159501000252/gr002.jpg" width="329"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.2</span> The <img alt="Image" height="11" src="images/B9780124159501000252/fx007.jpg" width="79"/> class: <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() and <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() methods.</div></figcaption></figure></div></section><section><h2 class="h1hd" id="s0025"><a id="st0035"/>15.3 A tree-based bounded priority queue</h2><p class="textfl" id="p0045">The <img alt="Image" height="11" src="images/B9780124159501000252/fx010.jpg" width="66"/> (<a href="#f0020" id="cf0020">Fig. 15.3</a>) is a lock-free quiescently consistent bounded-range priority queue. It is a binary tree of <img alt="Image" height="9" src="images/B9780124159501000252/fx011.jpg" width="52"/> objects (<a href="#f0025" id="cf0025">Fig. 15.4</a>). As depicted in <a href="#f0030" id="cf0030">Fig. 15.5</a>, the tree has <i>m</i> leaves where the <i>i</i>th leaf node has a bin holding items of score <i>i</i>. There are <span class="hiddenClass"><mml:math><mml:mi>m</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000252/si2.png" style="vertical-align:middle" width="40"/></span> shared bounded counters in the tree's internal nodes that keep track of the number of items in the leaves of the subtree rooted in each node's left (lower score/higher priority) child.</p><div class="pageavoid"><figure class="fig" id="f0020"><img alt="Image" height="520" src="images/B9780124159501000252/gr003.jpg" width="350"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.3</span> The <img alt="Image" height="11" src="images/B9780124159501000252/fx010.jpg" width="66"/> bounded-range priority queue.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0025"><img alt="Image" height="125" src="images/B9780124159501000252/gr004.jpg" width="218"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.4</span> The <img alt="Image" height="11" src="images/B9780124159501000252/fx010.jpg" width="66"/> class: the inner <img alt="Image" height="9" src="images/B9780124159501000252/fx011.jpg" width="52"/> class.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0030"><img alt="Image" height="339" src="images/B9780124159501000252/gr005.jpg" width="497"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.5</span> The <img alt="Image" height="11" src="images/B9780124159501000252/fx010.jpg" width="66"/> priority queue is a tree of bounded counters. Items reside in bins at the leaves. Internal nodes hold the number of items in the subtree rooted at the node's left child. In part (a), threads <i>A</i> and <i>D</i> add items by traversing up the tree, incrementing the counters in the nodes when they ascend from the left. Thread <i>B</i> follows the counters down the tree, descending left if the counter had a nonzero value (we do not show the effect of <i>B</i>'s decrements). Parts (b)–(d) show a sequence in which concurrent threads <i>A</i> and <i>B</i> meet at the node marked by a star. In part (b), thread <i>D</i> adds <i>d</i>, and then <i>A</i> adds <i>a</i> and ascends to the starred node, incrementing a counter along the way. In part (c), <i>B</i> traverses down the tree, decrementing counters to zero and popping <i>a</i>. In part (d), <i>A</i> continues its ascent, incrementing the counter at the root even though <i>B</i> already removed any trace of <i>a</i> from the starred node down. Nevertheless, all is well, because the nonzero root counter correctly leads <i>C</i> to item <i>d</i>, the item with the highest priority.</div></figcaption></figure></div><p class="text" id="p0050">An <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000252/si3.png" style="vertical-align:middle" width="37"/></span> call adds <i>x</i> to the bin at the <i>k</i>th leaf, and increments node counters in leaf-to-root order. The <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method traverses <span aria-label="Page 362" epub:type="pagebreak" id="page_362" role="doc-pagebreak"/><span aria-label="Page 363" epub:type="pagebreak" id="page_363" role="doc-pagebreak"/>the tree in root-to-leaf order. Starting from the root, it finds the leaf with highest priority whose bin is nonempty. It examines each node's counter, going right if the counter is zero and decrementing it and going left otherwise (line 24).</p><p class="text" id="p0055">An <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() traversal by a thread <i>A</i> moving up may meet a <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() traversal by a thread <i>B</i> moving down. As in the story of Hansel and Gretel, the descending thread <i>B</i> follows the trail of nonzero counters left by the ascending <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() to locate and remove <i>A</i>'s item from its bin. Part (a) of <a href="#f0030" id="cf0035">Fig. 15.5</a> shows an execution of the <img alt="Image" height="11" src="images/B9780124159501000252/fx010.jpg" width="66"/>.</p><p class="text" id="p0060">One may be concerned about the following “Grimm” scenario, shown in <a href="#f0030" id="cf0040">Fig. 15.5</a>. Thread <i>A</i>, moving up, meets thread <i>B</i>, moving down, at a tree node marked by a star. Thread <i>B</i> moves down from the starred node to collect <i>A</i>'s item at the leaf, while <i>A</i> continues up the tree, incrementing counters until it reaches the root. What if another thread, <i>C</i>, starts to follow <i>A</i>'s path of nonzero counters from the root down to the starred node where <i>B</i> encountered <i>A</i>? When <i>C</i> reaches the starred node, it may be stranded there in the middle of the tree, and seeing no marks it would follow the right child branches to an empty <img alt="Image" height="9" src="images/B9780124159501000252/fx004.jpg" width="18"/>, even though there might be other items in the queue.</p><p class="text" id="p0065">Fortunately, this scenario cannot happen. As depicted in parts (b)–(d) of <a href="#f0030" id="cf0045">Fig. 15.5</a>, the only way the descending thread <i>B</i> could meet the ascending thread <i>A</i> at the starred node is if another <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() call by an earlier thread <i>D</i> incremented the same set of counters from the starred node to the root, allowing the descending thread <i>B</i> to reach the starred node in the first place. The ascending thread <i>A</i>, when incrementing counters from the starred node to the root, is simply completing the increment sequence leading to the item inserted by some other thread <i>D</i>. To summarize, if the item returned by some thread on line 24 is <i>null</i>, then the priority queue is indeed empty.</p><p class="text" id="p0070">The <img alt="Image" height="11" src="images/B9780124159501000252/fx010.jpg" width="66"/> algorithm is not linearizable, since threads may overtake each other, but it is quiescently consistent. The <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() and <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() methods are lock-free if the bins and counters are lock-free (the number of steps needed by <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() is bounded by the tree depth and <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() can fail to complete only if items are continually being added and removed from the tree). A typical insertion or deletion takes a number of steps logarithmic in the lowest priority (maximal score) in the range.</p></section><section><h2 class="h1hd" id="s0030"><a id="st0040"/>15.4 An unbounded heap-based priority queue</h2><p class="textfl" id="p0075">This section presents a linearizable priority queue that supports priorities from an unbounded range. It uses fine-grained locking for synchronization.</p><p class="text" id="p0080">A <i>heap</i> is a tree where each tree node contains an item and a score. If <i>b</i> is a child node of <i>a</i>, then <i>b</i>'s priority is no greater than <i>a</i>'s priority (i.e., items higher in the tree have lower scores and are more important). The <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method removes and returns the root of the tree, and then rebalances the root's subtrees. Here, we consider binary trees, where there are only two subtrees to rebalance.</p><section><h3 class="h2hd" id="s0035"><a id="st0045"/>15.4.1 A sequential heap</h3><p class="textfl" id="p0085"><a href="#f0035" id="cs0010">Figs. 15.6</a> and <a href="#f0040">15.7</a> show a <i>sequential</i> heap implementation. An efficient way to represent a binary heap is as an array of nodes, where the tree's root is array entry <span aria-label="Page 364" epub:type="pagebreak" id="page_364" role="doc-pagebreak"/>1, and the right and left children of array entry <i>i</i> are entries <span class="hiddenClass"><mml:math><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000252/si4.png" style="vertical-align:middle" width="25"/></span> and <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000252/si5.png" style="vertical-align:middle" width="63"/></span>, respectively. The <img alt="Image" height="8" src="images/B9780124159501000252/fx013.jpg" width="25"/> field is the index of the first unused node.</p><div class="pageavoid"><figure class="fig" id="f0035"><img alt="Image" height="438" src="images/B9780124159501000252/gr006.jpg" width="345"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.6</span> The <img alt="Image" height="11" src="images/B9780124159501000252/fx012.jpg" width="93"/> class: inner node class and <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() method.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0040"><img alt="Image" height="438" src="images/B9780124159501000252/gr007.jpg" width="458"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.7</span> The <img alt="Image" height="11" src="images/B9780124159501000252/fx012.jpg" width="93"/> class: the <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method.</div></figcaption></figure></div><p class="text" id="p0090">Each node has an <img alt="Image" height="9" src="images/B9780124159501000252/fx014.jpg" width="25"/> and a <img alt="Image" height="6" src="images/B9780124159501000252/fx015.jpg" width="32"/> field. To add an item, the <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() method sets <img alt="Image" height="9" src="images/B9780124159501000252/fx016.jpg" width="32"/> to the index of the first empty array slot (line 13). (For brevity, we omit code to resize a full array.) The method then initializes that node to hold the new item and score (line 14). At this point, the heap property may be violated, because the new node, which is a leaf of the tree, may have higher priority (lower score) than an ancestor. To restore the heap property, the new node “percolates up” the tree. We repeatedly compare the new node's priority with its parent's, swapping them if the parent's priority is lower (it has a higher score). When we encounter a parent with a higher priority, or we reach the root, the new node is correctly positioned, and the method returns.</p><p class="text" id="p0095">To remove and return the highest-priority item, the <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method records the root's item, which is the highest-priority item in the tree. (For brevity, we omit the code to deal with an empty heap.) It then moves <span aria-label="Page 365" epub:type="pagebreak" id="page_365" role="doc-pagebreak"/>a leaf entry up to replace the root (lines 29–31). If the tree is empty, the method returns the recorded item (line 32). Otherwise, the heap property may be violated, because the leaf node recently promoted to the root may have lower priority than some of its descendants. To restore the heap property, the new root “percolates down” the tree. If both children are empty, we are done (line 39). If the right child is empty, or if the right child has lower priority than the left, then we examine the left child (line 41). Otherwise, we examine the right child (line 43). If the child has higher priority than the parent, then we swap the child and parent, and continue moving down the tree (line 46). When both children have lower priorities, or we reach a leaf, the displaced node is correctly positioned, and the method returns.<span aria-label="Page 366" epub:type="pagebreak" id="page_366" role="doc-pagebreak"/></p></section><section><h3 class="h2hd" id="s0040"><a id="st0050"/>15.4.2 A concurrent heap</h3><p class="textfl" id="p0100">The <img alt="Image" height="11" src="images/B9780124159501000252/fx017.jpg" width="99"/> class is mostly just a concurrent version of the <img alt="Image" height="11" src="images/B9780124159501000252/fx012.jpg" width="93"/> class. As in the sequential heap, <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() creates a new leaf node, and percolates it up the tree until the heap property is restored. To allow concurrent calls to proceed in parallel, the <img alt="Image" height="11" src="images/B9780124159501000252/fx017.jpg" width="99"/> class percolates items up the tree as a sequence of discrete atomic steps that can be interleaved with other such steps. In the same way, <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() deletes the root node, moves a leaf node to the root, and percolates that node down the tree until the heap property is restored. The <img alt="Image" height="11" src="images/B9780124159501000252/fx017.jpg" width="99"/> class percolates items down the tree as a sequence of discrete atomic steps that can be interleaved with other such steps.</p><p class="text" id="p0105"><i>Warning</i>: The code presented here does <i>not</i> deal with heap overflow (adding an item when the heap is full) or underflow (removing an item when the heap is empty). Dealing with these cases makes the code longer, without adding much of interest.</p><p class="text" id="p0110">The class uses a <img alt="Image" height="11" src="images/B9780124159501000252/fx018.jpg" width="52"/> field to make short, atomic modifications to two or more fields (<a href="#f0045" id="cf0050">Fig. 15.8</a>).</p><div class="pageavoid"><figure class="fig" id="f0045"><img alt="Image" height="257" src="images/B9780124159501000252/gr008.jpg" width="347"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.8</span> The <img alt="Image" height="11" src="images/B9780124159501000252/fx017.jpg" width="99"/> class: fields.</div></figcaption></figure></div><p class="text" id="p0115">The <img alt="Image" height="11" src="images/B9780124159501000252/fx019.jpg" width="52"/> class (<a href="#f0050" id="cf0055">Fig. 15.9</a>) provides the following fields: The <img alt="Image" height="9" src="images/B9780124159501000252/fx020.jpg" width="25"/> field is a lock (line 23) held for short-lived modifications, and also while the node is being percolated <i>down</i> the tree. For brevity, the class exports <img alt="Image" height="9" src="images/B9780124159501000252/fx020.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000252/fx021.jpg" width="39"/>() methods to lock and unlock the node directly. The <img alt="Image" height="11" src="images/B9780124159501000252/fx022.jpg" width="18"/> field has one of the following states: <img alt="Image" height="9" src="images/B9780124159501000252/fx023.jpg" width="32"/> means the node is not in use, <img alt="Image" height="9" src="images/B9780124159501000252/fx024.jpg" width="59"/> means the node holds an item and a score, and <img alt="Image" height="9" src="images/B9780124159501000252/fx025.jpg" width="25"/> means that the node is being percolated <i>up</i> the tree, and is not yet in its proper position. While the node is <img alt="Image" height="9" src="images/B9780124159501000252/fx025.jpg" width="25"/>, the <img alt="Image" height="6" src="images/B9780124159501000252/fx026.jpg" width="33"/> field holds the ID of the thread responsible for moving it. For brevity, the class provides an <img alt="Image" height="9" src="images/B9780124159501000252/fx027.jpg" width="46"/> method that returns <i>true</i> if and only if the node's tag is <img alt="Image" height="9" src="images/B9780124159501000252/fx025.jpg" width="25"/> and the owner is the current thread.</p><div class="pageavoid"><figure class="fig" id="f0050"><img alt="Image" height="322" src="images/B9780124159501000252/gr009.jpg" width="346"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.9</span> The <img alt="Image" height="11" src="images/B9780124159501000252/fx017.jpg" width="99"/> class: inner <img alt="Image" height="11" src="images/B9780124159501000252/fx019.jpg" width="52"/> class.</div></figcaption></figure></div><p class="text" id="p0120">The asymmetry in synchronization between the <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method, which percolates down the tree holding the lock, and the <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() method, which percolates up the tree with the <img alt="Image" height="11" src="images/B9780124159501000252/fx022.jpg" width="18"/> field set to <img alt="Image" height="9" src="images/B9780124159501000252/fx025.jpg" width="25"/>, ensures that a <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() call is not delayed if it encounters a node that is <span aria-label="Page 367" epub:type="pagebreak" id="page_367" role="doc-pagebreak"/>in the middle of being shepherded up the tree by an <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() call. As a result, an <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() call must be prepared to have its node swapped out from underneath it. If the node vanishes, the <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() call simply moves up the tree. It is sure to encounter that node somewhere between its present position and the root.</p><p class="text" id="p0125">The <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method (<a href="#f0055" id="cf0060">Fig. 15.10</a>) acquires the global <img alt="Image" height="11" src="images/B9780124159501000252/fx018.jpg" width="52"/>, decrements the <img alt="Image" height="8" src="images/B9780124159501000252/fx013.jpg" width="25"/> field, returning the index of a leaf node, locks the first unused slot in the array, and releases <img alt="Image" height="11" src="images/B9780124159501000252/fx018.jpg" width="52"/> (lines 38–42). It then stores the root's item in a local variable to be returned later as the result of the call (line 43). It marks the node as <img alt="Image" height="9" src="images/B9780124159501000252/fx023.jpg" width="32"/> and unowned, swaps it with the leaf node, and unlocks the (now empty) leaf (lines 44–46).</p><div class="pageavoid"><figure class="fig" id="f0055"><img alt="Image" height="682" src="images/B9780124159501000252/gr010.jpg" width="507"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.10</span> The <img alt="Image" height="11" src="images/B9780124159501000252/fx017.jpg" width="99"/> class: the <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method.</div></figcaption></figure></div><p class="text" id="p0130">At this point, the method has recorded its eventual result in a local variable, moved the leaf to the root, and marked the leaf's former position as <img alt="Image" height="9" src="images/B9780124159501000252/fx023.jpg" width="32"/>. It retains the lock on the root. If the heap had only one item, then the leaf and the root are the same, so the method checks whether the root has just been marked as <img alt="Image" height="9" src="images/B9780124159501000252/fx023.jpg" width="32"/>. If so, it unlocks the root and returns the item (lines 47–51).</p><p class="text" id="p0135">The new root node is now percolated down the tree until it reaches its proper position, following much the same logic as the sequential implementation. The node being percolated down is locked until it reaches its proper position. When we swap two nodes, we lock them both and swap their fields. At each step, the method locks the node's right and left children (line 58). If the left child is empty, we unlock both children and return (line 60). If the right child is empty or the left child has higher priority, then we unlock the right child and examine the left (line 64). Otherwise, we unlock the left child and examine the right (line <span aria-label="Page 368" epub:type="pagebreak" id="page_368" role="doc-pagebreak"/>67).<span aria-label="Page 369" epub:type="pagebreak" id="page_369" role="doc-pagebreak"/></p><p class="text" id="p0140">If the child has higher priority than the parent, then we swap the parent and child, and unlock the (former) parent (line 71). Otherwise, we unlock the child and the parent and return.</p><p class="text" id="p0145"><span aria-label="Page 370" epub:type="pagebreak" id="page_370" role="doc-pagebreak"/>The concurrent <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() method (<a href="#f0060" id="cf0065">Fig. 15.11</a>) acquires the <img alt="Image" height="11" src="images/B9780124159501000252/fx018.jpg" width="52"/>, allocates, locks, initializes, and unlocks an empty leaf node (lines 84–89). This leaf node has tag <img alt="Image" height="9" src="images/B9780124159501000252/fx025.jpg" width="25"/>, and the owner is the calling thread. It then unlocks the leaf node, proceeds to percolate that node up the tree, using the <img alt="Image" height="9" src="images/B9780124159501000252/fx016.jpg" width="32"/> variable to keep track of the node. It locks the parent and then <span aria-label="Page 371" epub:type="pagebreak" id="page_371" role="doc-pagebreak"/>the child (all locks are acquired in ascending order). If the parent is <img alt="Image" height="9" src="images/B9780124159501000252/fx024.jpg" width="59"/> and the child is owned by the caller, then it compares their priorities. If the child has higher priority, then the method swaps their fields, and moves up (line 98). Otherwise the node is where it belongs, and it is marked <img alt="Image" height="9" src="images/B9780124159501000252/fx024.jpg" width="59"/> and unowned (line 101). If the child is not owned by the caller, then the node must have been moved up by a concurrent <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() call so the method simply moves up the tree to search for its node (line 106).</p><div class="pageavoid"><figure class="fig" id="f0060"><img alt="Image" height="652" src="images/B9780124159501000252/gr011.jpg" width="479"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.11</span> The <img alt="Image" height="11" src="images/B9780124159501000252/fx017.jpg" width="99"/> class: the <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() method.</div></figcaption></figure></div><p class="text" id="p0150"><a href="#f0065" id="cf0070">Fig. 15.12</a> shows an execution of the <img alt="Image" height="11" src="images/B9780124159501000252/fx017.jpg" width="99"/> class. In part (a), the heap tree structure is depicted, with the priorities written in the nodes and the respective array entries above the nodes. The <img alt="Image" height="8" src="images/B9780124159501000252/fx013.jpg" width="25"/> field is set to 10, the next array entry into which a new item can be added. As can be seen, thread <i>A</i> starts a <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method call, collecting the value 1 from the root as the one to be returned, moving the leaf node with score 10 to the root, and setting <img alt="Image" height="8" src="images/B9780124159501000252/fx013.jpg" width="25"/> back to 9. The <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method checks whether 10 needs to be percolated down the heap. In part (b), thread <i>A</i> percolates 10 down the heap, while thread <i>B</i> adds a new item with score 2 to the heap in the recently emptied array entry 9. The <img alt="Image" height="6" src="images/B9780124159501000252/fx026.jpg" width="33"/> of the new node is <i>B</i>, and <i>B</i> starts to percolate 2 up the heap, swapping it with its parent node of score 7. After this swap, it releases the locks on the nodes. At the same time, <i>A</i> swaps the node with scores 10 and 3. In part (c), <i>A</i>, ignoring the busy state of 2, swaps 10 and 2, and then 10 and 7, using hand-over-hand locking. It has thus swapped 2, which was not locked, from under thread <i>B</i>. In part (d), when <i>B</i> moves to the parent node in array entry 4, it finds that the busy node with score 2 it was percolating up has disappeared. However, it continues up the heap and locates the node with 2 as it ascends, moving it to its correct position in the heap.</p><div class="pageavoid"><figure class="fig" id="f0065"><img alt="Image" height="625" src="images/B9780124159501000252/gr012.jpg" width="497"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.12</span> The <img alt="Image" height="11" src="images/B9780124159501000252/fx017.jpg" width="99"/> class: a heap-based priority queue.</div></figcaption></figure></div></section></section><section><h2 class="h1hd" id="s0045"><a id="st0055"/>15.5 A skiplist-based unbounded priority queue</h2><p class="textfl" id="p0155">One drawback of the <img alt="Image" height="11" src="images/B9780124159501000252/fx017.jpg" width="99"/> priority queue algorithm is that the underlying heap structure requires complex, coordinated rebalancing. In this section, we examine an alternative that requires no rebalancing.</p><p class="text" id="p0160">Recall from Chapter <a href="B9780124159501000240.xhtml">14</a> that a skiplist is a collection of ordered lists. Each list is a sequence of <i>nodes</i>, and each node contains an <i>item</i>. Each node belongs to a subset of the lists, and nodes in each list are sorted by their hash values. Each list has a <i>level</i>, ranging from 0 to a maximum. The bottom-level list contains all the nodes, and each higher-level list is a sublist of the lower-level lists. Each list contains about half the nodes of the next lower-level list. As a result, inserting or removing a node from a skiplist containing <i>k</i> items takes expected time <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000252/si6.png" style="vertical-align:middle" width="56"/></span>.</p><p class="text" id="p0165">In Chapter <a href="B9780124159501000240.xhtml">14</a>, we used skiplists to implement sets of items. Here, we adapt skiplists to implement a priority queue of items tagged with priorities. We describe a <img alt="Image" height="11" src="images/B9780124159501000252/fx028.jpg" width="105"/> class that provides the basic functionality needed to implement an efficient priority queue. We base the <img alt="Image" height="11" src="images/B9780124159501000252/fx028.jpg" width="105"/> class (<a href="#f0070" id="cf0075">Fig. 15.13</a>) on the <img alt="Image" height="11" src="images/B9780124159501000252/fx029.jpg" width="105"/> class of Chapter <a href="B9780124159501000240.xhtml">14</a>, though we could just as easily have based it on the <img alt="Image" height="11" src="images/B9780124159501000252/fx030.jpg" width="78"/> class. Later, we describe a <img alt="Image" height="11" src="images/B9780124159501000252/fx031.jpg" width="59"/> wrapper (<a href="#f0075" id="cf0080">Fig. 15.14</a>) to cover some of the <img alt="Image" height="11" src="images/B9780124159501000252/fx032.jpg" width="126"/> class's rough edges.</p><div class="pageavoid"><figure class="fig" id="f0070"><img alt="Image" height="470" src="images/B9780124159501000252/gr013.jpg" width="329"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.13</span> The <img alt="Image" height="11" src="images/B9780124159501000252/fx032.jpg" width="126"/> class: inner <img alt="Image" height="9" src="images/B9780124159501000252/fx033.jpg" width="46"/> class.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0075"><img alt="Image" height="306" src="images/B9780124159501000252/gr014.jpg" width="320"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.14</span> The <img alt="Image" height="11" src="images/B9780124159501000252/fx034.jpg" width="79"/> class.</div></figcaption></figure></div><p class="text" id="p0170"><span aria-label="Page 372" epub:type="pagebreak" id="page_372" role="doc-pagebreak"/>Here is a bird's-eye view of the algorithm. The <img alt="Image" height="11" src="images/B9780124159501000252/fx028.jpg" width="105"/> class sorts items by priority instead of by hash value, ensuring that high-priority items (the ones we want to remove first) appear at the front of the list. <a href="#f0080" id="cf0085">Fig. 15.15</a> shows such a <img alt="Image" height="11" src="images/B9780124159501000252/fx028.jpg" width="105"/> structure. Removing the item with highest priority is done <i>lazily</i> (see Chapter <a href="B9780124159501000197.xhtml">9</a>). A node is <i>logically removed</i> by marking it as removed, and is later <i>physically removed</i> by unlinking it from the list. The <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method works in two steps: First, it scans through the bottom-level list for the first unmarked node. When it finds one, it tries to mark it. If it fails, it continues scanning down the list, but if it succeeds, then <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() calls the <img alt="Image" height="11" src="images/B9780124159501000252/fx028.jpg" width="105"/> class's logarithmic-time <img alt="Image" height="6" src="images/B9780124159501000252/fx036.jpg" width="38"/>() method to physically remove the marked node.</p><div class="pageavoid"><figure class="fig" id="f0080"><img alt="Image" height="130" src="images/B9780124159501000252/gr015.jpg" width="498"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.15</span> The <img alt="Image" height="11" src="images/B9780124159501000252/fx031.jpg" width="59"/> priority queue: an execution that is quiescently consistent but not linearizable. In part (a), thread <i>A</i> starts a <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method call. It traverses the lowest-level list in the <img alt="Image" height="11" src="images/B9780124159501000252/fx028.jpg" width="105"/> to find and logically remove the first unmarked node. It traverses over all marked nodes, even ones like the node with score 5, which is in the process of being physically removed from the <img alt="Image" height="11" src="images/B9780124159501000252/fx035.jpg" width="52"/>. In part (b), while <i>A</i> is visiting the node with score 9, thread <i>B</i> adds a node with score 3, and then adds a node with score 18. Thread <i>A</i> marks and returns the node with score 18. A linearizable execution could not return an item with score 18 before the item with score 3 is returned.</div></figcaption></figure></div><p class="text" id="p0175">We now turn our attention to the algorithm details. <a href="#f0070" id="cf0090">Fig. 15.13</a> shows an outline of the <img alt="Image" height="11" src="images/B9780124159501000252/fx028.jpg" width="105"/> class, a modified version <span aria-label="Page 373" epub:type="pagebreak" id="page_373" role="doc-pagebreak"/>of the <img alt="Image" height="11" src="images/B9780124159501000252/fx029.jpg" width="105"/> class of Chapter <a href="B9780124159501000240.xhtml">14</a>. It is convenient to have the <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000252/fx036.jpg" width="38"/>() calls take skiplist nodes instead of items as arguments and results. These methods are straightforward adaptations of the corresponding <img alt="Image" height="11" src="images/B9780124159501000252/fx029.jpg" width="105"/> methods, and are left as exercises. This class's nodes differ from <img alt="Image" height="11" src="images/B9780124159501000252/fx029.jpg" width="105"/> nodes in two fields: An integer <img alt="Image" height="6" src="images/B9780124159501000252/fx015.jpg" width="32"/> field (line 4) and an <img alt="Image" height="9" src="images/B9780124159501000252/fx037.jpg" width="86"/> <img alt="Image" height="9" src="images/B9780124159501000252/fx038.jpg" width="39"/> field used for logical deletion from the <span aria-label="Page 374" epub:type="pagebreak" id="page_374" role="doc-pagebreak"/>priority queue (not from the skiplist) (line 5). The <img alt="Image" height="9" src="images/B9780124159501000252/fx039.jpg" width="92"/>() method scans the lowest-level list until it finds a node whose <img alt="Image" height="9" src="images/B9780124159501000252/fx038.jpg" width="39"/> field is <i>false</i>, and then atomically tries to set that field to <i>true</i> (line 19). If it fails, it tries again. When it succeeds, it returns the newly marked node to the caller (line 20).</p><p class="text" id="p0180"><a href="#f0075" id="cf0095">Fig. 15.14</a> shows the <img alt="Image" height="11" src="images/B9780124159501000252/fx034.jpg" width="79"/> class. This class is just a wrapper for a <img alt="Image" height="11" src="images/B9780124159501000252/fx032.jpg" width="126"/>. The <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000252/si7.png" style="vertical-align:middle" width="40"/></span> method adds item <i>x</i> with score <i>p</i> by creating a node to hold both values, and passing that node to the <img alt="Image" height="11" src="images/B9780124159501000252/fx028.jpg" width="105"/> class's <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() method. The <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method calls the <img alt="Image" height="11" src="images/B9780124159501000252/fx028.jpg" width="105"/> class's <img alt="Image" height="9" src="images/B9780124159501000252/fx039.jpg" width="92"/>() method to mark a node as logically deleted, and then calls <img alt="Image" height="6" src="images/B9780124159501000252/fx036.jpg" width="38"/>() to physically remove that node.</p><p class="text" id="p0185">The <img alt="Image" height="11" src="images/B9780124159501000252/fx031.jpg" width="59"/> class is quiescently consistent: If an item <i>x</i> was present before the start of a <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() call, then the item returned will have a score less than or equal to that of <i>x</i>. This class is not linearizable: A thread might add a higher-priority (lower score) item and then a lower-priority item, and the traversing thread might find and return the later inserted lower-priority item, violating linearizability. This behavior is quiescently consistent, however, because one can reorder <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() calls concurrent with any <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() to be consistent with a sequential priority queue.</p><p class="text" id="p0190">The <img alt="Image" height="11" src="images/B9780124159501000252/fx031.jpg" width="59"/> class is lock-free. A thread traversing the lowest level of the <img alt="Image" height="11" src="images/B9780124159501000252/fx035.jpg" width="52"/> might always be beaten to the next logically undeleted node by another call, but it can fail repeatedly only if other threads repeatedly succeed.</p><p class="text" id="p0195">In general, the quiescently consistent <img alt="Image" height="11" src="images/B9780124159501000252/fx031.jpg" width="59"/> tends to outperform the linearizable heap-based queue. If there are <i>n</i> threads, then the first logically undeleted node is always among the first <i>n</i> nodes in the bottom-level list. Once a node has been logically deleted, then it will be physically deleted in the worst case in <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000252/si6.png" style="vertical-align:middle" width="56"/></span> steps, where <i>k</i> is the size of the list. In practice, a node will probably be deleted much more quickly, since that node is likely to be close to the start of the list.</p><p class="text" id="p0200">There are, however, several sources of contention in the algorithm that affect its performance and require the use of back-off and tuning. Contention could occur if several threads concurrently try to mark a node, where the losers proceed together to try to mark the next node, and so on. Contention can also arise when physically removing an item from the skiplist. All nodes to be removed are likely to be neighbors at the start of the skiplist, so chances are high that they share predecessors, which could cause repeated <img alt="Image" height="12" src="images/B9780124159501000252/fx040.jpg" width="97"/> failures when attempting to snip out references to the nodes.</p></section><section><h2 class="h1hd" id="s0050"><a id="st0060"/>15.6 Chapter notes</h2><p class="textfl" id="p0205">The <img alt="Image" height="11" src="images/B9780124159501000252/fx017.jpg" width="99"/> priority queue is by Galen Hunt, Maged Michael, Srinivasan Parthasarathy, and Michael Scott <a epub:type="noteref" href="#br0410" id="cf0100" role="doc-noteref">[82]</a>. The <img alt="Image" height="11" src="images/B9780124159501000252/fx007.jpg" width="79"/> and <img alt="Image" height="11" src="images/B9780124159501000252/fx010.jpg" width="66"/> priority queues are credited to Nir Shavit and Asaph Zemach <a epub:type="noteref" href="#br0790" id="cf0105" role="doc-noteref">[158]</a>. The <img alt="Image" height="11" src="images/B9780124159501000252/fx031.jpg" width="59"/> is by Itai Lotan and Nir Shavit <a epub:type="noteref" href="#br0575" id="cf0110" role="doc-noteref">[115]</a>, who also present a linearizable version of the algorithm.<span aria-label="Page 375" epub:type="pagebreak" id="page_375" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0055"><a id="st0065"/>15.7 Exercises</h2><p class="textfl" id="p0210"/><div class="boxg1" id="enun0010"><p class="b1num">Exercise 15.1 </p><div><p class="b1textfl" id="p0215">Give an example of a quiescently consistent priority queue execution that is not linearizable.</p></div></div><p class="textfl"/><p class="text" id="p0220"/><div class="boxg1" id="enun0015"><p class="b1num">Exercise 15.2 </p><div><p class="b1textfl" id="p0225">Implement a quiescently consistent <img alt="Image" height="9" src="images/B9780124159501000252/fx003.jpg" width="46"/> with a lock-free implementation of the <img alt="Image" height="9" src="images/B9780124159501000252/fx041.jpg" width="146"/>() and <img alt="Image" height="9" src="images/B9780124159501000252/fx042.jpg" width="146"/>() methods using a counting network or diffracting tree.</p></div></div><p class="textfl"/><p class="text" id="p0230"/><div class="boxg1" id="enun0020"><p class="b1num">Exercise 15.3 </p><div><p class="b1textfl" id="p0235">In the <img alt="Image" height="11" src="images/B9780124159501000252/fx010.jpg" width="66"/> algorithm, what would happen if we replace the <img alt="Image" height="9" src="images/B9780124159501000252/fx042.jpg" width="146"/>() method with a regular <img alt="Image" height="11" src="images/B9780124159501000252/fx006.jpg" width="99"/>()?</p></div></div><p class="textfl"/><p class="text" id="p0240"/><div class="boxg1" id="enun0025"><p class="b1num">Exercise 15.4 </p><div><p class="b1textfl" id="p0245">Use <img alt="Image" height="9" src="images/B9780124159501000252/fx041.jpg" width="146"/>() methods in <img alt="Image" height="9" src="images/B9780124159501000252/fx043.jpg" width="52"/> counters to devise a <img alt="Image" height="11" src="images/B9780124159501000252/fx010.jpg" width="66"/> algorithm with bounded capacity.</p></div></div><p class="textfl"/><p class="text" id="p0250"/><div class="boxg1" id="enun0030"><p class="b1num">Exercise 15.5 </p><div><p class="b1textfl" id="p0255">In the <img alt="Image" height="11" src="images/B9780124159501000252/fx010.jpg" width="66"/> class, what would happen if <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>(), after placing an item in the appropriate <img alt="Image" height="9" src="images/B9780124159501000252/fx004.jpg" width="18"/>, incremented counters in the same <i>top-down</i> manner as in the <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method? Give a detailed example.</p></div></div><p class="textfl"/><p class="text" id="p0260"/><div class="boxg1" id="enun0035"><p class="b1num">Exercise 15.6 </p><div><p class="b1textfl" id="p0265">Prove that the <img alt="Image" height="11" src="images/B9780124159501000252/fx010.jpg" width="66"/> is a quiescently consistent priority queue implementation.</p></div></div><p class="textfl"/><p class="text" id="p0270"/><div class="boxg1" id="enun0040"><p class="b1num">Exercise 15.7 </p><div><p class="b1textfl" id="p0275">Modify <img alt="Image" height="11" src="images/B9780124159501000252/fx017.jpg" width="99"/> to allocate new heap nodes dynamically. What are the performance limitations of this approach?</p></div></div><p class="textfl"/><p class="text" id="p0280"/><div class="boxg1" id="enun0045"><p class="b1num">Exercise 15.8 </p><div><p class="b1textfl" id="p0285"><a href="#f0085" id="cf0115">Fig. 15.16</a> shows a <i>bit-reversed</i> counter. We could use the bit-reversed counter to manage the <img alt="Image" height="8" src="images/B9780124159501000252/fx013.jpg" width="25"/> field of the <img alt="Image" height="11" src="images/B9780124159501000252/fx017.jpg" width="99"/> class. Prove the following: For any two consecutive insertions, the two paths from the leaves to the root have no common nodes other than the root. Why is this a useful property for the <img alt="Image" height="11" src="images/B9780124159501000252/fx017.jpg" width="99"/>?</p><div class="pageavoid"><figure class="fig" id="f0085"><img alt="Image" height="635" src="images/B9780124159501000252/gr016.jpg" width="261"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 15.16</span> A bit-reversed counter.</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p0290"/><div class="boxg1" id="enun0050"><p class="b1num">Exercise 15.9 </p><div><p class="b1textfl" id="p0295">Provide code for <img alt="Image" height="11" src="images/B9780124159501000252/fx028.jpg" width="105"/>'s <img alt="Image" height="9" src="images/B9780124159501000252/fx001.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000252/fx036.jpg" width="38"/>() methods.</p></div></div><p class="textfl"/><p class="text" id="p0300"/><div class="boxg1" id="enun0055"><p class="b1num">Exercise 15.10 </p><div><p class="b1textfl" id="p0305">The <img alt="Image" height="11" src="images/B9780124159501000252/fx028.jpg" width="105"/> class used in this chapter is based on the <img alt="Image" height="11" src="images/B9780124159501000252/fx029.jpg" width="105"/> class. Write a <img alt="Image" height="11" src="images/B9780124159501000252/fx028.jpg" width="105"/> class based on the <img alt="Image" height="11" src="images/B9780124159501000252/fx030.jpg" width="78"/> class.</p></div></div><p class="textfl"/><p class="text" id="p0310"/><div class="boxg1" id="enun0060"><p class="b1num">Exercise 15.11 </p><div><p class="b1textfl" id="p0315">Describe a scenario in the <img alt="Image" height="11" src="images/B9780124159501000252/fx031.jpg" width="59"/> implementation in which contention would arise from multiple concurrent <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() method calls.</p></div></div><p class="textfl"/><p class="text" id="p0320"/><div class="boxg1" id="enun0065"><p class="b1num">Exercise 15.12 </p><div><p class="b1textfl" id="p0325">The <img alt="Image" height="11" src="images/B9780124159501000252/fx031.jpg" width="59"/> class is quiescently consistent but not linearizable. Here is one way to make this class linearizable by adding a simple timestamping mechanism. After a node is completely inserted into the <img alt="Image" height="11" src="images/B9780124159501000252/fx031.jpg" width="59"/>, it acquires a timestamp. A thread performing a <img alt="Image" height="9" src="images/B9780124159501000252/fx002.jpg" width="58"/>() notes the time at which it starts its traversal of the lower level of the <img alt="Image" height="11" src="images/B9780124159501000252/fx031.jpg" width="59"/>, and only considers nodes whose timestamp is earlier than the time at which it started its traversal, effectively ignoring nodes inserted during its traversal. Implement this class and justify why it works. <span aria-label="Page 376" epub:type="pagebreak" id="page_376" role="doc-pagebreak"/></p></div></div><p class="textfl"/></section><footer><section epub:type="bibliography" role="doc-bibliography"><div id="bl0605"><h2 class="reftitle" id="st0070">Bibliography</h2><p class="reflist1" epub:type="biblioentry footnote" id="br0410" role="doc-biblioentry">[82] Galen C. Hunt, Maged M. Michael, Srinivasan Parthasarathy, Michael L. Scott,  An efficient algorithm for concurrent priority queue heaps,   <cite><i>Information Processing Letters</i></cite> 1996;60(3):151–157.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0575" role="doc-biblioentry">[115] I. Lotan, N. Shavit,  Skiplist-based concurrent priority queues,   <i>Proc. of the 14th International Parallel and Distributed Processing Symposium</i>.  <i>IPDPS</i>.  2000:263–268.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0790" role="doc-biblioentry">[158] Nir Shavit, Asaph Zemach,  Diffracting trees,   <cite><i>ACM Transactions on Computer Systems</i></cite> 1996;14(4):385–428.</p></div></section></footer></section></body></html>