<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>14.6  Multiple-Key Access</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part265.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part267.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">14.6  <span style=" color: #00AEEF;">Multiple-Key Access</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Until now, we have assumed implicitly that only one index on one attribute is used to process a query on a relation. However, for certain types of queries, it is advantageous to use multiple indices if they exist, or to use an index built on a multiattribute search key.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">14.6.1 Using Multiple Single-Key Indices</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2702.png"/></span></p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Assume that the <i>instructor </i>ﬁle has two indices: one for <i>dept name </i>and one for <i>salary</i>. Consider the following query: “Find all instructors in the Finance department with salary equal to $80,000.” We write</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 202pt;text-indent: 0pt;text-align: left;">select <span class="s69">ID</span></p><p class="s46" style="padding-left: 202pt;text-indent: 0pt;text-align: left;">from <i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2703.png"/></span></p><p class="s46" style="padding-left: 119pt;text-indent: 82pt;line-height: 227%;text-align: left;">where <i>dept name </i><span class="p">= &#39;Finance&#39; </span>and <i>salary </i><span class="p">= 80000; There are three strategies possible for processing this query:</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2704.png"/></span></p><p style="padding-left: 145pt;text-indent: -16pt;text-align: justify;"><span class="s63">1. </span>Use the index on <i>dept name </i>to ﬁnd all records pertaining to the Finance depart- ment. Examine each such record to see whether <i>salary </i>= 80000.</p><p style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;"><span class="s63">2. </span>Use the index on <i>salary </i>to ﬁnd all records pertaining to instructors with salary of $80,000. Examine each such record to see whether the department name is “Finance”.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2705.png"/></span></p><p style="padding-top: 4pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;"><span class="s63">3. </span>Use the index on <i>dept name </i>to ﬁnd <i>pointers </i>to all records pertaining to the Fi- nance department. Also, use the index on <i>salary </i>to ﬁnd pointers to all records pertaining to instructors with a salary of $80,000. Take the intersection of these two sets of pointers. Those pointers that are in the intersection point to records pertaining to instructors of the Finance department and with salary of $80,000.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">The third strategy is the only one of the three that takes advantage of the existence of multiple indices. However, even this strategy may be a poor choice if all of the following hold:</p><p class="s39" style="padding-top: 10pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s40">There are many records pertaining to the Finance department.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s40">There are many records pertaining to instructors with a salary of $80,000.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: left;">• <span class="s40">There are only a few records pertaining to </span><span class="s13">both </span><span class="p">the Finance department and in- structors with a salary of $80,000.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">If these conditions hold, we must scan a large number of pointers to produce a small result. An index structure called a “bitmap index” can in some cases greatly speed up the intersection operation used in the third strategy. Bitmap indices are outlined in Section 14.9.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">14.6.2 Indices on Multiple Keys</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2706.png"/></span></p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">An alternative strategy for this case is to create and use an index on a composite search key (<i>dept name</i>, <i>salary</i>)— that is, the search key consisting of the department name concatenated with the instructor salary.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We can use an ordered (B<span class="s181">+</span>-tree) index on the preceding composite search key to answer eﬃciently queries of the form</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 170pt;text-indent: 0pt;text-align: left;">select <span class="s69">ID</span></p><p class="s46" style="padding-left: 170pt;text-indent: 0pt;text-align: left;">from <i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2707.png"/></span></p><p class="s46" style="padding-left: 170pt;text-indent: 0pt;text-align: left;">where <i>dept name </i><span class="p">= &#39;Finance&#39; </span>and <i>salary </i><span class="p">= 80000;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2708.png"/></span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">Queries such as the following query, which speciﬁes an equality condition on the ﬁrst attribute of the search key (<i>dept name</i>) and a range on the second attribute of the search key (<i>salary</i>), can also be handled eﬃciently since they correspond to a range query on the search attribute.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 169pt;text-indent: 0pt;text-align: left;">select <span class="s69">ID</span></p><p class="s46" style="padding-left: 169pt;text-indent: 0pt;line-height: 11pt;text-align: left;">from <i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2709.png"/></span></p><p class="s46" style="padding-left: 169pt;text-indent: 0pt;line-height: 20pt;text-align: left;">where <i>dept name </i><span class="p">= &#39;Finance&#39; </span>and <i>salary </i><span class="s83">&lt; </span><span class="p">80000;</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2710.png"/></span></p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">We can even use an ordered index on the search key (<i>dept name</i>, <i>salary</i>) to answer the following query on only one attribute eﬃciently:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 244pt;text-indent: 0pt;text-align: left;">select <span class="s69">ID</span></p><p class="s46" style="padding-left: 244pt;text-indent: 0pt;text-align: left;">from <i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2711.png"/></span></p><p class="s46" style="padding-left: 244pt;text-indent: 0pt;text-align: left;">where <i>dept name </i><span class="p">= &#39;Finance&#39;;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2712.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2713.png"/></span></p><p style="padding-top: 7pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">An equality condition <i>dept name </i>= “Finance” is equivalent to a range query on the range with lower end (Finance, <span class="s15">−∞</span>) and upper end (Finance, <span class="s15">+∞</span>). Range queries on just the <i>dept name </i>attribute can be handled in a similar manner.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The use of an ordered-index structure on a composite search key, however, has a few shortcomings. As an illustration, consider the query</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 7pt;padding-left: 200pt;text-indent: 0pt;text-align: left;">select <span class="s69">ID</span></p><p class="s46" style="padding-left: 200pt;text-indent: 0pt;line-height: 11pt;text-align: left;">from <i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2714.png"/></span></p><p class="s46" style="padding-left: 200pt;text-indent: 0pt;line-height: 20pt;text-align: left;">where <i>dept name </i><span class="s83">&lt; </span><span class="p">&#39;Finance&#39; </span>and <i>salary </i><span class="s83">&lt; </span><span class="p">80000;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2715.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2716.png"/></span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We can answer this query by using an ordered index on the search key (<i>dept name</i>, <i>salary</i>): For each value of <i>dept name </i>that is less than “Finance” in alphabetic order, the system locates records with a <i>salary </i>value of 80000. However, each record is likely to be in a diﬀerent disk block, because of the ordering of records in the ﬁle, leading to many <span class="s44">I/O </span>operations.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2717.png"/></span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The diﬀerence between this query and the previous two queries is that the condition on the ﬁrst attribute (<i>dept name</i>) is a comparison condition, rather than an equality condition. The condition does not correspond to a range query on the search key.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">To speed the processing of general composite search-key queries (which can involve one or more comparison operations), we can use several special structures. We shall consider <i>bitmap indices </i>in Section 14.9. There is another structure, called the <i>R-tree</i>, that can be used for this purpose. The R-tree is an extension of the B<span class="s181">+</span>-tree to handle indexing on multiple dimensions and is discussed in Section 14.10.1.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">14.6.3 Covering Indices</p><p class="s63" style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Covering indices <span class="p">are indices that store the values of some attributes (other than the search-key attributes) along with the pointers to the record. Storing extra attribute val- ues is useful with secondary indices, since they allow us to answer some queries using just the index, without even looking up the actual records.</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2718.png"/></span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">For example, suppose that we have a nonclustering index on the <span class="s69">ID </span>attribute of the <i>instructor </i>relation. If we store the value of the <i>salary </i>attribute along with the record pointer, we can answer queries that require the salary (but not the other attribute, <i>dept name</i>) without accessing the <i>instructor </i>record.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The same eﬀect could be obtained by creating an index on the search key (<span class="s69">ID</span>, <i>salary</i>), but a covering index reduces the size of the search key, allowinga larger fanout in the nonleaf nodes, and potentially reducing the height of the index.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part265.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part267.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
