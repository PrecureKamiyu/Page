<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 42. Advanced Features of Shared Libraries</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch41.html" title="Chapter 41. Fundamentals of Shared Libraries"/><link rel="next" href="ch43.html" title="Chapter 43. Interprocess Communication Overview"/></head><body><section class="chapter" title="Chapter 42. Advanced Features of Shared Libraries" epub:type="chapter" id="advanced_features_of_shared_libraries"><div class="titlepage"><div><div><h2 class="title">Chapter 42. Advanced Features of Shared Libraries</h2></div></div></div><p>The previous chapter covered the fundamentals of shared libraries. This chapter
            describes a number of advanced features of shared libraries, including the
            following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>dynamically loading shared libraries;</p></li><li class="listitem"><p>controlling the visibility of symbols defined by a shared library;</p></li><li class="listitem"><p>using linker scripts to create versioned symbols;</p></li><li class="listitem"><p>using initialization and finalization functions to automatically execute code
                    when a library is loaded and unloaded;</p></li><li class="listitem"><p>shared library preloading; and</p></li><li class="listitem"><p>using <code class="literal">LD_DEBUG</code> to monitor the operation of
                    the dynamic linker.</p></li></ul></div><div class="sect1" title="Dynamically Loaded Libraries"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="dynamically_loaded_libraries">Dynamically Loaded Libraries</h2></div></div></div><p>When an executable starts, the dynamic linker loads all of the shared libraries in
                the program’s dynamic dependency list. Sometimes, however, it can be useful to load
                libraries at a later time. For example, a plug-in is loaded only when it is needed.
                This functionality is provided by an API to the dynamic linker. This API, usually
                referred to as the <span class="emphasis"><em>dlopen</em></span> API, originated on Solaris, and much
                of it is now specified in SUSv3.<a id="IDX-CHP-42-5971" class="indexterm"/><a id="IDX-CHP-42-5972" class="indexterm"/></p><p>The <span class="emphasis"><em>dlopen</em></span> API enables a program to open a shared library at
                run time, search for a function by name in that library, and then call the function.
                A shared library loaded at run time in this way is commonly referred to as a
                    <span class="emphasis"><em>dynamically loaded library</em></span>, and is created in the same way
                as any other shared library.</p><p>The core <span class="emphasis"><em>dlopen</em></span> API consists of the following functions (all
                of which are specified in SUSv3):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>dlopen()</em></span> function opens a shared library,
                        returning a handle used by subsequent calls.<a id="IDX-CHP-42-5973" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>dlsym()</em></span> function searches a library for a symbol
                        (a string containing the name of a function or variable) and returns its
                        address.</p></li><li class="listitem"><p>The <span class="emphasis"><em>dlclose()</em></span> function closes a library previously
                        opened by <span class="emphasis"><em>dlopen()</em></span>.<a id="IDX-CHP-42-5974" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>dlerror()</em></span> function returns an error-message
                        string, and is used after a failure return from one of the preceding
                        functions.</p></li></ul></div><p>The <span class="emphasis"><em>glibc</em></span> implementation also includes a number of related
                functions, some of which we describe below.</p><p>To build programs that use the <span class="emphasis"><em>dlopen</em></span> API on Linux, we must
                specify the <span class="emphasis"><em>-ldl</em></span> option, in order to link against the
                    <span class="emphasis"><em>libdl</em></span> library.</p><div class="sect2" title="Opening a Shared Library: dlopen()"><div class="titlepage"><div><div><h3 class="title" id="opening_a_shared_library_colon_dlopen_op">Opening a Shared Library: <span class="emphasis"><em>dlopen()</em></span></h3></div></div></div><p>The <span class="emphasis"><em>dlopen()</em></span> function loads the shared library named in
                        <span class="emphasis"><em>libfilename</em></span> into the calling process’s virtual address
                    space and increments the count of open references to the library.<a id="IDX-CHP-42-5975" class="indexterm"/><a id="IDX-CHP-42-5976" class="indexterm"/><a id="IDX-CHP-42-5977" class="indexterm"/><a id="IDX-CHP-42-5978" class="indexterm"/><a id="IDX-CHP-42-5979" class="indexterm"/><a id="IDX-CHP-42-5980" class="indexterm"/><a id="IDX-CHP-42-5981" class="indexterm"/></p><a id="I_programlisting42_d1e113294"/><pre class="programlisting">#include &lt;dlfcn.h&gt;

void *<strong class="userinput"><code>dlopen</code></strong>(const char *<span class="emphasis"><em>libfilename</em></span>, int <span class="emphasis"><em>flags</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns library handle on success, or <code class="literal">NULL</code> on error</p></div><p>If <span class="emphasis"><em>libfilename</em></span> contains a slash (<code class="literal">/</code>), <span class="emphasis"><em>dlopen()</em></span> interprets it as an absolute or
                    relative pathname. Otherwise, the dynamic linker searches for the shared library
                    using the rules described in <a class="xref" href="ch41.html#finding_shared_libraries_at_run_time" title="Finding Shared Libraries at Run Time">Finding Shared Libraries at Run Time</a>.</p><p>On success, <span class="emphasis"><em>dlopen()</em></span> returns a handle that can be used to
                    refer to the library in subsequent calls to functions in the
                        <span class="emphasis"><em>dlopen</em></span> API. If an error occurred (e.g., the library
                    couldn’t be found), <span class="emphasis"><em>dlopen()</em></span> returns <code class="literal">NULL</code>.</p><p>If the shared library specified by <span class="emphasis"><em>libfilename</em></span> contains
                    dependencies on other shared libraries, <span class="emphasis"><em>dlopen()</em></span> also
                    automatically loads those libraries. This procedure occurs recursively if
                    necessary. We refer to the set of such loaded libraries as this library’s
                        <span class="emphasis"><em>dependency tree</em></span>.<a id="IDX-CHP-42-5982" class="indexterm"/></p><p>It is possible to call <span class="emphasis"><em>dlopen()</em></span> multiple times on the
                    same library file. The library is loaded into memory only once (by the initial
                    call), and all calls return the same <span class="emphasis"><em>handle</em></span> value. However,
                    the <span class="emphasis"><em>dlopen</em></span> API maintains a reference count for each library
                    handle. This count is incremented by each call to <span class="emphasis"><em>dlopen()</em></span>
                    and decremented by each call to <span class="emphasis"><em>dlclose()</em></span>; only when the
                    count reaches 0 does <span class="emphasis"><em>dlclose()</em></span> unload the library from
                    memory.</p><p>The <span class="emphasis"><em>flags</em></span> argument is a bit mask that must include
                    exactly one of the constants <code class="literal">RTLD_LAZY</code> or
                        <code class="literal">RTLD_NOW</code>, with the following
                    meanings:</p><div class="variablelist"><dl><dt><span class="term">
                            <code class="literal">RTLD_LAZY</code>
                        </span></dt><dd><p>Undefined function symbols in the library should be resolved only
                                as the code is executed. If a piece of code requiring a particular
                                symbol is not executed, that symbol is never resolved. Lazy
                                resolution is performed only for function references; references to
                                variables are always resolved immediately. Specifying the <code class="literal">RTLD_LAZY</code> flag provides behavior that
                                corresponds to the normal operation of the dynamic linker when
                                loading the shared libraries identified in an executable’s dynamic
                                dependency list.</p></dd><dt><span class="term">
                            <code class="literal">RTLD_NOW</code>
                        </span></dt><dd><p>All undefined symbols in the library should be immediately
                                resolved before <span class="emphasis"><em>dlopen()</em></span> completes, regardless
                                of whether they will ever be required. As a consequence, opening the
                                library is slower, but any potential undefined function symbol
                                errors are detected immediately instead of at some later time. This
                                can be useful when debugging an application, or simply to ensure
                                that an application fails immediately on an unresolved symbol,
                                rather than doing so only after executing for a long time.</p></dd></dl></div><div class="note" title="Note"><h3 class="title">Note</h3><p>By setting the environment variable <code class="literal">LD_BIND_NOW</code> to a nonempty string, we can force the dynamic
                        linker to immediately resolve all symbols (i.e., like <code class="literal">RTLD_NOW</code>) when loading the shared libraries
                        identified in an executable’s dynamic dependency list. This environment
                        variable is effective in <span class="emphasis"><em>glibc</em></span> 2.1.1 and later. Setting
                            <code class="literal">LD_BIND_NOW</code> overrides the effect of
                        the <span class="emphasis"><em>dlopen()</em></span>
                        <code class="literal">RTLD_LAZY</code> flag.</p></div><p>It is also possible to include further values in <span class="emphasis"><em>flags</em></span>.
                    The following flags are specified in SUSv3:</p><div class="variablelist"><dl><dt><span class="term">
                            <code class="literal">RTLD_GLOBAL</code>
                        </span></dt><dd><p>Symbols in this library and its dependency tree are made available
                                for resolving references in other libraries loaded by this process
                                and also for lookups via <span class="emphasis"><em>dlsym()</em></span>.</p></dd><dt><span class="term">
                            <code class="literal">RTLD_LOCAL</code>
                        </span></dt><dd><p>This is the converse of <code class="literal">RTLD_GLOBAL</code> and the default if neither constant is
                                specified. It specifies that symbols in this library and its
                                dependency tree are not available to resolve references in
                                subsequently loaded libraries.</p></dd></dl></div><p>SUSv3 doesn’t specify a default if neither <code class="literal">RTLD_GLOBAL</code> nor <code class="literal">RTLD_LOCAL</code> is
                    specified. Most UNIX implementations assume the same default (<code class="literal">RTLD_LOCAL</code>) as Linux, but a few assume a default
                    of <code class="literal">RTLD_GLOBAL</code>.</p><p>Linux also supports a number of flags that are not specified in SUSv3:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">RTLD_NODELETE</code> (since
                                <span class="emphasis"><em>glibc</em></span> 2.2)</span></dt><dd><p>Don’t unload the library during a <span class="emphasis"><em>dlclose()</em></span>,
                                even if the reference count falls to 0. This means that the
                                library’s static variables are not reinitialized if the library is
                                later reloaded by <span class="emphasis"><em>dlopen()</em></span>. (We can achieve a
                                similar effect for libraries loaded automatically by the dynamic
                                linker by specifying the <span class="emphasis"><em>gcc -Wl,-znodelete</em></span>
                                option when creating the library.)<a id="IDX-CHP-42-5983" class="indexterm"/></p></dd><dt><span class="term"><code class="literal">RTLD_NOLOAD</code> (since
                                <span class="emphasis"><em>glibc</em></span> 2.2)</span></dt><dd><p>Don’t load the library. This serves two purposes. First, we can
                                use this flag to check if a particular library is currently loaded
                                as part of the process’s address space. If it is,
                                    <span class="emphasis"><em>dlopen()</em></span> returns the library’s handle; if
                                it is not, <span class="emphasis"><em>dlopen()</em></span> returns <code class="literal">NULL</code>. Second, we can use this flag to
                                “promote” the <span class="emphasis"><em>flags</em></span> of an already loaded
                                library. For example, we can specify <code class="literal">RTLD_NOLOAD | RTLD_GLOBAL</code> in
                                    <span class="emphasis"><em>flags</em></span> when using
                                    <span class="emphasis"><em>dlopen()</em></span> on a library previously opened
                                with <code class="literal">RTLD_LOCAL</code>.</p></dd><dt><span class="term"><code class="literal">RTLD_DEEPBIND</code> (since
                                <span class="emphasis"><em>glibc</em></span> 2.3.4)</span></dt><dd><p>When resolving symbol references made by this library, search for
                                definitions in the library before searching for definitions in
                                libraries that have already been loaded. This allows a library to be
                                self-contained, using its own symbol definitions in preference to
                                global symbols with the same name defined in other shared libraries
                                that have already been loaded. (This is similar to the effect of the
                                    <span class="emphasis"><em>-Bsymbolic</em></span> linker option described in <a class="xref" href="ch41.html#run-time_symbol_resolution" title="Run-Time Symbol Resolution">Run-Time Symbol Resolution</a>.)</p></dd></dl></div><p>The <code class="literal">RTLD_NODELETE</code> and <code class="literal">RTLD_NOLOAD</code> flags are also implemented in the
                    Solaris <span class="emphasis"><em>dlopen</em></span> API, but are available on few other UNIX
                    implementations. The <code class="literal">RTLD_DEEPBIND</code> flag is
                    Linux-specific.</p><p>As a special case, we can specify <span class="emphasis"><em>libfilename</em></span> as <code class="literal">NULL</code>. This causes <span class="emphasis"><em>dlopen()</em></span> to
                    return a handle for the main program. (SUSv3 refers to this as a handle for the
                    “global symbol object.”) Specifying this handle in a subsequent call to
                        <span class="emphasis"><em>dlsym()</em></span> causes the requested symbol to be sought in the
                    main program, followed by all shared libraries loaded at program startup, and
                    then all libraries dynamically loaded with the <code class="literal">RTLD_GLOBAL</code> flag.<a id="IDX-CHP-42-5984" class="indexterm"/></p></div><div class="sect2" title="Diagnosing Errors: dlerror()"><div class="titlepage"><div><div><h3 class="title" id="diagnosing_errors_colon_dlerror_open_par">Diagnosing Errors: <span class="emphasis"><em>dlerror()</em></span></h3></div></div></div><p>If we receive an error return from <span class="emphasis"><em>dlopen()</em></span> or one of the
                    other functions in the <span class="emphasis"><em>dlopen</em></span> API, we can use
                        <span class="emphasis"><em>dlerror()</em></span> to obtain a pointer to a string that
                    indicates the cause of the error.<a id="IDX-CHP-42-5986" class="indexterm"/><a id="IDX-CHP-42-5987" class="indexterm"/><a id="IDX-CHP-42-5988" class="indexterm"/><a id="IDX-CHP-42-5989" class="indexterm"/><a id="IDX-CHP-42-5985" class="indexterm"/></p><a id="I_programlisting42_d1e113628"/><pre class="programlisting">#include &lt;dlfcn.h&gt;

const char *<span class="emphasis"><em>dlerror</em></span>(void);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer to error-diagnostic string, or <code class="literal">NULL</code> if no error has occurred since previous call to
                            <span class="emphasis"><em>dlerror()</em></span></p></div><p>The <span class="emphasis"><em>dlerror()</em></span> function returns <code class="literal">NULL</code> if no error has occurred since the last call to
                        <span class="emphasis"><em>dlerror()</em></span>. We’ll see how this is useful in the next
                    section.</p></div><div class="sect2" title="Obtaining the Address of a Symbol: dlsym()"><div class="titlepage"><div><div><h3 class="title" id="obtaining_the_address_of_a_symbol_colon">Obtaining the Address of a Symbol: <span class="emphasis"><em>dlsym()</em></span></h3></div></div></div><p>The <span class="emphasis"><em>dlsym()</em></span> function searches for the named
                        <span class="emphasis"><em>symbol</em></span> (a function or variable) in the library referred
                    to by <span class="emphasis"><em>handle</em></span> and in the libraries in that library’s
                    dependency tree.<a id="IDX-CHP-42-5990" class="indexterm"/><a id="IDX-CHP-42-5991" class="indexterm"/></p><a id="I_programlisting42_d1e113679"/><pre class="programlisting">#include &lt;dlfcn.h&gt;

void *<strong class="userinput"><code>dlsym</code></strong>(void *<span class="emphasis"><em>handle</em></span>, char *<span class="emphasis"><em>symbol</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns address of <span class="emphasis"><em>symbol</em></span>, or <code class="literal">NULL</code> if <span class="emphasis"><em>symbol</em></span> is not
                        found</p></div><p>If <span class="emphasis"><em>symbol</em></span> is found, <span class="emphasis"><em>dlsym()</em></span> returns
                    its address; otherwise, <span class="emphasis"><em>dlsym()</em></span> returns <code class="literal">NULL</code>. The <span class="emphasis"><em>handle</em></span> argument is
                    normally a library handle returned by a previous call to
                        <span class="emphasis"><em>dlopen()</em></span>. Alternatively, it may be one of the so-called
                    pseudohandles described below.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>A related function, <span class="emphasis"><em>dlvsym(handle, symbol, version)</em></span>,
                        is similar to <span class="emphasis"><em>dlsym()</em></span>, but can be used to search a
                        symbol-versioned library for a symbol definition whose version matches the
                        string specified in <span class="emphasis"><em>version</em></span>. (We describe symbol
                        versioning in <a class="xref" href="ch42.html#symbol_versioning" title="Symbol Versioning">Symbol Versioning</a>.) The <code class="literal">_GNU_SOURCE</code> feature test macro must be defined
                        in order to obtain the declaration of this function from <code class="literal">&lt;dlfcn.h&gt;</code>.</p></div><p>The value of a symbol returned by <span class="emphasis"><em>dlsym()</em></span> may be <code class="literal">NULL</code>, which is indistinguishable from the “symbol
                    not found” return. In order to differentiate the two possibilities, we must call
                        <span class="emphasis"><em>dlerror()</em></span> beforehand (to make sure that any previously
                    held error string is cleared) and then if, after the call to
                        <span class="emphasis"><em>dlsym()</em></span>, <span class="emphasis"><em>dlerror()</em></span> returns a
                        non-<code class="literal">NULL</code> value, we know that an error
                        occurred.<a id="IDX-CHP-42-5992" class="indexterm"/></p><p>If <span class="emphasis"><em>symbol</em></span> is the name of a variable, then we can assign
                    the return value of <span class="emphasis"><em>dlsym()</em></span> to an appropriate pointer type,
                    and obtain the value of the variable by dereferencing the pointer:</p><a id="I_programlisting42_d1e113777"/><pre class="programlisting">int *ip;

ip = (int *) dlsym(symbol, "myvar");
if (ip != NULL)
    printf("Value is %d\n", *ip);</pre><p>If <span class="emphasis"><em>symbol</em></span> is the name of a function, then the pointer
                    returned by <span class="emphasis"><em>dlsym()</em></span> can be used to call the function. We
                    can store the value returned by <span class="emphasis"><em>dlsym()</em></span> in a pointer of the
                    appropriate type, such as the following:</p><a id="I_programlisting42_d1e113790"/><pre class="programlisting">int (*funcp)(int);              /* Pointer to a function taking an integer
                                   argument and returning an integer */</pre><p>However, we can’t simply assign the result of <span class="emphasis"><em>dlsym()</em></span> to
                    such a pointer, as in the following example:</p><a id="I_programlisting42_d1e113798"/><pre class="programlisting">funcp = dlsym(handle, symbol);</pre><p>The reason is that the C99 standard forbids assignment between a function
                    pointer and <span class="emphasis"><em>void *</em></span>. The solution is to use the following
                    (somewhat clumsy) cast:</p><a id="I_programlisting42_d1e113805"/><pre class="programlisting">*(void **) (&amp;funcp) = dlsym(handle, symbol);</pre><p>Having used <span class="emphasis"><em>dlsym()</em></span> to obtain a pointer to the function,
                    we can then call the function using the usual C syntax for dereferencing
                    function pointers:</p><a id="I_programlisting42_d1e113812"/><pre class="programlisting">res = (*funcp)(somearg);</pre><p>Instead of the <span class="emphasis"><em>*(void **)</em></span> syntax shown above, one might
                    consider using the following seemingly equivalent code when assigning the return
                    value of <span class="emphasis"><em>dlsym()</em></span>:</p><a id="I_programlisting42_d1e113822"/><pre class="programlisting">(void *) funcp = dlsym(handle, symbol);</pre><p>However, for this code, <span class="emphasis"><em>gcc -pedantic</em></span> warns that “ANSI C
                    forbids the use of cast expressions as lvalues.” The <span class="emphasis"><em>*(void
                        **)</em></span> syntax doesn’t incur this warning because we are assigning to
                    an address <span class="emphasis"><em>pointed to</em></span> by the assignment’s lvalue.</p><p>On many UNIX implementations, we can use casts such as the following to
                    eliminate warnings from the C compiler:</p><a id="I_programlisting42_d1e113837"/><pre class="programlisting">funcp = (int (*) (int)) dlsym(handle, symbol);</pre><p>However, the specification of <span class="emphasis"><em>dlsym()</em></span> in SUSv3
                        <span class="emphasis"><em>Technical Corrigendum Number 1</em></span> notes that the C99
                    standard nevertheless requires compilers to generate a warning for such a
                    conversion, and proposes the <span class="emphasis"><em>*(void **)</em></span> syntax shown
                    above.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 TC1 noted that because of the need for the <span class="emphasis"><em>*(void
                            **)</em></span> syntax, a future version of the standard may define
                        separate <span class="emphasis"><em>dlsym()</em></span>-like APIs for handling data and
                        function pointers. However, SUSv4 contains no changes with respect to this
                        point.</p></div><div class="sect3" title="Using library pseudohandles with dlsym()"><div class="titlepage"><div><div><h4 class="title" id="using_library_pseudohandles_with_dlsym_o">Using library pseudohandles with <span class="emphasis"><em>dlsym()</em></span></h4></div></div></div><p>Instead of specifying a library handle returned by a call to
                            <span class="emphasis"><em>dlopen()</em></span>, either of the following
                            <span class="emphasis"><em>pseudohandles</em></span> may be specified as the
                            <span class="emphasis"><em>handle</em></span> argument for
                            <span class="emphasis"><em>dlsym()</em></span>:<a id="IDX-CHP-42-5993" class="indexterm"/><a id="IDX-CHP-42-5994" class="indexterm"/><a id="IDX-CHP-42-5995" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term">
                                <code class="literal">RTLD_DEFAULT</code>
                            </span></dt><dd><p>Search for <span class="emphasis"><em>symbol</em></span> starting with the main
                                    program, and then proceeding in order through the list of all
                                    shared libraries loaded, including those libraries dynamically
                                    loaded by <span class="emphasis"><em>dlopen()</em></span> with the <code class="literal">RTLD_GLOBAL</code> flag. This corresponds
                                    to the default search model employed by the dynamic
                                    linker.</p></dd><dt><span class="term">
                                <code class="literal">RTLD_NEXT</code>
                            </span></dt><dd><p>Search for <span class="emphasis"><em>symbol</em></span> in shared libraries
                                    loaded after the one invoking <span class="emphasis"><em>dlsym()</em></span>. This
                                    is useful when creating a wrapper function with the same name as
                                    a function defined elsewhere. For example, in our main program,
                                    we may define our own version of <span class="emphasis"><em>malloc()</em></span>
                                    (which perhaps does some bookkeeping of memory allocation), and
                                    this function can invoke the real <span class="emphasis"><em>malloc()</em></span>
                                    by first obtaining its address via the call <span class="emphasis"><em>func =
                                        dlsym(RTLD_NEXT, “malloc”)</em></span>.</p></dd></dl></div><p>The pseudohandle values listed above are not required by SUSv3 (which
                        nevertheless reserves them for future use), and are not available on all
                        UNIX implementations. In order to get the definitions of these constants
                        from <code class="literal">&lt;dlfcn.h&gt;</code>, we must
                        define the <code class="literal">_GNU_SOURCE</code> feature test
                        macro.</p></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id56">Example program</h4></div></div></div><p><a class="xref" href="ch42.html#using_the_dlopen_api" title="Example 42-1. Using the dlopen API">Example 42-1</a> demonstrates the use of the
                            <span class="emphasis"><em>dlopen</em></span> API. This program takes two command-line
                        arguments: the name of a shared library to load and the name of a function
                        to execute within that library. The following examples demonstrate the use
                        of this program:</p><a id="I_programlisting42_d1e113951"/><pre class="programlisting">$ <strong class="userinput"><code>./dynload ./libdemo.so.1 x1</code></strong>
Called mod1-x1
$ <strong class="userinput"><code>LD_LIBRARY_PATH=. ./dynload libdemo.so.1 x1</code></strong>
Called mod1-x1</pre><p>In the first of the above commands, <span class="emphasis"><em>dlopen()</em></span> notes
                        that the library path includes a slash and thus interprets it as a relative
                        pathname (in this case, to a library in the current working directory). In
                        the second command, we specify a library search path in <code class="literal">LD_LIBRARY_PATH</code>. This search path is
                        interpreted according to the usual rules of the dynamic linker (in this
                        case, likewise to find the library in the current working directory).</p><div class="example"><a id="using_the_dlopen_api"/><div class="example-title">Example 42-1. Using the <span class="emphasis"><em>dlopen</em></span> API</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>shlibs/dynload.c</code></strong>
#include &lt;dlfcn.h&gt;
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    void *libHandle;            /* Handle for shared library */
    void (*funcp)(void);        /* Pointer to function with no arguments */
    const char *err;

    if (argc != 3 || strcmp(argv[1], "--help") == 0)
        usageErr("%s lib-path func-name\n", argv[0]);

    /* Load the shared library and get a handle for later use */

    libHandle = dlopen(argv[1], RTLD_LAZY);
    if (libHandle == NULL)
        fatal("dlopen: %s", dlerror());

    /* Search library for symbol named in argv[2] */

    (void) dlerror();                           /* Clear dlerror() */
    *(void **) (&amp;funcp) = dlsym(libHandle, argv[2]);
    err = dlerror();
    if (err != NULL)
        fatal("dlsym: %s", err);

    /* If the address returned by dlsym() is non-NULL, try calling it
       as a function that takes no arguments */

    if (funcp == NULL)
        printf("%s is NULL\n", argv[2]);
    else
        (*funcp)();

    dlclose(libHandle);                         /* Close the library */

    exit(EXIT_SUCCESS);
}

      <strong class="userinput"><code>shlibs/dynload.c</code></strong></pre></div></div></div></div><div class="sect2" title="Closing a Shared Library: dlclose()"><div class="titlepage"><div><div><h3 class="title" id="closing_a_shared_library_colon_dlclose_o">Closing a Shared Library: <span class="emphasis"><em>dlclose()</em></span></h3></div></div></div><p>The <span class="emphasis"><em>dlclose()</em></span> function closes a library.<a id="IDX-CHP-42-5996" class="indexterm"/></p><a id="I_programlisting42_d1e113993"/><pre class="programlisting">#include &lt;dlfcn.h&gt;

int <strong class="userinput"><code>dlclose</code></strong>(void *<span class="emphasis"><em>handle</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>dlclose()</em></span> function decrements the system’s counter of
                    open references to the library referred to by <span class="emphasis"><em>handle</em></span>. If
                    this reference count falls to 0, and no symbols in the library are required by
                    other libraries, then the library is unloaded. This procedure is also
                    (recursively) performed for the libraries in this library’s dependency tree. An
                    implicit <span class="emphasis"><em>dlclose()</em></span> of all libraries is performed on process
                    termination.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>From <span class="emphasis"><em>glibc</em></span> 2.2.3 onward, a function within a shared
                        library can use <span class="emphasis"><em>atexit()</em></span> (or
                            <span class="emphasis"><em>on_exit()</em></span>) to establish a function that is called
                        automatically when the library is unloaded.<a id="IDX-CHP-42-5997" class="indexterm"/><a id="IDX-CHP-42-5998" class="indexterm"/></p></div></div><div class="sect2" title="Obtaining Information About Loaded Symbols: dladdr()"><div class="titlepage"><div><div><h3 class="title" id="obtaining_information_about_loaded_symbo">Obtaining Information About Loaded Symbols:
                    <span class="emphasis"><em>dladdr()</em></span></h3></div></div></div><p>Given an address in <span class="emphasis"><em>addr</em></span> (typically, one obtained by an
                    earlier call to <span class="emphasis"><em>dlsym()</em></span>), <span class="emphasis"><em>dladdr()</em></span>
                    returns a structure containing information about that address.<a id="IDX-CHP-42-6000" class="indexterm"/><a id="IDX-CHP-42-6001" class="indexterm"/><a id="IDX-CHP-42-6002" class="indexterm"/><a id="IDX-CHP-42-5999" class="indexterm"/></p><a id="I_programlisting42_d1e114078"/><pre class="programlisting">#define _GNU_SOURCE
#include &lt;dlfcn.h&gt;

int <strong class="userinput"><code>dladdr</code></strong>(const void *<span class="emphasis"><em>addr</em></span>, Dl_info *<span class="emphasis"><em>info</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns nonzero value if <span class="emphasis"><em>addr</em></span> was found in a shared
                        library, otherwise 0</p></div><p>The <span class="emphasis"><em>info</em></span> argument is a pointer to a caller-allocated
                    structure that has the following form:</p><a id="I_programlisting42_d1e114100"/><pre class="programlisting">typedef struct {
    const char *dli_fname;          /* Pathname of shared library
                                       containing 'addr' */
    void       *dli_fbase;          /* Base address at which shared
                                       library is loaded */
    const char *dli_sname;          /* Name of nearest run-time symbol
                                       with an address &lt;= 'addr' */
    void       *dli_saddr;          /* Actual value of the symbol
                                       returned in 'dli_sname' */
} Dl_info;</pre><p>The first two fields of the <span class="emphasis"><em>Dl_info</em></span> structure specify the
                    pathname and run-time base address of the shared library containing the address
                    specified in <span class="emphasis"><em>addr</em></span>. The last two fields return information
                    about that address. Assuming that <span class="emphasis"><em>addr</em></span> points to the exact
                    address of a symbol in the shared library, then <span class="emphasis"><em>dli_saddr</em></span>
                    returns the same value as was passed in <span class="emphasis"><em>addr</em></span>.<a id="IDX-CHP-42-6003" class="indexterm"/></p><p>SUSv3 doesn’t specify <span class="emphasis"><em>dladdr()</em></span>, and this function is not
                    available on all UNIX implementations.</p></div><div class="sect2" title="Accessing Symbols in the Main Program"><div class="titlepage"><div><div><h3 class="title" id="accessing_symbols_in_the_main_program">Accessing Symbols in the Main Program</h3></div></div></div><p>Suppose that we use <span class="emphasis"><em>dlopen()</em></span> to dynamically load a shared
                    library, use <span class="emphasis"><em>dlsym()</em></span> to obtain the address of a function
                        <span class="emphasis"><em>x()</em></span> from that library, and then call
                        <span class="emphasis"><em>x()</em></span>. If <span class="emphasis"><em>x()</em></span> in turn calls a
                    function <span class="emphasis"><em>y()</em></span>, then <span class="emphasis"><em>y()</em></span> would normally
                    be sought in one of the shared libraries loaded by the program.</p><p>Sometimes, it is desirable instead to have <span class="emphasis"><em>x()</em></span> invoke an
                    implementation of <span class="emphasis"><em>y()</em></span> in the main program. (This is similar
                    to a callback mechanism.) In order to do this, we must make the (global-scope)
                    symbols in the main program available to the dynamic linker, by linking the
                    program using the <span class="emphasis"><em>--export-dynamic</em></span> linker option:<a id="IDX-CHP-42-6004" class="indexterm"/></p><a id="I_programlisting42_d1e114175"/><pre class="programlisting">$ <strong class="userinput"><code>gcc -Wl,--export-dynamic main.c</code></strong>     <em class="lineannotation"><span class="lineannotation">(plus further options and arguments)</span></em></pre><p>Equivalently, we can write the following:</p><a id="I_programlisting42_d1e114184"/><pre class="programlisting">$ <strong class="userinput"><code>gcc -export-dynamic main.c</code></strong></pre><p>Using either of these options allows a dynamically loaded library to access
                    global symbols in the main program.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>gcc -rdynamic</em></span> option and the <span class="emphasis"><em>gcc
                            -Wl,-E</em></span> option are further synonyms for
                            <span class="emphasis"><em>-Wl,--export-dynamic</em></span>.</p></div></div></div><div class="sect1" title="Controlling Symbol Visibility"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="controlling_symbol_visibility">Controlling Symbol Visibility</h2></div></div></div><p>A well-designed shared library should make visible only those symbols (functions
                and variables) that form part of its specified application binary interface (ABI).
                The reasons for this are as follows:<a id="IDX-CHP-42-6005" class="indexterm"/><a id="IDX-CHP-42-6006" class="indexterm"/><a id="IDX-CHP-42-6007" class="indexterm"/><a id="IDX-CHP-42-6008" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If the shared library designer accidentally exports unspecified
                        interfaces, then authors of applications that use the library may choose to
                        employ these interfaces. This creates a compatibility problem for future
                        upgrades of the shared library. The library developer expects to be able to
                        change or remove any interfaces other than those in the documented ABI,
                        while the library user expects to continue using the same interfaces (with
                        the same semantics) that they currently employ.</p></li><li class="listitem"><p>During run-time symbol resolution, any symbols that are exported by a
                        shared library might interpose definitions that are provided in other shared
                        libraries (<a class="xref" href="ch41.html#run-time_symbol_resolution" title="Run-Time Symbol Resolution">Run-Time Symbol Resolution</a>).</p></li><li class="listitem"><p>Exporting unnecessary symbols increases the size of the dynamic symbol
                        table that must be loaded at run time.</p></li></ul></div><p>All of these problems can be minimized or avoided altogether if the library
                designer ensures that only the symbols required by the library’s specified ABI are
                exported. The following techniques can be used to control the export of
                symbols:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>In a C program, we can use the <code class="literal">static</code>
                        keyword to make a symbol private to a source-code module, thus rendering it
                        unavailable for binding by other object files.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>As well as making a symbol private to a source-code module, the <code class="literal">static</code> keyword also has a converse effect. If a
                    symbol is marked as <code class="literal">static</code>, then all
                    references to the symbol in the same source file will be bound to that
                    definition of the symbol. Consequently, these references won’t be subject to
                    run-time interposition by definitions from other shared libraries (in the manner
                    described in <a class="xref" href="ch41.html#run-time_symbol_resolution" title="Run-Time Symbol Resolution">Run-Time Symbol Resolution</a>). This effect of the
                        <code class="literal">static</code> keyword is similar to the
                        <span class="emphasis"><em>-Bsymbolic</em></span> linker option described in <a class="xref" href="ch41.html#run-time_symbol_resolution" title="Run-Time Symbol Resolution">Run-Time Symbol Resolution</a>, with the difference that the
                        <code class="literal">static</code> keyword affects a single symbol
                    within a single source file.</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The GNU C complier, <span class="emphasis"><em>gcc</em></span>, provides a compiler-specific
                        attribute declaration that performs a similar task to the <code class="literal">static</code> keyword:</p><a id="I_programlisting42_d1e114277"/><pre class="programlisting">void
__attribute__ ((visibility("hidden")))
func(void) {
    /* Code */
}</pre><p>Whereas the <code class="literal">static</code> keyword limits the
                        visibility of a symbol to a single source code file, the <code class="literal">hidden</code> attribute makes the symbol available
                        across all source code files that compose the shared library, but prevents
                        it from being visible outside the library.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>As with the <code class="literal">static</code> keyword, the
                                <code class="literal">hidden</code> attribute also has the
                            converse effect of preventing symbol interposition at run time.</p></div></li><li class="listitem"><p>Version scripts (<a class="xref" href="ch42.html#linker_version_scripts" title="Linker Version Scripts">Linker Version Scripts</a>) can be used to
                        precisely control symbol visibility and to select the version of a symbol to
                        which a reference is bound.</p></li><li class="listitem"><p>When dynamically loading a shared library (<a class="xref" href="ch42.html#opening_a_shared_library_colon_dlopen_op" title="Opening a Shared Library: dlopen()">Opening a Shared Library: <span class="emphasis"><em>dlopen()</em></span></a>), the
                            <span class="emphasis"><em>dlopen()</em></span>
                        <code class="literal">RTLD_GLOBAL</code> flag can be used to specify
                        that the symbols defined by the library should be made available for binding
                        by subsequently loaded libraries, and the
                            <span class="emphasis"><em>—export-dynamic</em></span> linker option (<a class="xref" href="ch42.html#accessing_symbols_in_the_main_program" title="Accessing Symbols in the Main Program">Accessing Symbols in the Main Program</a>) can be used to make
                        the global symbols of the main program available to dynamically loaded
                        libraries.</p></li></ul></div><p>For further details on the topic of symbol visibility, see [Drepper, 2004
                (b)].</p></div><div class="sect1" title="Linker Version Scripts"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="linker_version_scripts">Linker Version Scripts</h2></div></div></div><p>A <span class="emphasis"><em>version script</em></span> is a text file containing instructions for
                the linker, <span class="emphasis"><em>ld</em></span>. In order to use a version script, we must
                specify the <span class="emphasis"><em>—version-script</em></span> linker option:<a id="IDX-CHP-42-6009" class="indexterm"/><a id="IDX-CHP-42-6010" class="indexterm"/></p><a id="I_programlisting42_d1e114342"/><pre class="programlisting">$ <strong class="userinput"><code>gcc -Wl,--version-script,</code></strong><strong class="userinput"><code><em class="replaceable"><code>myscriptfile.map</code></em></code></strong> <strong class="userinput"><code>...</code></strong></pre><p>Version scripts are commonly (but not universally) identified using the extension
                    <code class="literal">.map</code>.</p><p>The following sections describe some uses of version scripts.</p><div class="sect2" title="Controlling Symbol Visibility with Version Scripts"><div class="titlepage"><div><div><h3 class="title" id="controlling_symbol_visibility_with_versi">Controlling Symbol Visibility with Version Scripts</h3></div></div></div><p>One use of version scripts is to control the visibility of symbols that might
                    otherwise accidentally be made global (i.e., visible to applications linking
                    against the library). As a simple example, suppose that we are building a shared
                    library from the three source files <code class="literal">vis_comm.c</code>, <code class="literal">vis_f1.c</code>, and
                        <code class="literal">vis_f2.c</code>, which respectively define the
                    functions <span class="emphasis"><em>vis_comm()</em></span>, <span class="emphasis"><em>vis_f1()</em></span>, and
                        <span class="emphasis"><em>vis_f2()</em></span>. The <span class="emphasis"><em>vis_comm()</em></span> function
                    is called by <span class="emphasis"><em>vis_f1()</em></span> and <span class="emphasis"><em>vis_f2()</em></span>,
                    but is not intended for direct use by applications linked against the library.
                    Suppose we build the shared library in the usual way:</p><a id="I_programlisting42_d1e114392"/><pre class="programlisting">$ <strong class="userinput"><code>gcc -g -c -fPIC -Wall vis_comm.c vis_f1.c vis_f2.c</code></strong>
$ <strong class="userinput"><code>gcc -g -shared -o vis.so vis_comm.o vis_f1.o vis_f2.o</code></strong></pre><p>If we use the following <span class="emphasis"><em>readelf</em></span> command to list the
                    dynamic symbols exported by the library, we see the following:</p><a id="I_programlisting42_d1e114404"/><pre class="programlisting">$ <strong class="userinput"><code>readelf --syms --use-dynamic vis.so | grep vis_</code></strong>
   30  12: 00000790    59    FUNC GLOBAL DEFAULT  10 vis_f1
   25  13: 000007d0    73    FUNC GLOBAL DEFAULT  10 vis_f2
   27  16: 00000770    20    FUNC GLOBAL DEFAULT  10 vis_comm</pre><p>This shared library exported three symbols: <span class="emphasis"><em>vis_comm()</em></span>,
                        <span class="emphasis"><em>vis_f1()</em></span>, and <span class="emphasis"><em>vis_f2()</em></span>. However,
                    we would like to ensure that only the symbols <span class="emphasis"><em>vis_f1()</em></span> and
                        <span class="emphasis"><em>vis_f2()</em></span> are exported by the library. We can achieve
                    this result using the following version script:</p><a id="I_programlisting42_d1e114426"/><pre class="programlisting">$ <strong class="userinput"><code>cat vis.map</code></strong>
VER_1 {
    global:
        vis_f1;
        vis_f2;
    local:
        *;
};</pre><p>The identifier <span class="emphasis"><em>VER_1</em></span> is an example of a <span class="emphasis"><em>version
                        tag</em></span>. As we’ll see in the discussion of symbol versioning in <a class="xref" href="ch42.html#symbol_versioning" title="Symbol Versioning">Symbol Versioning</a>, a version script may contain multiple
                        <span class="emphasis"><em>version nodes</em></span>, each grouped within braces (<code class="literal">{}</code>) and prefixed with a unique version tag. If we
                    are using a version script only for the purpose of controlling symbol
                    visibility, then the version tag is redundant; nevertheless, older versions of
                        <span class="emphasis"><em>ld</em></span> required it. Modern versions of
                        <span class="emphasis"><em>ld</em></span> allow the version tag to be omitted; in this case,
                    the version node is said to have an anonymous version tag, and no other version
                    nodes may be present in the script.</p><p>Within the version node, the <code class="literal">global</code> keyword
                    begins a semicolon-separated list of symbols that are made visible outside the
                    library. The local keyword begins a list of symbols that are to be hidden from
                    the outside world. The asterisk (*) here illustrates the fact that we can use
                    wildcard patterns in these symbol specifications. The wildcard characters are
                    the same as those used for shell filename matching—for example, <code class="literal">*</code> and <code class="literal">?</code>. (See
                    the <span class="emphasis"><em>glob(7)</em></span> manual page for further details.) In this
                    example, using an asterisk for the <code class="literal">local</code>
                    specification says that everything that wasn’t explicitly declared <code class="literal">global</code> is hidden. If we did not say this, then
                        <span class="emphasis"><em>vis_comm()</em></span> would still be visible, since the default is
                    to make C global symbols visible outside the shared library.</p><p>We can then build our shared library using the version script as
                    follows:</p><a id="I_programlisting42_d1e114480"/><pre class="programlisting">$ <strong class="userinput"><code>gcc -g -c -fPIC -Wall vis_comm.c vis_f1.c vis_f2.c</code></strong>
$ <strong class="userinput"><code>gcc -g -shared -o vis.so vis_comm.o vis_f1.o vis_f2.o \</code></strong>
        <strong class="userinput"><code>-Wl,--version-script,vis.map</code></strong></pre><p>Using <span class="emphasis"><em>readelf</em></span> once more shows that
                        <span class="emphasis"><em>vis_comm()</em></span> is no longer externally visible:</p><a id="I_programlisting42_d1e114499"/><pre class="programlisting">$ <strong class="userinput"><code>readelf --syms --use-dynamic vis.so | grep vis_</code></strong>
   25   0: 00000730    73    FUNC GLOBAL DEFAULT  11 vis_f2
   29  16: 000006f0    59    FUNC GLOBAL DEFAULT  11 vis_f1</pre></div><div class="sect2" title="Symbol Versioning"><div class="titlepage"><div><div><h3 class="title" id="symbol_versioning">Symbol Versioning</h3></div></div></div><p>Symbol versioning allows a single shared library to provide multiple versions
                    of the same function. Each program uses the version of the function that was
                    current when the program was (statically) linked against the shared library. As
                    a result, we can make an incompatible change to a shared library without needing
                    to increase the library’s major version number. Carried to an extreme, symbol
                    versioning can replace the traditional shared library major and minor versioning
                    scheme. Symbol versioning is used in this manner in <span class="emphasis"><em>glibc</em></span>
                    2.1 and later, so that all versions of <span class="emphasis"><em>glibc</em></span> from 2.0
                    onward are supported within a single major library version (<code class="literal">libc.so.6</code>).<a id="IDX-CHP-42-6011" class="indexterm"/><a id="IDX-CHP-42-6012" class="indexterm"/></p><p>We demonstrate the use of symbol versioning with a simple example. We begin by
                    creating the first version of a shared library using a version script:</p><a id="I_programlisting42_d1e114531"/><pre class="programlisting">$ <strong class="userinput"><code>cat sv_lib_v1.c</code></strong>
#include &lt;stdio.h&gt;

void xyz(void) { printf("v1 xyz\n"); }
$ <strong class="userinput"><code>cat sv_v1.map</code></strong>
VER_1 {
        global: xyz;
        local:  *;      # Hide all other symbols
};
$ <strong class="userinput"><code>gcc -g -c -fPIC -Wall sv_lib_v1.c</code></strong>
$ <strong class="userinput"><code>gcc -g -shared -o libsv.so sv_lib_v1.o -Wl,--version-script,sv_v1.map</code></strong></pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Within a version script, the hash character (<code class="literal">#</code>) starts a comment.</p></div><p>(To keep the example simple, we avoid the use of explicit library sonames and
                    library major version numbers.)</p><p>At this stage, our version script, <code class="literal">sv_v1.map</code>, serves only to control the visibility of the shared
                    library’s symbols; <span class="emphasis"><em>xyz()</em></span> is exported, but all other symbols
                    (of which there are none in this small example) are hidden. Next, we create a
                    program, <span class="emphasis"><em>p1</em></span>, which makes use of this library:</p><a id="I_programlisting42_d1e114563"/><pre class="programlisting">$ <strong class="userinput"><code>cat sv_prog.c</code></strong>
#include &lt;stdlib.h&gt;

int
main(int argc, char *argv[])
{
    void xyz(void);

    xyz();

    exit(EXIT_SUCCESS);
}
$ <strong class="userinput"><code>gcc -g -o p1 sv_prog.c libsv.so</code></strong></pre><p>When we run this program, we see the expected result:</p><a id="I_programlisting42_d1e114572"/><pre class="programlisting">$ <strong class="userinput"><code>LD_LIBRARY_PATH=. ./p1</code></strong>
v1 xyz</pre><p>Now, suppose that we want to modify the definition of
                        <span class="emphasis"><em>xyz()</em></span> within our library, while still ensuring that
                    program <span class="emphasis"><em>p1</em></span> continues to use the old version of this
                    function. To do this, we must define two versions of <span class="emphasis"><em>xyz()</em></span>
                    within our library:</p><a id="I_programlisting42_d1e114589"/><pre class="programlisting">$ <strong class="userinput"><code>cat sv_lib_v2.c</code></strong>
#include &lt;stdio.h&gt;

__asm__(".symver xyz_old,xyz@VER_1");
__asm__(".symver xyz_new,xyz@@VER_2");

void xyz_old(void) { printf("v1 xyz\n"); }

void xyz_new(void) { printf("v2 xyz\n"); }

void pqr(void) { printf("v2 pqr\n"); }</pre><p>Our two versions of <span class="emphasis"><em>xyz()</em></span> are provided by the functions
                        <span class="emphasis"><em>xyz_old()</em></span> and <span class="emphasis"><em>xyz_new()</em></span>. The
                        <span class="emphasis"><em>xyz_old()</em></span> function corresponds to our original
                    definition of <span class="emphasis"><em>xyz()</em></span>, which is the one that should continue
                    to be used by program <span class="emphasis"><em>p1</em></span>. The
                        <span class="emphasis"><em>xyz_new()</em></span> function provides the definition of
                        <span class="emphasis"><em>xyz()</em></span> to be used by programs linking against the new
                    version of the library.</p><p>The two <code class="literal">.symver</code> assembler directives are
                    the glue that ties these two functions to different version tags in the modified
                    version script (shown in a moment) that we use to create the new version of the
                    shared library. The first of these directives says that
                        <span class="emphasis"><em>xyz_old()</em></span> is the implementation of
                        <span class="emphasis"><em>xyz()</em></span> to be used for applications linked against
                    version tag <span class="emphasis"><em>VER_1</em></span> (i.e., program <span class="emphasis"><em>p1</em></span> in
                    our example), and that <span class="emphasis"><em>xyz_new()</em></span> is the implementation of
                        <span class="emphasis"><em>xyz()</em></span> to be used by applications linked against version
                    tag <span class="emphasis"><em>VER_2</em></span>.</p><p>The use of <code class="literal">@@</code> rather than <code class="literal">@</code> in the second <code class="literal">.symver</code> directive indicates that this is the default definition
                    of <span class="emphasis"><em>xyz()</em></span> to which applications should bind when statically
                    linked against this shared library. Exactly one of the <code class="literal">.symver</code> directives for a symbol should be marked using <code class="literal">@@</code>.</p><p>The corresponding version script for our modified library is as
                    follows:</p><a id="I_programlisting42_d1e114671"/><pre class="programlisting">$ <strong class="userinput"><code>cat sv_v2.map</code></strong>
VER_1 {
        global: xyz;
        local:  *;      # Hide all other symbols
};

VER_2 {
        global: pqr;
} VER_1;</pre><p>This version script provides a new version tag, <span class="emphasis"><em>VER_2</em></span>,
                    which depends on the tag <span class="emphasis"><em>VER_1</em></span>. This dependency is
                    indicated by the following line:</p><a id="I_programlisting42_d1e114684"/><pre class="programlisting">} VER_1;</pre><p>Version tag dependencies indicate the relationships between successive library
                    versions. Semantically, the only effect of version tag dependencies on Linux is
                    that a version node inherits <code class="literal">global</code> and
                        <code class="literal">local</code> specifications from the version
                    node upon which it depends.</p><p>Dependencies can be chained, so that we could have another version node tagged
                        <span class="emphasis"><em>VER_3</em></span>, which depended on <span class="emphasis"><em>VER_2</em></span>,
                    and so on.</p><p>The version tag names have no meanings in themselves. Their relationship with
                    one another is determined only by the specified version dependencies, and we
                    chose the names <span class="emphasis"><em>VER_1</em></span> and <span class="emphasis"><em>VER_2</em></span> merely
                    to be suggestive of these relationships. To assist maintenance, recommended
                    practice is to use version tags that include the package name and a version
                    number. For example, <span class="emphasis"><em>glibc</em></span> uses version tags with names
                    such as <span class="emphasis"><em>GLIBC_2.0</em></span>, <span class="emphasis"><em>GLIBC_2.1</em></span>, and so
                    on.</p><p>The <span class="emphasis"><em>VER_2</em></span> version tag also specifies that the new
                    function <span class="emphasis"><em>pqr()</em></span> is to be exported by the library and bound
                    to the <span class="emphasis"><em>VER_2</em></span> version tag. If we didn’t declare
                        <span class="emphasis"><em>pqr()</em></span> in this manner, then the <code class="literal">local</code> specification that <span class="emphasis"><em>VER_2</em></span> version tag
                    inherited from the <span class="emphasis"><em>VER_1</em></span> version tag would make
                        <span class="emphasis"><em>pqr()</em></span> invisible outside the library. Note also that if
                    we omitted the <code class="literal">local</code> specification
                    altogether, then the symbols <span class="emphasis"><em>xyz_old()</em></span> and
                        <span class="emphasis"><em>xyz_new()</em></span> would also be exported by the library (which
                    is typically not what we want).</p><p>We now build the new version of our library in the usual way:</p><a id="I_programlisting42_d1e114758"/><pre class="programlisting">$ <strong class="userinput"><code>gcc -g -c -fPIC -Wall sv_lib_v2.c</code></strong>
$ <strong class="userinput"><code>gcc -g -shared -o libsv.so sv_lib_v2.o -Wl,--version-script,sv_v2.map</code></strong></pre><p>Now we can create a new program, <span class="emphasis"><em>p2</em></span>, which uses the new
                    definition of <span class="emphasis"><em>xyz()</em></span>, while program <span class="emphasis"><em>p1</em></span>
                    uses the old version of <span class="emphasis"><em>xyz()</em></span>.</p><a id="I_programlisting42_d1e114779"/><pre class="programlisting">$ <strong class="userinput"><code>gcc -g -o p2 sv_prog.c libsv.so</code></strong>
$ <strong class="userinput"><code>LD_LIBRARY_PATH=. ./p2</code></strong>
v2 xyz                                        <em class="lineannotation"><span class="lineannotation">Uses</span></em> <span class="emphasis"><em>xyz@VER_2</em></span>
$ <strong class="userinput"><code>LD_LIBRARY_PATH=. ./p1</code></strong>
v1 xyz                                        <em class="lineannotation"><span class="lineannotation">Uses</span></em> <span class="emphasis"><em>xyz@VER_1</em></span></pre><p>The version tag dependencies of an executable are recorded at static link
                    time. We can use <span class="emphasis"><em>objdump -t</em></span> to display the symbol tables of
                    each executable, thus showing the different version tag dependencies of each
                    program:</p><a id="I_programlisting42_d1e114807"/><pre class="programlisting">$ <strong class="userinput"><code>objdump -t p1 | grep xyz</code></strong>
08048380       F *UND*  0000002e              xyz@@VER_1
$ <strong class="userinput"><code>objdump -t p2 | grep xyz</code></strong>
080483a0       F *UND*  0000002e              xyz@@VER_2</pre><p>We can also use <span class="emphasis"><em>readelf -s</em></span> to obtain similar
                    information.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Further information about symbol versioning can be found using the command
                            <span class="emphasis"><em>info ld scripts version</em></span> and at <a class="ulink" href="http://people.redhat.com/drepper/symbol-versioning" target="_top">http://people.redhat.com/drepper/symbol-versioning</a>.</p></div></div></div><div class="sect1" title="Initialization and Finalization Functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="initialization_and_finalization_function">Initialization and Finalization Functions</h2></div></div></div><p>It is possible to define one or more functions that are executed automatically
                when a shared library is loaded and unloaded. This allows us to perform
                initialization and finalization actions when working with shared libraries.
                Initialization and finalization functions are executed regardless of whether the
                library is loaded automatically or loaded explicitly using the
                    <span class="emphasis"><em>dlopen</em></span> interface (<a class="xref" href="ch42.html#dynamically_loaded_libraries" title="Dynamically Loaded Libraries">Dynamically Loaded Libraries</a>).<a id="IDX-CHP-42-6013" class="indexterm"/><a id="IDX-CHP-42-6014" class="indexterm"/></p><p>Initialization and finalization functions are defined using the
                    <span class="emphasis"><em>gcc</em></span>
                <code class="literal">constructor</code> and <code class="literal">destructor</code> attributes. Each function that is to be executed when the
                library is loaded should be defined as follows:</p><a id="I_programlisting42_d1e114859"/><pre class="programlisting">void __attribute__ ((constructor)) some_name_load(void)
{
    /* Initialization code */
}</pre><p>Unload functions are similarly defined:</p><a id="I_programlisting42_d1e114863"/><pre class="programlisting">void __attribute__ ((destructor)) some_name_unload(void)
{
    /* Finalization code */
}</pre><p>The function names <span class="emphasis"><em>some_name_load()</em></span> and
                    <span class="emphasis"><em>some_name_unload()</em></span> can be replaced by any desired
                names.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>It is also possible to use the <span class="emphasis"><em>gcc</em></span>
                    <code class="literal">constructor</code> and <code class="literal">destructor</code> attributes to create initialization and finalization
                    functions in a main program.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="the_underscore_init_open_parenthesis"/></div></div></div><div class="sect3" title="The _init() and _fini() functions"><div class="titlepage"><div><div><h4 class="title" id="the_underscore_init_open_parenthesis-id1">The <span class="emphasis"><em>_init()</em></span> and <span class="emphasis"><em>_fini()</em></span>
                        functions</h4></div></div></div><p>An older technique for shared library initialization and finalization is
                        to create two functions, <span class="emphasis"><em>_init()</em></span> and
                            <span class="emphasis"><em>_fini()</em></span>, as part of the library. The <span class="emphasis"><em>void
                            _init(void)</em></span> function contains code that is to executed when
                        the library is first loaded by a process. The <span class="emphasis"><em>void
                            _fini(void)</em></span> function contains code that is to be executed
                        when the library is unloaded.<a id="IDX-CHP-42-6017" class="indexterm"/><a id="IDX-CHP-42-6018" class="indexterm"/><a id="IDX-CHP-42-6015" class="indexterm"/><a id="IDX-CHP-42-6016" class="indexterm"/></p><p>If we create <span class="emphasis"><em>_init()</em></span> and <span class="emphasis"><em>_fini()</em></span>
                        functions, then we must specify the <span class="emphasis"><em>gcc -nostartfiles</em></span>
                        option when building the shared library, in order to prevent the linker from
                        including default versions of these functions. (Using the
                            <span class="emphasis"><em>-Wl,-init</em></span> and <span class="emphasis"><em>-Wl,-fini</em></span> linker
                        options, we can choose alternative names for these two functions if
                        desired.)</p><p>Use of <span class="emphasis"><em>_init()</em></span> and <span class="emphasis"><em>_fini()</em></span> is
                        now considered obsolete in favor of the <span class="emphasis"><em>gcc</em></span>
                        <code class="literal">constructor</code> and <code class="literal">destructor</code> attributes, which, among other advantages, allow
                        us to define multiple initialization and finalization functions.</p></div></div></div><div class="sect1" title="Preloading Shared Libraries"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="preloading_shared_libraries">Preloading Shared Libraries</h2></div></div></div><p>For testing purposes, it can sometimes be useful to selectively override functions
                (and other symbols) that would normally be found by the dynamic linker using the
                rules described in <a class="xref" href="ch41.html#finding_shared_libraries_at_run_time" title="Finding Shared Libraries at Run Time">Finding Shared Libraries at Run Time</a>. To do
                this, we can define the environment variable <code class="literal">LD_PRELOAD</code> as a string consisting of space-separated or
                colon-separated names of shared libraries that should be loaded before any other
                shared libraries. Since these libraries are loaded first, any functions they define
                will automatically be used if required by the executable, thus overriding any other
                functions of the same name that the dynamic linker would otherwise have searched
                for. For example, suppose that we have a program that calls functions
                    <span class="emphasis"><em>x1()</em></span> and <span class="emphasis"><em>x2()</em></span>, defined in our
                    <span class="emphasis"><em>libdemo</em></span> library. When we run this program, we see the
                following output:</p><a id="I_programlisting42_d1e114982"/><pre class="programlisting">$ <strong class="userinput"><code>./prog</code></strong>
Called mod1-x1 DEMO
Called mod2-x2 DEMO</pre><p>(In this example, we assume that the shared library is in one of the standard
                directories, and thus we don’t need to use the <code class="literal">LD_LIBRARY_PATH</code> environment variable.)</p><p>We could selectively override the function <span class="emphasis"><em>x1()</em></span> by creating
                another shared library, <code class="literal">libalt.so</code>, which contains
                a different definition of <span class="emphasis"><em>x1()</em></span>. Preloading this library when
                running the program would result in the following:</p><a id="I_programlisting42_d1e115003"/><pre class="programlisting">$ <strong class="userinput"><code>LD_PRELOAD=libalt.so ./prog</code></strong>
Called mod1-x1 ALT
Called mod2-x2 DEMO</pre><p>Here, we see that the version of <span class="emphasis"><em>x1()</em></span> defined in <code class="literal">libalt.so</code> is invoked, but that the call to
                    <span class="emphasis"><em>x2()</em></span>, for which no definition is provided in <code class="literal">libalt.so</code>, results in the invocation of the
                    <span class="emphasis"><em>x2()</em></span> function defined in <code class="literal">libdemo.so</code>.</p><p>The <code class="literal">LD_PRELOAD</code> environment variable controls
                preloading on a per-process basis. Alternatively, the file <code class="literal">/etc/ld.so.preload</code>, which lists libraries separated by white space,
                can be used to perform the same task on a system-wide basis. (Libraries specified by
                    <code class="literal">LD_PRELOAD</code> are loaded before those specified
                in <code class="literal">/etc/ld.so.preload</code>.)</p><p>For security reasons, set-user-ID and set-group-ID programs ignore <code class="literal">LD_PRELOAD</code>.</p></div><div class="sect1" title="Monitoring the Dynamic Linker: LD_DEBUG"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="monitoring_the_dynamic_linker_colon_ld_u">Monitoring the Dynamic Linker: <code class="literal">LD_DEBUG</code></h2></div></div></div><p>Sometimes, it is useful to monitor the operation of the dynamic linker in order to
                know, for example, where it is searching for libraries. We can use the <code class="literal">LD_DEBUG</code> environment variable to do this. By setting
                this variable to one (or more) of a set of standard keywords, we can obtain various
                kinds of tracing information from the dynamic linker.<a id="IDX-CHP-42-6019" class="indexterm"/><a id="IDX-CHP-42-6020" class="indexterm"/><a id="IDX-CHP-42-6021" class="indexterm"/><a id="IDX-CHP-42-6022" class="indexterm"/></p><p>If we assign the value <span class="emphasis"><em>help</em></span> to <code class="literal">LD_DEBUG</code>, the dynamic linker displays help information about <code class="literal">LD_DEBUG</code>, and the specified command is
                    <span class="emphasis"><em>not</em></span> executed:</p><a id="I_programlisting42_d1e115088"/><pre class="programlisting">$ <strong class="userinput"><code>LD_DEBUG=help date</code></strong>
Valid options for the LD_DEBUG environment variable are:

  libs       display library search paths
  reloc      display relocation processing
  files      display progress for input file
  symbols    display symbol table processing
  bindings   display information about symbol binding
  versions   display version dependencies
  all        all previous options combined
  statistics display relocation statistics
  unused     determine unused DSOs
  help       display this help message and exit

To direct the debugging output into a file instead of standard output
a filename can be specified using the LD_DEBUG_OUTPUT environment variable.</pre><p>The following example shows an abridged version of the output provided when we
                request tracing of information about library searches:</p><a id="I_programlisting42_d1e115095"/><pre class="programlisting">$ <strong class="userinput"><code>LD_DEBUG=libs date</code></strong>
     10687:     find library=librt.so.1 [0]; searching
     10687:      search cache=/etc/ld.so.cache
     10687:       trying file=/lib/librt.so.1
     10687:     find library=libc.so.6 [0]; searching
     10687:      search cache=/etc/ld.so.cache
     10687:       trying file=/lib/libc.so.6
     10687:     find library=libpthread.so.0 [0]; searching
     10687:      search cache=/etc/ld.so.cache
     10687:       trying file=/lib/libpthread.so.0
     10687:     calling init: /lib/libpthread.so.0
     10687:     calling init: /lib/libc.so.6
     10687:     calling init: /lib/librt.so.1
     10687:     initialize program: date
     10687:     transferring control: date
Tue Dec 28 17:26:56 CEST 2010
     10687:     calling fini: date [0]
     10687:     calling fini: /lib/librt.so.1 [0]
     10687:     calling fini: /lib/libpthread.so.0 [0]
     10687:     calling fini: /lib/libc.so.6 [0]</pre><p>The value 10687 displayed at the start of each line is the process ID of the
                process being traced. This is useful if we are monitoring several processes (e.g.,
                parent and child).</p><p>By default, <code class="literal">LD_DEBUG</code> output is written to
                standard error, but we can direct it elsewhere by assigning a pathname to the
                    <code class="literal">LD_DEBUG_OUTPUT</code> environment
                    variable.<a id="IDX-CHP-42-6023" class="indexterm"/></p><p>If desired, we can assign multiple options to <code class="literal">LD_DEBUG</code> by separating them with commas (no spaces should appear).
                The output of the <span class="emphasis"><em>symbols</em></span> option (which traces symbol
                resolution by the dynamic linker) is particularly voluminous.</p><p><code class="literal">LD_DEBUG</code> is effective both for libraries
                implicitly loaded by the dynamic linker and for libraries dynamically loaded by
                    <span class="emphasis"><em>dlopen()</em></span>.</p><p>For security reasons, <code class="literal">LD_DEBUG</code> is (since
                    <span class="emphasis"><em>glibc</em></span> 2.2.5) ignored in set-user-ID and set-group-ID
                programs.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id41">Summary</h2></div></div></div><p>The dynamic linker provides the <span class="emphasis"><em>dlopen</em></span> API, which allows
                programs to explicitly load additional shared libraries at run time. This allows
                programs to implement plug-in functionality.<a id="IDX-CHP-42-6024" class="indexterm"/><a id="IDX-CHP-42-6025" class="indexterm"/></p><p>An important aspect of shared library design is controlling symbol visibility, so
                that the library exports only those symbols (functions and variables) that should
                actually be used by programs linked against the library. We looked at a range of
                techniques that can be used to control symbol visibility. Among these techniques was
                the use of version scripts, which provide fine-grained control of symbol
                visibility.</p><p>We also showed how version scripts can be used to implement a scheme that allows a
                single shared library to export multiple definitions of a symbol for use by
                different applications linked against the library. (Each application uses the
                definition that was current when the application was statically linked against the
                library.) This technique provides an alternative to the traditional library
                versioning approach of using major and minor version numbers in the shared library
                real name.</p><p>Defining initialization and finalization functions within a shared library allows
                us to automatically execute code when the library is loaded and unloaded.</p><p>The <code class="literal">LD_PRELOAD</code> environment variable allows us
                to preload shared libraries. Using this mechanism, we can selectively override
                functions and other symbols that the dynamic linker would normally find in other
                shared libraries.</p><p>We can assign various values to the <code class="literal">LD_DEBUG</code>
                environment variable in order to monitor the operation of the dynamic linker.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="further_information-id57"/></div></div></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id58">Further information</h4></div></div></div><p>Refer to the sources of further information listed in <a class="xref" href="ch41.html#summary-id40" title="Summary">Summary</a>.</p></div></div></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id27">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Write a program to verify that if a library is closed with
                            <span class="emphasis"><em>dlclose()</em></span>, it is not unloaded if any of its symbols
                        are used by another library.<a id="IDX-CHP-42-6026" class="indexterm"/></p></li><li class="listitem"><p>Add a <span class="emphasis"><em>dladdr()</em></span> call to the program in <a class="xref" href="ch42.html#using_the_dlopen_api" title="Example 42-1. Using the dlopen API">Example 42-1</a> (<code class="literal">dynload.c</code>) in order to retrieve information about the address
                        returned by <span class="emphasis"><em>dlsym()</em></span>. Print out the values of the fields
                        of the returned <span class="emphasis"><em>Dl_info</em></span> structure, and verify that they
                        are as expected.</p></li></ol></div></div></section></body></html>
