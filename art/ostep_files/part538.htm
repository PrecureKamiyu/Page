<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Table 49.1: Reading A File: Client-side And File Server Actions</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part537.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part539.htm">下一个 &gt;</a></p><p style="padding-top: 4pt;padding-left: 57pt;text-indent: 0pt;text-align: justify;">Table 49.1: <b>Reading A File: Client-side And File Server Actions</b></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">cached state. The benefit is obvious: although the <i>first </i>access to <span class="s41">/home/ remzi/notes.txt </span>generates many client-server messages (as described above), it also establishes callbacks for all the directories as well as the file notes.txt, and thus subsequent accesses are entirely local and require no server interaction at all. Thus, in the common case where a file is cached at the client, AFS behaves nearly identically to a local disk-based file system. If one accesses a file more than once, the second access should be just as fast as accessing a file locally.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>C<span class="s45">ACHE </span>C<span class="s45">ONSISTENCY </span>I<span class="s45">S </span>N<span class="s45">OT </span>A P<span class="s45">ANACEA</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">When discussing distributed file systems, much is made of the cache con- sistency the file systems provide. However, this baseline consistency does not solve all problems with regards to file access from multiple clients. For example, if you are building a code repository, with multiple clients performing check-ins and check-outs of code, you can’t simply rely on the underlying file system to do all of the work for you; rather, you have to use explicit <b>file-level locking </b>in order to ensure that the “right” thing happens when such concurrent accesses take place. Indeed, any applica- tion that truly cares about concurrent updates will add extra machinery to handle conflicts. The baseline consistency described in this chapter and the previous one are useful primarily for casual usage, i.e., when a user logs into a different client, they expect some reasonable version of their files to show up there. Expecting more from these protocols is setting yourself up for failure, disappointment, and tear-filled frustration.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part537.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part539.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
