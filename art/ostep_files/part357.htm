<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>33.5 A Problem: Blocking System Calls</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part356.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part358.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">33.5 A Problem: Blocking System Calls</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Thus far, event-based programming sounds great, right? You program a simple loop, and handle events as they arise. You don’t even need to think about locking! But there is an issue: what if an event requires that you issue a system call that might block?</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">For example, imagine a request comes from a client into a server to read a file from disk and return its contents to the requesting client (much like a simple HTTP request). To service such a request, some event han- dler will eventually have to issue an <span class="s41">open() </span>system call to open the file, followed by a series of <span class="s41">read() </span>calls to read the file. When the file is read into memory, the server will likely start sending the results to the client.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Both the <span class="s41">open() </span>and <span class="s41">read() </span>calls may issue I/O requests to the stor- age system (when the needed metadata or data is not in memory already), and thus may take a long time to service. With a thread-based server, this is no issue: while the thread issuing the I/O request suspends (waiting for the I/O to complete), other threads can run, thus enabling the server to make progress. Indeed, this natural <b>overlap </b>of I/O and other computa- tion is what makes thread-based programming quite natural and straight- forward.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">With an event-based approach, however, there are no other threads to run: just the main event loop. And this implies that if an event handler issues a call that blocks, the <i>entire </i>server will do just that: block until the call completes. When the event loop blocks, the system sits idle, and thus is a huge potential waste of resources. We thus have a rule that must be obeyed in event-based systems: no blocking calls are allowed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part356.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part358.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
