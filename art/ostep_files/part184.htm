<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>18.3 Paging: Also Too Slow</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part183.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part185.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">18.3 Paging: Also Too Slow</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">With page tables in memory, we already know that they might be too big. Turns out they can slow things down too. For example, take our simple instruction:</p><p class="s38" style="padding-top: 4pt;padding-left: 81pt;text-indent: 0pt;text-align: left;">movl 21, %eax</p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Again, let’s just examine the explicit reference to address 21 and not worry about the instruction fetch. In this example, we will assume the hardware performs the translation for us. To fetch the desired data, the system must first <b>translate </b>the virtual address (21) into the correct physi- cal address (117). Thus, before issuing the load to address 117, the system must first fetch the proper page table entry from the process’s page ta- ble, perform the translation, and then finally get the desired data from physical memory.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To do so, the hardware must know where the page table is for the currently-running process. Let’s assume for now that a single <b>page-table base register </b>contains the physical address of the starting location of the page table. To find the location of the desired PTE, the hardware will thus perform the following functions:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">VPN  = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT PTEAddr = PageTableBaseRegister + (VPN <span class="s39">* </span>sizeof(PTE))</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_244.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">In our example, <span class="s41">VPN MASK </span>would be set to 0x30 (hex 30, or binary 110000) which picks out the VPN bits from the full virtual address; <span class="s41">SHIFT </span>is set to 4 (the number of bits in the offset), such that we move the VPN bits down to form the correct integer virtual page number. For exam- ple, with virtual address 21 (010101), and masking turns this value into 010000; the shift turns it into 01, or virtual page 1, as desired. We then use this value as an index into the array of PTEs pointed to by the page table base register.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Once this physical address is known, the hardware can fetch the PTE from memory, extract the PFN, and concatenate it with the offset from the virtual address to form the desired physical address. Specifically, you can think of the PFN being left-shifted by <span class="s41">SHIFT</span>, and then logically OR’d with the offset to form the final address as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">offset  = VirtualAddress &amp; OFFSET_MASK PhysAddr = (PFN &lt;&lt; SHIFT) | offset</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">1  <span class="s38">// Extract the VPN from the virtual address</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">2  <span class="s38">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">3</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">4  <span class="s38">// Form the address of the page-table entry (PTE)</span></p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;text-align: left;"><span class="s37">5  </span>PTEAddr = PTBR + (VPN <span class="s39">* </span>sizeof(PTE))</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">6</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">7  <span class="s38">// Fetch the PTE</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">8  <span class="s38">PTE = AccessMemory(PTEAddr)</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">9</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">10  <span class="s38">// Check if process can access the page</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">11  <span class="s38">if (PTE.Valid == False)</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">12    <span class="s38">RaiseException(SEGMENTATION_FAULT)</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">13  <span class="s38">else if (CanAccess(PTE.ProtectBits) == False)</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">14    <span class="s38">RaiseException(PROTECTION_FAULT)</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">15  <span class="s38">else</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">16     <span class="s38">// Access is OK: form physical address and fetch it</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">17     <span class="s38">offset  = VirtualAddress &amp; OFFSET_MASK</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">18     <span class="s38">PhysAddr = (PTE.PFN &lt;&lt; PFN_SHIFT) | offset</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">19    <span class="s38">Register = AccessMemory(PhysAddr)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 95pt;text-indent: 0pt;text-align: left;">Figure 18.6: <b>Accessing Memory With Paging</b></p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 88%;text-align: justify;">Finally, the hardware can fetch the desired data from memory and put it into register <span class="s41">eax</span>. The program has now succeeded at loading a value from memory!</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 59pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>D<span class="s45">ATA </span>S<span class="s45">TRUCTURE </span>– T<span class="s45">HE </span>P<span class="s45">AGE </span>T<span class="s45">ABLE</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">One of the most important data structures in the memory management subsystem of a modern OS is the <b>page table</b>. In general, a page table stores <b>virtual-to-physical address translations</b>, thus letting the system know where each page of an address space actually resides in physical memory. Because each address space requires such translations, in gen- eral there is one page table per process in the system. The exact structure of the page table is either determined by the hardware (older systems) or can be more flexibly managed by the OS (modern systems).</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To summarize, we now describe the initial protocol for what happens on each memory reference. Figure <span style=" color: #00AEEF;">18.6 </span>shows the basic approach. For every memory reference (whether an instruction fetch or an explicit load or store), paging requires us to perform one extra memory reference in order to first fetch the translation from the page table. That is a lot of work! Extra memory references are costly, and in this case will likely slow down the process by a factor of two or more.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">And now you can hopefully see that there are <i>two </i>real problems that we must solve. Without careful design of both hardware and software, page tables will cause the system to run too slowly, as well as take up too much memory. While seemingly a great solution for our memory virtualization needs, these two crucial problems must first be overcome.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part183.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part185.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
