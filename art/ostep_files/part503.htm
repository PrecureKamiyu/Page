<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>44.8 Overheads Of Checksumming</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part502.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part504.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">44.8 Overheads Of Checksumming</p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Before closing, we now discuss some of the overheads of using check- sums for data protection. There are two distinct kinds of overheads, as is common in computer systems: space and time.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Space overheads come in two forms. The first is on the disk (or other storage medium) itself; each stored checksum takes up room on the disk, which can no longer be used for user data. A typical ratio might be an 8- byte checksum per 4 KB data block, for a 0.19% on-disk space overhead.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The second type of space overhead comes in the memory of the sys- tem. When accessing data, there must now be room in memory for the checksums as well as the data itself. However, if the system simply checks the checksum and then discards it once done, this overhead is short-lived and not much of a concern. Only if checksums are kept in memory (for an added level of protection against memory corruption [Z+13]) will this small overhead be observable.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">While space overheads are small, the time overheads induced by check- summing can be quite noticeable. Minimally, the CPU must compute the checksum over each block, both when the data is stored (to determine the value of the stored checksum) as well as when it is accessed (to com- pute the checksum again and compare it against the stored checksum). One approach to reducing CPU overheads, employed by many systems that use checksums (including network stacks), is to combine data copy- ing and checksumming into one streamlined activity; because the copy is needed anyhow (e.g., to copy the data from the kernel page cache into a user buffer), combined copying/checksumming can be quite effective.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: left;">Beyond CPU overheads, some checksumming schemes can induce ex- tra I/O overheads, particularly when checksums are stored distinctly from the data (thus requiring extra I/Os to access them), and for any extra I/O needed for background scrubbing. The former can be reduced by design; the latter can be tuned and thus its impact limited, perhaps by control- ling when such scrubbing activity takes place. The middle of the night, when most (not all!) productive workers have gone to bed, may be a good time to perform such scrubbing activity and increase the robustness of the storage system.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part502.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part504.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
