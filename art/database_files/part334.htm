<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>18.6  Validation-Based Protocols</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part333.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part335.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">18.6  <span style=" color: #00AEEF;">Validation-Based Protocols</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">In cases where a majority of transactions are read-only transactions, the rate of conﬂicts among transactions may be low. Thus, many of these transactions, if executed without the supervision of a concurrency-control scheme, would nevertheless leave the system in a consistent state. A concurrency-control scheme imposes overhead of code execu- tion and possible delay of transactions. It may be better to use an alternative scheme that imposes less overhead. A diﬃculty in reducing the overhead is that we do not know in advance which transactions will be involved in a conﬂict. To gain that knowledge, we need a scheme for <i>monitoring </i>the system.</p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 94%;text-align: justify;">The <span class="s63">validation protocol </span>requires that each transaction <i>T</i><span class="s97">i </span>executes in two or three diﬀerent phases in its lifetime, depending on whether it is a read-only or an update transaction. The phases are, in order:</p><p style="padding-top: 8pt;padding-left: 113pt;text-indent: -16pt;line-height: 92%;text-align: justify;"><span class="s63">1. Read phase</span>. During this phase, the system executes transaction <i>T</i><span class="s97">i</span>. It reads the values of the various data items and stores them in variables local to <i>T</i><span class="s97">i</span>. It per- forms all <span class="s49">write </span>operations on temporary local variables, without updates of the actual database.</p><p style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;line-height: 94%;text-align: justify;"><span class="s63">2. Validation phase</span>. The validation test (described below) is applied to transaction <i>T</i><span class="s97">i</span>. This determines whether <i>T</i><span class="s97">i </span>is allowed to proceed to the write phase without causing a violation of serializability. If a transaction fails the validation test, the</p><p style="padding-left: 113pt;text-indent: 0pt;text-align: justify;">system aborts the transaction.</p><p style="padding-top: 7pt;padding-left: 113pt;text-indent: -17pt;line-height: 88%;text-align: justify;"><span class="s63">3. Write phase</span>. If the validation test succeeds for transaction <i>T</i><span class="s145">i</span>, the temporary local variables that hold the results of any <span class="s49">write </span>operations performed by <i>T</i><span class="s97">i </span>are copied to the database. Read-only transactions omit this phase.</p><p style="padding-top: 7pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Each transaction must go through the phases in the order shown. However, phases of concurrently executing transactions can be interleaved.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">To perform the validation test, we need to know when the various phases of trans- actions took place. We shall, therefore, associate three diﬀerent timestamps with each transaction <i>T</i><span class="s97">i</span>:</p><p style="padding-top: 11pt;padding-left: 97pt;text-indent: 0pt;text-align: left;"><span class="s63">1. </span><span class="s439">StartTS</span>(<i>T</i><span class="s97">i </span>), the time when <i>T</i><span class="s97">i </span>started its execution.</p><p style="padding-top: 5pt;padding-left: 113pt;text-indent: -17pt;line-height: 87%;text-align: left;"><span class="s63">2. </span><span class="s439">ValidationTS</span>(<i>T</i><span class="s97">i</span>), the time when <i>T</i><span class="s97">i </span>ﬁnished its read phase and started its valida- tion phase.</p><p style="padding-top: 6pt;padding-left: 96pt;text-indent: 0pt;text-align: left;"><span class="s63">3. </span><span class="s439">FinishTS</span>(<i>T</i><span class="s97">i </span>), the time when <i>T</i><span class="s97">i </span>ﬁnished its write phase.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-left: 229pt;text-indent: 0pt;text-align: left;">Note 18.1 <span class="s146">VIEW SERIALIZABILITY</span></p><p style="padding-top: 9pt;padding-left: 129pt;text-indent: 0pt;text-align: justify;">There is another form of equivalence that is less stringent than conﬂict equivalence, but that, like conﬂict equivalence, is based on only the <span class="s49">read </span>and <span class="s49">write </span>operations of transactions.</p><p style="padding-left: 129pt;text-indent: 17pt;text-align: justify;">Consider two schedules <i>S </i>and <i>S</i><span class="s181">′</span>, where the same set of transactions partic- ipates in both schedules. The schedules <i>S </i>and <i>S</i><span class="s181">′</span><span class="s15"> </span>are said to be <b>view equivalent </b>if three conditions are met:</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;line-height: 14pt;text-align: right;"><span class="s63">1. </span>For each data item <i>Q</i>, if transaction <i>T</i><span class="s97">i </span>reads the initial value of <i>Q </i>in schedule</p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 14pt;text-align: right;">S<span class="p">, then transaction </span>T<span class="s97">i </span><span class="p">must, in schedule </span>S<span class="s181">′</span><span class="p">, also read the initial value of </span>Q<span class="p">.</span></p><p style="padding-top: 5pt;padding-left: 154pt;text-indent: -17pt;line-height: 88%;text-align: justify;"><span class="s63">2. </span>For each data item <i>Q</i>, if transaction <i>T</i><span class="s145">i </span>executes <span class="s49">read</span>(<i>Q</i>) in schedule <i>S</i>, and if that value was produced by a <span class="s49">write</span>(<i>Q</i>) operation executed by transaction <i>T</i><span class="s97">j </span>, then the <span class="s49">read</span>(<i>Q</i>) operation of transaction <i>T</i><span class="s97">i </span>must, in schedule <i>S</i><span class="s181">′</span>, also read the value of <i>Q </i>that was produced by the same <span class="s49">write</span>(<i>Q</i>) operation of trans-</p><p style="padding-left: 154pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">action <i>T</i><span class="s97">j </span>.</p><p style="padding-top: 4pt;padding-left: 154pt;text-indent: -17pt;text-align: justify;"><span class="s63">3. </span>For each data item <i>Q</i>, the transaction (if any) that performs the ﬁnal <span class="s49">write</span>(<i>Q</i>) operation in schedule <i>S </i>must perform the ﬁnal <span class="s49">write</span>(<i>Q</i>) in sched- ule <i>S</i><span class="s181">′</span>.</p><p style="padding-top: 11pt;padding-left: 129pt;text-indent: 0pt;text-align: justify;">Conditions 1 and 2 ensure that each transaction reads the same values in both schedules and, therefore, performs the same computation. Condition 3, coupled with conditions 1 and 2, ensures that both schedules result in the same ﬁnal system state.</p><p style="padding-left: 129pt;text-indent: 17pt;text-align: right;">The concept of view equivalence leads to the concept of view serializability. We say that a schedule <i>S </i>is <b>view serializable </b>if it is view equivalent to a serial schedule.</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: right;">As an illustration, suppose that we augment schedule 4 with transaction <i>T</i><span class="s98">29</span></p><p style="padding-left: 129pt;text-indent: 0pt;text-align: justify;">and obtain the following view serializable (schedule 5):</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s440" style="padding-top: 4pt;padding-left: 249pt;text-indent: 0pt;text-align: center;">T<span class="s441">27</span></p><p class="s85" style="padding-top: 4pt;padding-left: 240pt;text-indent: -2pt;line-height: 214%;text-align: center;">read (<i>Q</i>) write (<i>Q</i>)</p><p class="s440" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">T<span class="s441">28</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s85" style="padding-left: 55pt;text-indent: 0pt;text-align: center;">write (<i>Q</i>)</p><p class="s440" style="padding-top: 4pt;padding-left: 80pt;text-indent: 0pt;text-align: center;">T<span class="s441">29</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s85" style="padding-left: 76pt;text-indent: 0pt;text-align: center;">write (<i>Q</i>)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 5pt;padding-left: 129pt;text-indent: 0pt;line-height: 70%;text-align: justify;"><span class="p">Indeed, schedule 5 is view equivalent to the serial schedule </span><span class="s83">&lt;</span>T<span class="s130">27</span><span class="s94">, </span>T<span class="s130">28</span><span class="s94">, </span>T<span class="s130">29</span><span class="s83">&gt;</span><span class="p">, since the one </span><span class="s49">read</span><span class="p">(</span>Q<span class="p">) instruction reads the initial value of </span>Q <span class="p">in both schedules and </span>T<span class="s98">29</span></p><p style="padding-top: 1pt;padding-left: 129pt;text-indent: 0pt;text-align: justify;">performs the ﬁnal write of <i>Q </i>in both schedules.</p><p style="padding-left: 129pt;text-indent: 17pt;text-align: justify;">Every conﬂict-serializable schedule is also view serializable, but there are view- serializable schedules that are not conﬂict serializable. Indeed, schedule 5 is not conﬂict serializable, since every pair of consecutive instructions conﬂicts, and, thus, no swapping of instructions is possible.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="493" height="739" alt="image" src="Image_3019.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-left: 94pt;text-indent: 0pt;text-align: left;">Note 18.1 <span class="s146">VIEW SERIALIZABILITY (Cont.)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 9pt;text-indent: 17pt;line-height: 13pt;text-align: justify;">Observe that, in schedule 5, transactions <i>T</i><span class="s130">28 </span><span class="s94">and </span><i>T</i><span class="s130">29 </span><span class="s94">perform </span><span class="s49">write</span>(<i>Q</i>) op- erations without having performed a <span class="s49">read</span>(<i>Q</i>) operation. Writes of this sort are called <b>blind writes</b>. Blind writes appear in any view-serializable schedule that is not conﬂict serializable.</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">We determine the serializability order by the timestamp-ordering technique, using</p><p style="padding-top: 2pt;padding-left: 88pt;text-indent: 0pt;line-height: 72%;text-align: justify;">the value of the timestamp <i>ValidationTS</i>(<i>T</i><span class="s145">i</span>). Thus, the value TS(<i>T</i><span class="s145">i</span>)= <i>ValidationTS</i>(<i>T</i><span class="s145">i </span>) and, if TS(<i>T</i><span class="s97">j </span>) <span class="s83">&lt; </span>TS(<i>T</i><span class="s97">k</span>), then any produced schedule must be equivalent to a serial schedule in which transaction <i>T</i><span class="s97">j </span>appears before transaction <i>T</i><span class="s97">k</span>.</p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 17pt;line-height: 73%;text-align: justify;">The <span class="s63">validation test </span>for transaction <i>T</i><span class="s97">i </span>requires that, for all transactions <i>T</i><span class="s97">k </span>with TS(<i>T</i><span class="s97">k</span>) <span class="s83">&lt; </span>TS(<i>T</i><span class="s97">i</span>), one of the following two conditions must hold:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 113pt;text-indent: -16pt;line-height: 70%;text-align: justify;"><span class="s63">1. </span>FinishTS<span class="p">(</span>T<span class="s97">k</span><span class="p">) </span><span class="s83">&lt; </span>StartTS<span class="p">(</span>T<span class="s97">i</span><span class="p">). Since </span>T<span class="s97">k </span><span class="p">completes its execution before </span>T<span class="s97">i </span><span class="p">started, the serializability order is indeed maintained.</span></p><p style="padding-top: 8pt;padding-left: 113pt;text-indent: -17pt;line-height: 76%;text-align: justify;"><span class="s63">2. </span>The set of data items written by <i>T</i><span class="s97">k </span>does not intersect with the set of data items read by <i>T</i><span class="s97">i</span>, and <i>T</i><span class="s97">k </span>completes its write phase before <i>T</i><span class="s97">i </span>starts its validation phase (<i>StartTS</i>(<i>T</i><span class="s97">i</span>) <span class="s83">&lt; </span><i>FinishTS</i>(<i>T</i><span class="s97">k</span>) <span class="s83">&lt; </span><i>ValidationTS</i>(<i>T</i><span class="s97">i </span>)). This condition ensures that the writes of <i>T</i><span class="s145">k </span>and <i>T</i><span class="s145">i </span>do not overlap. Since the writes of <i>T</i><span class="s145">k </span>do not aﬀect the read</p><p style="padding-left: 113pt;text-indent: 0pt;line-height: 90%;text-align: justify;">of <i>T</i><span class="s145">i</span>, and since <i>T</i><span class="s145">i </span>cannot aﬀect the read of <i>T</i><span class="s145">k</span>, the serializability order is indeed maintained.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 106pt;text-indent: 0pt;line-height: 13pt;text-align: justify;"><span class="p">As an illustration, consider again transactions </span>T<span class="s130">25 </span><span class="s94">and </span>T<span class="s130">26</span><span class="s94">. Suppose that TS(</span>T<span class="s130">25</span><span class="s94">)</span></p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;line-height: 70%;text-align: justify;"><span class="s83">&lt; </span>TS(<i>T</i><span class="s98">26</span>). Then, the validation phase succeeds in the schedule 6 in Figure 18.19. Note that the writes to the actual variables are performed only after the validation phase of</p><p class="s13" style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;line-height: 14pt;text-align: justify;">T<span class="s130">26</span><span class="s94">. Thus, </span>T<span class="s130">25 </span><span class="s94">reads the old values of </span>B <span class="p">and </span>A<span class="p">, and this schedule is serializable.</span></p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">The validation scheme automatically guards against cascading rollbacks, since the</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">actual writes take place only after the transaction issuing the write has committed. However, there is a possibility of starvation of long transactions, due to a sequence of conﬂicting short transactions that cause repeated restarts of the long transaction. To avoid starvation, conﬂicting transactions must be temporarily blocked to enable the long transaction to ﬁnish.</p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 94%;text-align: justify;">Note also that the validation conditions result in a transaction <i>T </i>only being val- idated again the set of transactions <i>T</i><span class="s97">i </span>that ﬁnished after <i>T </i>started, and, further, are serialized before <i>T </i>. Transactions that ﬁnished before <i>T </i>started can be ignored in the</p><p style="padding-top: 2pt;padding-left: 88pt;text-indent: 0pt;line-height: 72%;text-align: justify;">validation tests. Transactions <i>T</i><span class="s145">i </span>that are serialized after <i>T </i>(that is, they have <i>Valida- tionTS</i>(<i>T</i><span class="s97">i</span>) <span class="s83">&gt; </span><i>ValidationTS</i>(<i>T </i>)) can also be ignored; when such a transaction <i>T</i><span class="s97">i </span>is vali- dated, it would be validated against <i>T </i>if <i>T </i>ﬁnished after <i>T</i><span class="s97">i </span>started.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:233.934pt" cellspacing="0"><tr style="height:18pt"><td style="width:78pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F" bgcolor="#C6E9FA"><p class="s426" style="padding-top: 2pt;padding-left: 31pt;padding-right: 31pt;text-indent: 0pt;line-height: 14pt;text-align: center;"><a name="bookmark387">T</a><span class="s352">25</span><a name="bookmark428">&zwnj;</a></p></td><td style="width:64pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F" bgcolor="#C6E9FA"><p class="s426" style="padding-top: 2pt;padding-left: 24pt;padding-right: 24pt;text-indent: 0pt;line-height: 14pt;text-align: center;">T<span class="s352">26</span></p></td></tr><tr style="height:18pt"><td style="width:78pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">read</span>(<i>B</i>)</p></td><td style="width:64pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:13pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:64pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s72" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="s424">read</span>(<i>B</i>)</p></td></tr><tr style="height:15pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:64pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s71" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">B <span class="s72">:= </span>B <span class="s365">− </span><span class="s72">50</span></p></td></tr><tr style="height:12pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:64pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s72" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="s424">read</span>(<i>A</i>)</p></td></tr><tr style="height:27pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s72" style="padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">read</span>(<i>A</i>)</p></td><td style="width:64pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s71" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">A <span class="s72">:= </span>A <span class="s365">+ </span><span class="s72">50</span></p></td></tr><tr style="height:15pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s442" style="padding-left: 6pt;text-indent: 0pt;line-height: 13pt;text-align: left;">&lt;<span class="s72">validate</span>&gt;</p></td><td style="width:64pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:12pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 6pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="s424">display</span>(<i>A+ B</i>)</p></td><td style="width:64pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:15pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:64pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s442" style="padding-left: 7pt;text-indent: 0pt;line-height: 13pt;text-align: left;">&lt;<span class="s72">validate</span>&gt;</p></td></tr><tr style="height:12pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:64pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s72" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="s424">write</span>(<i>B</i>)</p></td></tr><tr style="height:14pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:64pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s72" style="padding-left: 7pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">write</span>(<i>A</i>)</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 160pt;text-indent: 0pt;text-align: left;">Figure 18.19 <span class="s74">Schedule 6, a schedule produced by using validation.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">This validation scheme is called the <span class="s63">optimistic concurrency-control </span>scheme since transactions execute optimistically, assuming they will be able to ﬁnish execution and validate at the end. In contrast, locking and timestamp ordering are pessimistic in that they force a wait or a rollback whenever a conﬂict is detected, even though there is a chance that the schedule may be conﬂict serializable.</p><p style="padding-top: 2pt;padding-left: 119pt;text-indent: 17pt;line-height: 80%;text-align: justify;">It is possible to use TS(<i>T</i><span class="s145">i</span>) = <i>StartTS</i>(<i>T</i><span class="s145">i</span>) instead of <i>ValidationTS</i>(<i>T</i><span class="s145">i </span>) without af- fecting serializability. However, doing so may result in a transaction <i>T</i><span class="s97">i </span>entering the validation phase before a transaction <i>T</i><span class="s97">j </span>that has TS(<i>T</i><span class="s97">j </span>) <span class="s83">&lt; </span>TS(<i>T</i><span class="s97">i</span>). Then, the validation</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 59%;text-align: justify;">of <i>T</i><span class="s97">i </span>would have to wait for <i>T</i><span class="s97">j </span>to complete, so its read and write sets are completely</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">known. Using <i>ValidationTS </i>avoids this problem.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part333.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part335.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
