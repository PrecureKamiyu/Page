<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>First Attempt</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part322.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part324.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">First Attempt</p><p style="padding-top: 5pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: left;">Our first attempt at solving the problem introduces two semaphores, <span class="s41">empty </span>and <span class="s41">full</span>, which the threads will use to indicate when a buffer entry has been emptied or filled, respectively. The code for the put and get routines is in Figure <span style=" color: #00AEEF;">31.5</span>, and our attempt at solving the producer and consumer problem is in Figure <span style=" color: #00AEEF;">31.6</span>.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In this example, the producer first waits for a buffer to become empty in order to put data into it, and the consumer similarly waits for a buffer to become filled before using it. Let us first imagine that <span class="s41">MAX=1 </span>(there is only one buffer in the array), and see if this works.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_457.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Imagine again there are two threads, a producer and a consumer. Let us examine a specific scenario on a single CPU. Assume the consumer gets to run first. Thus, the consumer will hit line c1 in the figure above, calling <span class="s41">sem wait(&amp;full)</span>. Because full was initialized to the value 0,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:24.0602pt" cellspacing="0"><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">1</p></td><td style="width:21pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 6pt;text-align: right;">int</p></td><td style="width:55pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">buffer[MAX];</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">2</p></td><td style="width:21pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: right;">int</p></td><td style="width:55pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">fill = 0;</p></td></tr><tr style="height:9pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;text-align: center;">3</p></td><td style="width:21pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 8pt;text-align: right;">int</p></td><td style="width:55pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 8pt;text-align: left;">use = 0;</p></td></tr><tr style="height:7pt"><td style="width:11pt"><p class="s135" style="padding-right: 3pt;text-indent: 0pt;line-height: 5pt;text-align: center;">4</p></td><td style="width:21pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:55pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">5  <span class="s38">void put(int value) {</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">6     <span class="s38">buffer[fill] = value;  // line f1</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">7     <span class="s38">fill = (fill + 1) % MAX; // line f2</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">8  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">9</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">10  <span class="s38">int get() {</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">11     <span class="s38">int tmp = buffer[use];  // line g1</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">12     <span class="s38">use = (use + 1) % MAX;  // line g2</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">13    <span class="s38">return tmp;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">14  <span class="s38">}</span></p><p style="padding-left: 107pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Figure 31.5: <b>The Put and Get Routines</b></p><p class="s37" style="padding-top: 6pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">1  <span class="s38">sem_t empty;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">2  <span class="s38">sem_t full;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">3</p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">4  </span>void <span class="s39">*</span>producer(void <span class="s39">*</span>arg) {</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;line-height: 7pt;text-align: left;">5    <span class="s38">int i;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">6     <span class="s38">for (i = 0; i &lt; loops; i++) {</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">7        <span class="s38">sem_wait(&amp;empty);     // line P1</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">8        <span class="s38">put(i);         // line P2</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">9        <span class="s38">sem_post(&amp;full);     // line P3</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">10    <span class="s38">}</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">11  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">12</p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">13  </span>void <span class="s39">*</span>consumer(void <span class="s39">*</span>arg) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 7pt;text-align: left;">14    <span class="s38">int i, tmp = 0;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">15    <span class="s38">while (tmp != -1) {</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">16        <span class="s38">sem_wait(&amp;full);     // line C1</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">17        <span class="s38">tmp = get();       // line C2</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">18        <span class="s38">sem_post(&amp;empty);     // line C3</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">19       <span class="s38">printf(&quot;%d\n&quot;, tmp);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">20    <span class="s38">}</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">21  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">22</p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">23  </span>int main(int argc, char <span class="s39">*</span>argv[]) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 7pt;text-align: left;">24    <span class="s38">// ...</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">25     <span class="s38">sem_init(&amp;empty, 0, MAX); // MAX buffers are empty to begin with...</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">26     <span class="s38">sem_init(&amp;full, 0, 0);  // ... and 0 are full</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">27    <span class="s38">// ...</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">28  <span class="s38">}</span></p><p style="padding-left: 80pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Figure 31.6: <b>Adding the Full and Empty Conditions</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_458.png"/></span></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 88%;text-align: justify;">the call will decrement <span class="s41">full </span>(to -1), block the consumer, and wait for another thread to call <span class="s41">sem post() </span>on <span class="s41">full</span>, as desired.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_459.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_460.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Assume the producer then runs. It will hit line P1, thus calling the <span class="s41">sem wait(&amp;empty) </span>routine. Unlike the consumer, the producer will continue through this line, because empty was initialized to the value MAX (in this case, 1). Thus, empty will be decremented to 0 and the producer will put a data value into the first entry of buffer (line P2). The producer will then continue on to P3 and call <span class="s41">sem post(&amp;full)</span>, chang- ing the value of the full semaphore from -1 to 0 and waking the consumer (e.g., move it from blocked to ready).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_461.png"/></span></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In this case, one of two things could happen. If the producer contin- ues to run, it will loop around and hit line P1 again. This time, how- ever, it would block, as the empty semaphore’s value is 0. If the producer instead was interrupted and the consumer began to run, it would call <span class="s41">sem wait(&amp;full) </span>(line c1) and find that the buffer was indeed full and thus consume it. In either case, we achieve the desired behavior.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">You can try this same example with more threads (e.g., multiple pro- ducers, and multiple consumers). It should still work.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Let us now imagine that <span class="s41">MAX </span>is greater than 1 (say <span class="s41">MAX </span>= 10). For this example, let us assume that there are multiple producers and multiple consumers. We now have a problem: a race condition. Do you see where it occurs? (take some time and look for it) If you can’t see it, here’s a hint: look more closely at the put() and get() code.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">OK, let’s understand the issue. Imagine two producers (Pa and Pb) both calling into put() at roughly the same time. Assume producer Pa gets to run first, and just starts to fill the first buffer entry (fill = 0 at line f1). Before Pa gets a chance to increment the fill counter to 1, it is interrupted. Producer Pb starts to run, and at line f1 it also puts its data into the 0th element of buffer, which means that the old data there is overwritten! This is a no-no; we don’t want any data from the producer to be lost.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part322.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part324.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
