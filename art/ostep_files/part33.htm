<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Virtualization</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part32.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part34.htm">下一个 &gt;</a></p><h1 style="padding-left: 21pt;text-indent: 0pt;text-align: center;">Virtualization</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part34.htm">A Dialogue on Virtualization</a><a class="toc0" href="part35.htm">The Abstraction: The Process</a><a class="toc1" href="part36.htm">4.1 The Abstraction: A Process</a><a class="toc1" href="part37.htm">4.2 Process API</a><a class="toc1" href="part38.htm">4.3 Process Creation: A Little More Detail</a><a class="toc1" href="part39.htm">4.4 Process States</a><a class="toc1" href="part40.htm">4.5 Data Structures</a><a class="toc1" href="part41.htm">4.6 Summary</a><a class="toc1" href="part42.htm">References</a><a class="toc0" href="part43.htm">Interlude: Process API</a><a class="toc1" href="part44.htm">5.1 The fork() System Call</a><a class="toc1" href="part45.htm">5.2  Adding wait() System Call</a><a class="toc1" href="part46.htm">5.3 Finally, the exec() System Call</a><a class="toc1" href="part47.htm">5.4 Why? Motivating the API</a><a class="toc1" href="part48.htm">5.5 Other Parts of the API</a><a class="toc1" href="part49.htm">5.6 Summary</a><a class="toc1" href="part50.htm">References</a><a class="toc0" href="part51.htm">Mechanism: Limited Direct Execution</a><a class="toc1" href="part52.htm">6.1 Basic Technique: Limited Direct Execution</a><a class="toc2" href="part53.htm">Table 6.1: Direction Execution Protocol (Without Limits)</a><a class="toc1" href="part54.htm">6.2 Problem #1: Restricted Operations</a><a class="toc1" href="part55.htm">6.3 Problem #2: Switching Between Processes</a><a class="toc2" href="part56.htm">A Cooperative Approach: Wait For System Calls</a><a class="toc2" href="part57.htm">A Non-Cooperative Approach: The OS Takes Control</a><a class="toc2" href="part58.htm">Saving and Restoring Context</a><a class="toc1" href="part60.htm">6.4 Worried About Concurrency?</a><a class="toc1" href="part61.htm">6.5 Summary</a><a class="toc1" href="part62.htm">References</a><a class="toc1" href="part63.htm">Homework (Measurement)</a><a class="toc0" href="part64.htm">Scheduling: Introduction</a><a class="toc1" href="part65.htm">7.1 Workload Assumptions</a><a class="toc2" href="part66.htm">a fully-operational scheduling discipline1.</a><a class="toc1" href="part67.htm">7.2 Scheduling Metrics</a><a class="toc1" href="part68.htm">7.3 First In, First Out (FIFO)</a><a class="toc1" href="part69.htm">7.4 Shortest Job First (SJF)</a><a class="toc1" href="part70.htm">7.5 Shortest Time-to-Completion First (STCF)</a><a class="toc1" href="part71.htm">7.6 Round Robin</a><a class="toc1" href="part72.htm">7.7 Incorporating I/O</a><a class="toc1" href="part73.htm">7.8 No More Oracle</a><a class="toc1" href="part74.htm">7.9 Summary</a><a class="toc1" href="part75.htm">References</a><a class="toc1" href="part76.htm">Homework</a><a class="toc2" href="part77.htm">Questions</a><a class="toc0" href="part78.htm">Scheduling:           The Multi-Level Feedback Queue</a><a class="toc1" href="part79.htm">8.1 MLFQ: Basic Rules</a><a class="toc1" href="part80.htm">8.2 Attempt #1: How to Change Priority</a><a class="toc2" href="part81.htm">Example 1: A Single Long-Running Job</a><a class="toc2" href="part82.htm">Example 2: Along Came A Short Job</a><a class="toc2" href="part84.htm">Example 3: What About I/O?</a><a class="toc2" href="part85.htm">Problems With Our Current MLFQ</a><a class="toc1" href="part86.htm">8.3 Attempt #2: The Priority Boost</a><a class="toc2" href="part87.htm">Figure 8.6: Without (Left) and With (Right) Gaming Tolerance</a><a class="toc1" href="part88.htm">8.4 Attempt #3: Better Accounting</a><a class="toc1" href="part89.htm">8.5 Tuning MLFQ And Other Issues</a><a class="toc1" href="part90.htm">8.6 MLFQ: Summary</a><a class="toc1" href="part91.htm">References</a><a class="toc1" href="part92.htm">Homework</a><a class="toc2" href="part93.htm">Questions</a><a class="toc0" href="part94.htm">Scheduling: Proportional Share</a><a class="toc1" href="part95.htm">9.1 Basic Concept: Tickets Represent Your Share</a><a class="toc1" href="part96.htm">9.2 Ticket Mechanisms</a><a class="toc1" href="part97.htm">9.3 Implementation</a><a class="toc1" href="part98.htm">9.4 An Example</a><a class="toc1" href="part99.htm">9.5 How To Assign Tickets?</a><a class="toc1" href="part100.htm">9.6 Why Not Deterministic?</a><a class="toc1" href="part101.htm">9.7 Summary</a><a class="toc1" href="part102.htm">References</a><a class="toc1" href="part103.htm">Homework</a><a class="toc2" href="part104.htm">Questions</a><a class="toc0" href="part105.htm">Multiprocessor Scheduling (Advanced)</a><a class="toc1" href="part106.htm">10.1 Background: Multiprocessor Architecture</a><a class="toc1" href="part107.htm">10.2 Don’t Forget Synchronization</a><a class="toc1" href="part108.htm">10.3 One Final Issue: Cache Affinity</a><a class="toc1" href="part109.htm">10.4 Single-Queue Scheduling</a><a class="toc1" href="part110.htm">10.5 Multi-Queue Scheduling</a><a class="toc1" href="part111.htm">10.6 Linux Multiprocessor Schedulers</a><a class="toc1" href="part112.htm">10.7 Summary</a><a class="toc1" href="part113.htm">References</a><a class="toc0" href="part114.htm">Summary Dialogue on CPU Virtualization</a><a class="toc0" href="part115.htm">A Dialogue on Memory Virtualization</a><a class="toc0" href="part116.htm">The Abstraction: Address Spaces</a><a class="toc1" href="part117.htm">13.1 Early Systems</a><a class="toc1" href="part118.htm">13.2 Multiprogramming and Time Sharing</a><a class="toc1" href="part119.htm">13.3 The Address Space</a><a class="toc1" href="part120.htm">13.4 Goals</a><a class="toc1" href="part121.htm">13.5 Summary</a><a class="toc1" href="part122.htm">References</a><a class="toc0" href="part123.htm">Interlude: Memory API</a><a class="toc1" href="part124.htm">14.1 Types of Memory</a><a class="toc1" href="part125.htm">14.2 The malloc() Call</a><a class="toc1" href="part126.htm">14.3 The free() Call</a><a class="toc1" href="part127.htm">14.4 Common Errors</a><a class="toc2" href="part128.htm">Forgetting To Allocate Memory</a><a class="toc2" href="part129.htm">Not Allocating Enough Memory</a><a class="toc2" href="part130.htm">Forgetting to Initialize Allocated Memory</a><a class="toc2" href="part131.htm">Forgetting To Free Memory</a><a class="toc2" href="part132.htm">Freeing Memory Before You Are Done With It</a><a class="toc2" href="part133.htm">Freeing Memory Repeatedly</a><a class="toc2" href="part134.htm">Calling free() Incorrectly</a><a class="toc2" href="part135.htm">Summary</a><a class="toc1" href="part136.htm">14.5 Underlying OS Support</a><a class="toc1" href="part137.htm">14.6 Other Calls</a><a class="toc1" href="part138.htm">14.7 Summary</a><a class="toc1" href="part139.htm">References</a><a class="toc0" href="part140.htm">Mechanism: Address Translation</a><a class="toc1" href="part141.htm">15.1 Assumptions</a><a class="toc1" href="part142.htm">15.2 An Example</a><a class="toc1" href="part143.htm">15.3 Dynamic (Hardware-based) Relocation</a><a class="toc2" href="part144.htm">Example Translations</a><a class="toc1" href="part145.htm">15.4 OS Issues</a><a class="toc1" href="part146.htm">15.5 Summary</a><a class="toc1" href="part147.htm">References</a><a class="toc1" href="part148.htm">Homework</a><a class="toc2" href="part149.htm">Questions</a><a class="toc0" href="part150.htm">Segmentation</a><a class="toc1" href="part151.htm">16.1 Segmentation: Generalized Base/Bounds</a><a class="toc1" href="part152.htm">16.2 Which Segment Are We Referring To?</a><a class="toc1" href="part153.htm">16.3 What About The Stack?</a><a class="toc2" href="part154.htm">Table 16.2: Segment Registers (With Negative-Growth Support)</a><a class="toc1" href="part155.htm">16.4 Support for Sharing</a><a class="toc1" href="part156.htm">16.5 Fine-grained vs. Coarse-grained Segmentation</a><a class="toc1" href="part157.htm">16.6 OS Support</a><a class="toc1" href="part158.htm">16.7 Summary</a><a class="toc1" href="part159.htm">References</a><a class="toc1" href="part160.htm">Homework</a><a class="toc2" href="part161.htm">Questions</a><a class="toc0" href="part162.htm">Free-Space Management</a><a class="toc1" href="part163.htm">17.1 Assumptions</a><a class="toc1" href="part164.htm">17.2 Low-level Mechanisms</a><a class="toc2" href="part165.htm">Splitting and Coalescing</a><a class="toc2" href="part166.htm">Tracking The Size Of Allocated Regions</a><a class="toc2" href="part167.htm">Embedding A Free List</a><a class="toc2" href="part168.htm">Growing The Heap</a><a class="toc1" href="part169.htm">17.3 Basic Strategies</a><a class="toc2" href="part170.htm">Best Fit</a><a class="toc2" href="part171.htm">Worst Fit</a><a class="toc2" href="part172.htm">First Fit</a><a class="toc2" href="part173.htm">Next Fit</a><a class="toc2" href="part174.htm">Examples</a><a class="toc1" href="part175.htm">17.4 Other Approaches</a><a class="toc2" href="part176.htm">Segregated Lists</a><a class="toc2" href="part177.htm">Buddy Allocation</a><a class="toc2" href="part178.htm">Other Ideas</a><a class="toc1" href="part179.htm">17.5 Summary</a><a class="toc1" href="part180.htm">References</a><a class="toc0" href="part181.htm">Paging: Introduction</a><a class="toc1" href="part182.htm">18.1 Where Are Page Tables Stored?</a><a class="toc1" href="part183.htm">18.2 What’s Actually In The Page Table?</a><a class="toc1" href="part184.htm">18.3 Paging: Also Too Slow</a><a class="toc1" href="part185.htm">18.4 A Memory Trace</a><a class="toc1" href="part186.htm">18.5 Summary</a><a class="toc1" href="part187.htm">References</a><a class="toc1" href="part188.htm">Homework</a><a class="toc2" href="part189.htm">Questions</a><a class="toc0" href="part190.htm">Paging: Faster Translations (TLBs)</a><a class="toc1" href="part191.htm">19.1 TLB Basic Algorithm</a><a class="toc1" href="part192.htm">19.2 Example: Accessing An Array</a><a class="toc1" href="part193.htm">19.3 Who Handles The TLB Miss?</a><a class="toc1" href="part194.htm">19.4 TLB Contents: What’s In There?</a><a class="toc1" href="part195.htm">19.5 TLB Issue: Context Switches</a><a class="toc1" href="part196.htm">19.6 Issue: Replacement Policy</a><a class="toc1" href="part197.htm">19.7 A Real TLB Entry</a><a class="toc1" href="part198.htm">19.8 Summary</a><a class="toc1" href="part199.htm">References</a><a class="toc1" href="part200.htm">Homework (Measurement)</a><a class="toc2" href="part201.htm">Questions</a><a class="toc0" href="part202.htm">Paging: Smaller Tables</a><a class="toc1" href="part203.htm">20.1 Simple Solution: Bigger Pages</a><a class="toc1" href="part204.htm">20.2 Hybrid Approach: Paging and Segments</a><a class="toc1" href="part205.htm">20.3 Multi-level Page Tables</a><a class="toc2" href="part206.htm">A Detailed Multi-Level Example</a><a class="toc2" href="part207.htm">More Than Two Levels</a><a class="toc2" href="part208.htm">The Translation Process: Remember the TLB</a><a class="toc1" href="part209.htm">20.4 Inverted Page Tables</a><a class="toc1" href="part210.htm">20.5 Swapping the Page Tables to Disk</a><a class="toc1" href="part211.htm">20.6 Summary</a><a class="toc1" href="part212.htm">References</a><a class="toc1" href="part213.htm">Homework</a><a class="toc2" href="part214.htm">Questions</a><a class="toc0" href="part215.htm">Beyond Physical Memory: Mechanisms</a><a class="toc1" href="part216.htm">21.1 Swap Space</a><a class="toc1" href="part217.htm">21.2 The Present Bit</a><a class="toc1" href="part218.htm">21.3 The Page Fault</a><a class="toc1" href="part219.htm">21.4 What If Memory Is Full?</a><a class="toc1" href="part220.htm">21.5 Page Fault Control Flow</a><a class="toc1" href="part221.htm">21.6 When Replacements Really Occur</a><a class="toc1" href="part222.htm">21.7 Summary</a><a class="toc1" href="part223.htm">References</a><a class="toc0" href="part224.htm">Beyond Physical Memory: Policies</a><a class="toc1" href="part225.htm">22.1 Cache Management</a><a class="toc1" href="part226.htm">22.2 The Optimal Replacement Policy</a><a class="toc1" href="part227.htm">22.3 A Simple Policy: FIFO</a><a class="toc1" href="part228.htm">22.4 Another Simple Policy: Random</a><a class="toc1" href="part229.htm">22.5 Using History: LRU</a><a class="toc1" href="part230.htm">22.6 Workload Examples</a><a class="toc2" href="part231.htm">The No-Locality Workload</a><a class="toc2" href="part232.htm">Cache Size (Blocks)</a><a class="toc2" href="part233.htm">The 80-20 Workload</a><a class="toc2" href="part234.htm">Cache Size (Blocks)</a><a class="toc2" href="part235.htm">The Looping-Sequential Workload</a><a class="toc2" href="part236.htm">Cache Size (Blocks)</a><a class="toc1" href="part237.htm">22.7 Implementing Historical Algorithms</a><a class="toc1" href="part238.htm">22.8 Approximating LRU</a><a class="toc2" href="part239.htm">The 80-20 Workload</a><a class="toc2" href="part240.htm">Cache Size (Blocks)</a><a class="toc1" href="part241.htm">22.9 Considering Dirty Pages</a><a class="toc1" href="part242.htm">22.10 Other VM Policies</a><a class="toc1" href="part243.htm">22.11 Thrashing</a><a class="toc1" href="part244.htm">22.12 Summary</a><a class="toc1" href="part245.htm">References</a><a class="toc1" href="part246.htm">Homework</a><a class="toc2" href="part247.htm">Questions</a><a class="toc0" href="part248.htm">The VAX/VMS Virtual Memory System</a><a class="toc1" href="part249.htm">23.1 Background</a><a class="toc1" href="part250.htm">23.2 Memory Management Hardware</a><a class="toc1" href="part251.htm">23.3 A Real Address Space</a><a class="toc1" href="part252.htm">23.4 Page Replacement</a><a class="toc2" href="part253.htm">Segmented FIFO</a><a class="toc2" href="part254.htm">Page Clustering</a><a class="toc1" href="part255.htm">23.5 Other Neat VM Tricks</a><a class="toc1" href="part256.htm">23.6 Summary</a><a class="toc1" href="part257.htm">References</a><a class="toc0" href="part258.htm">Summary Dialogue on Memory Virtualization</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part32.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part34.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
