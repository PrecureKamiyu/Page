<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>22.8 Approximating LRU</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part237.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part239.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">22.8 Approximating LRU</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">As it turns out, the answer is yes: approximating LRU is more fea- sible from a computational-overhead standpoint, and indeed it is what many modern systems do. The idea requires some hardware support, in the form of a <b>use bit </b>(sometimes called the <b>reference bit</b>), the first of which was implemented in the first system with paging, the Atlas one- level store [KE+62]. There is one use bit per page of the system, and the use bits live in memory somewhere (they could be in the per-process page tables, for example, or just in an array somewhere). Whenever a page is referenced (i.e., read or written), the use bit is set by hardware to 1. The hardware never clears the bit, though (i.e., sets it to 0); that is the respon- sibility of the OS.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">How does the OS employ the use bit to approximate LRU? Well, there could be a lot of ways, but with the <b>clock algorithm </b>[C69], one simple approach was suggested. Imagine all the pages of the system arranged in a circular list. A <b>clock hand </b>points to some particular page to begin with (it doesn’t really matter which). When a replacement must occur, the OS checks if the currently-pointed to page <span class="s43">P </span>has a use bit of 1 or 0. If 1, this implies that page <span class="s43">P </span>was recently used and thus is <i>not </i>a good candidate for replacement. Thus, the clock hand is incremented to the next page <span class="s43">P </span><span class="s44">+ 1</span>, and the use bit for <span class="s43">P </span>set to 0 (cleared). The algorithm continues until it finds a use bit that is set to 0, implying this page has not been recently used (or, in the worst case, that all pages have been and that we have now searched through the entire set of pages, clearing all the bits).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Note that this approach is not the only way to employ a use bit to approximate LRU. Indeed, any approach which periodically clears the use bits and then differentiates between which pages have use bits of 1 versus 0 to decide which to replace would be fine. The clock algorithm of Corbato’s was just one early approach which met with some success, and had the nice property of not repeatedly scanning through all of memory looking for an unused page.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s48" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">100%</p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part239.htm">The 80-20 Workload</a><a class="toc0" href="part240.htm">Cache Size (Blocks)</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part237.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part239.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
