<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Scheduling:           The Multi-Level Feedback Queue</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part77.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part79.htm">下一个 &gt;</a></p><p class="s8" style="padding-top: 4pt;padding-left: 118pt;text-indent: 135pt;line-height: 92%;text-align: left;">Scheduling:           The Multi-Level Feedback Queue</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">In this chapter, we’ll tackle the problem of developing one of the most well-known approaches to scheduling, known as the <b>Multi-level Feed- back Queue (MLFQ)</b>. The Multi-level Feedback Queue (MLFQ) sched- uler was first described by Corbato et al. in 1962 [C+62] in a system known as the Compatible Time-Sharing System (CTSS), and this work, along with later work on Multics, led the ACM to award Corbato its highest honor, the <b>Turing Award</b>. The scheduler has subsequently been refined throughout the years to the implementations you will encounter in some modern systems.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The fundamental problem MLFQ tries to address is two-fold. First, it would like to optimize <i>turnaround time</i>, which, as we saw in the previous note, is done by running shorter jobs first; unfortunately, the OS doesn’t generally know how long a job will run for, exactly the knowledge that algorithms like SJF (or STCF) require. Second, MLFQ would like to make a system feel responsive to interactive users (i.e., users sitting and staring at the screen, waiting for a process to finish), and thus minimize <i>response time</i>; unfortunately, algorithms like Round Robin reduce response time but are terrible for turnaround time. Thus, our problem: given that we in general do not know anything about a process, how can we build a scheduler to achieve these goals? How can the scheduler learn, as the system runs, the characteristics of the jobs it is running, and thus make better scheduling decisions?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">HE </span>C<span class="s7">RUX</span>:</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 10pt;text-align: center;">H<span class="s7">OW </span>T<span class="s7">O </span>S<span class="s7">CHEDULE </span>W<span class="s7">ITHOUT </span>P<span class="s7">ERFECT </span>K<span class="s7">NOWLEDGE</span>?</p><p style="padding-left: 9pt;text-indent: 11pt;line-height: 89%;text-align: justify;">How can we design a scheduler that both minimizes response time for interactive jobs while also minimizing turnaround time without <i>a priori </i>knowledge of job length?</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 21pt;text-indent: 0pt;text-align: center;">71</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 97pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: L<span class="s7">EARN </span>F<span class="s7">ROM </span>H<span class="s7">ISTORY</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">The multi-level feedback queue is an excellent example of a system that learns from the past to predict the future. Such approaches are com- mon in operating systems (and many other places in Computer Science, including hardware branch predictors and caching algorithms). Such approaches work when jobs have phases of behavior and are thus pre- dictable; of course, one must be careful with such techniques, as they can easily be wrong and drive a system to make worse decisions than they would have with no knowledge at all.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part79.htm">8.1 MLFQ: Basic Rules</a><a class="toc0" href="part80.htm">8.2 Attempt #1: How to Change Priority</a><a class="toc1" href="part81.htm">Example 1: A Single Long-Running Job</a><a class="toc1" href="part82.htm">Example 2: Along Came A Short Job</a><a class="toc2" href="part83.htm">Figure 8.4: A Mixed I/O-intensive and CPU-intensive Workload</a><a class="toc1" href="part84.htm">Example 3: What About I/O?</a><a class="toc1" href="part85.htm">Problems With Our Current MLFQ</a><a class="toc0" href="part86.htm">8.3 Attempt #2: The Priority Boost</a><a class="toc1" href="part87.htm">Figure 8.6: Without (Left) and With (Right) Gaming Tolerance</a><a class="toc0" href="part88.htm">8.4 Attempt #3: Better Accounting</a><a class="toc0" href="part89.htm">8.5 Tuning MLFQ And Other Issues</a><a class="toc0" href="part90.htm">8.6 MLFQ: Summary</a><a class="toc0" href="part91.htm">References</a><a class="toc0" href="part92.htm">Homework</a><a class="toc1" href="part93.htm">Questions</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part77.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part79.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
