<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>26.3  Achieving Blockchain Properties via Cryptographic Hash Functions</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part463.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part465.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 8pt;padding-left: 119pt;text-indent: -47pt;text-align: left;">26.3  <span style=" color: #00AEEF;">Achieving Blockchain Properties via Cryptographic Hash Functions</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">In this section, we focus on the use of cryptographic hash functions to ensure some of the properties of blockchains. We begin with a discussion of special types of hash function for which it is infeasible to compute the inverse function or ﬁnd hash colli- sions. We show how these concepts extend to public-key encryption, which we ﬁrst saw in Section 9.9. We then show how cryptographic hash functions can be used to ensure the anonymity, irrefutability, and tamper-resistance properties. We show how hash functions are used in mining algorithms later in Section 26.4.1.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">26.3.1 Properties of Cryptographic Hash Functions</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">In Section 14.5, hash functions were used as a means of accessing data. Here, we use hash functions for a very diﬀerent set of purposes, and as a result, we shall need hash functions with additional properties beyond those discussed earlier.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">A hash function <i>h </i>takes input from some (large) domain of values and generates as its output a ﬁxed-length bit string. Typically, the cardinality of the domain is much larger than the cardinality of the range. Furthermore, the hash function must have a <i>uniform distribution</i>, that is, each range value must be equally probable given random input. A hash function <i>h </i>is <span class="s63">collision resistant </span>if it is infeasible to ﬁnd two distinct values <i>x </i>and <i>y </i>such that <i>h</i>(<i>x</i>) <span class="s15">= </span><i>h</i>(<i>y</i>). By <span class="s63">infeasible</span>, we mean that there is strong mathematical</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_3466.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">2<span class="s78">These properties pertain to blockchains, but not to most cryptocurrency exchanges. Most exchanges hold not only customers’ data but also their keys, which means that a hack against the exchange’s database can result in theft of users’ private keys.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">evidence, if not an actual proof, that there is no way to ﬁnd two distinct values <i>x </i>and <i>y</i></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">such that <i>h</i>(<i>x</i>) <span class="s15">= </span><i>h</i>(<i>y</i>) that is any better than random guessing.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The current standard choice of a cryptographic hash function is called <span class="s44">SHA</span>-256, a function that generates output 256 bits in length. This means that given a value <i>x</i>, the chance that a randomly chosen <i>y </i>will hash to the same value to which <i>x </i>hashes is 1<span class="s15">∕</span>2<span class="s76">256</span>. This means that even using the fastest computers, the probability of a successful guess is eﬀectively zero.<span class="s76">3</span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The collision-resistance property contributes to the tamper resistance of a blockchain in a very important way. Suppose an adversary wishes to modify a block</p><p class="s13" style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">B<span class="p">. Since the next-newer block after </span>B <span class="p">contains not only a pointer to </span>B <span class="p">but also the hash of </span>B<span class="p">, any modiﬁcation to </span>B <span class="p">must be such that the hash of </span>B <span class="p">remains unchanged after the modiﬁcation in order to avoid having to modify also that next-newer block. Finding such a modiﬁcation is infeasible if the hash function has the collision-resistance prop- erty, and, therefore, any attempt to tamper with a block requires changing all newer blocks in the chain.</span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A second important property that we require of a cryptographic hash function is <span class="s63">irreversibility</span>, which means that given only <i>h</i>(<i>x</i>), it is infeasible to ﬁnd <i>x</i>. The term <i>irreversible </i>comes from the property that, given <i>x</i>, it is easy to compute <i>h</i>(<i>x</i>), but given only <i>h</i>(<i>x</i>), it is infeasible to ﬁnd <i>h</i><span class="s181">−</span><span class="s76">1</span>(<i>h</i>(<i>x</i>)). The next section shows how this concept is applied to blockchains.<span class="s76">4</span></p><p class="s68" style="padding-top: 10pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">26.3.2 Public-Key Encryption, Digital Signatures, and Irrefutability</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Section 9.9 described two categories of encryption methods: <i>private-key </i>encryption, where users share a secret key, and <i>public-key </i>encryption, where each user has two keys, a public key and a private key. The main problem with private-key encryption is that users must ﬁnd a way at the outset to share the secret private key. Public-key encryption allows users who have never met to communicate securely. This property of public-key encryption is essential to blockchain applications that serve arbitrarily large communities of users worldwide.</p><p class="s13" style="padding-top: 1pt;padding-left: 88pt;text-indent: 17pt;line-height: 92%;text-align: justify;"><span class="p">Each user </span>U<span class="s145">i </span><span class="p">has a public key </span>E<span class="s145">i </span><span class="p">and a private key </span>D<span class="s145">i</span><span class="p">. A message encrypted using </span>E<span class="s145">i </span><span class="p">can be decrypted only with the key </span>D<span class="s145">i</span><span class="p">, and, symmetrically, a message encrypted using </span>D<span class="s145">i </span><span class="p">can be decrypted only with the key </span>E<span class="s145">i</span><span class="p">, If user </span>u<span class="s98">1</span><span class="p"> wishes to send a secure message </span>x <span class="p">to </span>U<span class="s130">2</span><span class="s94">, </span>U<span class="s130">1 </span><span class="s94">encrypts </span>x <span class="p">using the public key </span>E<span class="s130">2 </span><span class="s94">of user </span>U<span class="s130">2</span><span class="s94">. Only </span>U<span class="s130">2 </span><span class="s94">has the key </span>D<span class="s130">2 </span><span class="s94">to decrypt the result. For this to work, the speciﬁc function used must have the irreversibility property so that given a public key </span>E<span class="s97">i </span><span class="p">it is infeasible to compute the inverse function,</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="96" height="1" alt="image" src="Image_3467.png"/></span></p><p class="s78" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="s77">3</span>2<span class="s544">256</span> is larger than 10<span class="s544">77</span>. If a computer could make one guess per cycle it would take more than 10<span class="s544">67</span> seconds to have a 50 percent chance of guessing correctly. That translates to more than 10<span class="s544">59</span> years. To put that in context, astronomers predict that the sun will have grown in size to envelop Earth within 10<span class="s544">10</span> years.</p><p class="s77" style="padding-left: 88pt;text-indent: 0pt;line-height: 9pt;text-align: justify;">4<span class="s78">This property has long been used for storing passwords. Rather than storing user passwords in clear text, leaving them</span></p><p class="s80" style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">susceptible to being stolen, hashes are kept instead. Then, when a user logs in and enters a password, the hash of that password is computed and compared to the stored value. Were an attacker to steal the hashes, that attacker would still lack the actual passwords, and, if the hash function in use has the irreversibility property, then it is infeasible for the hacker to reverse-engineer the user passwords.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 119pt;text-indent: 0pt;line-height: 90%;text-align: justify;">that is, to ﬁnd <i>D</i><span class="s145">i</span>. This creates a mechanism for users who have never met to share secret messages.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Suppose now that instead of seeking to send a secret message, user <i>U</i><span class="s98">1</span> wishes to “sign” a document <i>x</i>. User <i>U</i><span class="s98">1</span> can encrypt <i>x </i>using the private key <i>D</i><span class="s98">1</span>. Since this key is private, no one besides <i>U</i><span class="s98">1</span> could have computed that value, but anyone can verify the signature by decrypting using the public key of <i>U</i><span class="s98">1</span>, that is, <i>E</i><span class="s98">1</span>. This provides a public proof that user <i>U</i><span class="s98">1</span> has signed document <i>x</i>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In blockchain applications, the concept of a digital signature is used to validate transactions. Observe that the linkage of blocks in the blockchain, using a pointer and the hash of block to which the pointer points, means that a user can sign an entire chain simply by signing the hash of the newest block in the chain. See the Further Reading section at the end of the chapter for references to the mathematics of public- key encryption.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">26.3.3 Simple Blockchain Transactions</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">In our discussion of database transactions in Chapter 17, we described a transaction as a sequence of steps that read and/or write data values from the database. That concept of a transaction is based on a data model where there is a single store of data values that are accessed by transactions. A blockchain, in its simplest form, is more closely an analog of a database log in that it records the actual transactions and not just ﬁnal data values. That analogy breaks down, however, in most blockchains, because transactions are either fully independent or depend explicitly on each other. The model we describe here corresponds to simple Bitcoin transactions.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">As an example, consider two users, <i>A </i>and <i>B</i>, and assume <i>A </i>wishes to pay <i>B </i>10 units of some currency. If this were a traditional banking application with a ﬁat currency such as the U.S. dollar, the transaction implementing this transfer would read <i>A</i>’s account balance, decrement it by 10, and write that value to the database, and then read <i>B</i>’s balance, add 10, and write that value to the database. In a blockchain-based system, this transaction is speciﬁed in a diﬀerent manner.</p><p style="padding-left: 119pt;text-indent: 17pt;line-height: 13pt;text-align: justify;">Rather than referencing data items, a Bitcoin-style blockchain transaction refer- ences users and other transactions. Users are referenced by their user <span class="s44">ID</span>. User <i>A </i>would locate a transaction or set of transactions from past history <i>T</i><span class="s98">1</span>, <i>T</i><span class="s98">2</span>, <span class="s15">… </span>, <i>T</i><span class="s97">n </span>that paid <i>A </i>a total of at least 10 units of the currency. <i>A </i>would then create a transaction <i>T </i>that takes the output (i.e., the amount paid to <i>A</i>) by those transactions as input, and as its output pays 10 units of the currency to <i>B </i>and the remainder back to <i>A </i>as the “change.” The original transactions <i>T</i><span class="s98">1</span>, <i>T</i><span class="s98">2</span>, <span class="s15">… </span>, <i>T</i><span class="s145">n </span>are then treated as having been spent.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Thus, each transaction indicates how much money has been paid to whom; the currency balance of a user <i>A </i>is deﬁned by a set of unspent transactions that have paid money to <i>A</i>. Assuming <i>A </i>is honest, those transactions’ outputs (i.e., the output of <i>T</i><span class="s98">1</span>, <i>T</i><span class="s98">2</span>, <span class="s15">… </span>, <i>T</i><span class="s97">n</span>) would not have been spent already by <i>A </i>in a previous transaction. If</p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">A <span class="p">were indeed dishonest and </span>T <span class="p">attempted to spend the output of some </span>T<span class="s98">1</span><span class="p"> a second</span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">time, <i>T </i>would be a <span class="s63">double-spend </span>transaction. Double-spend transactions and other in-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 88pt;text-indent: 0pt;line-height: 91%;text-align: justify;">valid transactions are detected in the mining process that we discuss in Section 26.4, by keeping track of all unspent transactions and verifying that each transaction <i>T</i><span class="s97">i </span>that is input to <i>T </i>is unspent when <i>T </i>is executed. After <i>T </i>is executed, each such <i>T</i><span class="s97">i </span>is treated as spent.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Ethereum uses a diﬀerent and more powerful model, where the blockchain main- tains state (including current balance) for each account in the system. Transactions update the state, and can transfer funds from one account to another. The model used in Ethereum is discussed in Section 26.5.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">A Bitcoin-style transaction <i>T </i>speciﬁes:</p><p class="s13" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s40">The input transactions </span>T<span class="s130">1</span><span class="s94">, </span>T<span class="s130">2</span><span class="s94">, </span><span class="s15">… </span><span class="p">, </span>T<span class="s97">n</span><span class="p">.</span></p><p class="s13" style="padding-top: 1pt;padding-left: 107pt;text-indent: -16pt;text-align: left;"><span class="s39">• </span><span class="s40">The set of users being paid and the amount to be paid to each, which in our example is 10 units to </span>B <span class="p">and the remainder to </span>A<span class="p">.</span><span class="s76">5</span></p><p class="s13" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span>A<span class="p">’s signature of the transaction, to prove that </span>A <span class="p">in fact authorized this transaction.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: left;">• <span class="s40">A more complex transaction might include executable code as part of its speciﬁ- cation, but we shall defer that to Section 26.6.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: left;">• <span class="s40">Data to be stored in the blockchain; the data must be under some size, which is blockchain dependent.</span></p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">The transaction model described here is quite distinct from that of a traditional database system in a variety of ways, including:</p><p class="s39" style="padding-top: 9pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Existing data items are not modiﬁed. Instead, transactions add new information. As a result, not only the current state but also the history leading to the current state are fully visible.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Conﬂicts in transaction ordering are prevented. If conﬂicts occur, the transaction causing a conﬂict is detected and deemed invalid as part of the process of adding a block to the chain, described in Section 26.4.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Although the blockchain is a distributed system, a transaction is created locally. It becomes part of the permanent, shared blockchain only through the mining process. This is, in eﬀect, a form of deferred transaction commit.</span></p><p class="s13" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">Dependencies of one transaction upon another are stated explicitly in a transaction since a transaction lists those transactions whose outputs it uses as input. If we view this in terms of the precedence graph introduced in Chapter 17, our example would include precedence-graph edges </span>T<span class="s130">1 </span><span class="s86">→ </span>T <span class="p">, </span>T<span class="s130">2 </span><span class="s86">→ </span>T <span class="p">, </span><span class="s15">… </span><span class="p">, </span>T<span class="s97">n </span><span class="s86">→ </span>T <span class="p">.</span></p><p class="s39" style="padding-top: 1pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">There is no explicit concurrency control. Much of the need for concurrency control is eliminated by the maintenance of a complete history and the direct sequencing</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="96" height="1" alt="image" src="Image_3468.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">5<span class="s78">In a real system, there may also be a payout to the miner of the transaction, that is, the node that adds the block to the blockchain, as we discuss in Section 26.4.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: 0pt;text-align: left;"><a name="bookmark564">of transactions. Thus, there is no contention for the current value of any database data item.</a><a name="bookmark594">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">This Bitcoin-based example is not the only way blockchain systems manage transaction ordering. We shall see another example when we consider smart contracts in Section 26.6.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The fact that data may be stored in the blockchain makes the blockchain more than just a tamper-resistant transaction log. It allows for the representation of any sort of information that might be stored in a traditional database. In Section 26.5.2, we shall see how this capability, particularly in blockchains with a concept of blockchain state, makes the blockchain a true database.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part463.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part465.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
