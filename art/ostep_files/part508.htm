<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Distributed Systems</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part507.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part509.htm">下一个 &gt;</a></p><p class="s8" style="padding-top: 3pt;padding-left: 201pt;text-indent: 0pt;text-align: left;">Distributed Systems</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Distributed systems have changed the face of the world. When your web browser connects to a web server somewhere else on the planet, it is par- ticipating in what seems to be a simple form of a <b>client/server </b>distributed system. When you contact a modern web service such as Google or face- book, you are not just interacting with a single machine, however; be- hind the scenes, these complex services are built from a large collection (i.e., thousands) of machines, each of which cooperate to provide the par- ticular service of the site. Thus, it should be clear what makes studying distributed systems interesting. Indeed, it is worthy of an entire class; here, we just introduce a few of the major topics.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">A number of new challenges arise when building a distributed system. The major one we focus on is <b>failure</b>; machines, disks, networks, and software all fail from time to time, as we do not (and likely, will never) know how to build “perfect” components and systems. However, when we build a modern web service, we’d like it to appear to clients as if it never fails; how can we accomplish this task?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">HE </span>C<span class="s7">RUX</span>:</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 10pt;text-align: center;">H<span class="s7">OW </span>T<span class="s7">O </span>B<span class="s7">UILD </span>S<span class="s7">YSTEMS </span>T<span class="s7">HAT </span>W<span class="s7">ORK </span>W<span class="s7">HEN </span>C<span class="s7">OMPONENTS </span>F<span class="s7">AIL</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">How can we build a working system out of parts that don’t work correctly all the time? The basic question should remind you of some of the topics we discussed in RAID storage arrays; however, the problems here tend to be more complex, as are the solutions.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Interestingly, while failure is a central challenge in constructing dis- tributed systems, it also represents an opportunity. Yes, machines fail; but the mere fact that a machine fails does not imply the entire system must fail. By collecting together a set of machines, we can build a sys- tem that appears to rarely fail, despite the fact that its components fail regularly. This reality is the central beauty and value of distributed sys- tems, and why they underly virtually every modern web service you use, including Google, Facebook, etc.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">IP</span>: C<span class="s7">OMMUNICATION </span>I<span class="s7">S </span>I<span class="s7">NHERENTLY </span>U<span class="s7">NRELIABLE</span></p><p style="padding-left: 8pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In virtually all circumstances, it is good to view communication as a fundamentally unreliable activity. Bit corruption, down or non-working links and machines, and lack of buffer space for incoming packets all lead to the same result: packets sometimes do not reach their destination. To build reliable services atop such unreliable networks, we must consider techniques that can cope with packet loss.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Other important issues exist as well. System <b>performance </b>is often crit- ical; with a network connecting our distributed system together, system designers must often think carefully about how to accomplish their given tasks, trying to reduce the number of messages sent and further make communication as efficient (low latency, high bandwidth) as possible.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Finally, <b>security </b>is also a necessary consideration. When connecting to a remote site, having some assurance that the remote party is who they say they are becomes a central problem. Further, ensuring that third parties cannot monitor or alter an on-going communication between two others is also a challenge.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: left;">In this introduction, we’ll cover the most basic new aspect that is new in a distributed system: <b>communication</b>. Namely, how should machines within a distributed system communicate with one another? We’ll start with the most basic primitives available, messages, and build a few higher- level primitives on top of them. As we said above, failure will be a central focus: how should communication layers handle failures?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part509.htm">47.1 Communication Basics</a><a class="toc0" href="part510.htm">47.2 Unreliable Communication Layers</a><a class="toc0" href="part511.htm">47.3 Reliable Communication Layers</a><a class="toc0" href="part512.htm">47.4 Communication Abstractions</a><a class="toc0" href="part513.htm">47.5 Remote Procedure Call (RPC)</a><a class="toc1" href="part514.htm">Stub Generator</a><a class="toc1" href="part515.htm">Run-Time Library</a><a class="toc1" href="part516.htm">Other Issues</a><a class="toc0" href="part517.htm">47.6 Summary</a><a class="toc0" href="part518.htm">References</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part507.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part509.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
