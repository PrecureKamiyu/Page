<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:mml="http://www.w3.org/1998/Math/MathML" lang="EN" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="default-style"/><title>The Art of Multiprocessor Programming</title><link href="Elsevier_eBook.css" rel="stylesheet" type="text/css"/><link href="math.css" rel="stylesheet" type="text/css"/><link href="media.css" media="only screen" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4f1c4a5b-a3e2-48ff-98f3-ff17812cd57a" name="Adept.expected.resource"/></head><body><section epub:type="chapter" role="doc-chapter"><div aria-label="Page 451" epub:type="pagebreak" id="page_451" role="doc-pagebreak"/><div id="CN"><a id="c0010tit1"/></div><header><hgroup><h1 class="chaptitle" id="c0010tit">Chapter 19: Optimism and manual memory management</h1></hgroup><section epub:type="preamble"><div class="abstract"><h2 class="h1hd" id="ab0010"><a id="st0010"/>Abstract</h2><p class="abspara">This chapter switches from C++ to Java to explore the challenges of manual memory management in a concurrent system. This is an important issue faced by designers of concurrent low-level systems software. We present two approaches that represent different ends of a spectrum. On one end are hazard pointers. Hazard pointers enable tight bounds on the amount of memory whose reclamation is deferred, but result in a complex programming model and potentially high latency. On the other end is epoch-based reclamation. Epoch-based reclamation is easier to program, and has lower latency, but cannot tightly bound unreclaimed memory. Both techniques can be nonblocking, and thus can be suitable for a wide range of practical applications.</p></div></section><section id="ks0010"><h3 class="h2hd" id="st0015">Keywords</h3><p class="keywords">manual memory management; allocation; hazard pointers; epochs; C++; lock-freedom; bounded memory overhead</p></section></header><p class="textfl" id="p0010">For the remaining chapters of this book, we focus on challenges and opportunities that arise when creating concurrent software using the C++ programming language. C++ has rich support for concurrency, with language-level threads, locks, a memory consistency model, and the <img alt="Image" height="9" src="images/B978012415950100029X/fx001.jpg" width="52"/> template, but it lacks the automatic memory management (i.e., garbage collection) of Java, and its consequent memory safety guarantees. In this chapter, we focus on the challenges that arise for optimistic synchronization when the programmer is responsible for explicitly managing memory.</p><section><h2 class="h1hd" id="s0010"><a id="st0020"/>19.1 Transitioning from Java to C++</h2><p class="textfl" id="p0015">C++ and Java have (not coincidentally) very similar syntax. Both allocate memory with the <img alt="Image" height="6" src="images/B978012415950100029X/fx002.jpg" width="20"/> keyword, both use the <img alt="Image" height="9" src="images/B978012415950100029X/fx003.jpg" width="32"/> keyword to declare types, and many of the primitive types (e.g., <img alt="Image" height="9" src="images/B978012415950100029X/fx004.jpg" width="18"/>, <img alt="Image" height="9" src="images/B978012415950100029X/fx005.jpg" width="32"/>, <img alt="Image" height="9" src="images/B978012415950100029X/fx006.jpg" width="40"/>) are the same.</p><p class="text" id="p0020">One notable difference is with regard to <img alt="Image" height="9" src="images/B978012415950100029X/fx007.jpg" width="53"/> fields. The features provided by the Java <img alt="Image" height="9" src="images/B978012415950100029X/fx007.jpg" width="53"/> keyword and the <span class="sans-serif">java.util.concurrent.atomic</span> package are provided in C++ through the <img alt="Image" height="9" src="images/B978012415950100029X/fx008.jpg" width="86"/> template (defined in the <img alt="Image" height="9" src="images/B978012415950100029X/fx009.jpg" width="52"/> header). The <img alt="Image" height="9" src="images/B978012415950100029X/fx010.jpg" width="93"/> template defines <i>atomic objects</i> of type <img alt="Image" height="9" src="images/B978012415950100029X/fx011.jpg" width="5"/>, so we can easily define objects equivalent to <img alt="Image" height="10" src="images/B978012415950100029X/fx012.jpg" width="78"/> and <img alt="Image" height="9" src="images/B978012415950100029X/fx013.jpg" width="100"/>, for example. It is also easy to define an array of atomic registers. Because C++ programmers can cast between pointers and integers, we can also use <img alt="Image" height="9" src="images/B978012415950100029X/fx008.jpg" width="86"/> to achieve the behaviors of an <img alt="Image" height="8" src="images/B978012415950100029X/fx014.jpg" width="138"/>. <a href="#enun0010" id="cf0010">Pragma 19.1.1</a> gives several examples.</p><p class="text" id="p0025"><span aria-label="Page 452" epub:type="pagebreak" id="page_452" role="doc-pagebreak"/></p><div class="boxg1" id="enun0010"><p class="b1num">Pragma 19.1.1 </p><div><p class="b1textfl" id="p0030">In C++, atomic variables should be declared using the <img alt="Image" height="9" src="images/B978012415950100029X/fx008.jpg" width="86"/> template.</p><div class="pageavoid"><figure class="fig" id="f0010"><img alt="Image" class="img" height="472" src="images/B978012415950100029X/fx015.jpg" width="397"/></figure></div><p class="textfl"> The <img alt="Image" height="13" src="images/B978012415950100029X/fx016.jpg" width="59"/> type is an unsigned integer that is guaranteed to be the same number of bits as a pointer: It is helpful when casting between pointers and integers from code that can be run in 32-bit and 64-bit environments. Casting between pointers and integers is, in general, unsafe; we use it only when an algorithm needs a mark bit that is modified atomically with a pointer.</p></div></div><p class="textfl"/><p class="text" id="p0035">The <img alt="Image" height="12" src="images/B978012415950100029X/fx017.jpg" width="37"/> and <img alt="Image" height="12" src="images/B978012415950100029X/fx018.jpg" width="44"/> methods of atomic objects take an optional parameter, which can be used to relax the memory ordering guarantees when the object is accessed. In this chapter, we never provide such a parameter, and so always get the default, which provides the strongest guarantees (i.e., linearizability).</p></section><section><h2 class="h1hd" id="s0015"><a id="st0025"/>19.2 Optimism and explicit reclamation</h2><p class="textfl" id="p0040">The optimistic techniques we describe in much of this book make the following assumption: If the linearization of an operation <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si1.png" style="vertical-align:middle" width="17"/></span> causes some other pending operation <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="15" src="images/B978012415950100029X/si2.png" style="vertical-align:middle" width="21"/></span> to restart, no harm will come if it takes some time for <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="15" src="images/B978012415950100029X/si2.png" style="vertical-align:middle" width="21"/></span> to realize that it has become invalid and must retry from the beginning. In languages like Java and C#, which have automatic memory reclamation (garbage collection), this assumption is reasonable. However, in C++, doomed-to-retry operations might not be harmless.</p><p class="text" id="p0045">The essence of the problem is that in C++, merely holding a pointer to an object does not ensure that the use of that object will be safe: If another thread reclaims the memory corresponding to that object (using <img alt="Image" height="9" src="images/B978012415950100029X/fx019.jpg" width="40"/> or <img alt="Image" height="9" src="images/B978012415950100029X/fx020.jpg" width="25"/>), then all bets are off. Consider the interleaving in <a href="#f0015" id="cf0015">Fig. 19.1</a>, where thread <span aria-label="Page 453" epub:type="pagebreak" id="page_453" role="doc-pagebreak"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si3.png" style="vertical-align:middle" width="16"/></span> reads the next pointer of the node holding the value 7. <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si4.png" style="vertical-align:middle" width="17"/></span> deletes the node holding the value 8, and then at some point in the future <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si3.png" style="vertical-align:middle" width="16"/></span> attempts to dereference the pointer. The memory of the deleted object could be used by the program in some way that <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si3.png" style="vertical-align:middle" width="16"/></span> does not expect, or the memory of the deleted object could be returned to the operating system. Many hard-to-trace bugs could result. A few of the most common are listed below.</p><div class="pageavoid"><figure class="fig" id="f0015"><img alt="Image" height="212" src="images/B978012415950100029X/gr001.jpg" width="497"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 19.1</span> Concurrent access to a lazy list by two threads.</div></figcaption></figure></div><p class="text" id="p0050">First, thread <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si4.png" style="vertical-align:middle" width="17"/></span> might call <img alt="Image" height="6" src="images/B978012415950100029X/fx002.jpg" width="20"/> to create a different object of the same type, and the call to <img alt="Image" height="6" src="images/B978012415950100029X/fx002.jpg" width="20"/> may have returned the same memory region that formerly stored 8. <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si4.png" style="vertical-align:middle" width="17"/></span> might still be initializing (constructing) the object, in which case accesses to the node by <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si3.png" style="vertical-align:middle" width="16"/></span> will produce undefined behavior.</p><p class="text" id="p0055">Second, suppose that thread <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si4.png" style="vertical-align:middle" width="17"/></span> calls <img alt="Image" height="6" src="images/B978012415950100029X/fx002.jpg" width="20"/> to constructs a new node with the value 25, and inserts it into the list. If <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si3.png" style="vertical-align:middle" width="16"/></span> was searching for 9, it might conclude that the node holding 7 points to the node holding 25, and thus that 9 is not in the list.</p><p class="text" id="p0060">Third, some other thread <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si5.png" style="vertical-align:middle" width="16"/></span> might call <img alt="Image" height="6" src="images/B978012415950100029X/fx002.jpg" width="20"/> to create a completely different type of object. If <img alt="Image" height="6" src="images/B978012415950100029X/fx002.jpg" width="20"/> returns the region that formerly stored 8, then accesses to that object by <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si5.png" style="vertical-align:middle" width="16"/></span> will race with invalid attempts to use that same memory as a list node by <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si3.png" style="vertical-align:middle" width="16"/></span>. These races violate type safety and are completely dependent on low-level decisions by the allocator about when to give the deleted memory to a different thread.</p><p class="text" id="p0065">Fourth, the allocator may decide to return the memory region to the operating system. In this case, any subsequent access by <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si3.png" style="vertical-align:middle" width="16"/></span> will cause a segmentation fault.</p><p class="text" id="p0070">Note that in all cases, <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si3.png" style="vertical-align:middle" width="16"/></span> may exhibit incorrect or dangerous behaviors. Using optimistic algorithms in programming languages with manual memory reclamation, like C++, requires us to pay close attention to the pending operations in a program's history, and establish sufficient conditions for avoiding the bad behaviors described above. In this chapter, we derive a sufficient condition for using optimistic algorithms in C and C++, and then we explore two implementations.<span aria-label="Page 454" epub:type="pagebreak" id="page_454" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0020"><a id="st0030"/>19.3 Protecting pending operations</h2><p class="textfl" id="p0075">When a region of memory is reclaimed, the programmer cannot know how that region of memory will be reused, or even whether it is reused. The first step in developing a general solution to prevent the sorts of races described in the previous section is to recognize that such races first become possible when the region is reclaimed (via <img alt="Image" height="9" src="images/B978012415950100029X/fx020.jpg" width="25"/> or <img alt="Image" height="9" src="images/B978012415950100029X/fx019.jpg" width="40"/>). We define the act of reclaiming a region of memory as racing with any concurrent access to the region. We can prevent these races by delaying reclamation. If we think in terms of pending operations on a concurrent data structure, a sufficient condition is that <i>memory is only reclaimed when it is impossible for any pending operation to access it in the future</i>.</p><p class="text" id="p0080">In a language with automatic memory management, this property can be ensured by a <i>garbage collector</i>, which tracks every reference to every object allocated in the program. These references could be on the heap, in a thread's stack, or in a thread's registers. An object can be reclaimed when no references to it remain, since it can never be accessed again.</p><p class="text" id="p0085">The property is also achieved by <i>reference counting</i>. In a reference-counted implementation of the list, a counter of type <img alt="Image" height="9" src="images/B978012415950100029X/fx021.jpg" width="72"/> is associated with each node. Whenever a reference to node <i>N</i> is created (either in a local variable or by pointing some other node's <img alt="Image" height="8" src="images/B978012415950100029X/fx022.jpg" width="25"/> pointer to <i>N</i>), the count must first be incremented. Whenever a reference to <i>N</i> is destroyed (for example, by overwriting a local variable), the count is subsequently decremented. When the count reaches zero, there are no outstanding references to the node, and it can be reclaimed.</p><p class="text" id="p0090">C++ supports reference counting via the <img alt="Image" height="13" src="images/B978012415950100029X/fx023.jpg" width="160"/> template. To use it, threads never create local variables of type <img alt="Image" height="9" src="images/B978012415950100029X/fx024.jpg" width="38"/>; instead, they use local variables of type <img alt="Image" height="13" src="images/B978012415950100029X/fx025.jpg" width="200"/>. Similarly, the type of the <img alt="Image" height="9" src="images/B978012415950100029X/fx026.jpg" width="25"/>'s <img alt="Image" height="8" src="images/B978012415950100029X/fx022.jpg" width="25"/> pointer must be <img alt="Image" height="13" src="images/B978012415950100029X/fx025.jpg" width="200"/>.</p><p class="text" id="p0095">Under the hood, <img alt="Image" height="13" src="images/B978012415950100029X/fx027.jpg" width="207"/> introduces two overheads. First, the reference count associated with a <img alt="Image" height="13" src="images/B978012415950100029X/fx025.jpg" width="200"/> must be stored on the heap. With one <img alt="Image" height="13" src="images/B978012415950100029X/fx025.jpg" width="200"/> per list node, reference counting effectively doubles the number of memory locations accessed during a list traversal. Fortunately, this overhead affects only latency, not scalability. However, the second overhead affects scalability. Every reader of a node must first increment the node's reference count; later, it must decrement the reference count, once the node is not needed anymore. In a linked list, every traversal references the same prefix of list nodes. For each node, each thread will write to the counter twice, and as we know, concurrent writes to the same location cause cache contention.</p><p class="text" id="p0100">Before constructing more scalable approaches, it is useful to ask why reference counting works. By incrementing a counter associated with a node <i>before</i> accessing the node, an operation can ensure that other threads know of its intention to use the node. In response, those other threads promise not to reclaim the node if the count is nonzero. And in exchange for this guarantee of protection, the operation inherits the responsibility to reclaim a node if it discovers (upon decrementing the counter) that it had inhibited reclamation by some other thread.</p><p class="text" id="p0105"><span aria-label="Page 455" epub:type="pagebreak" id="page_455" role="doc-pagebreak"/>Thus we can say that reference counting serves two roles: It allows operations to <i>protect</i> a node from concurrent deletion, and it allows threads to <i>delegate</i> the reclamation of a node. While delegation means that a node is not reclaimed <i>immediately</i>, from the perspective of the deleting thread, it is reclaimed <i>as soon as possible</i> without violating safety.</p><p class="text" id="p0110">It would be correct to allow operations to protect a node from concurrent deletion, but require the deleting thread to defer reclamation, <i>without delegating to another thread</i>. That is, if a region of memory has outstanding references, the deleting operation will not reclaim it immediately. Instead, it will put it into some set, and then periodically query the set for entries that have no remaining references. When such an entry is found, it can be reclaimed immediately and removed from the set.</p><p class="text" id="p0115">One can think of this strategy as a sort of fine-granularity garbage collection, where the programmer controls which regions of memory are reclaimed immediately, and which are deferred.</p><p class="text" id="p0120">We can vary how we implement the set (for example, by using per-thread sets), the frequency with which threads search for reclaimable memory, and the mechanisms by which operations protect nodes. In doing so, we can trade tight bounds on the amount of unreclaimed memory for low run-time overhead and minimal communication between threads.</p></section><section><h2 class="h1hd" id="s0025"><a id="st0035"/>19.4 An object for managing memory</h2><p class="textfl" id="p0125"><a href="#f0020" id="cf0020">Fig. 19.2</a> presents a generic interface for protecting memory during an optimistic operation. There are many different ways to implement the object; we discuss two in this chapter. What matters for now is to understand the specification of the object.</p><div class="pageavoid"><figure class="fig" id="f0020"><img alt="Image" height="208" src="images/B978012415950100029X/gr002.jpg" width="490"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 19.2</span> An interface for protecting memory during an optimistic operation.</div></figcaption></figure></div><p class="text" id="p0130"><span aria-label="Page 456" epub:type="pagebreak" id="page_456" role="doc-pagebreak"/>To have a single interface that is suitable for a variety of memory reclamation algorithms, our object has seven methods. The most important part of the interface are the last three functions. They let a thread try to protect some memory from reclamation, stop requesting protection for memory, and schedule memory for reclamation as soon as it has no outstanding protection requests from concurrent threads.</p></section><section><h2 class="h1hd" id="s0030"><a id="st0040"/>19.5 Traversing a list</h2><p class="textfl" id="p0135">Suppose that we wanted to use the <img alt="Image" height="10" src="images/B978012415950100029X/fx028.jpg" width="60"/> object to protect an optimistic traversal of a nonblocking list-based integer set (Section <a href="B9780124159501000197.xhtml">9.8</a>). First, of course, we must translate the code to C++. To do this, we make use of <img alt="Image" height="9" src="images/B978012415950100029X/fx008.jpg" width="86"/> variables instead of the <img alt="Image" height="9" src="images/B978012415950100029X/fx007.jpg" width="53"/> keyword in Java. Then we can redesign the <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() method of the <img alt="Image" height="9" src="images/B978012415950100029X/fx030.jpg" width="39"/> class from <a href="B9780124159501000197.xhtml">Fig. 9.23</a>, so that it protects memory during optimistic accesses.</p><p class="text" id="p0140"><a href="#f0025" id="cf0025">Fig. 19.3</a> presents the data type for nodes in our C++ nonblocking list, as well as some helper functions for setting and unsetting the low bit of pointers. Setting and unsetting the low bit of pointers is the C++ equivalent of the <img alt="Image" height="8" src="images/B978012415950100029X/fx031.jpg" width="151"/> class in Java. Note that in C++, we can set the low bit of a pointer directly, but we cannot use a pointer whose low bit is 1: we must copy the pointer and explicitly unset the low bit of the copy before using it.</p><div class="pageavoid"><figure class="fig" id="f0025"><img alt="Image" height="322" src="images/B978012415950100029X/gr003.jpg" width="455"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 19.3</span> C++ nonblocking linked list: node data type and helper functions.</div></figcaption></figure></div><p class="text" id="p0145"><span aria-label="Page 457" epub:type="pagebreak" id="page_457" role="doc-pagebreak"/>With these definitions, a list is defined as a pointer to the head node. We refer to this pointer as <img alt="Image" height="9" src="images/B978012415950100029X/fx032.jpg" width="25"/>. As in other high-performance optimistic lists, we avoid a corner case by making the first node in the list a “sentinel” node, whose value is never read. In that way, <img alt="Image" height="9" src="images/B978012415950100029X/fx032.jpg" width="25"/> is never null.</p><p class="text" id="p0150"><a href="#f0030" id="cf0030">Fig. 19.4</a> reintroduces the <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() function from the nonblocking list-based set from Section <a href="B9780124159501000197.xhtml">9.8</a>, rewritten in C++. The main difference in our C++ version is that it must explicitly manage memory. We use an explicit <img alt="Image" height="10" src="images/B978012415950100029X/fx028.jpg" width="60"/> object for <span aria-label="Page 458" epub:type="pagebreak" id="page_458" role="doc-pagebreak"/>this purpose. Note that <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() is an internal function. A public function that calls <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() must do so between calls to <img alt="Image" height="10" src="images/B978012415950100029X/fx028.jpg" width="60"/>'s <img alt="Image" height="14" src="images/B978012415950100029X/fx033.jpg" width="59"/>() and <img alt="Image" height="14" src="images/B978012415950100029X/fx034.jpg" width="46"/>() methods. Also, <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() protects up to two locations at a time, so it must be preceded by a call to <img alt="Image" height="14" src="images/B978012415950100029X/fx035.jpg" width="106"/>(<i>i</i>), with the value of <i>i</i> no less than 2.</p><div class="pageavoid"><figure class="fig" id="f0030"><img alt="Image" height="563" src="images/B978012415950100029X/gr004.jpg" width="456"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 19.4</span> Traversing a nonblocking linked list with safe reclamation.</div></figcaption></figure></div><p class="text" id="p0155">Starting with the sentinel node, our traversal follows the same pattern as the nonblocking Java list: We keep track of a window of three consecutive nodes, <img alt="Image" height="9" src="images/B978012415950100029X/fx036.jpg" width="25"/>, <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/>, and <img alt="Image" height="8" src="images/B978012415950100029X/fx022.jpg" width="25"/>. At all points, the memory representing <img alt="Image" height="9" src="images/B978012415950100029X/fx036.jpg" width="25"/> is safe to access, because it has already been reserved (or it is the sentinel). Also, <img alt="Image" height="9" src="images/B978012415950100029X/fx036.jpg" width="25"/> always references a node whose key is less than the search key. Note, too, that <img alt="Image" height="9" src="images/B978012415950100029X/fx036.jpg" width="25"/> and <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/> are guaranteed to be unmarked.</p><p class="text" id="p0160">Before using the successor of <img alt="Image" height="9" src="images/B978012415950100029X/fx036.jpg" width="25"/>, we must protect it via a call to <img alt="Image" height="14" src="images/B978012415950100029X/fx038.jpg" width="79"/>() (line 26). If this returns <img alt="Image" height="8" src="images/B978012415950100029X/fx039.jpg" width="26"/>, then <img alt="Image" height="10" src="images/B978012415950100029X/fx028.jpg" width="60"/> cannot guarantee that <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/> was not reclaimed between the time when it was read (line 24 or line 32) and the time when <img alt="Image" height="14" src="images/B978012415950100029X/fx038.jpg" width="79"/>() was called. In this case, the code double-checks that <i>after</i> the call to <img alt="Image" height="14" src="images/B978012415950100029X/fx038.jpg" width="79"/>(), <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/> still succeeds <img alt="Image" height="9" src="images/B978012415950100029X/fx036.jpg" width="25"/>. If not, the <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() operation retries.</p><p class="text" id="p0165">Line 32 finds the successor of the current node, as <img alt="Image" height="8" src="images/B978012415950100029X/fx022.jpg" width="25"/>. If the pointer to <img alt="Image" height="8" src="images/B978012415950100029X/fx022.jpg" width="25"/> is not marked, then at line 45, we ensure that <img alt="Image" height="9" src="images/B978012415950100029X/fx036.jpg" width="25"/> remains linked to <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/>. If so, we check the key stored at <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/>, and use its value to determine whether to continue traversing or to return. If the <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() operation should continue, it will no longer use the <img alt="Image" height="9" src="images/B978012415950100029X/fx036.jpg" width="25"/> pointer, so it unreserves it.</p><p class="text" id="p0170">If <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() discovers a marked node at <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/>, it uses <img alt="Image" height="14" src="images/B978012415950100029X/fx040.jpg" width="165"/> to unlink <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/>, and then hands <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/> to <img alt="Image" height="10" src="images/B978012415950100029X/fx028.jpg" width="60"/> for reclamation. When <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() returns true, <img alt="Image" height="9" src="images/B978012415950100029X/fx036.jpg" width="25"/> and <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/> are reserved and protected from reclamation.</p><p class="text" id="p0175">With the <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() function, the public operations on our nonblocking C++ linked list are straightforward. They appear in <a href="#f0035" id="cf0035">Fig. 19.5</a>.</p><div class="pageavoid"><figure class="fig" id="f0035"><img alt="Image" height="667" src="images/B978012415950100029X/gr005.jpg" width="366"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 19.5</span> Public methods of the C++ nonblocking list-based set.</div></figcaption></figure></div></section><section><h2 class="h1hd" id="s0035"><a id="st0045"/>19.6 Hazard pointers</h2><p class="textfl" id="p0180">Our first solution for protecting the in-use nodes of the nonblocking list uses a variant of a technique known as <i>hazard pointers</i>. The approach has two main components. The first is a mechanism through which threads can share the locations they have reserved, so that other threads may see those reservations any time they attempt to reclaim memory. The second is a per-thread mechanism for deferring the reclamation of memory.</p><p class="text" id="p0185"><a href="#f0040" id="cf0040">Fig. 19.6</a> presents the two main data types of this implementation. Every thread has its own <img alt="Image" height="9" src="images/B978012415950100029X/fx041.jpg" width="86"/> object, which it can access directly via <img alt="Image" height="11" src="images/B978012415950100029X/fx042.jpg" width="106"/>. The entire set of these objects is organized as a linked list, represented by <img alt="Image" height="11" src="images/B978012415950100029X/fx043.jpg" width="106"/>. Within a thread's context, there is a private set of locations that the thread has scheduled for reclamation, and a shared array of locations that the thread does not want other threads to reclaim. For convenience, our code does not allow threads to remove their contexts from the shared set. That is, <img alt="Image" height="14" src="images/B978012415950100029X/fx044.jpg" width="119"/>() does not remove a thread's context from the set rooted at <img alt="Image" height="11" src="images/B978012415950100029X/fx043.jpg" width="106"/>. <span aria-label="Page 459" epub:type="pagebreak" id="page_459" role="doc-pagebreak"/><span aria-label="Page 460" epub:type="pagebreak" id="page_460" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0040"><img alt="Image" height="388" src="images/B978012415950100029X/gr006.jpg" width="337"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 19.6</span> Data types to support hazard pointers with blocking reclamation.</div></figcaption></figure></div><p class="text" id="p0190"><a href="#f0045" id="cf0045">Fig. 19.7</a> presents the rest of our implementation of hazard pointers. Since our implementation is blocking, and since we never unlink thread contexts, both <img alt="Image" height="14" src="images/B978012415950100029X/fx035.jpg" width="106"/>() and <img alt="Image" height="14" src="images/B978012415950100029X/fx044.jpg" width="119"/>() are trivial: The former creates a thread context and inserts it at the head of <img alt="Image" height="10" src="images/B978012415950100029X/fx028.jpg" width="60"/>'s list; the latter is a no-op. Similarly, <img alt="Image" height="14" src="images/B978012415950100029X/fx033.jpg" width="59"/>() is a no-op: Its postcondition is that the calling thread has no reservations and no pending reclamations. Both of these properties are provided by <img alt="Image" height="14" src="images/B978012415950100029X/fx034.jpg" width="46"/>().</p><div class="pageavoid"><figure class="fig" id="f0045"><img alt="Image" height="592" src="images/B978012415950100029X/gr007.jpg" width="494"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 19.7</span> <img alt="Image" height="10" src="images/B978012415950100029X/fx028.jpg" width="60"/> methods to support hazard pointers with blocking reclamation.</div></figcaption></figure></div><p class="text" id="p0195">During execution, a thread reserves a pointer <img alt="Image" height="11" src="images/B978012415950100029X/fx045.jpg" width="19"/> by finding an empty slot in its <img alt="Image" height="9" src="images/B978012415950100029X/fx046.jpg" width="78"/> array and writing <img alt="Image" height="11" src="images/B978012415950100029X/fx045.jpg" width="19"/> into it. The array positions are all <img alt="Image" height="9" src="images/B978012415950100029X/fx008.jpg" width="86"/>, so that we can be sure that any such write will be strongly ordered: all previously issued reads and writes will complete before it, and all subsequent reads and writes will not happen until after it.</p><p class="text" id="p0200">Note that in our hazard pointer implementation, <img alt="Image" height="14" src="images/B978012415950100029X/fx038.jpg" width="79"/>() always returns <i>true</i>. This is necessary to prevent races. Consider the moment when thread <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si6.png" style="vertical-align:middle" width="16"/></span> executes line 24 of the <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() method. When the line completes, <img alt="Image" height="9" src="images/B978012415950100029X/fx036.jpg" width="25"/> points to <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/>, but <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si6.png" style="vertical-align:middle" width="16"/></span> has not yet reserved <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/>. At that point, another thread <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si7.png" style="vertical-align:middle" width="17"/></span> could mark and unlink <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/>. If <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si7.png" style="vertical-align:middle" width="17"/></span> scanned <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si6.png" style="vertical-align:middle" width="16"/></span>'s <img alt="Image" height="9" src="images/B978012415950100029X/fx046.jpg" width="78"/> array, it would not find <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/>, and thus it could reclaim <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/> immediately. A subsequent access to <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/> by <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si6.png" style="vertical-align:middle" width="16"/></span> would cause a race. <span aria-label="Page 461" epub:type="pagebreak" id="page_461" role="doc-pagebreak"/>By returning <i>true</i>, <img alt="Image" height="14" src="images/B978012415950100029X/fx038.jpg" width="79"/>() notifies the <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() function that accesses to <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/> are not yet guaranteed to be safe; <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() must double-check that <img alt="Image" height="9" src="images/B978012415950100029X/fx036.jpg" width="25"/> still points to <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/>. Note that <img alt="Image" height="14" src="images/B978012415950100029X/fx038.jpg" width="79"/>() stored <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/> in an <img alt="Image" height="9" src="images/B978012415950100029X/fx001.jpg" width="52"/> field, which guarantees that the double-check follows the write of <img alt="Image" height="6" src="images/B978012415950100029X/fx037.jpg" width="25"/> to <img alt="Image" height="9" src="images/B978012415950100029X/fx046.jpg" width="78"/>.</p><p class="text" id="p0205">In our nonblocking list implementation, as in many other algorithms, a location is not reclaimed by the thread that <i>marks</i> a node, but the <span aria-label="Page 462" epub:type="pagebreak" id="page_462" role="doc-pagebreak"/>thread that unlinks it. This is one of many situations in which more than one thread may have a reservation for a memory region that is logically deleted from the data structure. In general, the number of reservations for an unlinked node should rapidly drop to zero, but is most likely to be nonzero immediately after being unlinked. Thus it would be unwise for the unlinking thread to attempt to reclaim memory immediately. Instead, <img alt="Image" height="14" src="images/B978012415950100029X/fx047.jpg" width="145"/> places <img alt="Image" height="11" src="images/B978012415950100029X/fx045.jpg" width="19"/> into a thread-private vector, and delays reclamation until <img alt="Image" height="14" src="images/B978012415950100029X/fx034.jpg" width="46"/>().</p><p class="text" id="p0210">The postconditions of our implementation of <img alt="Image" height="14" src="images/B978012415950100029X/fx034.jpg" width="46"/>() are the same as the preconditions of <img alt="Image" height="14" src="images/B978012415950100029X/fx033.jpg" width="59"/>(): The thread has no reservations and no outstanding reclamations. Achieving the former is simple, and is achieved by the loop on line 47. To ensure that there are no outstanding reclamations, the caller of <img alt="Image" height="14" src="images/B978012415950100029X/fx034.jpg" width="46"/>() iterates through the elements in its <img alt="Image" height="13" src="images/B978012415950100029X/fx048.jpg" width="105"/> set. For each entry, the caller iterates through the <img alt="Image" height="10" src="images/B978012415950100029X/fx028.jpg" width="60"/>'s set of thread contexts, and for each context, the caller checks if the context includes a reservation for the entry. If it does, the caller spin-waits until the reservation changes. Since the entry has already been unlinked, it would seem that the caller of <img alt="Image" height="14" src="images/B978012415950100029X/fx033.jpg" width="59"/>() can be sure that no subsequent reservation will appear, and hence the location is safe to reclaim. However, there is one troublesome ordering. Suppose that some thread <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si8.png" style="vertical-align:middle" width="14"/></span> is <i>about to</i> reserve location <i>l</i>, and some thread <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si6.png" style="vertical-align:middle" width="16"/></span> has called <img alt="Image" height="14" src="images/B978012415950100029X/fx034.jpg" width="46"/>() and has seen that <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si8.png" style="vertical-align:middle" width="14"/></span> does not have <i>l</i> in <img alt="Image" height="9" src="images/B978012415950100029X/fx046.jpg" width="78"/>. We cannot allow <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si8.png" style="vertical-align:middle" width="14"/></span> to subsequently write <i>l</i> into <img alt="Image" height="9" src="images/B978012415950100029X/fx046.jpg" width="78"/> and use <i>l</i>. Again, this is why <img alt="Image" height="14" src="images/B978012415950100029X/fx038.jpg" width="79"/>() must return <i>true</i>: to ensure that <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B978012415950100029X/si8.png" style="vertical-align:middle" width="14"/></span> will double-check, see that <i>l</i> has been unlinked, and restart.</p><p class="text" id="p0215">It is possible to make a hazard pointer implementation lock-free if we are willing to allow a bounded amount of memory to remain unclaimed for an unbounded amount of time. Suppose that every time a thread reached line 60, it instead skipped reclamation for the current entry in <img alt="Image" height="13" src="images/B978012415950100029X/fx048.jpg" width="105"/>, and moved on to the next. With <i>T</i> threads and <i>num</i> maximum reserved addresses per thread, up to <span class="hiddenClass"><mml:math><mml:mi>T</mml:mi><mml:mo>×</mml:mo><mml:mtext mathvariant="italic">num</mml:mtext></mml:math></span><span><img alt="Image" height="11" src="images/B978012415950100029X/si9.png" style="vertical-align:middle" width="60"/></span> locations could be unreclaimable at any time. For higher performance, this bound is typically multiplied by an order of magnitude.</p></section><section><h2 class="h1hd" id="s0040"><a id="st0050"/>19.7 Epoch-based reclamation</h2><p class="textfl" id="p0220">Our hazard pointer implementation is precise, ensuring that reclamation can happen as soon as possible, so that there is no unnecessary backlog of to-be-reclaimed memory. However, that precision comes at a great cost: During the course of every operation, there will be a linear number of calls to <img alt="Image" height="14" src="images/B978012415950100029X/fx038.jpg" width="79"/>(), each of which performs an expensive <i>strongly ordered</i> write to shared memory. While writes are more expensive than reads, the fact of <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B978012415950100029X/si10.png" style="vertical-align:middle" width="34"/></span> writes should not have too significant of an impact on modern CPUs, because they are to a small, fixed number of locations (the thread's <img alt="Image" height="9" src="images/B978012415950100029X/fx046.jpg" width="78"/> array). However, since each of these writes is to a <img alt="Image" height="9" src="images/B978012415950100029X/fx008.jpg" width="86"/> variable, each entails a memory fence, and every memory fence increases latency significantly.</p><p class="text" id="p0225"><span aria-label="Page 463" epub:type="pagebreak" id="page_463" role="doc-pagebreak"/>When the percentage of <img alt="Image" height="6" src="images/B978012415950100029X/fx049.jpg" width="38"/>() operations is small, the cost of these fences is hard to justify: They protect <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() from unlikely interleavings with the infrequently called <img alt="Image" height="6" src="images/B978012415950100029X/fx049.jpg" width="38"/>() operation. If we relax guarantees on the number of unreclaimed locations, we can eliminate many of these fences. To do so, we introduce the concept of <i>epochs</i>.</p><p class="text" id="p0230">Suppose that every thread had its own shared counter, initialized to zero. Whenever the thread called <img alt="Image" height="14" src="images/B978012415950100029X/fx033.jpg" width="59"/>(), it would increment that counter. Whenever it called <img alt="Image" height="14" src="images/B978012415950100029X/fx034.jpg" width="46"/>(), it would increment that counter again. If we looked at a thread's counter and found an even number, we could immediately conclude that the thread was not between <img alt="Image" height="14" src="images/B978012415950100029X/fx033.jpg" width="59"/>() and <img alt="Image" height="14" src="images/B978012415950100029X/fx034.jpg" width="46"/>(). That, in turn, must mean that the thread could not have any references to the nodes of our linked list.</p><p class="text" id="p0235">Unfortunately, if one thread is repeatedly executing operations on the list, another thread may never see an even number. Instead, it may see a different odd number each time it looks. However, this information is equally useful: It means that the thread has completed one operation and started another. Any memory that was unlinked concurrently with the former operation cannot be accessed during the current operation attempt, and thus as soon as the counter changed from one odd number to another odd number, the unlinked memory would be unreachable, and safe to reclaim.</p><p class="text" id="p0240">Putting these ideas together, we can create a remarkably simple <img alt="Image" height="10" src="images/B978012415950100029X/fx028.jpg" width="60"/> object. This new version will not be able to put any bounds on the number of unreclaimed objects, because a single thread stalling in the middle of its <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() operation will make it impossible for any other thread to reclaim <i>anything</i>. When <img alt="Image" height="6" src="images/B978012415950100029X/fx049.jpg" width="38"/>() calls are exceptionally rare, or when a program (such as an operating system itself) can guarantee that a call to <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() cannot stall indefinitely, the cost of unbounded garbage is more than offset by the performance improvement that comes from the elimination of <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B978012415950100029X/si10.png" style="vertical-align:middle" width="34"/></span> memory fences.</p><p class="text" id="p0245">In <a href="#f0050" id="cf0050">Fig. 19.8</a>, we implement a <img alt="Image" height="10" src="images/B978012415950100029X/fx028.jpg" width="60"/> based on epochs. As with our implementation of hazard pointers, we have chosen to make the implementation blocking, by having each thread immediately reclaim all the memory it unlinked when it reaches <img alt="Image" height="14" src="images/B978012415950100029X/fx034.jpg" width="46"/>().</p><div class="pageavoid"><figure class="fig" id="f0050"><img alt="Image" height="652" src="images/B978012415950100029X/gr008.jpg" width="494"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 19.8</span> Epoch-based reclamation.</div></figcaption></figure></div><p class="text" id="p0250">As with the hazard pointer implementation, we have a global shared list of thread contexts, and each thread keeps a private vector of the locations it has scheduled for reclamation. However, we no longer need to track the individual pointers accessed by the operation: instead, a thread maintains a <img alt="Image" height="9" src="images/B978012415950100029X/fx008.jpg" width="86"/> counter, which it increments to odd in <img alt="Image" height="14" src="images/B978012415950100029X/fx033.jpg" width="59"/>(). The increment has strong memory ordering, which means that <i>before</i> an operation touches any of the shared memory that comprises the nodes of the list, that thread has notified all other threads that they may not reclaim anything.</p><p class="text" id="p0255">In <img alt="Image" height="14" src="images/B978012415950100029X/fx034.jpg" width="46"/>(), a thread increments its counter to even, indicating that it will no longer access any of the shared memory of the list. As with the increment in <img alt="Image" height="14" src="images/B978012415950100029X/fx033.jpg" width="59"/>(), this increment is strongly ordered, so that it is guaranteed to happen <i>after</i> all of the parent operation's loads and stores to shared memory. If a thread has deferred reclamation of any locations, then it must wait until the execution of every concurrent thread <span aria-label="Page 464" epub:type="pagebreak" id="page_464" role="doc-pagebreak"/>has, at least momentarily, been outside of a data structure operation. It does this by checking each thread's counter: If the counter is even or if it changes from one odd number to a larger odd number, then that <span aria-label="Page 465" epub:type="pagebreak" id="page_465" role="doc-pagebreak"/>thread can no longer find a pointer to the locations awaiting reclamation. Once all threads' progress has been verified, the deferred reclamations can be performed.</p><p class="text" id="p0260">Given these implementations of <img alt="Image" height="14" src="images/B978012415950100029X/fx033.jpg" width="59"/>() and <img alt="Image" height="14" src="images/B978012415950100029X/fx034.jpg" width="46"/>(), <img alt="Image" height="14" src="images/B978012415950100029X/fx038.jpg" width="79"/>() can be a single statement: <img alt="Image" height="9" src="images/B978012415950100029X/fx050.jpg" width="80"/>. To understand why this is correct, consider an interleaving between a call to <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() and a call to <img alt="Image" height="6" src="images/B978012415950100029X/fx049.jpg" width="38"/>() that marks location <i>l</i> for deletion. If <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() discovered a node whose next pointer was <i>l</i>, then it must have done so <i>after</i> it made its counter odd. At the time when it read <i>l</i>, the node at <i>l</i> had not yet been unlinked, and therefore the corresponding <img alt="Image" height="6" src="images/B978012415950100029X/fx049.jpg" width="38"/>() operation could not have reached its <img alt="Image" height="14" src="images/B978012415950100029X/fx034.jpg" width="46"/>(). If, at this point, the <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() thread were to delay, and the <img alt="Image" height="6" src="images/B978012415950100029X/fx049.jpg" width="38"/>() thread were to reach <img alt="Image" height="14" src="images/B978012415950100029X/fx033.jpg" width="59"/>(), <i>l</i> would not be reclaimed: The <img alt="Image" height="6" src="images/B978012415950100029X/fx049.jpg" width="38"/>() thread is guaranteed to see the <img alt="Image" height="9" src="images/B978012415950100029X/fx029.jpg" width="25"/>() thread's odd counter value, and wait. Therefore, there is no benefit in double-checking the reachability of <i>l</i>: Its fields can be accessed without any additional checks to ensure that it has not been reclaimed.</p></section><section><h2 class="h1hd" id="s0045"><a id="st0055"/>19.8 Chapter notes</h2><p class="textfl" id="p0265">Variants of the hazard pointer technique were discovered by Michael <a epub:type="noteref" href="#br0635" id="cf0055" role="doc-noteref">[127]</a> and by Herlihy, Luchangoo, &amp; Moir <a epub:type="noteref" href="#br0335" id="cf0060" role="doc-noteref">[67]</a>. Subsequently, Petrank et al. proposed improvements to reduce the fence overhead <a epub:type="noteref" href="#br0110" id="cs0010" role="doc-noteref">[22</a>,<a epub:type="noteref" href="#br0155" role="doc-noteref">31]</a>. Michael also showed how to eliminate the fence overhead, when reclamation is extremely rare, by leveraging interprocess interrupts <a epub:type="noteref" href="#br0220" id="cf0065" role="doc-noteref">[44]</a>.</p><p class="text" id="p0270">Epoch-based techniques were used by Fraser <a epub:type="noteref" href="#br0240" id="cf0070" role="doc-noteref">[48]</a> in the context of nonblocking data structures, and subsequently adapted for use in software transactional memory by Hudson et al. <a epub:type="noteref" href="#br0405" id="cf0075" role="doc-noteref">[81]</a>. They were also proposed by McKenney in the context of operating systems <a epub:type="noteref" href="#br0615" id="cf0080" role="doc-noteref">[123]</a>, where they protected kernel data structures. In that context, movement from user mode to kernel mode would make a processor's counter odd, and returning to user mode would make it even again.</p><p class="text" id="p0275">Research into both of these techniques has given much attention to attempting to provide nonblocking progress without an unbounded worst-case space overhead. To achieve nonblocking guarantees, <img alt="Image" height="14" src="images/B978012415950100029X/fx034.jpg" width="46"/>() pushes the contents of <img alt="Image" height="13" src="images/B978012415950100029X/fx048.jpg" width="105"/> into a per-thread buffer. When the buffer becomes large, hazard pointer implementations use a variant of <img alt="Image" height="13" src="images/B978012415950100029X/fx051.jpg" width="140"/> that skips nodes with outstanding reservations. The number of skipped nodes can be bounded. Nonblocking epoch-based techniques bundle several operations' worth of contents from <img alt="Image" height="13" src="images/B978012415950100029X/fx048.jpg" width="105"/> into a new buffer, to which is added a snapshot of all threads' counters. Each time one of these bundles is collected, the corresponding counter snapshot is compared with past ones. Bundles whose snapshots have been superseded by the new snapshot can be reclaimed. In the worst case, this technique can lead to out-of-memory errors if a single operation delays arbitrarily during an operation. However, Brown showed that interprocess interrupts can be used to prevent this pathological scenario <a epub:type="noteref" href="#br0115" id="cf0085" role="doc-noteref">[23]</a>.<span aria-label="Page 466" epub:type="pagebreak" id="page_466" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0050"><a id="st0060"/>19.9 Exercises</h2><p class="textfl" id="p0280"/><div class="boxg1" id="enun0015"><p class="b1num">Exercise 19.1 </p><div><p class="b1textfl" id="p0285">If the LockFreeStack (Section <a href="B9780124159501000215.xhtml">11.2</a>) used hazard pointers to protect memory, would it still be vulnerable to the ABA problem? Why or why not?</p></div></div><p class="textfl"/><p class="text" id="p0290"/><div class="boxg1" id="enun0020"><p class="b1num">Exercise 19.2 </p><div><p class="b1textfl" id="p0295">Describe how to use hazard pointers to protect the memory in the lock-free unbounded queue from Section <a href="B9780124159501000203.xhtml">10.5</a>.</p></div></div><p class="textfl"/><p class="text" id="p0300"/><div class="boxg1" id="enun0025"><p class="b1num">Exercise 19.3 </p><div><p class="b1textfl" id="p0305">The presentation of hazard pointers in Section <a href="#s0035" id="cf0090">19.6</a> was blocking. The easiest way to make it nonblocking is defer reclamation of reserved objects. Under this strategy, what is the worst-case number of unreclaimed objects for any one thread's <img alt="Image" height="13" src="images/B978012415950100029X/fx048.jpg" width="105"/> vector? What is the worst-case number of unreclaimed objects in a system with <img alt="Image" height="9" src="images/B978012415950100029X/fx011.jpg" width="5"/> threads?</p></div></div><p class="textfl"/><p class="text" id="p0310"/><div class="boxg1" id="enun0030"><p class="b1num">Exercise 19.4 </p><div><p class="b1textfl" id="p0315">If a hazard pointer implementation is willing to let some objects go unreclaimed for a longer duration, then its <img alt="Image" height="13" src="images/B978012415950100029X/fx052.jpg" width="39"/> method could begin by copying all of the threads' reservations to a private list. It could then intersect that list with its <img alt="Image" height="13" src="images/B978012415950100029X/fx048.jpg" width="105"/> to identify the objects that were ready to reclaim. Under what circumstances would this be advantageous? Under what circumstances would it harm performance?</p></div></div><p class="textfl"/><p class="text" id="p0320"/><div class="boxg1" id="enun0035"><p class="b1num">Exercise 19.5 </p><div><p class="b1textfl" id="p0325">For each of the following data structures, discuss the number of hazard pointers that would be required in the worst case when implementing the data structure with optimistic concurrency control:</p><div><ol><li class="b1numlist" id="o0010">1.  lock-free queue,</li><li class="b1numlist" id="o0015">2.  lock-free stack,</li><li class="b1numlist" id="o0020">3.  lazy list,</li><li class="b1numlist" id="o0025">4.  skip list.</li></ol></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0350"/><div class="boxg1" id="enun0040"><p class="b1num">Exercise 19.6 </p><div><p class="b1textfl" id="p0355">The <img alt="Image" height="9" src="images/B978012415950100029X/fx008.jpg" width="86"/> types in C++ support <i>relaxed</i> memory ordering. What orderings can be relaxed in the hazard pointer implementation from Section <a href="#s0035" id="cf0095">19.6</a>?</p></div></div><p class="textfl"/><p class="text" id="p0360"/><div class="boxg1" id="enun0045"><p class="b1num">Exercise 19.7 </p><div><p class="b1textfl" id="p0365">Similar to <a href="#enun0025" id="cf0100">Exercise 19.3</a>, we could make the epoch-based reclamation in Section <a href="#s0040" id="cf0105">19.7</a> nonblocking. Rewrite the code in <a href="#f0050" id="cf0110">Fig. 19.8</a> so that threads do not wait at commit time.</p></div></div><p class="textfl"/><p class="text" id="p0370"/><div class="boxg1" id="enun0050"><p class="b1num">Exercise 19.8 </p><div><p class="b1textfl" id="p0375">In our implementation of epoch-based memory reclamation, we did not require threads to attain an atomic snapshot of all other threads' counters when deciding whether it was safe to reclaim an object. Why was this correct?</p></div></div><p class="textfl"/></section><footer><section epub:type="bibliography" role="doc-bibliography"><div id="bl0265"><h2 class="reftitle" id="st0065">Bibliography</h2><p class="reflist1" epub:type="biblioentry footnote" id="br0110" role="doc-biblioentry">[22] Anastasia Braginsky, Alex Kogan, Erez Petrank,  Drop the anchor: lightweight memory management for non-blocking data structures,   <i>Proceedings of the 25th ACM Symposium on Parallelism in Algorithms and Architectures</i>.  <i>Montreal, Quebec, Canada</i>.  July 2013.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0115" role="doc-biblioentry">[23] Trevor Brown,  Reclaiming memory for lock-free data structures: there has to be a better way,   <i>Proceedings of the 34th ACM Symposium on Principles of Distributed Computing</i>.  <i>Portland, OR</i>.  June 2015.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0155" role="doc-biblioentry">[31] Nachshon Cohen, Erez Petrank,  Efficient memory management for lock-free data structures with optimistic access,   <i>Proceedings of the 27th ACM Symposium on Parallelism in Algorithms and Architectures</i>.  <i>Portland, OR</i>.  June 2015.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0220" role="doc-biblioentry">[44]  Facebook,  Folly: Facebook Open-source Library,   <a href="https://github.com/facebook/folly/">https://github.com/facebook/folly/</a>; 2017.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0240" role="doc-biblioentry">[48] K. Fraser,  <i>Practical Lock-Freedom</i>. [Ph.D. dissertation] Cambridge, England: Kings College, University of Cambridge; September 2003.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0335" role="doc-biblioentry">[67] M. Herlihy, V. Luchangco, M. Moir,  The repeat offender problem: a mechanism for supporting lock-free dynamic-sized data structures,   <i>Proceedings of the 16th International Symposium on DIStributed Computing, vol. 2508</i>.  Springer-Verlag Heidelberg; January 2002:339–353.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0405" role="doc-biblioentry">[81] Richard L. Hudson, Bratin Saha, Ali-Reza Adl-Tabatabai, Benjamin Hertzberg,  A scalable transactional memory allocator,   <i>Proceedings of the International Symposium on Memory Management</i>.  <i>Ottawa, ON, Canada</i>.  June 2006.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0615" role="doc-biblioentry">[123] Paul E. McKenney,  <i>Exploiting Deferred Destruction: an Analysis of Read-Copy-Update Techniques in Operating System Kernels</i>. [PhD thesis] OGI School of Science and Engineering at Oregon Health and Sciences University; 2004.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0635" role="doc-biblioentry">[127] Maged M. Michael,  Hazard pointers: safe memory reclamation for lock-free objects,   <cite><i>IEEE Transactions on Parallel and Distributed Systems</i></cite> June 2004;15(6):491–504.</p></div></section></footer></section></body></html>