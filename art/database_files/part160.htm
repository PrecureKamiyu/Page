<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>7.9   Database-Design Process</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part159.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part161.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">7.9   <span style=" color: #00AEEF;">Database-Design Process</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">So far we have looked at detailed issues about normal forms and normalization. In this section, we study how normalization ﬁts into the overall database-design process.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Earlier in the chapter starting in Section 7.1.1, we assumed that a relation schema <i>r</i>(<i>R</i>) is given, and we proceeded to normalize it. There are several ways in which we could have come up with the schema <i>r</i>(<i>R</i>):</p><p style="padding-top: 8pt;padding-left: 145pt;text-indent: -16pt;text-align: left;"><span class="s63">1. </span><i>r</i>(<i>R</i>) could have been generated in converting an <span class="s44">E-R </span>diagram to a set of relation schemas.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 4pt;padding-left: 113pt;text-indent: -17pt;text-align: left;"><span class="s63">2. </span>r<span class="p">(</span>R<span class="p">) could have been a single relation schema containing </span>all <span class="p">attributes that are of interest. The normalization process then breaks up </span>r<span class="p">(</span>R<span class="p">) into smaller schemas.</span></p><p class="s13" style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: left;"><span class="s63">3. </span>r<span class="p">(</span>R<span class="p">) could have been the result of an ad hoc design of relations that we then test to verify that it satisﬁes a desired normal form.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">In the rest of this section, we examine the implications of these approaches. We also examine some practical issues in database design, including denormalization for per- formance and examples of bad design that are not detected by normalization.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">7.9.1 E-R Model and Normalization</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2060.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2061.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2062.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2063.png"/></span></p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">When we deﬁne an <span class="s44">E-R </span>diagram carefully, identifying all entity sets correctly, the rela- tion schemas generated from the <span class="s44">E-R </span>diagram should not need much further normal- ization. However, there can be functional dependencies among attributes of an entity set. For instance, suppose an <i>instructor </i>entity set had attributes <i>dept name </i>and <i>dept address</i>, and there is a functional dependency <i>dept name </i><span class="s86">→ </span><i>dept address</i>. We would</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">then need to normalize the relation generated from <i>instructor</i>.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2064.png"/></span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: right;">Most examples of such dependencies arise out of poor <span class="s44">E-R </span>diagram design. In the preceding example, if we had designed the <span class="s44">E-R </span>diagram correctly, we would have created a <i>department </i>entity set with attribute <i>dept address </i>and a relationship set between <i>instructor </i>and <i>department</i>. Similarly, a relationship set involving more than two entity sets may result in a schema that may not be in a desirable normal form. Since most relationship sets are binary, such cases are relatively rare. (In fact, some <span class="s44">E-R</span>-diagram variants actually make it diﬃcult or impossible to specify nonbinary relationship sets.) Functional dependencies can help us detect poor <span class="s44">E-R </span>design. If the generated re- lation schemas are not in desired normal form, the problem can be ﬁxed in the <span class="s44">E-R </span>diagram. That is, normalization can be done formally as part of data modeling. Alter- natively, normalization can be left to the designer’s intuition during <span class="s44">E-R </span>modeling, and</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">it can be done formally on the relation schemas generated from the <span class="s44">E-R </span>model.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A careful reader will have noted that in order for us to illustrate a need for mul- tivalued dependencies and fourth normal form, we had to begin with schemas that were not derived from our <span class="s44">E-R </span>design. Indeed, the process of creating an <span class="s44">E-R </span>design tends to generate <span class="s44">4NF </span>designs. If a multivalued dependency holds and is not implied by the corresponding functional dependency, it usually arises from one of the following sources:</p><p class="s39" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s40">A many-to-many relationship set.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s40">A multivalued attribute of an entity set.</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2065.png"/></span></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">For a many-to-many relationship set, each related entity set has its own schema, and there is an additional schema for the relationship set. For a multivalued attribute, a separate schema is created consisting of that attribute and the primary key of the entity set (as in the case of the <i>phone number </i>attribute of the entity set <i>instructor</i>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">The universal-relation approach to relational database design starts with an as- sumption that there is one single relation schema containing all attributes of interest. This single schema deﬁnes how users and applications interact with the database.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 8pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">7.9.2 Naming of Attributes and Relationships</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">A desirable feature of a database design is the <span class="s63">unique-role assumption</span>, which means that each attribute name has a unique meaning in the database. This prevents us from using the same attribute to mean diﬀerent things in diﬀerent schemas. For example, we might otherwise consider using the attribute <i>number </i>for phone number in the <i>instructor </i>schema and for room number in the <i>classroom </i>schema. The join of a relation on schema <i>instructor </i>with one on <i>classroom </i>is meaningless. While users and application developers can work carefully to ensure use of the right <i>number </i>in each circumstance, having a diﬀerent attribute name for phone number and for room number serves to reduce user errors.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">While it is a good idea to keep names for incompatible attributes distinct, if at- tributes of diﬀerent relations have the same meaning, it may be a good idea to use the same attribute name. For this reason we used the same attribute name “<i>name</i>” for both the <i>instructor </i>and the <i>student </i>entity sets. If this was not the case (i.e., if we used dif- ferent naming conventions for the instructor and student names), then if we wished to generalize these entity sets by creating a <i>person </i>entity set, we would have to rename the attribute. Thus, even if we did not currently have a generalization of <i>student </i>and <i>instructor</i>, if we foresee such a possibility, it is best to use the same name in both entity sets (and relations).</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Although technically, the order of attribute names in a schema does not matter, it is a convention to list primary-key attributes ﬁrst. This makes reading default output (as from <b>select *</b>) easier.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2066.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2067.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2068.png"/></span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In large database schemas, relationship sets (and schemas derived therefrom) are often named via a concatenation of the names of related entity sets, perhaps with an intervening hyphen or underscore. We have used a few such names, for example, <i>inst sec </i>and <i>student sec</i>. We used the names <i>teaches </i>and <i>takes </i>instead of using the longer concatenated names. This was acceptable since it is not hard for you to remember the associated entity sets for a few relationship sets. We cannot always create relationship- set names by simple concatenation; for example, a manager or works-for relationship between employees would not make much sense if it were called <i>employee employee</i>! Similarly, if there are multiple relationship sets possible between a pair of entity sets, the relationship-set names must include extra parts to identify the relationship set.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Diﬀerent organizations have diﬀerent conventions for naming entity sets. For ex- ample, we may call an entity set of students <i>student </i>or <i>students</i>. We have chosen to use the singular form in our database designs. Using either singular or plural is acceptable, as long as the convention is used consistently across all entity sets.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">As schemas grow larger, with increasing numbers of relationship sets, using con- sistent naming of attributes, relationships, and entities makes life much easier for the database designer and application programmers.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">7.9.3 Denormalization for Performance</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Occasionally database designers choose a schema that has redundant information; that is, it is not normalized. They use the redundancy to improve performance for speciﬁc applications. The penalty paid for not using a normalized schema is the extra work (in terms of coding time and execution time) to keep redundant data consistent.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">For instance, suppose all course prerequisites have to be displayed along with the course information, every time a course is accessed. In our normalized schema, this requires a join of <i>course </i>with <i>prereq</i>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">One alternative to computing the join on the ﬂy is to store a relation containing all the attributes of <i>course </i>and <i>prereq</i>. This makes displaying the “full” course information faster. However, the information for a course is repeated for every course prerequisite, and all copies must be updated by the application, whenever a course prerequisite is added or dropped. The process of taking a normalized schema and making it non- normalized is called <span class="s63">denormalization</span>, and designers use it to tune the performance of systems to support time-critical operations.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A better alternative, supported by many database systems today, is to use the nor- malized schema and additionally store the join of <i>course </i>and <i>prereq </i>as a materialized view. (Recall that a materialized view is a view whose result is stored in the database and brought up to date when the relations used in the view are updated.) Like denor- malization, using materialized views does have space and time overhead; however, it has the advantage that keeping the view up to date is the job of the database system, not the application programmer.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">7.9.4 Other Design Issues</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2069.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2070.png"/></span></p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: right;">There are some aspects of database design that are not addressed by normalization and can thus lead to bad database design. Data pertaining to time or to ranges of time have several such issues. We give examples here; obviously, such designs should be avoided. Consider a university database, where we want to store the total number of instruc- tors in each department in diﬀerent years. A relation <i>total inst</i>(<i>dept name</i>, <i>year</i>, <i>size</i>) could be used to store the desired information. The only functional dependency on this</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2071.png"/></span></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 14pt;text-align: justify;">relation is <i>dept name</i>, <i>year</i><span class="s86">→ </span><i>size</i>, and the relation is in <span class="s44">BCNF</span>.</p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">An alternative design is to use multiple relations, each storing the size informa-</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2072.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2073.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2074.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2075.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2076.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2077.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2078.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2079.png"/></span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">tion for a diﬀerent year. Let us say the years of interest are 2017, 2018, and 2019; we would then have relations of the form <i>total inst 2017</i>, <i>total inst 2018</i>, <i>total inst 2019</i>, all of which are on the schema (<i>dept name</i>, <i>size</i>). The only functional dependency here on each relation would be <i>dept name </i><span class="s86">→ </span><i>size</i>, so these relations are also in <span class="s44">BCNF</span>.</p><p style="padding-left: 87pt;text-indent: 0pt;line-height: 11pt;text-align: right;">However, this alternative design is clearly a bad idea— we would have to create a</p><p style="text-indent: 0pt;text-align: right;">new relation every year, and we would also have to write new queries every year, to take</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><a name="bookmark143">each new relation into account. Queries would also be more complicated since they may have to refer to many relations.</a><a name="bookmark171">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2080.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2081.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2082.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2083.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2084.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2085.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2086.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2087.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2088.png"/></span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Yet another way of representing the same data is to have a single relation <i>dept year</i>(<i>dept name</i>, <i>total inst 2017</i>, <i>total inst 2018</i>, <i>total inst 2019</i>). Here the only func- tional dependencies are from <i>dept name </i>to the other attributes, and again the relation is in <span class="s44">BCNF</span>. This design is also a bad idea since it has problems similar to the previous design— namely, we would have to modify the relation schema and write new queries every year. Queries would also be more complicated, since they may have to refer to many attributes.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2089.png"/></span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Representations such as those in the <i>dept year </i>relation, with one column for each value of an attribute, are called <span class="s63">crosstabs</span>; they are widely used in spreadsheets and reports and in data analysis tools. While such representations are useful for display to users, for the reasons just given, they are not desirable in a database design. <span class="s44">SQL </span>includes features to convert data from a normal relational representation to a cross- tab, for display, as we discussed in Section 11.3.1.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part159.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part161.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
