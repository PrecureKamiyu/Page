<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>17.2  A Simple Transaction Model</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part311.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part313.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 10pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">17.2  <span style=" color: #00AEEF;">A Simple Transaction Model</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Because <span class="s44">SQL </span>is a powerful and complex language, we begin our study of transactions with a simple database language that focuses on when data are moved from disk to main memory and from main memory to disk. In doing this, we ignore <span class="s44">SQL </span><b>insert </b>and <b>delete </b>operations and defer considering them until Section 18.4. The only actual operations on the data are restricted in our simple language to arithmetic operations. Later we shall discuss transactions in a realistic, <span class="s44">SQL</span>-based context with a richer set of operations. The data items in our simpliﬁed model contain a single data value (a number in our examples). Each data item is identiﬁed by a name (typically a single letter in our examples, that is, <i>A</i>, <i>B</i>, <i>C</i>, etc.).</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We shall illustrate the transaction concept using a simple bank application consist- ing of several accounts and a set of transactions that access and update those accounts. Transactions access data using two operations:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s49">read</span>(<i>X </i>), which transfers the data item <i>X </i>from the database to a variable, also called <i>X </i>, in a buﬀer in main memory belonging to the transaction that executed the <span class="s49">read </span>operation.</p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s49">write</span>(<i>X </i>), which transfers the value in the variable <i>X </i>in the main-memory buﬀer of the transaction that executed the <span class="s49">write </span>to the data item <i>X </i>in the database.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">It is important to know if a change to a data item appears only in main memory or if it has been written to the database on disk. In a real database system, the <span class="s49">write </span>operation does not necessarily result in the immediate update of the data on the disk; the <span class="s49">write </span>operation may be temporarily stored elsewhere and executed on the disk later. For now, however, we shall assume that the <span class="s49">write </span>operation updates the database immediately. We discuss storage issues further in Section 17.3 and discuss the issue of when database data in main memory are written to the database on disk in Chapter 19.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 88pt;text-indent: 17pt;line-height: 87%;text-align: left;">Let <i>T</i><span class="s97">i </span>be a transaction that transfers $50 from account <i>A </i>to account <i>B</i>. This trans- action can be deﬁned as:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 48pt;text-indent: 0pt;line-height: 14pt;text-align: center;"><i>T</i><span class="s97">i</span>: <span class="s49">read</span>(<i>A</i>);</p><p class="s13" style="padding-left: 80pt;text-indent: 0pt;line-height: 12pt;text-align: center;">A <span class="p">:= </span>A <span class="s15">− </span><span class="p">50;</span></p><p style="padding-left: 68pt;text-indent: 0pt;text-align: center;"><span class="s49">write</span>(<i>A</i>);</p><p style="padding-left: 65pt;text-indent: 0pt;text-align: center;"><span class="s49">read</span>(<i>B</i>);</p><p class="s13" style="padding-left: 78pt;text-indent: 0pt;text-align: center;">B <span class="p">:= </span>B <span class="p">+ 50;</span></p><p style="padding-left: 68pt;text-indent: 0pt;text-align: center;"><span class="s49">write</span>(<i>B</i>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">Let us now consider each of the <span class="s44">ACID </span>properties. (For ease of presentation, we consider them in an order diﬀerent from the order <span class="s44">A-C-I-D</span>.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s63">Consistency</span>: The consistency requirement here is that the sum of <i>A </i>and <i>B </i>be un- changed by the execution of the transaction. Without the consistency requirement, money could be created or destroyed by the transaction! It can be veriﬁed eas- ily that, if the database is consistent before an execution of the transaction, the database remains consistent after the execution of the transaction.</p><p style="padding-left: 107pt;text-indent: 15pt;text-align: justify;">Ensuring consistency for an individual transaction is the responsibility of the application programmer who codes the transaction. This task may be facilitated by automatic testing of integrity constraints, as we discussed in Section 4.4.</p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s63">Atomicity</span>: Suppose that, just before the execution of transaction <i>T</i><span class="s145">i</span>, the values of accounts <i>A </i>and <i>B </i>are $1000 and $2000, respectively. Now suppose that, during the execution of transaction <i>T</i><span class="s97">i</span>, a failure occurs that prevents <i>T</i><span class="s97">i </span>from completing its ex- ecution successfully. Further, suppose that the failure happened after the <span class="s49">write</span>(<i>A</i>) operation but before the <span class="s49">write</span>(<i>B</i>) operation. In this case, the values of accounts</p><p class="s13" style="padding-left: 107pt;text-indent: 0pt;text-align: justify;">A <span class="p">and </span>B <span class="p">reﬂected in the database are $950 and $2000. The system destroyed $50 as a result of this failure. In particular, we note that the sum </span>A <span class="p">+ </span>B <span class="p">is no longer preserved.</span></p><p style="padding-left: 107pt;text-indent: 15pt;line-height: 13pt;text-align: justify;">Thus, because of the failure, the state of the system no longer reﬂects a real state of the world that the database is supposed to capture. We term such a state an <span class="s63">inconsistent state</span>. We must ensure that such inconsistencies are not visible in a database system. Note, however, that the system must at some point be in an inconsistent state. Even if transaction <i>T</i><span class="s145">i </span>is executed to completion, there exists a point at which the value of account <i>A </i>is $950 and the value of account <i>B </i>is</p><p style="padding-left: 107pt;text-indent: 0pt;text-align: justify;">$2000, which is clearly an inconsistent state. This state, however, is eventually replaced by the consistent state where the value of account <i>A </i>is $950, and the value of account <i>B </i>is $2050. Thus, if the transaction never started or was guaranteed to complete, such an inconsistent state would not be visible except during the execution of the transaction. That is the reason for the atomicity requirement: If the atomicity property is present, all actions of the transaction are reﬂected in the database, or none are.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: 15pt;text-align: justify;">The basic idea behind ensuring atomicity is this: The database system keeps track (on disk) of the old values of any data on which a transaction performs a write. This information is written to a ﬁle called the <i>log</i>. If the transaction does not complete its execution, the database system restores the old values from the log to make it appear as though the transaction never executed. We discuss these ideas further in Section 17.4. Ensuring atomicity is the responsibility of the database sys- tem; speciﬁcally, it is handled by a component of the database called the <span class="s63">recovery system</span>, which we describe in detail in Chapter 19.</p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Durability</span><span class="p">: Once the execution of the transaction completes successfully, and the user who initiated the transaction has been notiﬁed that the transfer of funds has taken place, it must be the case that no system failure can result in a loss of data corresponding to this transfer of funds. The durability property guarantees that, once a transaction completes successfully, all the updates that it carried out on the database persist, even if there is a system failure after the transaction completes execution.</span></p><p style="padding-left: 139pt;text-indent: 14pt;text-align: justify;">We assume for now that a failure of the computer system may result in loss of data in main memory, but data written to disk are never lost. Protection against loss of data on disk is discussed in Chapter 19. We can guarantee durability by ensuring that either:</p><p class="s63" style="padding-top: 10pt;padding-left: 165pt;text-indent: -11pt;text-align: justify;">1. <span class="p">The updates carried out by the transaction have been written to disk before the transaction completes.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 165pt;text-indent: -11pt;text-align: justify;">2. <span class="p">Information about the updates carried out by the transaction is written to disk, and such information is suﬃcient to enable the database to reconstruct the updates when the database system is restarted after the failure.</span></p><p style="padding-top: 10pt;padding-left: 139pt;text-indent: 0pt;text-align: justify;">The recovery system of the database, described in Chapter 19, is responsible for ensuring durability, in addition to ensuring atomicity.</p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Isolation</span><span class="p">: Even if the consistency and atomicity properties are ensured for each transaction, if several transactions are executed concurrently, their operations may interleave in some undesirable way, resulting in an inconsistent state.</span></p><p class="s13" style="padding-left: 139pt;text-indent: 14pt;text-align: justify;"><span class="p">For example, as we saw earlier, the database is temporarily inconsistent while the transaction to transfer funds from </span>A <span class="p">to </span>B <span class="p">is executing, with the deducted total written to </span>A <span class="p">and the increased total yet to be written to </span>B<span class="p">. If a second concurrently running transaction reads </span>A <span class="p">and </span>B <span class="p">at this intermediate point and computes </span>A <span class="s15">+ </span>B<span class="p">, it will observe an inconsistent value. Furthermore, if this second transaction then performs updates on </span>A <span class="p">and </span>B <span class="p">based on the inconsistent values that it read, the database may be left in an inconsistent state even after both transactions have completed.</span></p><p style="padding-left: 139pt;text-indent: 14pt;text-align: justify;">A way to avoid the problem of concurrently executing transactions is to execute transactions serially— that is, one after the other. However, concurrent execution of transactions provides signiﬁcant performance beneﬁts, as we shall see in Section</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: 0pt;text-align: justify;"><a name="bookmark369">17.5. Other solutions have therefore been developed; they allow multiple transac- tions to execute concurrently.</a><a name="bookmark411">&zwnj;</a></p><p style="padding-left: 107pt;text-indent: 14pt;text-align: justify;">We discuss the problems caused by concurrently executing transactions in Sec- tion 17.5. The isolation property of a transaction ensures that the concurrent ex- ecution of transactions results in a system state that is equivalent to a state that could have been obtained had these transactions executed one at a time in some order. We shall discuss the principles of isolation further in Section 17.6. Ensuring the isolation property is the responsibility of a component of the database system called the <span class="s63">concurrency-control system</span>, which we discuss in Chapter 18.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part311.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part313.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
