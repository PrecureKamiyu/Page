<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>28.14 Using Queues: Sleeping Instead Of Spinning</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part292.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part294.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">28.14 Using Queues: Sleeping Instead Of Spinning</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The real problem with our previous approaches is that they leave too much to chance. The scheduler determines which thread runs next; if the scheduler makes a bad choice, a thread runs that must either spin waiting for the lock (our first approach), or yield the CPU immediately (our second approach). Either way, there is potential for waste and no prevention of starvation.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Thus, we must explicitly exert some control over who gets to acquire the lock next after the current holder releases it. To do this, we will need a little more OS support, as well as a queue to keep track of which threads are waiting to enter the lock.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: left;">For simplicity, we will use the support provided by Solaris, in terms of two calls: <span class="s41">park() </span>to put a calling thread to sleep, and <span class="s41">unpark(threadID) </span>to wake a particular thread as designated by <span class="s41">threadID</span>. These two rou- tines can be used in tandem to build a lock that puts a caller to sleep if it tries to acquire a held lock and wakes it when the lock is free. Let’s look at the code in Figure <span style=" color: #00AEEF;">28.8 </span>to understand one possible use of such primitives.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We do a couple of interesting things in this example. First, we combine the old test-and-set idea with an explicit queue of lock waiters to make a more efficient lock. Second, we use a queue to help control who gets the lock next and thus avoid starvation.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">You might notice how the guard is used, basically as a spin-lock around the flag and queue manipulations the lock is using. This approach thus doesn’t avoid spin-waiting entirely; a thread might be interrupted while acquiring or releasing the lock, and thus cause other threads to spin-wait for this one to run again. However, the time spent spinning is quite lim- ited (just a few instructions inside the lock and unlock code, instead of the user-defined critical section), and thus this approach may be reasonable.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 88%;text-align: justify;">Second, you might notice that in <span class="s41">lock()</span>, when a thread can not ac- quire the lock (it is already held), we are careful to add ourselves to a queue (by calling the <span class="s41">gettid() </span>call to get the thread ID of the current thread), set guard to 0, and yield the CPU. A question for the reader: What would happen if the release of the guard lock came <i>after </i>the <span class="s41">park()</span>, and not before? Hint: something bad.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 5pt;padding-left: 54pt;text-indent: 0pt;text-align: left;"><span class="s37">1  </span>typedef struct <span class="s75">&nbsp;</span>lock_t {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2    <span class="s38">int flag;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3    <span class="s38">int guard;</span></p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">4    </span>queue_t <span class="s39">*</span>q;</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">5  <span class="s38">} lock_t;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">6</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">7  </span>void lock_init(lock_t <span class="s39">*</span>m) {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;">8    <span class="s38">m-&gt;flag = 0;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">9    <span class="s38">m-&gt;guard = 0;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">10    <span class="s38">queue_init(m-&gt;q);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">11  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">12</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">13  </span>void lock(lock_t <span class="s39">*</span>m) {</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">14    <span class="s38">while (TestAndSet(&amp;m-&gt;guard, 1) == 1)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">15       <span class="s38">; //acquire guard lock by spinning</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">16    <span class="s38">if (m-&gt;flag == 0) {</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">17       <span class="s38">m-&gt;flag = 1; // lock is acquired</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">18       <span class="s38">m-&gt;guard = 0;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">19    <span class="s38">} else {</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">20       <span class="s38">queue_add(m-&gt;q, gettid());</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">21       <span class="s38">m-&gt;guard = 0;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">22       <span class="s38">park();</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">23    <span class="s38">}</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">24  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">25</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">26  </span>void unlock(lock_t <span class="s39">*</span>m) {</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">27    <span class="s38">while (TestAndSet(&amp;m-&gt;guard, 1) == 1)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">28       <span class="s38">; //acquire guard lock by spinning</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">29    <span class="s38">if (queue_empty(m-&gt;q))</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">30       <span class="s38">m-&gt;flag = 0; // let go of lock; no one wants it</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">31    <span class="s38">else</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">32       <span class="s38">unpark(queue_remove(m-&gt;q)); // hold lock (for next thread!)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">33    <span class="s38">m-&gt;guard = 0;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">34  <span class="s38">}</span></p><p style="padding-left: 81pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Figure 28.8: <b>Lock With Queues, Test-and-set, Yield, And Wakeup</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">You might also notice the interesting fact that the flag does not get set back to 0 when another thread gets woken up. Why is this? Well, it is not an error, but rather a necessity! When a thread is woken up, it will be as if it is returning from <span class="s41">park()</span>; however, it does not hold the guard at that point in the code and thus cannot even try to set the flag to 1. Thus, we just pass the lock directly from the thread releasing the lock to the next thread acquiring it; flag is not set to 0 in-between.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Finally, you might notice the perceived race condition in the solution, just before the call to <span class="s41">park()</span>. With just the wrong timing, a thread will be about to park, assuming that it should sleep until the lock is no longer held. A switch at that time to another thread (say, a thread holding the lock) could lead to trouble, for example, if that thread then released the lock. The subsequent park by the first thread would then sleep forever (potentially). This problem is sometimes called the <b>wakeup/waiting race</b>; to avoid it, we need to do some extra work.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">Solaris solves this problem by adding a third system call: <span class="s41">setpark()</span>. By calling this routine, a thread can indicate it is <i>about to </i>park. If it then happens to be interrupted and another thread calls unpark before park is</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: left;">actually called, the subsequent park returns immediately instead of sleep- ing. The code modification, inside of <span class="s41">lock()</span>, is quite small:</p><p class="s37" style="padding-top: 8pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">1       <span class="s38">queue_add(m-&gt;q, gettid());</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">2       <span class="s38">setpark(); // new code</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">3       <span class="s38">m-&gt;guard = 0;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">A different solution could pass the guard into the kernel. In that case, the kernel could take precautions to atomically release the lock and de- queue the running thread.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part292.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part294.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
