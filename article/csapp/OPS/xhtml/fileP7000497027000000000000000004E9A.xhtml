<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>5.11 Some Limiting Factors</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000004E9A" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P700049702700000000000000004360B" data-uri="chapter05.xhtml#P700049702700000000000000004360B" epub:type="title"><span class="pcalibre label pcalibre1">5.11 </span>Some Limiting Factors</h1></header>
<p id="P700049702700000000000000004360C" data-uri="chapter05.xhtml#P700049702700000000000000004360C" class="pcalibre1 pcalibre calibre2">We have seen that the critical path in a data-flow graph representation of a program indicates a fundamental lower bound on the time required to execute a program. That is, if there is some chain of data dependencies in a program where the sum of all of the latencies along that chain equals <var class="calibre5 pcalibre pcalibre1">T</var>, then the program will require at least <var class="calibre5 pcalibre pcalibre1">T</var> cycles to execute.</p>
<p id="P700049702700000000000000004360D" data-uri="chapter05.xhtml#P700049702700000000000000004360D" class="pcalibre1 pcalibre calibre2">We have also seen that the throughput bounds of the functional units also impose a lower bound on the execution time for a program. That is, assume that a program requires a total of <var class="calibre5 pcalibre pcalibre1">N</var> computations of some operation, that the microprocessor has <var class="calibre5 pcalibre pcalibre1">C</var> functional units capable of performing that operation, and that these units have an issue time of <var class="calibre5 pcalibre pcalibre1">I</var>. Then the program will require at least <i class="calibre5 pcalibre pcalibre1">N · I/C</i> cycles to execute.</p>
<p id="P700049702700000000000000004360E" data-uri="chapter05.xhtml#P700049702700000000000000004360E" class="pcalibre1 pcalibre calibre2">In this section, we will consider some other factors that limit the performance of programs on actual machines.</p>
<section id="P7000497027000000000000000004E9F" data-uri="chapter05.xhtml#P7000497027000000000000000004E9F" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000004360F" data-uri="chapter05.xhtml#P700049702700000000000000004360F" epub:type="title"><span class="pcalibre label pcalibre1">5.11.1 </span>Register Spilling</h1></header>
<p id="P7000497027000000000000000043610" data-uri="chapter05.xhtml#P7000497027000000000000000043610" class="pcalibre1 pcalibre calibre2">The benefits of loop parallelism are limited by the ability to express the computation in assembly code. If a program has a degree of parallelism <var class="calibre5 pcalibre pcalibre1">P</var> that exceeds the number of available registers, then the compiler will resort to <i class="calibre5 pcalibre pcalibre1">spilling</i>, storing some of the temporary values in memory, typically by allocating space on the run-time stack. As an example, the following measurements compare the result of extending the multiple accumulator scheme of <code id="P7000497027000000000000000043611" data-uri="chapter05.xhtml#P7000497027000000000000000043611" class="pcalibre1 calibre8 pcalibre">combine6</code> to the cases of <var class="calibre5 pcalibre pcalibre1">k</var> = 10 and <var class="calibre5 pcalibre pcalibre1">k</var> = 20:</p>
<table id="P7000497027000000000000000043612" data-uri="chapter05.xhtml#P7000497027000000000000000043612" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000043613" data-uri="chapter05.xhtml#P7000497027000000000000000043613" class="calibre18 pcalibre pcalibre1"/>
<th id="P7000497027000000000000000043614" data-uri="chapter05.xhtml#P7000497027000000000000000043614" class="calibre18 pcalibre pcalibre1"/>
<th id="P7000497027000000000000000043615" data-uri="chapter05.xhtml#P7000497027000000000000000043615" class="calibre18 pcalibre pcalibre1"/>
<th colspan="2" id="P7000497027000000000000000043616" data-uri="chapter05.xhtml#P7000497027000000000000000043616" class="calibre18 pcalibre pcalibre1">Integer</th>
<th colspan="2" id="P7000497027000000000000000043617" data-uri="chapter05.xhtml#P7000497027000000000000000043617" class="calibre18 pcalibre pcalibre1">Floating point</th>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000043618" data-uri="chapter05.xhtml#P7000497027000000000000000043618" class="calibre18 pcalibre pcalibre1">Function</th>
<th id="P7000497027000000000000000043619" data-uri="chapter05.xhtml#P7000497027000000000000000043619" class="calibre18 pcalibre pcalibre1">Page</th>
<th id="P700049702700000000000000004361A" data-uri="chapter05.xhtml#P700049702700000000000000004361A" class="calibre18 pcalibre pcalibre1">Method</th>
<th id="P700049702700000000000000004361B" data-uri="chapter05.xhtml#P700049702700000000000000004361B" class="calibre18 pcalibre pcalibre1">+</th>
<th id="P700049702700000000000000004361C" data-uri="chapter05.xhtml#P700049702700000000000000004361C" class="calibre18 pcalibre pcalibre1">*</th>
<th id="P700049702700000000000000004361D" data-uri="chapter05.xhtml#P700049702700000000000000004361D" class="calibre18 pcalibre pcalibre1">+</th>
<th id="P700049702700000000000000004361E" data-uri="chapter05.xhtml#P700049702700000000000000004361E" class="calibre18 pcalibre pcalibre1">*</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004361F" data-uri="chapter05.xhtml#P700049702700000000000000004361F" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000043620" data-uri="chapter05.xhtml#P7000497027000000000000000043620" class="calibre10 pcalibre pcalibre1">combine6</code></td>
<td id="P7000497027000000000000000043621" data-uri="chapter05.xhtml#P7000497027000000000000000043621" class="calibre20 pcalibre pcalibre1">537</td>
<td class="calibre20 pcalibre pcalibre1"/>
<td class="calibre20 pcalibre pcalibre1"/>
<td class="calibre20 pcalibre pcalibre1"/>
<td class="calibre20 pcalibre pcalibre1"/>
<td class="calibre20 pcalibre pcalibre1"/>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td class="calibre20 pcalibre pcalibre1"/>
<td class="calibre20 pcalibre pcalibre1"/>
<td id="P7000497027000000000000000043622" data-uri="chapter05.xhtml#P7000497027000000000000000043622" class="calibre20 pcalibre pcalibre1">10 × 10 unrolling</td>
<td id="P7000497027000000000000000043623" data-uri="chapter05.xhtml#P7000497027000000000000000043623" class="calibre20 pcalibre pcalibre1">0.55</td>
<td id="P7000497027000000000000000043624" data-uri="chapter05.xhtml#P7000497027000000000000000043624" class="calibre20 pcalibre pcalibre1">1.00</td>
<td id="P7000497027000000000000000043625" data-uri="chapter05.xhtml#P7000497027000000000000000043625" class="calibre20 pcalibre pcalibre1">1.01</td>
<td id="P7000497027000000000000000043626" data-uri="chapter05.xhtml#P7000497027000000000000000043626" class="calibre20 pcalibre pcalibre1">0.52</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td class="calibre20 pcalibre pcalibre1"/>
<td class="calibre20 pcalibre pcalibre1"/>
<td id="P7000497027000000000000000043627" data-uri="chapter05.xhtml#P7000497027000000000000000043627" class="calibre20 pcalibre pcalibre1">20 × 20 unrolling</td>
<td id="P7000497027000000000000000043628" data-uri="chapter05.xhtml#P7000497027000000000000000043628" class="calibre20 pcalibre pcalibre1">0.83</td>
<td id="P7000497027000000000000000043629" data-uri="chapter05.xhtml#P7000497027000000000000000043629" class="calibre20 pcalibre pcalibre1">1.03</td>
<td id="P700049702700000000000000004362A" data-uri="chapter05.xhtml#P700049702700000000000000004362A" class="calibre20 pcalibre pcalibre1">1.02</td>
<td id="P700049702700000000000000004362B" data-uri="chapter05.xhtml#P700049702700000000000000004362B" class="calibre20 pcalibre pcalibre1">0.68</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td colspan="2" id="P700049702700000000000000004362C" data-uri="chapter05.xhtml#P700049702700000000000000004362C" class="calibre20 pcalibre pcalibre1">Throughput bound</td>
<td class="calibre20 pcalibre pcalibre1"/>
<td id="P700049702700000000000000004362D" data-uri="chapter05.xhtml#P700049702700000000000000004362D" class="calibre20 pcalibre pcalibre1">0.50</td>
<td id="P700049702700000000000000004362E" data-uri="chapter05.xhtml#P700049702700000000000000004362E" class="calibre20 pcalibre pcalibre1">1.00</td>
<td id="P700049702700000000000000004362F" data-uri="chapter05.xhtml#P700049702700000000000000004362F" class="calibre20 pcalibre pcalibre1">1.00</td>
<td id="P7000497027000000000000000043630" data-uri="chapter05.xhtml#P7000497027000000000000000043630" class="calibre20 pcalibre pcalibre1">0.50</td>
</tr>
</tbody>
</table>
<p id="P7000497027000000000000000043631" data-uri="chapter05.xhtml#P7000497027000000000000000043631" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004EC3" title="549" data-uri="chapter05.xhtml#P7000497027000000000000000004EC3" epub:type="pagebreak"></span>We can see that none of the CPEs improve with this increased unrolling, and some even get worse. Modern x86-64 processors have 16 integer registers and can make use of the 16 YMM registers to store floating-point data. Once the number of loop variables exceeds the number of available registers, the program must allocate some on the stack.</p>
<p id="P7000497027000000000000000043632" data-uri="chapter05.xhtml#P7000497027000000000000000043632" class="pcalibre1 pcalibre calibre2">As an example, the following snippet of code shows how accumulator <code id="P7000497027000000000000000043633" data-uri="chapter05.xhtml#P7000497027000000000000000043633" class="pcalibre1 calibre8 pcalibre">acc0</code> is updated in the inner loop of the code with 10 × 10 unrolling:</p>
<pre id="P7000497027000000000000000043634" data-uri="chapter05.xhtml#P7000497027000000000000000043634" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000043635" data-uri="chapter05.xhtml#P7000497027000000000000000043635" class="calibre10 pcalibre pcalibre1">
<i class="calibre5 pcalibre pcalibre1">Updating of accumulator acc0 in 10 x 10 urolling</i>
vmulsd (%rdx), %xmm0, %xmm0	<i class="calibre5 pcalibre pcalibre1">acc0 *= data[i]</i>
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000043636" data-uri="chapter05.xhtml#P7000497027000000000000000043636">We can see that the accumulator is kept in register <code id="P7000497027000000000000000043637" data-uri="chapter05.xhtml#P7000497027000000000000000043637" class="pcalibre1 calibre8 pcalibre">%xmm0</code>, and so the program can simply read <code id="P7000497027000000000000000043638" data-uri="chapter05.xhtml#P7000497027000000000000000043638" class="pcalibre1 calibre8 pcalibre">data[i]</code> from memory and multiply it by this register.</p>
<p id="P7000497027000000000000000043639" data-uri="chapter05.xhtml#P7000497027000000000000000043639" class="pcalibre1 pcalibre calibre2">The comparable part of the code for 20 × 20 unrolling has a much different form:</p>
<pre id="P700049702700000000000000004363A" data-uri="chapter05.xhtml#P700049702700000000000000004363A" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004363B" data-uri="chapter05.xhtml#P700049702700000000000000004363B" class="calibre10 pcalibre pcalibre1">
<i class="calibre5 pcalibre pcalibre1">Updating of accumulator acc0 in 20 x 20 unrolling</i>
vmovsd 40(%rsp), %xmm0
vmulsd (%rdx), %xmm0, %xmm0
vmovsd %xmm0, 40(%rsp)
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004363C" data-uri="chapter05.xhtml#P700049702700000000000000004363C">The accumulator is kept as a local variable on the stack, at offset 40 from the stack pointer. The program must read both its value and the value of <code id="P700049702700000000000000004363D" data-uri="chapter05.xhtml#P700049702700000000000000004363D" class="pcalibre1 calibre8 pcalibre">data[i]</code> from memory, multiply them, and store the result back to memory.</p>
<p id="P700049702700000000000000004363E" data-uri="chapter05.xhtml#P700049702700000000000000004363E" class="pcalibre1 pcalibre calibre2">Once a compiler must resort to register spilling, any advantage of maintaining multiple accumulators will most likely be lost. Fortunately, x86-64 has enough registers that most loops will become throughput limited before this occurs.</p>
</section>
<section id="P7000497027000000000000000004ED1" data-uri="chapter05.xhtml#P7000497027000000000000000004ED1" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000004363F" data-uri="chapter05.xhtml#P700049702700000000000000004363F" epub:type="title"><span class="pcalibre label pcalibre1">5.11.2 </span>Branch Prediction and Misprediction Penalties</h1></header>
<p id="P7000497027000000000000000043640" data-uri="chapter05.xhtml#P7000497027000000000000000043640" class="pcalibre1 pcalibre calibre2">We demonstrated via experiments in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000002339_split_000.xhtml#P7000497027000000000000000002578"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">3.6.6</span></a> that a conditional branch can incur a significant <i class="calibre5 pcalibre pcalibre1">misprediction penalty</i> when the branch prediction logic does not correctly anticipate whether or not a branch will be taken. Now that we have learned something about how processors operate, we can understand where this penalty arises.</p>
<p id="P7000497027000000000000000043641" data-uri="chapter05.xhtml#P7000497027000000000000000043641" class="pcalibre1 pcalibre calibre2">Modern processors work well ahead of the currently executing instructions, reading new instructions from memory and decoding them to determine what operations to perform on what operands. This <i class="calibre5 pcalibre pcalibre1">instruction pipelining</i> works well as long as the instructions follow in a simple sequence. When a branch is encountered, the processor must guess which way the branch will go. For the case of a conditional jump, this means predicting whether or not the branch will be taken. For an instruction such as an indirect jump (as we saw in the code to jump to an address specified by a jump table entry) or a procedure return, this means predicting the target address. In this discussion, we focus on conditional branches.</p>
<p id="P7000497027000000000000000043642" data-uri="chapter05.xhtml#P7000497027000000000000000043642" class="pcalibre1 pcalibre calibre2">In a processor that employs <i class="calibre5 pcalibre pcalibre1">speculative execution</i>, the processor begins executing the instructions at the predicted branch target. It does this in a way that avoids modifying any actual register or memory locations until the actual outcome has been determined. If the prediction is correct, the processor can then <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004ED6" title="550" data-uri="chapter05.xhtml#P7000497027000000000000000004ED6" epub:type="pagebreak"></span>"commit" the results of the speculatively executed instructions by storing them in registers or memory. If the prediction is incorrect, the processor must discard all of the speculatively executed results and restart the instruction fetch process at the correct location. The misprediction penalty is incurred in doing this, because the instruction pipeline must be refilled before useful results are generated.</p>
<p id="P7000497027000000000000000043643" data-uri="chapter05.xhtml#P7000497027000000000000000043643" class="pcalibre1 pcalibre calibre2">We saw in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000002339_split_000.xhtml#P7000497027000000000000000002578"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">3.6.6</span></a> that recent versions of x86 processors, including all processors capable of executing x86-64 programs, have <i class="calibre5 pcalibre pcalibre1">conditional move</i> instructions. <span class="smallcaps pcalibre pcalibre1">gcc </span>can generate code that uses these instructions when compiling conditional statements and expressions, rather than the more traditional realizations based on conditional transfers of control. The basic idea for translating into conditional moves is to compute the values along both branches of a conditional expression or statement and then use conditional moves to select the desired value. We saw in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000041EB_split_001.xhtml#P70004970270000000000000000043A8"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">4.5.7</span></a> that conditional move instructions can be implemented as part of the pipelined processing of ordinary instructions. There is no need to guess whether or not the condition will hold, and hence no penalty for guessing incorrectly.</p>
<p id="P7000497027000000000000000043644" data-uri="chapter05.xhtml#P7000497027000000000000000043644" class="pcalibre1 pcalibre calibre2">How, then, can a C programmer make sure that branch misprediction penalties do not hamper a program's efficiency? Given the 19-cycle misprediction penalty we measured for the reference machine, the stakes are very high. There is no simple answer to this question, but the following general principles apply.</p>
<section id="P7000497027000000000000000004ED9" data-uri="chapter05.xhtml#P7000497027000000000000000004ED9" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000043645" data-uri="chapter05.xhtml#P7000497027000000000000000043645" epub:type="title">Do Not Be Overly Concerned about Predictable Branches</h1></header>
<p id="P7000497027000000000000000043646" data-uri="chapter05.xhtml#P7000497027000000000000000043646" class="pcalibre1 pcalibre calibre2">We have seen that the effect of a mispredicted branch can be very high, but that does not mean that all program branches will slow a program down. In fact, the branch prediction logic found in modern processors is very good at discerning regular patterns and long-term trends for the different branch instructions. For example, the loop-closing branches in our combining routines would typically be predicted as being taken, and hence would only incur a misprediction penalty on the last time around.</p>
<p id="P7000497027000000000000000043647" data-uri="chapter05.xhtml#P7000497027000000000000000043647" class="pcalibre1 pcalibre calibre2">As another example, consider the results we observed when shifting from <code id="P7000497027000000000000000043648" data-uri="chapter05.xhtml#P7000497027000000000000000043648" class="pcalibre1 calibre8 pcalibre">combine2</code> to <code id="P7000497027000000000000000043649" data-uri="chapter05.xhtml#P7000497027000000000000000043649" class="pcalibre1 calibre8 pcalibre">combine3</code>, when we took the function <code id="P700049702700000000000000004364A" data-uri="chapter05.xhtml#P700049702700000000000000004364A" class="pcalibre1 calibre8 pcalibre">get_vec_element</code> out of the inner loop of the function, as is reproduced below:</p>
<table id="P700049702700000000000000004364B" data-uri="chapter05.xhtml#P700049702700000000000000004364B" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P700049702700000000000000004364C" data-uri="chapter05.xhtml#P700049702700000000000000004364C" class="calibre18 pcalibre pcalibre1"/>
<th id="P700049702700000000000000004364D" data-uri="chapter05.xhtml#P700049702700000000000000004364D" class="calibre18 pcalibre pcalibre1"/>
<th id="P700049702700000000000000004364E" data-uri="chapter05.xhtml#P700049702700000000000000004364E" class="calibre18 pcalibre pcalibre1"/>
<th colspan="2" id="P700049702700000000000000004364F" data-uri="chapter05.xhtml#P700049702700000000000000004364F" class="calibre18 pcalibre pcalibre1">Integer</th>
<th colspan="2" id="P7000497027000000000000000043650" data-uri="chapter05.xhtml#P7000497027000000000000000043650" class="calibre18 pcalibre pcalibre1">Floating point</th>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000043651" data-uri="chapter05.xhtml#P7000497027000000000000000043651" class="calibre18 pcalibre pcalibre1">Function</th>
<th id="P7000497027000000000000000043652" data-uri="chapter05.xhtml#P7000497027000000000000000043652" class="calibre18 pcalibre pcalibre1">Page</th>
<th id="P7000497027000000000000000043653" data-uri="chapter05.xhtml#P7000497027000000000000000043653" class="calibre18 pcalibre pcalibre1">Method</th>
<th id="P7000497027000000000000000043654" data-uri="chapter05.xhtml#P7000497027000000000000000043654" class="calibre18 pcalibre pcalibre1">+</th>
<th id="P7000497027000000000000000043655" data-uri="chapter05.xhtml#P7000497027000000000000000043655" class="calibre18 pcalibre pcalibre1">*</th>
<th id="P7000497027000000000000000043656" data-uri="chapter05.xhtml#P7000497027000000000000000043656" class="calibre18 pcalibre pcalibre1">+</th>
<th id="P7000497027000000000000000043657" data-uri="chapter05.xhtml#P7000497027000000000000000043657" class="calibre18 pcalibre pcalibre1">*</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000043658" data-uri="chapter05.xhtml#P7000497027000000000000000043658" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000043659" data-uri="chapter05.xhtml#P7000497027000000000000000043659" class="calibre10 pcalibre pcalibre1">combine2</code></td>
<td id="P700049702700000000000000004365A" data-uri="chapter05.xhtml#P700049702700000000000000004365A" class="calibre20 pcalibre pcalibre1">509</td>
<td id="P700049702700000000000000004365B" data-uri="chapter05.xhtml#P700049702700000000000000004365B" class="calibre20 pcalibre pcalibre1">Move <code id="P700049702700000000000000004365C" data-uri="chapter05.xhtml#P700049702700000000000000004365C" class="calibre10 pcalibre pcalibre1">vec_length</code></td>
<td id="P700049702700000000000000004365D" data-uri="chapter05.xhtml#P700049702700000000000000004365D" class="calibre20 pcalibre pcalibre1">7.02</td>
<td id="P700049702700000000000000004365E" data-uri="chapter05.xhtml#P700049702700000000000000004365E" class="calibre20 pcalibre pcalibre1">9.03</td>
<td id="P700049702700000000000000004365F" data-uri="chapter05.xhtml#P700049702700000000000000004365F" class="calibre20 pcalibre pcalibre1">9.02</td>
<td id="P7000497027000000000000000043660" data-uri="chapter05.xhtml#P7000497027000000000000000043660" class="calibre20 pcalibre pcalibre1">11.03</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000043661" data-uri="chapter05.xhtml#P7000497027000000000000000043661" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000043662" data-uri="chapter05.xhtml#P7000497027000000000000000043662" class="calibre10 pcalibre pcalibre1">combine3</code></td>
<td id="P7000497027000000000000000043663" data-uri="chapter05.xhtml#P7000497027000000000000000043663" class="calibre20 pcalibre pcalibre1">513</td>
<td id="P7000497027000000000000000043664" data-uri="chapter05.xhtml#P7000497027000000000000000043664" class="calibre20 pcalibre pcalibre1">Direct data access</td>
<td id="P7000497027000000000000000043665" data-uri="chapter05.xhtml#P7000497027000000000000000043665" class="calibre20 pcalibre pcalibre1">7.17</td>
<td id="P7000497027000000000000000043666" data-uri="chapter05.xhtml#P7000497027000000000000000043666" class="calibre20 pcalibre pcalibre1">9.02</td>
<td id="P7000497027000000000000000043667" data-uri="chapter05.xhtml#P7000497027000000000000000043667" class="calibre20 pcalibre pcalibre1">9.02</td>
<td id="P7000497027000000000000000043668" data-uri="chapter05.xhtml#P7000497027000000000000000043668" class="calibre20 pcalibre pcalibre1">11.03</td>
</tr>
</tbody>
</table>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000043669" data-uri="chapter05.xhtml#P7000497027000000000000000043669">The CPE did not improve, even though the transformation eliminated two conditionals on each iteration that check whether the vector index is within bounds. For this function, the checks always succeed, and hence they are highly predictable.</p>
<p id="P700049702700000000000000004366A" data-uri="chapter05.xhtml#P700049702700000000000000004366A" class="pcalibre1 pcalibre calibre2">As a way to measure the performance impact of bounds checking, consider the following combining code, where we have modified the inner loop of <code id="P700049702700000000000000004366B" data-uri="chapter05.xhtml#P700049702700000000000000004366B" class="pcalibre1 calibre8 pcalibre">combine4</code> by replacing the access to the data element with the result of performing an inline substitution of the code for <code id="P700049702700000000000000004366C" data-uri="chapter05.xhtml#P700049702700000000000000004366C" class="pcalibre1 calibre8 pcalibre">get_vec_element</code>. We will call this new version <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004F02" title="551" data-uri="chapter05.xhtml#P7000497027000000000000000004F02" epub:type="pagebreak"></span><code id="P700049702700000000000000004366D" data-uri="chapter05.xhtml#P700049702700000000000000004366D" class="pcalibre1 calibre8 pcalibre">combine4b</code>. This code performs bounds checking and also references the vector elements through the vector data structure.</p>
<pre id="P700049702700000000000000004366E" data-uri="chapter05.xhtml#P700049702700000000000000004366E" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004366F" data-uri="chapter05.xhtml#P700049702700000000000000004366F" class="calibre10 pcalibre pcalibre1">
1	/* Include bounds check in loop */
2	void combine4b(vec_ptr v, data_t *dest)
3	{
4		long i;
5		long length = vec_length(v);
6		data_t acc = IDENT;
7	
8		for (i = 0; i &lt; length; i++) {
9			if (i &gt;= 0 &amp;&amp; i &lt; v-&gt;len) {
10				acc = acc OP v-&gt;data[i];
11			}
12		}
13		*dest = acc;
14	}
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000043670" data-uri="chapter05.xhtml#P7000497027000000000000000043670">We can then directly compare the CPE for the functions with and without bounds checking:</p>
<table id="P7000497027000000000000000043671" data-uri="chapter05.xhtml#P7000497027000000000000000043671" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000043672" data-uri="chapter05.xhtml#P7000497027000000000000000043672" class="calibre18 pcalibre pcalibre1"/>
<th id="P7000497027000000000000000043673" data-uri="chapter05.xhtml#P7000497027000000000000000043673" class="calibre18 pcalibre pcalibre1"/>
<th id="P7000497027000000000000000043674" data-uri="chapter05.xhtml#P7000497027000000000000000043674" class="calibre18 pcalibre pcalibre1"/>
<th colspan="2" id="P7000497027000000000000000043675" data-uri="chapter05.xhtml#P7000497027000000000000000043675" class="calibre18 pcalibre pcalibre1">Integer</th>
<th colspan="2" id="P7000497027000000000000000043676" data-uri="chapter05.xhtml#P7000497027000000000000000043676" class="calibre18 pcalibre pcalibre1">Floating point</th>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000043677" data-uri="chapter05.xhtml#P7000497027000000000000000043677" class="calibre18 pcalibre pcalibre1">Function</th>
<th id="P7000497027000000000000000043678" data-uri="chapter05.xhtml#P7000497027000000000000000043678" class="calibre18 pcalibre pcalibre1">Page</th>
<th id="P7000497027000000000000000043679" data-uri="chapter05.xhtml#P7000497027000000000000000043679" class="calibre18 pcalibre pcalibre1">Method</th>
<th id="P700049702700000000000000004367A" data-uri="chapter05.xhtml#P700049702700000000000000004367A" class="calibre18 pcalibre pcalibre1">+</th>
<th id="P700049702700000000000000004367B" data-uri="chapter05.xhtml#P700049702700000000000000004367B" class="calibre18 pcalibre pcalibre1">*</th>
<th id="P700049702700000000000000004367C" data-uri="chapter05.xhtml#P700049702700000000000000004367C" class="calibre18 pcalibre pcalibre1">+</th>
<th id="P700049702700000000000000004367D" data-uri="chapter05.xhtml#P700049702700000000000000004367D" class="calibre18 pcalibre pcalibre1">*</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004367E" data-uri="chapter05.xhtml#P700049702700000000000000004367E" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004367F" data-uri="chapter05.xhtml#P700049702700000000000000004367F" class="calibre10 pcalibre pcalibre1">combine4</code></td>
<td id="P7000497027000000000000000043680" data-uri="chapter05.xhtml#P7000497027000000000000000043680" class="calibre20 pcalibre pcalibre1">515</td>
<td id="P7000497027000000000000000043681" data-uri="chapter05.xhtml#P7000497027000000000000000043681" class="calibre20 pcalibre pcalibre1">No bounds checking</td>
<td id="P7000497027000000000000000043682" data-uri="chapter05.xhtml#P7000497027000000000000000043682" class="calibre20 pcalibre pcalibre1">1.27</td>
<td id="P7000497027000000000000000043683" data-uri="chapter05.xhtml#P7000497027000000000000000043683" class="calibre20 pcalibre pcalibre1">3.01</td>
<td id="P7000497027000000000000000043684" data-uri="chapter05.xhtml#P7000497027000000000000000043684" class="calibre20 pcalibre pcalibre1">3.01</td>
<td id="P7000497027000000000000000043685" data-uri="chapter05.xhtml#P7000497027000000000000000043685" class="calibre20 pcalibre pcalibre1">5.01</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000043686" data-uri="chapter05.xhtml#P7000497027000000000000000043686" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000043687" data-uri="chapter05.xhtml#P7000497027000000000000000043687" class="calibre10 pcalibre pcalibre1">combine4b</code></td>
<td id="P7000497027000000000000000043688" data-uri="chapter05.xhtml#P7000497027000000000000000043688" class="calibre20 pcalibre pcalibre1">515</td>
<td id="P7000497027000000000000000043689" data-uri="chapter05.xhtml#P7000497027000000000000000043689" class="calibre20 pcalibre pcalibre1">Bounds checking</td>
<td id="P700049702700000000000000004368A" data-uri="chapter05.xhtml#P700049702700000000000000004368A" class="calibre20 pcalibre pcalibre1">2.02</td>
<td id="P700049702700000000000000004368B" data-uri="chapter05.xhtml#P700049702700000000000000004368B" class="calibre20 pcalibre pcalibre1">3.01</td>
<td id="P700049702700000000000000004368C" data-uri="chapter05.xhtml#P700049702700000000000000004368C" class="calibre20 pcalibre pcalibre1">3.01</td>
<td id="P700049702700000000000000004368D" data-uri="chapter05.xhtml#P700049702700000000000000004368D" class="calibre20 pcalibre pcalibre1">5.01</td>
</tr>
</tbody>
</table>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004368E" data-uri="chapter05.xhtml#P700049702700000000000000004368E">The version with bounds checking is slightly slower for the case of integer addition, but it achieves the same performance for the other three cases. The performance of these cases is limited by the latencies of their respective combining operations. The additional computation required to perform bounds checking can take place in parallel with the combining operations. The processor is able to predict the outcomes of these branches, and so none of this evaluation has much effect on the fetching and processing of the instructions that form the critical path in the program execution.</p>
</section>
<section id="P7000497027000000000000000004F25" data-uri="chapter05.xhtml#P7000497027000000000000000004F25" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P700049702700000000000000004368F" data-uri="chapter05.xhtml#P700049702700000000000000004368F" epub:type="title">Write Code Suitable for Implementation with Conditional Moves</h1></header>
<p id="P7000497027000000000000000043690" data-uri="chapter05.xhtml#P7000497027000000000000000043690" class="pcalibre1 pcalibre calibre2">Branch prediction is only reliable for regular patterns. Many tests in a program are completely unpredictable, dependent on arbitrary features of the data, such as whether a number is negative or positive. For these, the branch prediction logic will do very poorly. For inherently unpredictable cases, program performance can be greatly enhanced if the compiler is able to generate code using conditional data transfers rather than conditional control transfers. This cannot be controlled directly by the C programmer, but some ways of expressing conditional behavior can be more directly translated into conditional moves than others.</p>
<p id="P7000497027000000000000000043691" data-uri="chapter05.xhtml#P7000497027000000000000000043691" class="pcalibre1 pcalibre calibre2">We have found that <span class="smallcaps pcalibre pcalibre1">gcc </span>is able to generate conditional moves for code written in a more "functional" style, where we use conditional operations to compute <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004F29" title="552" data-uri="chapter05.xhtml#P7000497027000000000000000004F29" epub:type="pagebreak"></span>values and then update the program state with these values, as opposed to a more "imperative" style, where we use conditionals to selectively update program state.</p>
<p id="P7000497027000000000000000043692" data-uri="chapter05.xhtml#P7000497027000000000000000043692" class="pcalibre1 pcalibre calibre2">There are no strict rules for these two styles, and so we illustrate with an example. Suppose we are given two arrays of integers <var class="calibre5 pcalibre pcalibre1">a</var> and <var class="calibre5 pcalibre pcalibre1">b</var>, and at each position <var class="calibre5 pcalibre pcalibre1">i</var>, we want to set <code id="P7000497027000000000000000043693" data-uri="chapter05.xhtml#P7000497027000000000000000043693" class="pcalibre1 calibre8 pcalibre">a[<var class="calibre5 pcalibre pcalibre1">i</var>]</code> to the minimum of <code id="P7000497027000000000000000043694" data-uri="chapter05.xhtml#P7000497027000000000000000043694" class="pcalibre1 calibre8 pcalibre">a[<var class="calibre5 pcalibre pcalibre1">i</var>]</code> and <code id="P7000497027000000000000000043695" data-uri="chapter05.xhtml#P7000497027000000000000000043695" class="pcalibre1 calibre8 pcalibre">b[<var class="calibre5 pcalibre pcalibre1">i</var>]</code>, and <code id="P7000497027000000000000000043696" data-uri="chapter05.xhtml#P7000497027000000000000000043696" class="pcalibre1 calibre8 pcalibre">b[<var class="calibre5 pcalibre pcalibre1">i</var>]</code> to the maximum.</p>
<p id="P7000497027000000000000000043697" data-uri="chapter05.xhtml#P7000497027000000000000000043697" class="pcalibre1 pcalibre calibre2">An imperative style of implementing this function is to check at each position <var class="calibre5 pcalibre pcalibre1">i</var> and swap the two elements if they are out of order:</p>
<pre id="P7000497027000000000000000043698" data-uri="chapter05.xhtml#P7000497027000000000000000043698" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000043699" data-uri="chapter05.xhtml#P7000497027000000000000000043699" class="calibre10 pcalibre pcalibre1">
1	/* Rearrange two vectors so that for each i, b[i] &gt;= a[i] */
2	void minmax1(long a[], long b[], long n) {
3		long i;
4		for (i = 0; i &lt; n; i++) {
5			if (a[i] &gt; b[i]) {
6				long t = a[i];
7				a[i] = b[i];
8				b[i] = t;
9			}
10		}
11	}
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004369A" data-uri="chapter05.xhtml#P700049702700000000000000004369A">Our measurements for this function show a CPE of around 13.5 for random data and 2.5-3.5 for predictable data, an indication of a misprediction penalty of around 20 cycles.</p>
<p id="P700049702700000000000000004369B" data-uri="chapter05.xhtml#P700049702700000000000000004369B" class="pcalibre1 pcalibre calibre2">A functional style of implementing this function is to compute the minimum and maximum values at each position <var class="calibre5 pcalibre pcalibre1">i</var> and then assign these values to <code id="P700049702700000000000000004369C" data-uri="chapter05.xhtml#P700049702700000000000000004369C" class="pcalibre1 calibre8 pcalibre">a[<var class="calibre5 pcalibre pcalibre1">i</var>]</code> and <code id="P700049702700000000000000004369D" data-uri="chapter05.xhtml#P700049702700000000000000004369D" class="pcalibre1 calibre8 pcalibre">b[<var class="calibre5 pcalibre pcalibre1">i</var>]</code>, respectively:</p>
<pre id="P700049702700000000000000004369E" data-uri="chapter05.xhtml#P700049702700000000000000004369E" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004369F" data-uri="chapter05.xhtml#P700049702700000000000000004369F" class="calibre10 pcalibre pcalibre1">
1	/* Rearrange two vectors so that for each i, b[i] &gt;= a[i] */
2	void minmax2(long a[], long b[], long n) {
3		long i;
4		for (i = 0; i &lt; n; i++) {
5			long min = a[i] &lt; b[i] ? a[i] : b[i];
6			long max = a[i] &lt; b[i] ? b[i] : a[i];
7			a[i] = min;
8			b[i] = max;
9		}
10	}
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000436A0" data-uri="chapter05.xhtml#P70004970270000000000000000436A0">Our measurements for this function show a CPE of around 4.0 regardless of whether the data are arbitrary or predictable. (We also examined the generated assembly code to make sure that it indeed uses conditional moves.)</p>
<p id="P70004970270000000000000000436A1" data-uri="chapter05.xhtml#P70004970270000000000000000436A1" class="pcalibre1 pcalibre calibre2">As discussed in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000002339_split_000.xhtml#P7000497027000000000000000002578"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">3.6.6</span></a>, not all conditional behavior can be implemented with conditional data transfers, and so there are inevitably cases where programmers cannot avoid writing code that will lead to conditional branches for which the processor will do poorly with its branch prediction. But, as we have shown, a little cleverness on the part of the programmer can sometimes make code more amenable to translation into conditional data transfers. This requires some amount <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004F3A" title="553" data-uri="chapter05.xhtml#P7000497027000000000000000004F3A" epub:type="pagebreak"></span>of experimentation, writing different versions of the function and then examining the generated assembly code and measuring performance.</p>
<section id="P7000497027000000000000000004F3B" data-uri="chapter05.xhtml#P7000497027000000000000000004F3B" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title10 pcalibre pcalibre1" id="P70004970270000000000000000436A2" data-uri="chapter05.xhtml#P70004970270000000000000000436A2" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">5.9 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005148">576</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P70004970270000000000000000436A3" data-uri="chapter05.xhtml#P70004970270000000000000000436A3">
<li class="general-problem pcalibre pcalibre1" id="P70004970270000000000000000436A4" data-uri="chapter05.xhtml#P70004970270000000000000000436A4">
<div class="edition pcalibre pcalibre1" id="P70004970270000000000000000436A5" data-uri="chapter05.xhtml#P70004970270000000000000000436A5"><p id="P70004970270000000000000000436A6" data-uri="chapter05.xhtml#P70004970270000000000000000436A6" class="pcalibre calibre3 pcalibre1">The traditional implementation of the merge step of mergesort requires three loops [<a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B468">98</a>]:</p>
<pre id="P70004970270000000000000000436A7" data-uri="chapter05.xhtml#P70004970270000000000000000436A7" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000436A8" data-uri="chapter05.xhtml#P70004970270000000000000000436A8" class="calibre10 pcalibre pcalibre1">
1	void merge(long src1[], long src2[], long dest[], long n) {
2		long i1 = 0;
3		long i2 = 0;
4		long id = 0;
5		while (i1 &lt; n &amp;&amp; i2 &lt; n) {
6			if (src1[i1] &lt; src2[i2])
7				dest[id++] = src1[i1++];
8			else
9				dest[id++] = src2[i2++];
10		}
11		while (i1 &lt; n)
12			dest[id++] = src1[i1++];
13		while (i2 &lt; n)
14			dest[id++] = src2[i2++];
15	}
</code></pre>
<p class="pcalibre calibre3 pcalibre1" id="P70004970270000000000000000436A9" data-uri="chapter05.xhtml#P70004970270000000000000000436A9">The branches caused by comparing variables <code id="P70004970270000000000000000436AA" data-uri="chapter05.xhtml#P70004970270000000000000000436AA" class="pcalibre1 calibre8 pcalibre">i1</code> and <code id="P70004970270000000000000000436AB" data-uri="chapter05.xhtml#P70004970270000000000000000436AB" class="pcalibre1 calibre8 pcalibre">i2</code> to n have good prediction performance—the only mispredictions occur when they first become false. The comparison between values <code id="P70004970270000000000000000436AC" data-uri="chapter05.xhtml#P70004970270000000000000000436AC" class="pcalibre1 calibre8 pcalibre">src1[i1]</code> and <code id="P70004970270000000000000000436AD" data-uri="chapter05.xhtml#P70004970270000000000000000436AD" class="pcalibre1 calibre8 pcalibre">src2[i2]</code> (line 6), on the other hand, is highly unpredictable for typical data. This comparison controls a conditional branch, yielding a CPE (where the number of elements is 2<var class="calibre5 pcalibre pcalibre1">n</var>) of around 15.0 when run on random data.</p>
<p id="P70004970270000000000000000436AE" data-uri="chapter05.xhtml#P70004970270000000000000000436AE" class="pcalibre calibre3 pcalibre1">Rewrite the code so that the effect of the conditional statement in the first loop (lines 6-9) can be implemented with a conditional move.</p></div></li>
</ol>
</section>
</section>
</section>
</section></body></html>
