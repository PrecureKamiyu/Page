<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 59. Sockets: Internet Domains</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch58.html" title="Chapter 58. Sockets: Fundamentals of TCP/IP Networks"/><link rel="next" href="ch60.html" title="Chapter 60. Sockets: Server Design"/></head><body><section class="chapter" title="Chapter 59. Sockets: Internet Domains" epub:type="chapter" id="sockets_colon_internet_domains"><div class="titlepage"><div><div><h2 class="title">Chapter 59. Sockets: Internet Domains</h2></div></div></div><p>Having looked at generic sockets concepts and the TCP/IP protocol suite in previous
            chapters, we are now ready in this chapter to look at programming with sockets in the
            IPv4 (<code class="literal">AF_INET</code>) and IPv6 (<code class="literal">AF_INET6</code>) domains.</p><p>As noted in <a class="xref" href="ch58.html" title="Chapter 58. Sockets: Fundamentals of TCP/IP Networks">Chapter 58</a>, Internet
            domain socket addresses consist of an IP address and a port number. Although computers
            use binary representations of IP addresses and port numbers, humans are much better at
            dealing with names than with numbers. Therefore, we describe the techniques used to
            identify host computers and ports using names. We also examine the use of library
            functions to obtain the IP address(es) for a particular hostname and the port number
            that corresponds to a particular service name. Our discussion of hostnames includes a
            description of the Domain Name System (DNS), which implements a distributed database
            that maps hostnames to IP addresses and vice versa.<a id="IDX-CHP-59-7618" class="indexterm"/></p><div class="sect1" title="Internet Domain Sockets"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="internet_domain_sockets">Internet Domain Sockets</h2></div></div></div><p>Internet domain stream sockets are implemented on top of TCP. They provide a
                reliable, bidirectional, byte-stream communication channel.</p><p>Internet domain datagram sockets are implemented on top of UDP. UDP sockets are
                similar to their UNIX domain counterparts, but note the following
                differences:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>UNIX domain datagram sockets are reliable, but UDP sockets are
                        not—datagrams may be lost, duplicated, or arrive in a different order from
                        that in which they were sent.</p></li><li class="listitem"><p>Sending on a UNIX domain datagram socket will block if the queue of data
                        for the receiving socket is full. By contrast, with UDP, if the incoming
                        datagram would overflow the receiver’s queue, then the datagram is silently
                        dropped.</p></li></ul></div></div><div class="sect1" title="Network Byte Order"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="network_byte_order">Network Byte Order</h2></div></div></div><p>IP addresses and port numbers are integer values. One problem we encounter when
                passing these values across a network is that different hardware architectures store
                the bytes of a multibyte integer in different orders. As shown in <a class="xref" href="ch59.html#big-endian_and_little-endian_byte_order" title="Figure 59-1. Big-endian and little-endian byte order for 2-byte and 4-byte integers">Figure 59-1</a>, architectures that store
                integers with the most significant byte first (i.e., at the lowest memory address)
                are termed <span class="emphasis"><em>big endian</em></span>; those that store the least significant
                byte first are termed <span class="emphasis"><em>little endian</em></span>. (The terms derive from
                Jonathan Swift’s 1726 satirical novel <span class="emphasis"><em>Gulliver’s Travels</em></span>, in
                which the terms refer to opposing political factions who open their boiled eggs at
                opposite ends.) The most notable example of a little-endian architecture is x86.
                (Digital’s VAX architecture was another historically important example, since BSD
                was widely used on that machine.) Most other architectures are big endian. A few
                hardware architectures are switchable between the two formats. The byte ordering
                used on a particular machine is called the <span class="emphasis"><em>host byte
                    order</em></span>.<a id="IDX-CHP-59-7619" class="indexterm"/><a id="IDX-CHP-59-7620" class="indexterm"/><a id="IDX-CHP-59-7621" class="indexterm"/><a id="IDX-CHP-59-7622" class="indexterm"/><a id="IDX-CHP-59-7623" class="indexterm"/></p><div class="figure"><a id="big-endian_and_little-endian_byte_order"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject59_d1e149581"/><img src="figs/web/59-1_SOCKINET-byte-order.png.jpg" alt="Big-endian and little-endian byte order for 2-byte and 4-byte integers"/></div></div><div class="figure-title">Figure 59-1. Big-endian and little-endian byte order for 2-byte and 4-byte
                    integers</div></div><p>Since port numbers and IP addresses must be transmitted between, and understood
                by, all hosts on a network, a standard ordering must be used. This ordering is
                called <span class="emphasis"><em>network byte order</em></span>, and happens to be big
                    endian.<a id="IDX-CHP-59-7624" class="indexterm"/><a id="IDX-CHP-59-7625" class="indexterm"/></p><p>Later in this chapter, we look at various functions that convert hostnames (e.g.,
                    <a class="ulink" href="http://www.kernel.org" target="_top">www.kernel.org</a>) and service names
                (e.g., <span class="emphasis"><em>http</em></span>) into the corresponding numeric forms. These
                functions generally return integers in network byte order, and these integers can be
                copied directly into the relevant fields of a socket address structure.</p><p>However, we sometimes make direct use of integer constants for IP addresses and
                port numbers. For example, we may choose to hard-code a port number into our
                program, specify a port number as a command-line argument to a program, or use
                constants such as <code class="literal">INADDR_ANY</code> and <code class="literal">INADDR_LOOPBACK</code> when specifying an IPv4 address. These
                values are represented in C according to the conventions of the host machine, so
                they are in host byte order. We must convert these values to network byte order
                before storing them in socket address structures.</p><p>The <span class="emphasis"><em>htons(), htonl(), ntohs(), and ntohl()</em></span> functions are
                defined (typically as macros) for converting integers in either direction between
                host and network byte order.</p><a id="I_programlisting59_d1e149618"/><pre class="programlisting">#include &lt;arpa/inet.h&gt;

uint16_t <strong class="userinput"><code>htons</code></strong>(uint16_t <span class="emphasis"><em>host_uint16</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns <span class="emphasis"><em>host_uint16</em></span> converted to network byte
                    order</p></div><a id="I_programlisting59_d1e149632"/><pre class="programlisting">uint32_t <strong class="userinput"><code>htonl</code></strong>(uint32_t <span class="emphasis"><em>host_uint32</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns <span class="emphasis"><em>host_uint32</em></span> converted to network byte
                    order</p></div><a id="I_programlisting59_d1e149647"/><pre class="programlisting">uint16_t <strong class="userinput"><code>ntohs</code></strong>(uint16_t <span class="emphasis"><em>net_uint16</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns <span class="emphasis"><em>net_uint16</em></span> converted to host byte order</p></div><a id="I_programlisting59_d1e149661"/><pre class="programlisting">uint32_t <strong class="userinput"><code>ntohl</code></strong>(uint32_t <span class="emphasis"><em>net_uint32</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns <span class="emphasis"><em>net_uint32</em></span> converted to host byte order</p></div><p>In earlier times, these functions had prototypes such as the following:</p><a id="I_programlisting59_d1e149677"/><pre class="programlisting">unsigned long htonl(unsigned long hostlong);</pre><p>This reveals the origin of the function names—in this case, <span class="emphasis"><em>host to
                    network long</em></span>. On most early systems on which sockets were
                implemented, short integers were 16 bits, and long integers were 32 bits. This no
                longer holds true on modern systems (at least for long integers), so the prototypes
                given above provide a more exact definition of the types dealt with by these
                functions, although the names remain unchanged. The <span class="emphasis"><em>uint16_t</em></span>
                and <span class="emphasis"><em>uint32_t</em></span> data types are 16-bit and 32-bit unsigned
                integers.</p><p>Strictly speaking, the use of these four functions is necessary only on systems
                where the host byte order differs from network byte order. However, these functions
                should always be used, so that programs are portable to different hardware
                architectures. On systems where the host byte order is the same as network byte
                order, these functions simply return their arguments unchanged.</p></div><div class="sect1" title="Data Representation"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="data_representation">Data Representation</h2></div></div></div><p>When writing network programs, we need to be aware of the fact that different
                computer architectures use different conventions for representing various data
                types. We have already noted that integer types can be stored in big-endian or
                little-endian form. There are also other possible differences. For example, the C
                    <span class="emphasis"><em>long</em></span> data type may be 32 bits on some systems and 64 bits
                on others. When we consider structures, the issue is further complicated by the fact
                that different implementations employ different rules for aligning the fields of a
                structure to address boundaries on the host system, leaving different numbers of
                padding bytes between the fields.<a id="IDX-CHP-59-7626" class="indexterm"/><a id="IDX-CHP-59-7627" class="indexterm"/><a id="IDX-CHP-59-7628" class="indexterm"/><a id="IDX-CHP-59-7629" class="indexterm"/><a id="IDX-CHP-59-7630" class="indexterm"/><a id="IDX-CHP-59-7631" class="indexterm"/><a id="IDX-CHP-59-7632" class="indexterm"/><a id="IDX-CHP-59-7633" class="indexterm"/><a id="IDX-CHP-59-7634" class="indexterm"/><a id="IDX-CHP-59-7635" class="indexterm"/><a id="IDX-CHP-59-7636" class="indexterm"/><a id="IDX-CHP-59-7637" class="indexterm"/><a id="IDX-CHP-59-7638" class="indexterm"/><a id="IDX-CHP-59-7639" class="indexterm"/><a id="IDX-CHP-59-7640" class="indexterm"/></p><p>Because of these differences in data representation, applications that exchange
                data between heterogeneous systems over a network must adopt some common convention
                for encoding that data. The sender must encode data according to this convention,
                while the receiver decodes following the same convention. The process of putting
                data into a standard format for transmission across a network is referred to as
                    <span class="emphasis"><em>marshalling</em></span>. Various marshalling standards exist, such as
                XDR (External Data Representation, described in RFC 1014), ASN.1-BER (Abstract
                Syntax Notation 1, <a class="ulink" href="http://www.asn1.org/" target="_top">http://www.asn1.org/</a>), CORBA, and XML. Typically,
                these standards define a fixed format for each data type (defining, for example,
                byte order and number of bits used). As well as being encoded in the required
                format, each data item is tagged with extra field(s) identifying its type (and,
                possibly, length).<a id="IDX-CHP-59-7641" class="indexterm"/><a id="IDX-CHP-59-7642" class="indexterm"/><a id="IDX-CHP-59-7643" class="indexterm"/></p><p>However, a simpler approach than marshalling is often employed: encode all
                transmitted data in text form, with separate data items delimited by a designated
                character, typically a newline character. One advantage of this approach is that we
                can use <span class="emphasis"><em>telnet</em></span> to debug an application. To do this, we use the
                following command:</p><a id="I_programlisting59_d1e149802"/><pre class="programlisting">$ <strong class="userinput"><code>telnet</code></strong> <strong class="userinput"><code><em class="replaceable"><code>host port</code></em></code></strong></pre><p>We can then type lines of text to be transmitted to the application, and view the
                responses sent by the application. We demonstrate this technique in <a class="xref" href="ch59.html#client-server_example_open_parenthesis_s" title="Client-Server Example (Stream Sockets)">Client-Server Example (Stream Sockets)</a>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The problems associated with differences in representation across
                    heterogeneous systems apply not only to data transfer across a network, but also
                    to any mechanism of data exchange between such systems. For example, we face the
                    same problems when transferring files on disk or tape between heterogeneous
                    systems. Network programming is simply the most common programming context in
                    which we are nowadays likely to encounter this issue.</p></div><p>If we encode data transmitted on a stream socket as newline-delimited text, then
                it is convenient to define a function such as <span class="emphasis"><em>readLine()</em></span>, shown
                in <a class="xref" href="ch59.html#reading_data_a_line_at_a_time" title="Example 59-1. Reading data a line at a time">Example 59-1</a>.<a id="IDX-CHP-59-7644" class="indexterm"/></p><a id="I_programlisting59_d1e149828"/><pre class="programlisting">#include "read_line.h"

ssize_t <strong class="userinput"><code>readLine</code></strong>(int <span class="emphasis"><em>fd</em></span>, void *<span class="emphasis"><em>buffer</em></span>, size_t <span class="emphasis"><em>n</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns number of bytes copied into <span class="emphasis"><em>buffer</em></span> (excluding
                    terminating null byte), or 0 on end-of-file, or -1 on error</p></div><p>The <span class="emphasis"><em>readLine()</em></span> function reads bytes from the file referred to
                by the file descriptor argument <span class="emphasis"><em>fd</em></span> until a newline is
                encountered. The input byte sequence is returned in the location pointed to by
                    <span class="emphasis"><em>buffer</em></span>, which must point to a region of at least
                    <span class="emphasis"><em>n</em></span> bytes of memory. The returned string is always
                null-terminated; thus, at most <span class="emphasis"><em>(n - 1)</em></span> bytes of actual data
                will be returned. On success, <span class="emphasis"><em>readLine()</em></span> returns the number of
                bytes of data placed in <span class="emphasis"><em>buffer</em></span>; the terminating null byte is
                not included in this count.</p><div class="example"><a id="reading_data_a_line_at_a_time"/><div class="example-title">Example 59-1. Reading data a line at a time</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>sockets/read_line.c</code></strong>
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include "read_line.h"                  /* Declaration of readLine() */

ssize_t
readLine(int fd, void *buffer, size_t n)
{
    ssize_t numRead;                    /* # of bytes fetched by last read() */
    size_t totRead;                     /* Total bytes read so far */
    char *buf;
    char ch;

    if (n &lt;= 0 || buffer == NULL) {
        errno = EINVAL;
        return -1;
    }

    buf = buffer;                       /* No pointer arithmetic on "void *" */

    totRead = 0;
    for (;;) {
        numRead = read(fd, &amp;ch, 1);

        if (numRead == -1) {
            if (errno == EINTR)        /* Interrupted --&gt; restart read() */
                continue;
            else
                return -1;              /* Some other error */

        } else if (numRead == 0) {      /* EOF */
            if (totRead == 0)           /* No bytes read; return 0 */
                return 0;
            else                        /* Some bytes read; add '\0' */
                break;

        } else {                        /* 'numRead' must be 1 if we get here */
            if (totRead &lt; n - 1) {      /* Discard &gt; (n - 1) bytes */
                totRead++;
                *buf++ = ch;
            }

            if (ch == '\n')
                break;
        }
    }

    *buf = '\0';
    return totRead;
}
     <strong class="userinput"><code>sockets/read_line.c</code></strong></pre></div></div><p>If the number of bytes read before a newline is encountered is greater than or
                equal to <span class="emphasis"><em>(n - 1)</em></span>, then the <span class="emphasis"><em>readLine()</em></span>
                function discards the excess bytes (including the newline). If a newline was read
                within the first <span class="emphasis"><em>(n - 1)</em></span> bytes, then it is included in the
                returned string. (Thus, we can determine if bytes were discarded by checking if a
                newline precedes the terminating null byte in the returned
                    <span class="emphasis"><em>buffer</em></span>.) We take this approach so that application
                protocols that rely on handling input in units of lines don’t end up processing a
                long line as though it were multiple lines. This would likely break the protocol, as
                the applications on either end would become desynchronized. An alternative approach
                would be to have <span class="emphasis"><em>readLine()</em></span> read only sufficient bytes to fill
                the supplied buffer, leaving any remaining bytes up to the next newline for the next
                call to <span class="emphasis"><em>readLine()</em></span>. In this case, the caller of
                    <span class="emphasis"><em>readLine()</em></span> would need to handle the possibility of a
                partial line being read.</p><p>We employ the <span class="emphasis"><em>readLine()</em></span> function in the example programs
                presented in <a class="xref" href="ch59.html#client-server_example_open_parenthesis_s" title="Client-Server Example (Stream Sockets)">Client-Server Example (Stream Sockets)</a>.</p></div><div class="sect1" title="Internet Socket Addresses"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="internet_socket_addresses">Internet Socket Addresses</h2></div></div></div><p>There are two types of Internet domain socket addresses: IPv4 and IPv6.<a id="IDX-CHP-59-7645" class="indexterm"/><a id="IDX-CHP-59-7646" class="indexterm"/><a id="IDX-CHP-59-7647" class="indexterm"/><a id="IDX-CHP-59-7648" class="indexterm"/><a id="IDX-CHP-59-7649" class="indexterm"/><a id="IDX-CHP-59-7650" class="indexterm"/><a id="IDX-CHP-59-7651" class="indexterm"/></p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="ipv4_socket_addresses_colon_struct"/></div></div></div><div class="sect3" title="IPv4 socket addresses: struct sockaddr_in"><div class="titlepage"><div><div><h4 class="title" id="ipv4_socket_addresses_colon_struct-id1">IPv4 socket addresses: <span class="emphasis"><em>struct sockaddr_in</em></span></h4></div></div></div><p>An IPv4 socket address is stored in a <span class="emphasis"><em>sockaddr_in</em></span>
                        structure, defined in <code class="literal">&lt;netinet/in.h&gt;</code> as follows:<a id="IDX-CHP-59-7652" class="indexterm"/><a id="IDX-CHP-59-7653" class="indexterm"/><a id="IDX-CHP-59-7654" class="indexterm"/></p><a id="I_programlisting59_d1e149986"/><pre class="programlisting">struct in_addr {                    /* IPv4 4-byte address */
    in_addr_t s_addr;               /* Unsigned 32-bit integer */
};

struct sockaddr_in {                /* IPv4 socket address */
    sa_family_t    sin_family;      /* Address family (AF_INET) */
    in_port_t      sin_port;        /* Port number */
    struct in_addr sin_addr;        /* IPv4 address */
    unsigned char  __pad[X];        /* Pad to size of 'sockaddr'
                                       structure (16 bytes) */
};</pre><p>In <a class="xref" href="ch56.html#generic_socket_address_structures_colon" title="Generic Socket Address Structures: struct sockaddr">Generic Socket Address Structures: <span class="emphasis"><em>struct sockaddr</em></span></a>, we saw that
                        the generic <span class="emphasis"><em>sockaddr</em></span> structure commences with a field
                        identifying the socket domain. This corresponds to the
                            <span class="emphasis"><em>sin_family</em></span> field in the
                            <span class="emphasis"><em>sockaddr_in</em></span> structure, which is always set to
                            <code class="literal">AF_INET</code>. The
                            <span class="emphasis"><em>sin_port</em></span> and <span class="emphasis"><em>sin_addr</em></span> fields
                        are the port number and the IP address, both in network byte order. The
                            <span class="emphasis"><em>in_port_t</em></span> and <span class="emphasis"><em>in_addr_t</em></span> data
                        types are unsigned integer types, 16 and 32 bits in length,
                        respectively.</p></div><div class="sect3" title="IPv6 socket addresses: struct sockaddr_in6"><div class="titlepage"><div><div><h4 class="title" id="ipv6_socket_addresses_colon_struct_socka">IPv6 socket addresses: <span class="emphasis"><em>struct sockaddr_in6</em></span></h4></div></div></div><p>Like an IPv4 address, an IPv6 socket address includes an IP address plus a
                        port number. The difference is that an IPv6 address is 128 bits instead of
                        32 bits. An IPv6 socket address is stored in a
                            <span class="emphasis"><em>sockaddr_in6</em></span> structure, defined in <code class="literal">&lt;netinet/in.h&gt;</code> as
                            follows:<a id="IDX-CHP-59-7655" class="indexterm"/><a id="IDX-CHP-59-7656" class="indexterm"/><a id="IDX-CHP-59-7657" class="indexterm"/><a id="IDX-CHP-59-7658" class="indexterm"/><a id="IDX-CHP-59-7659" class="indexterm"/><a id="IDX-CHP-59-7660" class="indexterm"/><a id="IDX-CHP-59-7661" class="indexterm"/><a id="IDX-CHP-59-7662" class="indexterm"/><a id="IDX-CHP-59-7663" class="indexterm"/><a id="IDX-CHP-59-7664" class="indexterm"/><a id="IDX-CHP-59-7665" class="indexterm"/><a id="IDX-CHP-59-7666" class="indexterm"/><a id="IDX-CHP-59-7667" class="indexterm"/></p><a id="I_programlisting59_d1e150089"/><pre class="programlisting">struct in6_addr {                   /* IPv6 address structure */
    uint8_t s6_addr[16];            /* 16 bytes == 128 bits */
};
struct sockaddr_in6 {               /* IPv6 socket address */
    sa_family_t sin6_family;        /* Address family (AF_INET6) */
    in_port_t   sin6_port;          /* Port number */
    uint32_t    sin6_flowinfo;      /* IPv6 flow information */
    struct in6_addr sin6_addr;      /* IPv6 address */
    uint32_t    sin6_scope_id;      /* Scope ID (new in kernel 2.4) */
};</pre><p>The <span class="emphasis"><em>sin_family</em></span> field is set to <code class="literal">AF_INET6</code>. The <span class="emphasis"><em>sin6_port</em></span>
                        and <span class="emphasis"><em>sin6_addr</em></span> fields are the port number and the IP
                        address. (The <span class="emphasis"><em>uint8_t</em></span> data type, used to type the bytes
                        of the <span class="emphasis"><em>in6_addr</em></span> structure, is an 8-bit unsigned
                        integer.) The remaining fields, <span class="emphasis"><em>sin6_flowinfo</em></span> and
                            <span class="emphasis"><em>sin6_scope_id</em></span>, are beyond the scope of this book;
                        for our purposes, they are always set to 0. All of the fields in the
                            <span class="emphasis"><em>sockaddr_in6</em></span> structure are in network byte
                            order.<a id="IDX-CHP-59-7668" class="indexterm"/><a id="IDX-CHP-59-7669" class="indexterm"/><a id="IDX-CHP-59-7670" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>IPv6 addresses are described in RFC 4291. Information about IPv6 flow
                            control (<span class="emphasis"><em>sin6_flowinfo</em></span>) can be found in <a class="xref" href="apa.html" title="Appendix A. Tracing System Calls">Appendix A</a> of [Stevens et al., 2004] and in
                            RFCs 2460 and 3697. RFCs 3493 and 4007 provide information about
                                <span class="emphasis"><em>sin6_scope_id</em></span>.<a id="IDX-CHP-59-7671" class="indexterm"/></p></div><p>IPv6 has equivalents of the IPv4 wildcard and loopback addresses. However,
                        their use is complicated by the fact that an IPv6 address is stored in an
                        array (rather than using a scalar type). We use the IPv6 wildcard address
                            (<code class="literal">0::0</code>) to illustrate this point. The
                        constant <code class="literal">IN6ADDR_ANY_INIT</code> is defined for
                        this address as follows:<a id="IDX-CHP-59-7672" class="indexterm"/></p><a id="I_programlisting59_d1e150165"/><pre class="programlisting">#define IN6ADDR_ANY_INIT { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } }</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>On Linux, some details in the header files differ from our description
                            in this section. In particular, the <span class="emphasis"><em>in6_addr</em></span>
                            structure contains a union definition that divides the 128-bit IPv6
                            address into 16 bytes, eight 2-byte integers, or four 32-byte integers.
                            Because of the presence of this definition, the
                                <span class="emphasis"><em>glibc</em></span> definition of the <code class="literal">IN6ADDR_ANY_INIT</code> constant actually
                            includes one more set of nested braces than is shown in the main
                                text.<a id="IDX-CHP-59-7673" class="indexterm"/></p></div><p>We can use the <code class="literal">IN6ADDR_ANY_INIT</code>
                        constant in the initializer that accompanies a variable declaration, but
                        can’t use it on the right-hand side of an assignment statement, since C
                        syntax doesn’t permit structured constants to be used in assignments.
                        Instead, we must use a predefined variable,
                        <span class="emphasis"><em>in6addr_any</em></span>, which is initialized as follows by the C
                        library:</p><a id="I_programlisting59_d1e150192"/><pre class="programlisting">const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;</pre><p>Thus, we can initialize an IPv6 socket address structure using the
                        wildcard address as follows:</p><a id="I_programlisting59_d1e150197"/><pre class="programlisting">struct sockaddr_in6 addr;

memset(&amp;addr, 0, sizeof(struct sockaddr_in6));
addr.sin6_family = AF_INET6;
addr.sin6_addr = in6addr_any;
addr.sin6_port = htons(SOME_PORT_NUM);</pre><p>The corresponding constant and variable for the IPv6 loopback address
                            (<code class="literal">::1</code>) are <code class="literal">IN6ADDR_LOOPBACK_INIT</code> and
                            <span class="emphasis"><em>in6addr_loopback</em></span>.<a id="IDX-CHP-59-7674" class="indexterm"/></p><p>Unlike their IPv4 counterparts, the IPv6 constant and variable
                        initializers are in network byte order. But, as shown in the above code, we
                        still must ensure that the port number is in network byte order.</p><p>If IPv4 and IPv6 coexist on a host, they share the same port-number space.
                        This means that if, for example, an application binds an IPv6 socket to TCP
                        port 2000 (using the IPv6 wildcard address), then an IPv4 TCP socket can’t
                        be bound to the same port. (The TCP/IP implementation ensures that sockets
                        on other hosts are able to communicate with this socket, regardless of
                        whether those hosts are running IPv4 or IPv6.)</p></div><div class="sect3" title="The sockaddr_storage structure"><div class="titlepage"><div><div><h4 class="title" id="the_sockaddr_underscore_storage_structur">The <span class="emphasis"><em>sockaddr_storage</em></span> structure</h4></div></div></div><p>With the IPv6 sockets API, the new generic
                            <span class="emphasis"><em>sockaddr_storage</em></span> structure was introduced. This
                        structure is defined to be large enough to hold any type of socket address
                        (i.e., any type of socket address structure can be cast and stored in it).
                        In particular, this structure allows us to transparently store either an
                        IPv4 or an IPv6 socket address, thus removing IP version dependencies from
                        our code. The <span class="emphasis"><em>sockaddr_storage</em></span> structure is defined on
                        Linux as follows:<a id="IDX-CHP-59-7676" class="indexterm"/><a id="IDX-CHP-59-7677" class="indexterm"/><a id="IDX-CHP-59-7678" class="indexterm"/><a id="IDX-CHP-59-7675" class="indexterm"/></p><a id="I_programlisting59_d1e150256"/><pre class="programlisting">#define __ss_aligntype uint32_t         /* On 32-bit architectures */
struct sockaddr_storage {
    sa_family_t ss_family;
    __ss_aligntype __ss_align;          /* Force alignment */
    char __ss_padding[SS_PADSIZE];      /* Pad to 128 bytes */
};</pre></div></div></div><div class="sect1" title="Overview of Host and Service Conversion Functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="overview_of_host_and_service_conversion">Overview of Host and Service Conversion Functions</h2></div></div></div><p>Computers represent IP addresses and port numbers in binary. However, humans find
                names easier to remember than numbers. Employing symbolic names also provides a
                useful level of indirection; users and programs can continue to use the same name
                even if the underlying numeric value changes.</p><p>A <span class="emphasis"><em>hostname</em></span> is the symbolic identifier for a system that is
                connected to a network (possibly with multiple IP addresses). A <span class="emphasis"><em>service
                    name</em></span> is the symbolic representation of a port number.<a id="IDX-CHP-59-7679" class="indexterm"/><a id="IDX-CHP-59-7680" class="indexterm"/></p><p>The following methods are available for representing host addresses and
                ports:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A host address can be represented as a binary value, as a symbolic
                        hostname, or in presentation format (dotted-decimal for IPv4 or hex-string
                        for IPv6).</p></li><li class="listitem"><p>A port can be represented as a binary value or as a symbolic service
                        name.</p></li></ul></div><p>Various library functions are provided for converting between these formats. This
                section briefly summarizes these functions. The following sections describe the
                modern APIs (<span class="emphasis"><em>inet_ntop()</em></span>, <span class="emphasis"><em>inet_pton()</em></span>,
                    <span class="emphasis"><em>getaddrinfo()</em></span>, <span class="emphasis"><em>getnameinfo()</em></span>, and so
                on) in detail. In <a class="xref" href="ch59.html#obsolete_apis_for_host_and_service_conve" title="Obsolete APIs for Host and Service Conversions">Obsolete APIs for Host and Service Conversions</a>, we
                briefly discuss the obsolete APIs (<span class="emphasis"><em>inet_aton()</em></span>,
                    <span class="emphasis"><em>inet_ntoa()</em></span>, <span class="emphasis"><em>gethostbyname()</em></span>,
                    <span class="emphasis"><em>getservbyname()</em></span>, and so on).<a id="IDX-CHP-59-7681" class="indexterm"/><a id="IDX-CHP-59-7682" class="indexterm"/></p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="converting_ipv4_addresses_between"/></div></div></div><div class="sect3" title="Converting IPv4 addresses between binary and human-readable forms"><div class="titlepage"><div><div><h4 class="title" id="converting_ipv4_addresses_between-id1">Converting IPv4 addresses between binary and human-readable forms</h4></div></div></div><p>The <span class="emphasis"><em>inet_aton()</em></span> and <span class="emphasis"><em>inet_ntoa()</em></span>
                        functions convert an IPv4 address in dotted-decimal notation to binary and
                        vice versa. We describe these functions primarily because they appear in
                        historical code. Nowadays, they are obsolete. Modern programs that need to
                        do such conversions should use the functions that we describe next.</p></div><div class="sect3" title="Converting IPv4 and IPv6 addresses between binary and human-readable forms"><div class="titlepage"><div><div><h4 class="title" id="converting_ipv4_and_ipv6_addresses_betwe">Converting IPv4 and IPv6 addresses between binary and human-readable
                        forms</h4></div></div></div><p>The <span class="emphasis"><em>inet_pton()</em></span> and <span class="emphasis"><em>inet_ntop()</em></span>
                        functions are like <span class="emphasis"><em>inet_aton()</em></span> and
                            <span class="emphasis"><em>inet_ntoa()</em></span>, but differ in that they also handle
                        IPv6 addresses. They convert binary IPv4 and IPv6 addresses to and from
                            <span class="emphasis"><em>presentation</em></span> format—that is, either dotted-decimal
                        or hex-string notation.<a id="IDX-CHP-59-7683" class="indexterm"/><a id="IDX-CHP-59-7684" class="indexterm"/></p><p>Since humans deal better with names than with numbers, we normally use
                        these functions only occasionally in programs. One use of
                            <span class="emphasis"><em>inet_ntop()</em></span> is to produce a printable
                        representation of an IP address for logging purposes. Sometimes, it is
                        preferable to use this function instead of converting (“resolving”) an IP
                        address to a hostname, for the following reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Resolving an IP address to a hostname involves a possibly
                                time-consuming request to a DNS server.</p></li><li class="listitem"><p>In some circumstances, there may not be a DNS (PTR) record that
                                maps the IP address to a corresponding hostname.</p></li></ul></div><p>We describe these functions (in <a class="xref" href="ch59.html#the_inet_underscore_pton_open_parenthesi" title="The inet_pton() and inet_ntop() Functions">The <span class="emphasis"><em>inet_pton()</em></span> and <span class="emphasis"><em>inet_ntop()</em></span>
                Functions</a>) before
                            <span class="emphasis"><em>getaddrinfo()</em></span> and
                            <span class="emphasis"><em>getnameinfo()</em></span>, which perform conversions between
                        binary representations and the corresponding symbolic names, principally
                        because they present a much simpler API. This allows us to quickly show some
                        working examples of the use of Internet domain sockets.<a id="IDX-CHP-59-7685" class="indexterm"/><a id="IDX-CHP-59-7686" class="indexterm"/></p></div><div class="sect3" title="Converting host and service names to and from binary form (obsolete)"><div class="titlepage"><div><div><h4 class="title" id="converting_host_and_service_names_to_and">Converting host and service names to and from binary form
                        (obsolete)</h4></div></div></div><p>The <span class="emphasis"><em>gethostbyname()</em></span> function returns the binary IP
                        address(es) corresponding to a hostname and the
                            <span class="emphasis"><em>getservbyname()</em></span> function returns the port number
                        corresponding to a service name. The reverse conversions are performed by
                            <span class="emphasis"><em>gethostbyaddr()</em></span> and
                            <span class="emphasis"><em>getservbyport()</em></span>. We describe these functions
                        because they are widely used in existing code. However, they are now
                        obsolete. (SUSv3 marks these functions obsolete, and SUSv4 removes their
                        specifications.) New code should use the <span class="emphasis"><em>getaddrinfo()</em></span>
                        and <span class="emphasis"><em>getnameinfo()</em></span> functions (described next) for such
                            conversions.<a id="IDX-CHP-59-7687" class="indexterm"/><a id="IDX-CHP-59-7688" class="indexterm"/><a id="IDX-CHP-59-7689" class="indexterm"/><a id="IDX-CHP-59-7690" class="indexterm"/></p></div><div class="sect3" title="Converting host and service names to and from binary form (modern)"><div class="titlepage"><div><div><h4 class="title" id="converting_host_and_service_names_to">Converting host and service names to and from binary form
                        (modern)</h4></div></div></div><p>The <span class="emphasis"><em>getaddrinfo()</em></span> function is the modern successor to
                        both <span class="emphasis"><em>gethostbyname()</em></span> and
                            <span class="emphasis"><em>getservbyname()</em></span>. Given a hostname and a service
                        name, <span class="emphasis"><em>getaddrinfo()</em></span> returns a set of structures
                        containing the corresponding binary IP address(es) and port number. Unlike
                            <span class="emphasis"><em>gethostbyname()</em></span>, <span class="emphasis"><em>getaddrinfo()</em></span>
                        transparently handles both IPv4 and IPv6 addresses. Thus, we can use it to
                        write programs that don’t contain dependencies on the IP version being
                        employed. All new code should use <span class="emphasis"><em>getaddrinfo()</em></span> for
                        converting hostnames and service names to binary representation.</p><p>The <span class="emphasis"><em>getnameinfo()</em></span> function performs the reverse
                        translation, converting an IP address and port number into the corresponding
                        hostname and service name.</p><p>We can also use <span class="emphasis"><em>getaddrinfo()</em></span> and
                            <span class="emphasis"><em>getnameinfo()</em></span> to convert binary IP addresses to and
                        from presentation format.</p><p>The discussion of <span class="emphasis"><em>getaddrinfo()</em></span> and
                            <span class="emphasis"><em>getnameinfo()</em></span>, in <a class="xref" href="ch59.html#protocol-independent_host_and_service_co" title="Protocol-Independent Host and Service Conversion">Protocol-Independent Host and Service Conversion</a>, requires an
                        accompanying description of DNS (<a class="xref" href="ch59.html#domain_name_system_open_parenthesis_dns" title="Domain Name System (DNS)">Domain Name System (DNS)</a>) and the <code class="literal">/etc/services</code> file (<a class="xref" href="ch59.html#the_solidus_etc_solidus_services_file" title="The /etc/services File">The <code class="literal">/etc/services</code> File</a>). DNS allows
                        cooperating servers to maintain a distributed database that maps binary IP
                        addresses to hostnames and vice versa. The existence of a system such as DNS
                        is essential to the operation of the Internet, since centralized management
                        of the enormous set of Internet hostnames would be impossible. The <code class="literal">/etc/services</code> file maps port numbers to
                        symbolic service names.</p></div></div></div><div class="sect1" title="The inet_pton() and inet_ntop() Functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_inet_underscore_pton_open_parenthesi">The <span class="emphasis"><em>inet_pton()</em></span> and <span class="emphasis"><em>inet_ntop()</em></span>
                Functions</h2></div></div></div><p>The <span class="emphasis"><em>inet_pton()</em></span> and <span class="emphasis"><em>inet_ntop()</em></span>
                functions allow conversion of both IPv4 and IPv6 addresses between binary form and
                dotted-decimal or hex-string notation.<a id="IDX-CHP-59-7693" class="indexterm"/><a id="IDX-CHP-59-7694" class="indexterm"/><a id="IDX-CHP-59-7695" class="indexterm"/><a id="IDX-CHP-59-7696" class="indexterm"/><a id="IDX-CHP-59-7697" class="indexterm"/><a id="IDX-CHP-59-7698" class="indexterm"/><a id="IDX-CHP-59-7691" class="indexterm"/><a id="IDX-CHP-59-7692" class="indexterm"/></p><a id="I_programlisting59_d1e150556"/><pre class="programlisting">#include &lt;arpa/inet.h&gt;

int <strong class="userinput"><code>inet_pton</code></strong>(int <span class="emphasis"><em>domain</em></span>, const char *<span class="emphasis"><em>src_str</em></span>, void *<span class="emphasis"><em>addrptr</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 1 on successful conversion, 0 if <span class="emphasis"><em>src_str</em></span> is not
                    in presentation format, or -1 on error</p></div><a id="I_programlisting59_d1e150576"/><pre class="programlisting">const char *<strong class="userinput"><code>inet_ntop</code></strong>(int <span class="emphasis"><em>domain</em></span>, const void *<span class="emphasis"><em>addrptr</em></span>,
 char *<span class="emphasis"><em>dst_str</em></span>, size_t <span class="emphasis"><em>len</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer to <span class="emphasis"><em>dst_str</em></span> on success, or NULL on
                    error</p></div><p>The <span class="emphasis"><em>p</em></span> in the names of these functions stands for
                “presentation,” and the n stands for “network.” The presentation form is a
                human-readable string, such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">204.152.189.116</code> (IPv4 dotted-decimal
                        address);</p></li><li class="listitem"><p><code class="literal">::1</code> (an IPv6 colon-separated
                        hexadecimal address); or</p></li><li class="listitem"><p><code class="literal">::FFFF:204.152.189.116</code> (an IPv4-mapped
                        IPv6 address).</p></li></ul></div><p>The <span class="emphasis"><em>inet_pton()</em></span> function converts the presentation string
                contained in <span class="emphasis"><em>src_str</em></span> into a binary IP address in network byte
                order. The <span class="emphasis"><em>domain</em></span> argument should be specified as either
                    <code class="literal">AF_INET</code> or <code class="literal">AF_INET6</code>. The converted address is placed in the structure pointed to
                by <span class="emphasis"><em>addrptr</em></span>, which should point to either an
                    <span class="emphasis"><em>in_addr</em></span> or an <span class="emphasis"><em>in6_addr</em></span> structure,
                according to the value specified in <span class="emphasis"><em>domain</em></span>.</p><p>The <span class="emphasis"><em>inet_ntop()</em></span> function performs the reverse conversion.
                Again, <span class="emphasis"><em>domain</em></span> should be specified as either <code class="literal">AF_INET</code> or <code class="literal">AF_INET6</code>, and <span class="emphasis"><em>addrptr</em></span> should point to an
                    <span class="emphasis"><em>in_addr</em></span> or <span class="emphasis"><em>in6_addr</em></span> structure that we
                wish to convert. The resulting null-terminated string is placed in the buffer
                pointed to by <span class="emphasis"><em>dst_str</em></span>. The <span class="emphasis"><em>len</em></span> argument
                must specify the size of this buffer. On success, <span class="emphasis"><em>inet_ntop()</em></span>
                returns <span class="emphasis"><em>dst_str</em></span>. If <span class="emphasis"><em>len</em></span> is too small, then
                    <span class="emphasis"><em>inet_ntop()</em></span> returns <code class="literal">NULL</code>, with <span class="emphasis"><em>errno</em></span> set to <code class="literal">ENOSPC</code>.</p><p>To correctly size the buffer pointed to by <span class="emphasis"><em>dst_str</em></span>, we can
                employ two constants defined in <code class="literal">&lt;netinet/in.h&gt;</code>. These constants indicate the maximum
                lengths (including the terminating null byte) of the presentation strings for IPv4
                and IPv6 addresses:</p><a id="I_programlisting59_d1e150711"/><pre class="programlisting">#define INET_ADDRSTRLEN  16     /* Maximum IPv4 dotted-decimal string */
#define INET6_ADDRSTRLEN 46     /* Maximum IPv6 hexadecimal string */</pre><p>We provide examples of the use of <span class="emphasis"><em>inet_pton()</em></span> and
                    <span class="emphasis"><em>inet_ntop()</em></span> in the next section.</p></div><div class="sect1" title="Client-Server Example (Datagram Sockets)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="client-server_example_open_parenthesis_d">Client-Server Example (Datagram Sockets)</h2></div></div></div><p>In this section, we take the case-conversion server and client programs shown in
                    <a class="xref" href="ch57.html#datagram_sockets_in_the_unix_domain" title="Datagram Sockets in the UNIX Domain">Datagram Sockets in the UNIX Domain</a> and modify them to use
                datagram sockets in the <code class="literal">AF_INET6</code> domain. We
                present these programs with a minimum of commentary, since their structure is
                similar to the earlier programs. The main differences in the new programs lie in the
                declaration and initialization of the IPv6 socket address structure, which we
                described in Section 59.4.<a id="IDX-CHP-59-7699" class="indexterm"/><a id="IDX-CHP-59-7700" class="indexterm"/><a id="IDX-CHP-59-7701" class="indexterm"/><a id="IDX-CHP-59-7702" class="indexterm"/><a id="IDX-CHP-59-7703" class="indexterm"/><a id="IDX-CHP-59-7704" class="indexterm"/><a id="IDX-CHP-59-7705" class="indexterm"/><a id="IDX-CHP-59-7706" class="indexterm"/><a id="IDX-CHP-59-7707" class="indexterm"/><a id="IDX-CHP-59-7708" class="indexterm"/></p><p>The client and server both employ the header file shown in <a class="xref" href="ch59.html#header_file_used_by_i6d_underscore_ucase" title="Example 59-2. Header file used by i6d_ucase_sv.c and i6d_ucase_cl.c">Example 59-2</a>. This header file defines
                the server’s port number and the maximum size of messages that the client and server
                can exchange.</p><div class="example"><a id="header_file_used_by_i6d_underscore_ucase"/><div class="example-title">Example 59-2. Header file used by <code class="literal">i6d_ucase_sv.c</code> and
                        <code class="literal">i6d_ucase_cl.c</code></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>sockets/i6d_ucase.h</code></strong>
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;ctype.h&gt;
#include "tlpi_hdr.h"

#define BUF_SIZE 10                     /* Maximum size of messages exchanged
                                           between client and server */

#define PORT_NUM 50002                  /* Server port number */
     <strong class="userinput"><code>sockets/i6d_ucase.h</code></strong></pre></div></div><p><a class="xref" href="ch59.html#ipv6_case-conversion_server_using_datagr" title="Example 59-3. IPv6 case-conversion server using datagram sockets">Example 59-3</a> shows the server
                program. The server uses the <span class="emphasis"><em>inet_ntop()</em></span> function to convert
                the host address of the client (obtained via the <span class="emphasis"><em>recvfrom()</em></span>
                call) to printable form.</p><p>The client program shown in <a class="xref" href="ch59.html#ipv6_case-conversion_client_using_datagr" title="Example 59-4. IPv6 case-conversion client using datagram sockets">Example 59-4</a> contains two notable
                modifications from the earlier UNIX domain version (<a class="xref" href="ch57.html#a_simple_unix_domain_datagram_client" title="Example 57-7. A simple UNIX domain datagram client">Example 57-7</a>, in <a class="xref" href="ch57.html#example_program-id72" title="Example program">Example program</a>). The first difference is that the client
                interprets its initial command-line argument as the IPv6 address of the server. (The
                remaining command-line arguments are passed as separate datagrams to the server.)
                The client converts the server address to binary form using
                    <span class="emphasis"><em>inet_pton()</em></span>. The other difference is that the client
                doesn’t bind its socket to an address. As noted in <a class="xref" href="ch58.html#port_numbers" title="Port Numbers">Port Numbers</a>,
                if an Internet domain socket is not bound to an address, the kernel binds the socket
                to an ephemeral port on the host system. We can observe this in the following shell
                session log, where we run the server and the client on the same host:</p><a id="I_programlisting59_d1e150839"/><pre class="programlisting">$ <strong class="userinput"><code>./i6d_ucase_sv &amp;</code></strong>
[1] 31047
$ <strong class="userinput"><code>./i6d_ucase_cl ::1 ciao</code></strong>                     <em class="lineannotation"><span class="lineannotation">Send to server on local host</span></em>
Server received 4 bytes from (::1, 32770)
Response 1: CIAO</pre><p>From the above output, we see that the server’s <span class="emphasis"><em>recvfrom()</em></span>
                call was able to obtain the address of the client’s socket, including the ephemeral
                port number, despite the fact that the client did not do a
                    <span class="emphasis"><em>bind()</em></span>.</p><div class="example"><a id="ipv6_case-conversion_server_using_datagr"/><div class="example-title">Example 59-3. IPv6 case-conversion server using datagram sockets</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>sockets/i6d_ucase_sv.c</code></strong>
#include "i6d_ucase.h"

int
main(int argc, char *argv[])
{
    struct sockaddr_in6 svaddr, claddr;
    int sfd, j;
    ssize_t numBytes;
    socklen_t len;
    char buf[BUF_SIZE];
    char claddrStr[INET6_ADDRSTRLEN];

    sfd = socket(AF_INET6, SOCK_DGRAM, 0);
    if (sfd == -1)
        errExit("socket");

    memset(&amp;svaddr, 0, sizeof(struct sockaddr_in6));
    svaddr.sin6_family = AF_INET6;
    svaddr.sin6_addr = in6addr_any;                    /* Wildcard address */
    svaddr.sin6_port = htons(PORT_NUM);

    if (bind(sfd, (struct sockaddr *) &amp;svaddr,
                sizeof(struct sockaddr_in6)) == -1)
        errExit("bind");

    /* Receive messages, convert to uppercase, and return to client */

    for (;;) {
        len = sizeof(struct sockaddr_in6);
        numBytes = recvfrom(sfd, buf, BUF_SIZE, 0,
                            (struct sockaddr *) &amp;claddr, &amp;len);
        if (numBytes == -1)
            errExit("recvfrom");

        if (inet_ntop(AF_INET6, &amp;claddr.sin6_addr, claddrStr,
                    INET6_ADDRSTRLEN) == NULL)
            printf("Couldn't convert client address to string\n");
        else
            printf("Server received %ld bytes from (%s, %u)\n",
                    (long) numBytes, claddrStr, ntohs(claddr.sin6_port));

        for (j = 0; j &lt; numBytes; j++)
            buf[j] = toupper((unsigned char) buf[j]);

        if (sendto(sfd, buf, numBytes, 0, (struct sockaddr *) &amp;claddr, len) !=
                numBytes)
            fatal("sendto");
    }
}
      <strong class="userinput"><code>sockets/i6d_ucase_sv.c</code></strong></pre></div></div><div class="example"><a id="ipv6_case-conversion_client_using_datagr"/><div class="example-title">Example 59-4. IPv6 case-conversion client using datagram sockets</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>sockets/i6d_ucase_cl.c</code></strong>
#include "i6d_ucase.h"

int
main(int argc, char *argv[])
{
    struct sockaddr_in6 svaddr;
    int sfd, j;
    size_t msgLen;
    ssize_t numBytes;
    char resp[BUF_SIZE];

    if (argc &lt; 3 || strcmp(argv[1], "--help") == 0)
        usageErr("%s host-address msg...\n", argv[0]);

    sfd = socket(AF_INET6, SOCK_DGRAM, 0);      /* Create client socket */
    if (sfd == -1)
        errExit("socket");

    memset(&amp;svaddr, 0, sizeof(struct sockaddr_in6));
    svaddr.sin6_family = AF_INET6;
    svaddr.sin6_port = htons(PORT_NUM);
    if (inet_pton(AF_INET6, argv[1], &amp;svaddr.sin6_addr) &lt;= 0)
        fatal("inet_pton failed for address '%s'", argv[1]);

    /* Send messages to server; echo responses on stdout */

    for (j = 2; j &lt; argc; j++) {
        msgLen = strlen(argv[j]);
        if (sendto(sfd, argv[j], msgLen, 0, (struct sockaddr *) &amp;svaddr,
                    sizeof(struct sockaddr_in6)) != msgLen)
            fatal("sendto");

        numBytes = recvfrom(sfd, resp, BUF_SIZE, 0, NULL, NULL);
        if (numBytes == -1)
            errExit("recvfrom");

        printf("Response %d: %.*s\n", j - 1, (int) numBytes, resp);
    }

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>sockets/i6d_ucase_cl.c</code></strong></pre></div></div></div><div class="sect1" title="Domain Name System (DNS)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="domain_name_system_open_parenthesis_dns">Domain Name System (DNS)</h2></div></div></div><p>In <a class="xref" href="ch59.html#protocol-independent_host_and_service_co" title="Protocol-Independent Host and Service Conversion">Protocol-Independent Host and Service Conversion</a>, we describe
                    <span class="emphasis"><em>getaddrinfo()</em></span>, which obtains the IP address(es)
                corresponding to a hostname, and <span class="emphasis"><em>getnameinfo()</em></span>, which performs
                the converse task. However, before looking at these functions, we explain how DNS is
                used to maintain the mappings between hostnames and IP addresses.<a id="IDX-CHP-59-7709" class="indexterm"/><a id="IDX-CHP-59-7710" class="indexterm"/><a id="IDX-CHP-59-7711" class="indexterm"/><a id="IDX-CHP-59-7712" class="indexterm"/><a id="IDX-CHP-59-7713" class="indexterm"/><a id="IDX-CHP-59-7714" class="indexterm"/><a id="IDX-CHP-59-7715" class="indexterm"/><a id="IDX-CHP-59-7716" class="indexterm"/><a id="IDX-CHP-59-7717" class="indexterm"/><a id="IDX-CHP-59-7718" class="indexterm"/><a id="IDX-CHP-59-7719" class="indexterm"/><a id="IDX-CHP-59-7720" class="indexterm"/><a id="IDX-CHP-59-7721" class="indexterm"/><a id="IDX-CHP-59-7722" class="indexterm"/><a id="IDX-CHP-59-7723" class="indexterm"/><a id="IDX-CHP-59-7724" class="indexterm"/><a id="IDX-CHP-59-7725" class="indexterm"/><a id="IDX-CHP-59-7726" class="indexterm"/><a id="IDX-CHP-59-7727" class="indexterm"/><a id="IDX-CHP-59-7728" class="indexterm"/></p><p>Before the advent of DNS, mappings between hostnames and IP addresses were defined
                in a manually maintained local file, <code class="literal">/etc/hosts</code>,
                containing records of the following form:</p><a id="I_programlisting59_d1e150994"/><pre class="programlisting"># IP-address    canonical hostname      [aliases]
127.0.0.1       localhost</pre><p>The <span class="emphasis"><em>gethostbyname()</em></span> function (the predecessor to
                    <span class="emphasis"><em>getaddrinfo()</em></span>) obtained an IP address by searching this
                file, looking for a match on either the canonical hostname (i.e., the official or
                primary name of the host) or one of the (optional, space-delimited)
                    aliases.<a id="IDX-CHP-59-7729" class="indexterm"/></p><p>However, the <code class="literal">/etc/hosts</code> scheme scales poorly,
                and then becomes impossible, as the number of hosts in the network increases (e.g.,
                the Internet, with millions of hosts).</p><p>DNS was devised to address this problem. The key ideas of DNS are the
                following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Hostnames are organized into a hierarchical namespace (<a class="xref" href="ch59.html#a_subset_of_the_dns_hierarchy" title="Figure 59-2. A subset of the DNS hierarchy">Figure 59-2</a>). Each
                            <span class="emphasis"><em>node</em></span> in the DNS hierarchy has a
                            <span class="emphasis"><em>label</em></span> (name), which may be up to 63 characters. At
                        the root of the hierarchy is an unnamed node, the “anonymous
                            root.”<a id="IDX-CHP-59-7730" class="indexterm"/></p></li><li class="listitem"><p>A node’s <span class="emphasis"><em>domain name</em></span> consists of all of the names
                        from that node up to the root concatenated together, with each name
                        separated by a period (<code class="literal">.</code>). For example,
                            <code class="literal">google.com</code> is the domain name for the
                        node <code class="literal">google</code>.<a id="IDX-CHP-59-7731" class="indexterm"/><a id="IDX-CHP-59-7732" class="indexterm"/></p></li><li class="listitem"><p>A <span class="emphasis"><em>fully qualified domain name</em></span> (FQDN), such as <a class="ulink" href="http://www.kernel.org" target="_top">www.kernel.org</a>., identifies a host
                        within the hierarchy. A fully qualified domain name is distinguished by
                        being terminated by a period, although in many contexts the period may be
                        omitted.</p></li><li class="listitem"><p>No single organization or system manages the entire hierarchy. Instead,
                        there is a hierarchy of DNS servers, each of which manages a branch (a
                            <span class="emphasis"><em>zone</em></span>) of the tree. Normally, each zone has a
                            <span class="emphasis"><em>primary master name server</em></span>, and one or more
                            <span class="emphasis"><em>slave name servers</em></span> (sometimes also known as
                            <span class="emphasis"><em>secondary master name servers</em></span>), which provide
                        backup in the event that the primary master name server crashes. Zones may
                        themselves be divided into separately managed smaller zones. When a host is
                        added within a zone, or the mapping of a hostname to an IP address is
                        changed, the administrator responsible for the corresponding local name
                        server updates the name database on that server. (No manual changes are
                        required on any other name-server databases in the hierarchy.)<a id="IDX-CHP-59-7733" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The DNS server implementation employed on Linux is the widely used
                            Berkeley Internet Name Domain (BIND) implementation,
                                <span class="emphasis"><em>named(8)</em></span>, maintained by the <span class="emphasis"><em>Internet
                                Systems Consortium</em></span> (<a class="ulink" href="http://www.isc.org/" target="_top">http://www.isc.org/</a>).
                            The operation of this daemon is controlled by the file <code class="literal">/etc/named.conf</code> (see the
                                <span class="emphasis"><em>named.conf(5)</em></span> manual page). The key reference
                            on DNS and BIND is [Albitz &amp; Liu, 2006]. Information about DNS
                            can also be found in <a class="xref" href="ch14.html" title="Chapter 14. File Systems">Chapter 14</a> of [Stevens, 1994],
                                <a class="xref" href="ch11.html" title="Chapter 11. System Limits and Options">Chapter 11</a> of [Stevens et al.,
                            2004], and <a class="xref" href="ch24.html" title="Chapter 24. Process Creation">Chapter 24</a> of [Comer,
                                2000].<a id="IDX-CHP-59-7734" class="indexterm"/><a id="IDX-CHP-59-7735" class="indexterm"/></p></div></li><li class="listitem"><p>When a program calls <span class="emphasis"><em>getaddrinfo()</em></span> to
                            <span class="emphasis"><em>resolve</em></span> (i.e., obtain the IP address for) a domain
                        name, <span class="emphasis"><em>getaddrinfo()</em></span> employs a suite of library
                        functions (the <span class="emphasis"><em>resolver library</em></span>) that communicate with
                        the local DNS server. If this server can’t supply the required information,
                        then it communicates with other DNS servers within the hierarchy in order to
                        obtain the information. Occasionally, this resolution process may take a
                        noticeable amount of time, and DNS servers employ caching techniques to
                        avoid unnecessary communication for frequently queried domain names.</p></li></ul></div><p>Using the above approach allows DNS to cope with large namespaces, and does not
                require centralized management of names.</p><div class="figure"><a id="a_subset_of_the_dns_hierarchy"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject59_d1e151135"/><img src="figs/web/59-2_SOCKINET-DNS-hierarchy-scale90.png.jpg" alt="A subset of the DNS hierarchy"/></div></div><div class="figure-title">Figure 59-2. A subset of the DNS hierarchy</div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="recursive_and_iterative_resolution"/></div></div></div><div class="sect3" title="Recursive and iterative resolution requests"><div class="titlepage"><div><div><h4 class="title" id="recursive_and_iterative_resolution-id1">Recursive and iterative resolution requests</h4></div></div></div><p>DNS resolution requests fall into two categories:
                            <span class="emphasis"><em>recursive</em></span> and <span class="emphasis"><em>iterative</em></span>. In a
                        recursive request, the requester asks the server to handle the entire task
                        of resolution, including the task of communicating with any other DNS
                        servers, if necessary. When an application on the local host calls
                            <span class="emphasis"><em>getaddrinfo()</em></span>, that function makes a recursive
                        request to the local DNS server. If the local DNS server does not itself
                        have the information to perform the resolution, it resolves the domain name
                            iteratively.<a id="IDX-CHP-59-7737" class="indexterm"/><a id="IDX-CHP-59-7738" class="indexterm"/><a id="IDX-CHP-59-7739" class="indexterm"/><a id="IDX-CHP-59-7740" class="indexterm"/><a id="IDX-CHP-59-7736" class="indexterm"/></p><p>We explain iterative resolution via an example. Suppose that the local DNS
                        server is asked to resolve the name <a class="ulink" href="http://www.otago.ac.nz" target="_top">www.otago.ac.nz</a>. To do this, it first communicates with one of
                        a small set of <span class="emphasis"><em>root name servers</em></span> that every DNS server
                        is required to know about. (We can obtain a list of these servers using the
                        command <span class="emphasis"><em>dig . NS</em></span> or from the web page at <a class="ulink" href="http://www.root-servers.org/" target="_top">http://www.root-servers.org/</a>.) Given the name <a class="ulink" href="http://www.otago.ac.nz" target="_top">www.otago.ac.nz</a>, the root name
                        server refers the local DNS server to one of the nz DNS servers. The local
                        DNS server then queries the <code class="literal">nz</code> server
                        with the name <a class="ulink" href="http://www.otago.ac.nz" target="_top">www.otago.ac.nz</a>,
                        and receives a response referring it to the ac.nz server. The local DNS
                        server then queries the ac.nz server with the name <a class="ulink" href="http://www.otago.ac.nz" target="_top">www.otago.ac.nz</a>, and is referred to
                        the otago.ac.nz server. Finally, the local DNS server queries the <code class="literal">otago.ac.nz</code> server with the name <a class="ulink" href="http://www.otago.ac.nz" target="_top">www.otago.ac.nz</a>, and obtains the
                        required IP address.<a id="IDX-CHP-59-7741" class="indexterm"/><a id="IDX-CHP-59-7742" class="indexterm"/></p><p>If we supply an incomplete domain name to
                            <span class="emphasis"><em>gethostbyname()</em></span>, the resolver will attempt to
                        complete it before resolving it. The rules on how a domain name is completed
                        are defined in <code class="literal">/etc/resolv.conf</code> (see the
                            <span class="emphasis"><em>resolv.conf(5)</em></span> manual page). By default, the
                        resolver will at least try completion using the domain name of the local
                        host. For example, if we are logged in on the machine <code class="literal">oghma.otago.ac.nz</code> and we type the command
                            <span class="emphasis"><em>ssh octavo</em></span>, the resulting DNS query will be for the
                        name <code class="literal">octavo.otago.ac.nz</code>.</p></div><div class="sect3" title="Top-level domains"><div class="titlepage"><div><div><h4 class="title" id="top-level_domains">Top-level domains</h4></div></div></div><p>The nodes immediately below the anonymous root form the so-called
                            <span class="emphasis"><em>top-level domains</em></span> (TLDs). (Below these are the
                            <span class="emphasis"><em>second-level domains</em></span>, and so on.) TLDs fall into
                        two categories: <span class="emphasis"><em>generic</em></span> and
                            <span class="emphasis"><em>country</em></span>.</p><p>Historically, there were seven <span class="emphasis"><em>generic</em></span> TLDs, most of
                        which can be considered international. We have shown four of the original
                        generic TLDs in <a class="xref" href="ch59.html#a_subset_of_the_dns_hierarchy" title="Figure 59-2. A subset of the DNS hierarchy">Figure 59-2</a>. The other
                        three are <code class="literal">int</code>, <code class="literal">mil</code>, and <code class="literal">gov</code>; the latter
                        two are reserved for the United States. In more recent times, a number of
                        new generic TLDs have been added (e.g., <code class="literal">info</code>, <code class="literal">name</code>, and <code class="literal">museum</code>).</p><p>Each nation has a corresponding <span class="emphasis"><em>country</em></span> (or
                            <span class="emphasis"><em>geographical</em></span>) TLD (standardized as ISO 3166-1),
                        with a 2-character name. In <a class="xref" href="ch59.html#a_subset_of_the_dns_hierarchy" title="Figure 59-2. A subset of the DNS hierarchy">Figure 59-2</a>,
                        we have shown a few of these: <code class="literal">de</code>
                        (Germany, <span class="emphasis"><em>Deutschland</em></span>), <code class="literal">eu</code> (a supra-national geographical TLD for the European
                        Union), <code class="literal">nz</code> (New Zealand), and <code class="literal">us</code> (United States of America). Several
                        countries divide their TLD into a set of second-level domains in a manner
                        similar to the generic domains. For example, New Zealand has <code class="literal">ac.nz</code> (academic institutions), <code class="literal">co.nz</code> (commercial), and <code class="literal">govt.nz</code> (government).</p></div></div></div><div class="sect1" title="The /etc/services File"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_solidus_etc_solidus_services_file">The <code class="literal">/etc/services</code> File</h2></div></div></div><p>As noted in <a class="xref" href="ch58.html#port_numbers" title="Port Numbers">Port Numbers</a>, well-known port numbers are centrally
                registered by IANA. Each of these ports has a corresponding <span class="emphasis"><em>service
                    name</em></span>. Because service numbers are centrally managed and are less
                volatile than IP addresses, an equivalent of the DNS server is usually not
                necessary. Instead, the port numbers and service names are recorded in the file
                    <code class="literal">/etc/services</code>. The
                    <span class="emphasis"><em>getaddrinfo()</em></span> and <span class="emphasis"><em>getnameinfo()</em></span>
                functions use the information in this file to convert service names to port numbers
                and vice versa.<a id="IDX-CHP-59-7743" class="indexterm"/><a id="IDX-CHP-59-7744" class="indexterm"/><a id="IDX-CHP-59-7745" class="indexterm"/></p><p>The <code class="literal">/etc/services</code> file consists of lines
                containing three columns, as shown in the following examples:<a id="IDX-CHP-59-7746" class="indexterm"/></p><a id="I_programlisting59_d1e151363"/><pre class="programlisting"># Service name  port/protocol  [aliases]
echo            7/tcp          Echo     # echo service
echo            7/udp          Echo
ssh             22/tcp                  # Secure Shell
ssh             22/udp
telnet          23/tcp                  # Telnet
telnet          23/udp
smtp            25/tcp                  # Simple Mail Transfer Protocol
smtp            25/udp
domain          53/tcp                  # Domain Name Server
domain          53/udp
http            80/tcp                  # Hypertext Transfer Protocol
http            80/udp
ntp             123/tcp                 # Network Time Protocol
ntp             123/udp
login           513/tcp                 # rlogin(1)
who             513/udp                 # rwho(1)
shell           514/tcp                 # rsh(1)
syslog          514/udp                 # syslog</pre><p>The <span class="emphasis"><em>protocol</em></span> is typically either <code class="literal">tcp</code> or <code class="literal">udp</code>. The optional
                (space-delimited) <span class="emphasis"><em>aliases</em></span> specify alternative names for the
                service. In addition to the above, lines may include comments starting with the
                    <code class="literal">#</code> character.</p><p>As noted previously, a given port number refers to distinct entities for UDP and
                TCP, but IANA policy assigns both port numbers to a service, even if that service
                uses only one protocol. For example, <span class="emphasis"><em>telnet</em></span>,
                    <span class="emphasis"><em>ssh</em></span>, HTTP, and SMTP all use TCP, but the corresponding UDP
                port is also assigned to these services. Conversely, NTP uses only UDP, but the TCP
                port 123 is also assigned to this service. In some cases, a service uses both UDP
                and TCP; DNS and <span class="emphasis"><em>echo</em></span> are examples of such services. Finally,
                there are a very few cases where the UDP and TCP ports with the same number are
                assigned to different services; for example, <span class="emphasis"><em>rsh</em></span> uses TCP port
                514, while the <span class="emphasis"><em>syslog</em></span> daemon (<a class="xref" href="ch37.html#logging_messages_and_errors_using_syslog" title="Logging Messages and Errors Using syslog">Logging Messages and Errors Using <span class="emphasis"><em>syslog</em></span></a>) uses UDP port 514. This is
                because these port numbers were assigned before the adoption of the present IANA
                policy.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <code class="literal">/etc/services</code> file is merely a record
                    of name-to-number mappings. It is not a reservation mechanism: the appearance of
                    a port number in <code class="literal">/etc/services</code> doesn’t
                    guarantee that it will actually be available for binding by a particular
                    service.</p></div></div><div class="sect1" title="Protocol-Independent Host and Service Conversion"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="protocol-independent_host_and_service_co">Protocol-Independent Host and Service Conversion</h2></div></div></div><p>The <span class="emphasis"><em>getaddrinfo()</em></span> function converts host and service names to
                IP addresses and port numbers. It was defined in POSIX.1g as the (reentrant)
                successor to the obsolete <span class="emphasis"><em>gethostbyname()</em></span> and
                    <span class="emphasis"><em>getservbyname()</em></span> functions. (Replacing the use of
                    <span class="emphasis"><em>gethostbyname()</em></span> with <span class="emphasis"><em>getaddrinfo()</em></span>
                allows us to eliminate IPv4-versus-IPv6 dependencies from our programs.)<a id="IDX-CHP-59-7747" class="indexterm"/><a id="IDX-CHP-59-7748" class="indexterm"/><a id="IDX-CHP-59-7749" class="indexterm"/></p><p>The <span class="emphasis"><em>getnameinfo()</em></span> function is the converse of
                    <span class="emphasis"><em>getaddrinfo()</em></span>. It translates a socket address structure
                (either IPv4 or IPv6) to strings containing the corresponding host and service name.
                This function is the (reentrant) equivalent of the obsolete
                    <span class="emphasis"><em>gethostbyaddr()</em></span> and <span class="emphasis"><em>getservbyport()</em></span>
                functions.</p><div class="note" title="Note"><h3 class="title">Note</h3><p><a class="xref" href="ch11.html" title="Chapter 11. System Limits and Options">Chapter 11</a> of [Stevens et al., 2004]
                    describes <span class="emphasis"><em>getaddrinfo()</em></span> and
                        <span class="emphasis"><em>getnameinfo()</em></span> in detail, and provides implementations
                    of these functions. These functions are also described in RFC 3493.<a id="IDX-CHP-59-7750" class="indexterm"/></p></div><div class="sect2" title="The getaddrinfo() Function"><div class="titlepage"><div><div><h3 class="title" id="the_getaddrinfo_open_parenthesis_close_p">The <span class="emphasis"><em>getaddrinfo()</em></span> Function</h3></div></div></div><p>Given a host name and a service name, <span class="emphasis"><em>getaddrinfo()</em></span>
                    returns a list of socket address structures, each of which contains an IP
                    address and port number.<a id="IDX-CHP-59-7751" class="indexterm"/><a id="IDX-CHP-59-7752" class="indexterm"/><a id="IDX-CHP-59-7753" class="indexterm"/></p><a id="I_programlisting59_d1e151502"/><pre class="programlisting">#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int <strong class="userinput"><code>getaddrinfo</code></strong>(const char *<span class="emphasis"><em>host</em></span>, const char *<span class="emphasis"><em>service</em></span>,
                const struct addrinfo *<span class="emphasis"><em>hints</em></span>, struct addrinfo **<span class="emphasis"><em>result</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or nonzero on error</p></div><p>As input, <span class="emphasis"><em>getaddrinfo()</em></span> takes the arguments
                        <span class="emphasis"><em>host</em></span>, <span class="emphasis"><em>service</em></span>, and
                        <span class="emphasis"><em>hints</em></span>. The <span class="emphasis"><em>host</em></span> argument contains
                    either a hostname or a numeric address string, expressed in IPv4 dotted-decimal
                    notation or IPv6 hex-string notation. (To be precise,
                        <span class="emphasis"><em>getaddrinfo()</em></span> accepts IPv4 numeric strings in the more
                    general numbers-and-dots notation described in <a class="xref" href="ch59.html#the_inet_underscore_aton_open_parenthesi" title="The inet_aton() and inet_ntoa() Functions">The <span class="emphasis"><em>inet_aton()</em></span> and <span class="emphasis"><em>inet_ntoa()</em></span>
                    Functions</a>.) The
                        <span class="emphasis"><em>service</em></span> argument contains either a service name or a
                    decimal port number. The <span class="emphasis"><em>hints</em></span> argument points to an
                        <span class="emphasis"><em>addrinfo</em></span> structure that specifies further criteria for
                    selecting the socket address structures returned via
                    <span class="emphasis"><em>result</em></span>. We describe the <span class="emphasis"><em>hints</em></span> argument
                    in more detail below.<a id="IDX-CHP-59-7754" class="indexterm"/></p><p>As output, <span class="emphasis"><em>getaddrinfo()</em></span> dynamically allocates a linked
                    list of <span class="emphasis"><em>addrinfo</em></span> structures and sets
                        <span class="emphasis"><em>result</em></span> pointing to the beginning of this list. Each of
                    these <span class="emphasis"><em>addrinfo</em></span> structures includes a pointer to a socket
                    address structure corresponding to <span class="emphasis"><em>host</em></span> and
                        <span class="emphasis"><em>service</em></span> (<a class="xref" href="ch59.html#structures_allocated_and_returned_by_get" title="Figure 59-3. Structures allocated and returned by getaddrinfo()">Figure 59-3</a>). The
                        <span class="emphasis"><em>addrinfo</em></span> structure has the following form:</p><a id="I_programlisting59_d1e151592"/><pre class="programlisting">struct addrinfo {
    int    ai_flags;            /* Input flags (AI_* constants) */
    int    ai_family;           /* Address family */
    int    ai_socktype;         /* Type: SOCK_STREAM, SOCK_DGRAM */
    int    ai_protocol;         /* Socket protocol */
    size_t ai_addrlen;          /* Size of structure pointed to by ai_addr */
    char  *ai_canonname;        /* Canonical name of host */
    struct sockaddr *ai_addr;   /* Pointer to socket address structure */
    struct addrinfo *ai_next;   /* Next structure in linked list */
};</pre><p>The <span class="emphasis"><em>result</em></span> argument returns a list of structures, rather
                    than a single structure, because there may be multiple combinations of host and
                    service corresponding to the criteria specified in <span class="emphasis"><em>host</em></span>,
                        <span class="emphasis"><em>service</em></span>, and <span class="emphasis"><em>hints</em></span>. For example,
                    multiple address structures could be returned for a host with more than one
                    network interface. Furthermore, if <span class="emphasis"><em>hints.ai_socktype</em></span> was
                    specified as 0, then two structures could be returned—one for a <code class="literal">SOCK_DGRAM</code> socket, the other for a <code class="literal">SOCK_STREAM</code> socket—if the given
                        <span class="emphasis"><em>service</em></span> was available for both UDP and TCP.</p><p>The fields of each <span class="emphasis"><em>addrinfo</em></span> structure returned via
                        <span class="emphasis"><em>result</em></span> describe properties of the associated socket
                    address structure. The <span class="emphasis"><em>ai_family</em></span> field is set to either
                        <code class="literal">AF_INET</code> or <code class="literal">AF_INET6</code>, informing us of the type of the socket address
                    structure. The <span class="emphasis"><em>ai_socktype</em></span> field is set to either <code class="literal">SOCK_STREAM</code> or <code class="literal">SOCK_DGRAM</code>, indicating whether this address structure is for a
                    TCP or a UDP service. The <span class="emphasis"><em>ai_protocol</em></span> field returns a
                    protocol value appropriate for the address family and socket type. (The three
                    fields <span class="emphasis"><em>ai_family</em></span>, <span class="emphasis"><em>ai_socktype</em></span>, and
                        <span class="emphasis"><em>ai_protocol</em></span> supply the values required for the
                    arguments used when calling <span class="emphasis"><em>socket()</em></span> to create a socket for
                    this address.) The <span class="emphasis"><em>ai_addrlen</em></span> field gives the size (in
                    bytes) of the socket address structure pointed to by
                        <span class="emphasis"><em>ai_addr</em></span>. The <span class="emphasis"><em>in_addr</em></span> field points
                    to the socket address structure (an <span class="emphasis"><em>in_addr</em></span> structure for
                    IPv4 or an <span class="emphasis"><em>in6_addr</em></span> structure for IPv6). The
                        <span class="emphasis"><em>ai_flags</em></span> field is unused (it is used for the
                        <span class="emphasis"><em>hints</em></span> argument). The <span class="emphasis"><em>ai_canonname</em></span>
                    field is used only in the first <span class="emphasis"><em>addrinfo</em></span> structure, and
                    only if the <code class="literal">AI_CANONNAME</code> flag is employed in
                        <span class="emphasis"><em>hints.ai_flags</em></span>, as described below.</p><p>As with <span class="emphasis"><em>gethostbyname()</em></span>,
                        <span class="emphasis"><em>getaddrinfo()</em></span> may need to send a request to a DNS
                    server, and this request may take some time to complete. The same applies for
                        <span class="emphasis"><em>getnameinfo()</em></span>, which we describe in <a class="xref" href="ch59.html#the_getnameinfo_open_parenthesis_close_p" title="The getnameinfo() Function">The <span class="emphasis"><em>getnameinfo()</em></span> Function</a>.</p><p>We demonstrate the use of <span class="emphasis"><em>getaddrinfo()</em></span> in <a class="xref" href="ch59.html#client-server_example_open_parenthesis_s" title="Client-Server Example (Stream Sockets)">Client-Server Example (Stream Sockets)</a>.</p><div class="figure"><a id="structures_allocated_and_returned_by_get"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject59_d1e151725"/><img src="figs/web/59-3_SOCKINET-addrinfo-list-scale90.png.jpg" alt="Structures allocated and returned by getaddrinfo()"/></div></div><div class="figure-title">Figure 59-3. Structures allocated and returned by
                        <span class="emphasis"><em>getaddrinfo()</em></span></div></div><div class="sect3" title="The hints argument"><div class="titlepage"><div><div><h4 class="title" id="the_hints_argument">The <span class="emphasis"><em>hints</em></span> argument</h4></div></div></div><p>The <span class="emphasis"><em>hints</em></span> argument specifies further criteria for
                        selecting the socket address structures returned by
                            <span class="emphasis"><em>getaddrinfo()</em></span>. When used as the
                            <span class="emphasis"><em>hints</em></span> argument, only the
                            <span class="emphasis"><em>ai_flags</em></span>, <span class="emphasis"><em>ai_family</em></span>,
                            <span class="emphasis"><em>ai_socktype</em></span>, and <span class="emphasis"><em>ai_protocol</em></span>
                        fields of the <span class="emphasis"><em>addrinfo</em></span> structure can be set. The other
                        fields are unused, and should be initialized to 0 or <code class="literal">NULL</code>, as appropriate.<a id="IDX-CHP-59-7755" class="indexterm"/><a id="IDX-CHP-59-7756" class="indexterm"/><a id="IDX-CHP-59-7757" class="indexterm"/><a id="IDX-CHP-59-7758" class="indexterm"/><a id="IDX-CHP-59-7759" class="indexterm"/><a id="IDX-CHP-59-7760" class="indexterm"/><a id="IDX-CHP-59-7761" class="indexterm"/><a id="IDX-CHP-59-7762" class="indexterm"/><a id="IDX-CHP-59-7763" class="indexterm"/><a id="IDX-CHP-59-7764" class="indexterm"/></p><p>The <span class="emphasis"><em>hints.ai_family</em></span> field selects the domain for the
                        returned socket address structures. It may be specified as <code class="literal">AF_INET</code> or <code class="literal">AF_INET6</code> (or some other <code class="literal">AF_*</code> constant, if the implementation supports it). If we are
                        interested in getting back all types of socket address structures, we can
                        specify the value <code class="literal">AF_UNSPEC</code> for this
                        field.</p><p>The <span class="emphasis"><em>hints.ai_socktype</em></span> field specifies the type of
                        socket for which the returned address structure is to be used. If we specify
                        this field as <code class="literal">SOCK_DGRAM</code>, then a lookup
                        is performed for the UDP service, and a corresponding socket address
                        structure is returned via <span class="emphasis"><em>result</em></span>. If we specify
                            <code class="literal">SOCK_STREAM</code>, a lookup for the TCP
                        service is performed. If <span class="emphasis"><em>hints.ai_socktype</em></span> is specified
                        as 0, any socket type is acceptable.</p><p>The <span class="emphasis"><em>hints.ai_protocol</em></span> field selects the socket
                        protocol for the returned address structures. For our purposes, this field
                        is always specified as 0, meaning that the caller will accept any
                        protocol.</p><p>The <span class="emphasis"><em>hints.ai_flags</em></span> field is a bit mask that modifies
                        the behavior of <span class="emphasis"><em>getaddrinfo()</em></span>. This field is formed by
                        ORing together zero or more of the following values:</p><div class="variablelist"><dl><dt><span class="term">
                                <code class="literal">AI_ADDRCONFIG</code>
                            </span></dt><dd><p>Return IPv4 addresses only if there is at least one IPv4
                                    address configured for the local system (other than the IPv4
                                    loopback address), and return IPv6 addresses only if there is at
                                    least one IPv6 address configured for the local system (other
                                    than the IPv6 loopback address).</p></dd><dt><span class="term">
                                <code class="literal">AI_ALL</code>
                            </span></dt><dd><p>See the description of <code class="literal">AI_V4MAPPED</code> below.</p></dd><dt><span class="term">
                                <code class="literal">AI_CANONNAME</code>
                            </span></dt><dd><p>If <span class="emphasis"><em>host</em></span> is not <code class="literal">NULL</code>, return a pointer to a null-terminated
                                    string containing the canonical name of the host. This pointer
                                    is returned in a buffer pointed to by the
                                        <span class="emphasis"><em>ai_canonname</em></span> field of the first of the
                                        <span class="emphasis"><em>addrinfo</em></span> structures returned via
                                        <span class="emphasis"><em>result</em></span>.<a id="IDX-CHP-59-7765" class="indexterm"/></p></dd><dt><span class="term">
                                <code class="literal">AI_NUMERICHOST</code>
                            </span></dt><dd><p>Force interpretation of <span class="emphasis"><em>host</em></span> as a numeric
                                    address string. This is used to prevent name resolution in cases
                                    where it is unnecessary, since name resolution can be
                                    time-consuming.</p></dd><dt><span class="term">
                                <code class="literal">AI_NUMERICSERV</code>
                            </span></dt><dd><p>Interpret <span class="emphasis"><em>service</em></span> as a numeric port
                                    number. This flag prevents the invocation of any name-resolution
                                    service, which is not required if <span class="emphasis"><em>service</em></span>
                                    is a numeric string.</p></dd><dt><span class="term">
                                <code class="literal">AI_PASSIVE</code>
                            </span></dt><dd><p>Return socket address structures suitable for a passive open
                                    (i.e., a listening socket). In this case,
                                        <span class="emphasis"><em>host</em></span> should be <code class="literal">NULL</code>, and the IP address component of the socket
                                    address structure(s) returned by <span class="emphasis"><em>result</em></span>
                                    will contain a wildcard IP address (i.e., <code class="literal">INADDR_ANY</code> or <code class="literal">IN6ADDR_ANY_INIT</code>). If this flag is
                                    not set, then the address structure(s) returned via
                                        <span class="emphasis"><em>result</em></span> will be suitable for use with
                                        <span class="emphasis"><em>connect()</em></span> and
                                        <span class="emphasis"><em>sendto()</em></span>; if <span class="emphasis"><em>host</em></span>
                                    is <code class="literal">NULL</code>, then the IP address
                                    in the returned socket address structures will be set to the
                                    loopback IP address (either <code class="literal">INADDR_LOOPBACK</code> or <code class="literal">IN6ADDR_LOOPBACK_INIT</code>, according to the
                                    domain).</p></dd><dt><span class="term">
                                <code class="literal">AI_V4MAPPED</code>
                            </span></dt><dd><p>If <code class="literal">AF_INET6</code> was specified
                                    in the <span class="emphasis"><em>ai_family</em></span> field of
                                        <span class="emphasis"><em>hints</em></span>, then IPv4-mapped IPv6 address
                                    structures should be returned in <span class="emphasis"><em>result</em></span> if
                                    no matching IPv6 address could be found. If <code class="literal">AI_ALL</code> is specified in conjunction
                                    with <code class="literal">AI_V4MAPPED</code>, then both
                                    IPv6 and IPv4 address structures are returned in
                                        <span class="emphasis"><em>result</em></span>, with IPv4 addresses being
                                    returned as IPv4-mapped IPv6 address structures.</p></dd></dl></div><p>As noted above for <code class="literal">AI_PASSIVE</code>,
                            <span class="emphasis"><em>host</em></span> can be specified as <code class="literal">NULL</code>. It is also possible to specify
                            <span class="emphasis"><em>service</em></span> as <code class="literal">NULL</code>,
                        in which case the port number in the returned address structures is set to 0
                        (i.e., we are just interested in resolving hostnames to addresses). It is
                        not permitted, however, to specify both <span class="emphasis"><em>host</em></span> and
                            <span class="emphasis"><em>service</em></span> as <code class="literal">NULL</code>.</p><p>If we don’t need to specify any of the above selection criteria in hints,
                        then <span class="emphasis"><em>hints</em></span> may be specified as <code class="literal">NULL</code>, in which case <span class="emphasis"><em>ai_socktype</em></span> and
                            <span class="emphasis"><em>ai_protocol</em></span> are assumed as 0,
                            <span class="emphasis"><em>ai_flags</em></span> is assumed as <code class="literal">(AI_V4MAPPED | AI_ADDRCONFIG)</code>, and
                            <span class="emphasis"><em>ai_family</em></span> is assumed as <code class="literal">AF_UNSPEC</code>. (The <span class="emphasis"><em>glibc</em></span> implementation
                        deliberately deviates from SUSv3, which states that if
                            <span class="emphasis"><em>hints</em></span> is <code class="literal">NULL</code>,
                            <span class="emphasis"><em>ai_flags</em></span> is assumed as 0.)</p></div></div><div class="sect2" title="Freeing addrinfo Lists: freeaddrinfo()"><div class="titlepage"><div><div><h3 class="title" id="freeing_addrinfo_lists_colon_freeaddrinf">Freeing <span class="emphasis"><em>addrinfo</em></span> Lists:
                        <span class="emphasis"><em>freeaddrinfo()</em></span></h3></div></div></div><p>The <span class="emphasis"><em>getaddrinfo()</em></span> function dynamically allocates memory
                    for all of the structures referred to by <span class="emphasis"><em>result</em></span> (<a class="xref" href="ch59.html#structures_allocated_and_returned_by_get" title="Figure 59-3. Structures allocated and returned by getaddrinfo()">Figure 59-3</a>). Consequently, the
                    caller must deallocate these structures when they are no longer needed. The
                        <span class="emphasis"><em>freeaddrinfo()</em></span> function is provided to conveniently
                    perform this deallocation in a single step.<a id="IDX-CHP-59-7767" class="indexterm"/><a id="IDX-CHP-59-7768" class="indexterm"/><a id="IDX-CHP-59-7769" class="indexterm"/><a id="IDX-CHP-59-7770" class="indexterm"/><a id="IDX-CHP-59-7771" class="indexterm"/><a id="IDX-CHP-59-7772" class="indexterm"/><a id="IDX-CHP-59-7773" class="indexterm"/><a id="IDX-CHP-59-7774" class="indexterm"/><a id="IDX-CHP-59-7775" class="indexterm"/><a id="IDX-CHP-59-7776" class="indexterm"/><a id="IDX-CHP-59-7777" class="indexterm"/><a id="IDX-CHP-59-7778" class="indexterm"/><a id="IDX-CHP-59-7779" class="indexterm"/><a id="IDX-CHP-59-7780" class="indexterm"/><a id="IDX-CHP-59-7766" class="indexterm"/></p><a id="I_programlisting59_d1e152175"/><pre class="programlisting">#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

void <strong class="userinput"><code>freeaddrinfo</code></strong>(struct addrinfo *<span class="emphasis"><em>result</em></span>);</pre><p>If we want to preserve a copy of one of the <span class="emphasis"><em>addrinfo</em></span>
                    structures or its associated socket address structure, then we must duplicate
                    the structure(s) before calling <span class="emphasis"><em>freeaddrinfo()</em></span>.</p></div><div class="sect2" title="Diagnosing Errors: gai_strerror()"><div class="titlepage"><div><div><h3 class="title" id="diagnosing_errors_colon_gai_underscore_s">Diagnosing Errors: <span class="emphasis"><em>gai_strerror()</em></span></h3></div></div></div><p>On error, <span class="emphasis"><em>getaddrinfo()</em></span> returns one of the nonzero error
                    codes shown in <a class="xref" href="ch59.html#error_returns_for_getaddrinfo_open_paren" title="Table 59-1. Error returns for getaddrinfo() and getnameinfo()">Table 59-1</a>.<a id="IDX-CHP-59-7781" class="indexterm"/></p><div class="table"><a id="error_returns_for_getaddrinfo_open_paren"/><div class="table-title">Table 59-1. Error returns for <span class="emphasis"><em>getaddrinfo()</em></span> and
                            <span class="emphasis"><em>getnameinfo()</em></span></div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Error constant</p>
                                </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                    <p>Description</p>
                                </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">EAI_ADDRFAMILY</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>No addresses for <span class="emphasis"><em>host exist</em></span> in
                                            <span class="emphasis"><em>hints.ai_family</em></span> (not in SUSv3, but
                                        defined on most implementations;
                                            <span class="emphasis"><em>getaddrinfo()</em></span> only)</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">EAI_AGAIN</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Temporary failure in name resolution (try again
                                        later)</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">EAI_BADFLAGS</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>An invalid flag was specified in
                                            <span class="emphasis"><em>hints.ai_flags</em></span></p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">EAI_FAIL</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Unrecoverable failure while accessing name server</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">EAI_FAMILY</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Address family specified in
                                            <span class="emphasis"><em>hints.ai_family</em></span> is not
                                        supported</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">EAI_MEMORY</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Memory allocation failure</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">EAI_NODATA</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>No address associated with <span class="emphasis"><em>host</em></span> (not
                                        in SUSv3, but defined on most implementations;
                                            <span class="emphasis"><em>getaddrinfo()</em></span> only)</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">EAI_NONAME</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Unknown <span class="emphasis"><em>host</em></span> or
                                            <span class="emphasis"><em>service</em></span>, or both
                                            <span class="emphasis"><em>host</em></span> and
                                            <span class="emphasis"><em>service</em></span> were <code class="literal">NULL</code>, or <code class="literal">AI_NUMERICSERV</code> specified and
                                            <span class="emphasis"><em>service</em></span> didn’t point to numeric
                                        string</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">EAI_OVERFLOW</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Argument buffer overflow</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">EAI_SERVICE</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Specified <span class="emphasis"><em>service</em></span> not supported for
                                            <span class="emphasis"><em>hints.ai_socktype</em></span>
                                            (<span class="emphasis"><em>getaddrinfo()</em></span> only)</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">EAI_SOCKTYPE</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Specified <span class="emphasis"><em>hints.ai_socktype</em></span> is not
                                        supported (<span class="emphasis"><em>getaddrinfo()</em></span> only)</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">EAI_SYSTEM</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; ">
                                    <p>System error returned in <span class="emphasis"><em>errno</em></span></p>
                                </td></tr></tbody></table></div></div><p>Given one of the error codes in <a class="xref" href="ch59.html#error_returns_for_getaddrinfo_open_paren" title="Table 59-1. Error returns for getaddrinfo() and getnameinfo()">Table 59-1</a>, the
                        <span class="emphasis"><em>gai_strerror()</em></span> function returns a string describing the
                    error. (This string is typically briefer than the description shown in <a class="xref" href="ch59.html#error_returns_for_getaddrinfo_open_paren" title="Table 59-1. Error returns for getaddrinfo() and getnameinfo()">Table 59-1</a>.)</p><a id="I_programlisting59_d1e152392"/><pre class="programlisting">#include &lt;netdb.h&gt;

const char *<strong class="userinput"><code>gai_strerror</code></strong>(int <span class="emphasis"><em>errcode</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer to string containing error message</p></div><p>We can use the string returned by <span class="emphasis"><em>gai_strerror()</em></span> as part
                    of an error message displayed by an application.</p></div><div class="sect2" title="The getnameinfo() Function"><div class="titlepage"><div><div><h3 class="title" id="the_getnameinfo_open_parenthesis_close_p">The <span class="emphasis"><em>getnameinfo()</em></span> Function</h3></div></div></div><p>The <span class="emphasis"><em>getnameinfo()</em></span> function is the converse of
                        <span class="emphasis"><em>getaddrinfo()</em></span>. Given a socket address structure (either
                    IPv4 or IPv6), it returns strings containing the corresponding host and service
                    name, or numeric equivalents if the names can’t be resolved.<a id="IDX-CHP-59-7783" class="indexterm"/><a id="IDX-CHP-59-7784" class="indexterm"/><a id="IDX-CHP-59-7785" class="indexterm"/><a id="IDX-CHP-59-7786" class="indexterm"/><a id="IDX-CHP-59-7787" class="indexterm"/><a id="IDX-CHP-59-7788" class="indexterm"/><a id="IDX-CHP-59-7789" class="indexterm"/><a id="IDX-CHP-59-7782" class="indexterm"/></p><a id="I_programlisting59_d1e152466"/><pre class="programlisting">#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int <strong class="userinput"><code>getnameinfo</code></strong>(const struct sockaddr *<span class="emphasis"><em>addr</em></span>, socklen_t <span class="emphasis"><em>addrlen</em></span>, char *<span class="emphasis"><em>host</em></span>,
                size_t <span class="emphasis"><em>hostlen</em></span>, char *<span class="emphasis"><em>service</em></span>, size_t <span class="emphasis"><em>servlen</em></span>, int <span class="emphasis"><em>flags</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or nonzero on error</p></div><p>The <span class="emphasis"><em>addr</em></span> argument is a pointer to the socket address
                    structure that is to be converted. The length of that structure is given in
                        <span class="emphasis"><em>addrlen</em></span>. Typically, the values for
                        <span class="emphasis"><em>addr</em></span> and <span class="emphasis"><em>addrlen</em></span> are obtained from
                    a call to <span class="emphasis"><em>accept()</em></span>, <span class="emphasis"><em>recvfrom()</em></span>,
                        <span class="emphasis"><em>getsockname()</em></span>, or
                    <span class="emphasis"><em>getpeername()</em></span>.</p><p>The resulting host and service names are returned as null-terminated strings
                    in the buffers pointed to by <span class="emphasis"><em>host</em></span> and
                        <span class="emphasis"><em>service</em></span>. These buffers must be allocated by the caller,
                    and their sizes must be passed in <span class="emphasis"><em>hostlen</em></span> and
                        <span class="emphasis"><em>servlen</em></span>. The <code class="literal">&lt;netdb.h&gt;</code> header file defines two constants to
                    assist in sizing these buffers. <code class="literal">NI_MAXHOST</code>
                    indicates the maximum size, in bytes, for a returned hostname string. It is
                    defined as 1025. <code class="literal">NI_MAXSERV</code> indicates the
                    maximum size, in bytes, for a returned service name string. It is defined as 32.
                    These two constants are not specified in SUSv3, but they are defined on all UNIX
                    implementations that provide <span class="emphasis"><em>getnameinfo()</em></span>. (Since
                        <span class="emphasis"><em>glibc</em></span> 2.8, we must define one of the feature text
                    macros <code class="literal">_BSD_SOURCE</code>, <code class="literal">_SVID_SOURCE</code>, or <code class="literal">_GNU_SOURCE</code>
                    to obtain the definitions of <code class="literal">NI_MAXHOST</code> and
                        <code class="literal">NI_MAXSERV</code>.)</p><p>If we are not interested in obtaining the hostname, we can specify
                        <span class="emphasis"><em>host</em></span> as <code class="literal">NULL</code> and
                        <span class="emphasis"><em>hostlen</em></span> as 0. Similarly, if we don’t need the service
                    name, we can specify <span class="emphasis"><em>service</em></span> as <code class="literal">NULL</code> and <span class="emphasis"><em>servlen</em></span> as 0. However, at least one
                    of <span class="emphasis"><em>host</em></span> and <span class="emphasis"><em>service</em></span> must be
                        non-<code class="literal">NULL</code> (and the corresponding length
                    argument must be nonzero).</p><p>The final argument, <span class="emphasis"><em>flags</em></span>, is a bit mask that controls
                    the behavior of <span class="emphasis"><em>getnameinfo()</em></span>. The following constants may
                    be ORed together to form this bit mask:</p><div class="variablelist"><dl><dt><span class="term">
                            <code class="literal">NI_DGRAM</code>
                        </span></dt><dd><p>By default, <span class="emphasis"><em>getnameinfo()</em></span> returns the name
                                corresponding to a <span class="emphasis"><em>stream</em></span> socket (i.e., TCP)
                                service. Normally, this doesn’t matter, because, as noted in <a class="xref" href="ch59.html#the_solidus_etc_solidus_services_file" title="The /etc/services File">The <code class="literal">/etc/services</code> File</a>, the service
                                names are usually the same for corresponding TCP and UDP ports.
                                However, in the few instances where the names differ, the <code class="literal">NI_DGRAM</code> flag forces the name of the
                                datagram socket (i.e., UDP) service to be returned.</p></dd><dt><span class="term">
                            <code class="literal">NI_NAMEREQD</code>
                        </span></dt><dd><p>By default, if the hostname can’t be resolved, a numeric address
                                string is returned in <span class="emphasis"><em>host</em></span>. If the <code class="literal">NI_NAMEREQD</code> flag is specified, an
                                error (<code class="literal">EAI_NONAME</code>) is returned
                                instead.</p></dd><dt><span class="term">
                            <code class="literal">NI_NOFQDN</code>
                        </span></dt><dd><p>By default, the fully qualified domain name for the host is
                                returned. Specifying the <code class="literal">NI_NOFQDN</code> flag causes just the first (i.e., the
                                hostname) part of the name to be returned, if this is a host on the
                                local network.</p></dd><dt><span class="term">
                            <code class="literal">NI_NUMERICHOST</code>
                        </span></dt><dd><p>Force a numeric address string to be returned in
                                    <span class="emphasis"><em>host</em></span>. This is useful if we want to avoid a
                                possibly time-consuming call to the DNS server.</p></dd><dt><span class="term">
                            <code class="literal">NI_NUMERICSERV</code>
                        </span></dt><dd><p>Force a decimal port number string to be returned in
                                    <span class="emphasis"><em>service</em></span>. This is useful in cases where we
                                know that the port number doesn’t correspond to a service name—for
                                example, if it is an ephemeral port number assigned to the socket by
                                the kernel—and we want to avoid the inefficiency of unnecessarily
                                searching <code class="literal">/etc/services</code>.</p></dd></dl></div><p>On success, <span class="emphasis"><em>getnameinfo()</em></span> returns 0. On error, it returns
                    one of the nonzero error codes shown in <a class="xref" href="ch59.html#error_returns_for_getaddrinfo_open_paren" title="Table 59-1. Error returns for getaddrinfo() and getnameinfo()">Table 59-1</a>.</p></div></div><div class="sect1" title="Client-Server Example (Stream Sockets)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="client-server_example_open_parenthesis_s">Client-Server Example (Stream Sockets)</h2></div></div></div><p>We now have enough information to look at a simple client-server application using
                TCP sockets. The task performed by this application is the same as that performed by
                the FIFO client-server application presented in <a class="xref" href="ch44.html#a_client-server_application_using_fifos" title="A Client-Server Application Using FIFOs">A Client-Server Application Using FIFOs</a>: allocating unique sequence
                numbers (or ranges of sequence numbers) to clients.<a id="IDX-CHP-59-7790" class="indexterm"/><a id="IDX-CHP-59-7791" class="indexterm"/><a id="IDX-CHP-59-7792" class="indexterm"/><a id="IDX-CHP-59-7793" class="indexterm"/><a id="IDX-CHP-59-7794" class="indexterm"/></p><p>In order to handle the possibility that integers may be represented in different
                formats on the server and client hosts, we encode all transmitted integers as
                strings terminated by a newline, and use our <span class="emphasis"><em>readLine()</em></span>
                function (<a class="xref" href="ch59.html#reading_data_a_line_at_a_time" title="Example 59-1. Reading data a line at a time">Example 59-1</a>) to read these
                strings.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="common_header_file-id3"/></div></div></div><div class="sect3" title="Common header file"><div class="titlepage"><div><div><h4 class="title" id="common_header_file-id4">Common header file</h4></div></div></div><p>Both the server and the client include the header file shown in <a class="xref" href="ch59.html#header_file_used_by_is_underscore_seqnum" title="Example 59-5. Header file used by is_seqnum_sv.c and is_seqnum_cl.c">Example 59-5</a>. This file includes
                        various other header files, and defines the TCP port number to be used by
                        the application.</p></div><div class="sect3" title="Server program"><div class="titlepage"><div><div><h4 class="title" id="server_program-id2">Server program</h4></div></div></div><p>The server program shown in <a class="xref" href="ch59.html#an_iterative_server_that_uses_a_stream_s" title="Example 59-6. An iterative server that uses a stream socket to communicate with clients">Example 59-6</a> performs the
                        following steps:<a id="IDX-CHP-59-7795" class="indexterm"/><a id="IDX-CHP-59-7796" class="indexterm"/><a id="IDX-CHP-59-7797" class="indexterm"/><a id="IDX-CHP-59-7798" class="indexterm"/><a id="IDX-CHP-59-7799" class="indexterm"/><a id="IDX-CHP-59-7800" class="indexterm"/><a id="IDX-CHP-59-7801" class="indexterm"/><a id="IDX-CHP-59-7802" class="indexterm"/><a id="IDX-CHP-59-7803" class="indexterm"/><a id="IDX-CHP-59-7804" class="indexterm"/><a id="IDX-CHP-59-7805" class="indexterm"/><a id="IDX-CHP-59-7806" class="indexterm"/><a id="IDX-CHP-59-7807" class="indexterm"/><a id="IDX-CHP-59-7808" class="indexterm"/><a id="IDX-CHP-59-7809" class="indexterm"/><a id="IDX-CHP-59-7810" class="indexterm"/><a id="IDX-CHP-59-7811" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Initialize the server’s sequence number either to 1 or to the
                                value supplied in the optional command-line argument
                                    <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e152859"/><img src="figs/web/U001.png" alt=""/></span>.</p></li><li class="listitem"><p>Ignore the <code class="literal">SIGPIPE</code> signal
                                    <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e152871"/><img src="figs/web/U002.png" alt=""/></span>. This prevents the server from receiving the
                                    <code class="literal">SIGPIPE</code> signal if it tries to
                                write to a socket whose peer has been closed; instead, the
                                    <span class="emphasis"><em>write()</em></span> fails with the error <code class="literal">EPIPE</code>.<a id="IDX-CHP-59-7812" class="indexterm"/></p></li><li class="listitem"><p>Call <span class="emphasis"><em>getaddrinfo()</em></span>
                                <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e152898"/><img src="figs/web/U004.png" alt=""/></span> to obtain a set of socket address structures
                                for a TCP socket that uses the port number <code class="literal">PORT_NUM</code>. (Instead of using a hard-coded port number,
                                we would more typically use a service name.) We specify the <code class="literal">AI_PASSIVE</code> flag <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e152910"/><img src="figs/web/U003.png" alt=""/></span> so that the resulting socket will be bound to
                                the wildcard address (<a class="xref" href="ch58.html#ip_addresses" title="IP Addresses">IP Addresses</a>). As a result,
                                if the server is run on a multihomed host, it can accept connection
                                requests sent to any of the host’s network addresses.<a id="IDX-CHP-59-7813" class="indexterm"/></p></li><li class="listitem"><p>Enter a loop that iterates through the socket address structures
                                returned by the previous step <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e152925"/><img src="figs/web/U005.png" alt=""/></span>. The loop terminates when the program finds an
                                address structure that can be used to successfully create and bind a
                                socket <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e152931"/><img src="figs/web/U007.png" alt=""/></span>.</p></li><li class="listitem"><p>Set the <code class="literal">SO_REUSEADDR</code> option for
                                the socket created in the previous step <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e152943"/><img src="figs/web/U006.png" alt=""/></span>. We defer discussion of this option until <a class="xref" href="ch61.html#the_so_underscore_reuseaddr_socket_optio" title="The SO_REUSEADDR Socket Option">The <span class="emphasis"><em>SO_REUSEADDR</em></span> Socket Option</a>, where we
                                note that a TCP server should usually set this option on its
                                listening socket.</p></li><li class="listitem"><p>Mark the socket as a listening socket <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e152954"/><img src="figs/web/U008.png" alt=""/></span>.</p></li><li class="listitem"><p>Commence an infinite <code class="literal">for</code> loop
                                    <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e152966"/><img src="figs/web/U009.png" alt=""/></span> that services clients iteratively (<a class="xref" href="ch60.html" title="Chapter 60. Sockets: Server Design">Chapter 60</a>). Each client’s request
                                is serviced before the next client’s request is accepted. For each
                                client, the server performs the following steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Accept a new connection <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e152978"/><img src="figs/web/U010.png" alt=""/></span>. The server passes non-<code class="literal">NULL</code> pointers for the second
                                        and third arguments to <span class="emphasis"><em>accept()</em></span>, in
                                        order to obtain the address of the client. The server
                                        displays the client’s address (IP address plus port number)
                                        on standard output <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e152990"/><img src="figs/web/U011.png" alt=""/></span>.</p></li><li class="listitem"><p>Read the client’s message <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e152999"/><img src="figs/web/U012.png" alt=""/></span>, which consists of a newline-terminated
                                        string specifying how many sequence numbers the client
                                        wants. The server converts this string to an integer and
                                        stores it in the variable <span class="emphasis"><em>reqLen</em></span>
                                        <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e153008"/><img src="figs/web/U013.png" alt=""/></span>.</p></li><li class="listitem"><p>Send the current value of the sequence number
                                            (<span class="emphasis"><em>seqNum</em></span>) back to the client,
                                        encoding it as a newline-terminated string
                                            <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e153020"/><img src="figs/web/U014.png" alt=""/></span>. The client can assume that it has been
                                        allocated all of the sequence numbers in the range
                                            <span class="emphasis"><em>seqNum</em></span> to <span class="emphasis"><em>(seqNum +
                                            reqLen - 1)</em></span>.</p></li><li class="listitem"><p>Update the value of the server’s sequence number by adding
                                            <span class="emphasis"><em>reqLen</em></span> to
                                            <span class="emphasis"><em>seqNum</em></span>
                                        <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e153041"/><img src="figs/web/U015.png" alt=""/></span>.</p></li></ul></div></li></ul></div><div class="example"><a id="header_file_used_by_is_underscore_seqnum"/><div class="example-title">Example 59-5. Header file used by <code class="literal">is_seqnum_sv.c</code>
                            and <code class="literal">is_seqnum_cl.c</code></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>sockets/is_seqnum.h</code></strong>
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;signal.h&gt;
#include "read_line.h"          /* Declaration of readLine() */
#include "tlpi_hdr.h"

#define PORT_NUM "50000"        /* Port number for server */

#define INT_LEN 30              /* Size of string able to hold largest
                                   integer (including terminating '\n') */xs
     <strong class="userinput"><code>sockets/is_seqnum.h</code></strong></pre></div></div><div class="example"><a id="an_iterative_server_that_uses_a_stream_s"/><div class="example-title">Example 59-6. An iterative server that uses a stream socket to communicate with
                            clients</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>sockets/is_seqnum_sv.c</code></strong>
    #define _BSD_SOURCE             /* To get definitions of NI_MAXHOST and
                                       NI_MAXSERV from &lt;netdb.h&gt; */
    #include &lt;netdb.h&gt;
    #include "is_seqnum.h"

    #define BACKLOG 50

    int
    main(int argc, char *argv[])
    {
        uint32_t seqNum;
        char reqLenStr[INT_LEN];            /* Length of requested sequence */
        char seqNumStr[INT_LEN];            /* Start of granted sequence */
        struct sockaddr_storage claddr;
        int lfd, cfd, optval, reqLen;
        socklen_t addrlen;
        struct addrinfo hints;
        struct addrinfo *result, *rp;
    #define ADDRSTRLEN (NI_MAXHOST + NI_MAXSERV + 10)
        char addrStr[ADDRSTRLEN];
        char host[NI_MAXHOST];
        char service[NI_MAXSERV];

        if (argc &gt; 1 &amp;&amp; strcmp(argv[1], "--help") == 0)
            usageErr("%s [init-seq-num]\n", argv[0]);
<img src="figs/web/U001.png" alt=""/>    seqNum = (argc &gt; 1) ? getInt(argv[1], 0, "init-seq-num") : 0;
<img src="figs/web/U002.png" alt=""/>    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
            errExit("signal");

        /* Call getaddrinfo() to obtain a list of addresses that
           we can try binding to */

        memset(&amp;hints, 0, sizeof(struct addrinfo));
        hints.ai_canonname = NULL;
        hints.ai_addr = NULL;
        hints.ai_next = NULL;
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_family = AF_UNSPEC;        /* Allows IPv4 or IPv6 */
<img src="figs/web/U003.png" alt=""/>    hints.ai_flags = AI_PASSIVE | AI_NUMERICSERV;
                            /* Wildcard IP address; service name is numeric */
<img src="figs/web/U004.png" alt=""/>    if (getaddrinfo(NULL, PORT_NUM, &amp;hints, &amp;result) != 0)
            errExit("getaddrinfo");

        /* Walk through returned list until we find an address structure
           that can be used to successfully create and bind a socket */

        optval = 1;
<img src="figs/web/U005.png" alt=""/>    for (rp = result; rp != NULL; rp = rp-&gt;ai_next) {
            lfd = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol);
            if (lfd == -1)
                continue;                   /* On error, try next address */
    <img src="figs/web/U006.png" alt=""/>        if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval))
                     == -1)
                 errExit("setsockopt");
<img src="figs/web/U007.png" alt=""/>        if (bind(lfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen) == 0)
                break;                      /* Success */

            /* bind() failed: close this socket and try next address */

            close(lfd);
        }

        if (rp == NULL)
            fatal("Could not bind socket to any address");
<img src="figs/web/U008.png" alt=""/>    if (listen(lfd, BACKLOG) == -1)
            errExit("listen");

        freeaddrinfo(result);
<img src="figs/web/U009.png" alt=""/>    for (;;) {                 /* Handle clients iteratively */

            /* Accept a client connection, obtaining client's address */

            addrlen = sizeof(struct sockaddr_storage);
<img src="figs/web/U010.png" alt=""/>        cfd = accept(lfd, (struct sockaddr *) &amp;claddr, &amp;addrlen);
            if (cfd == -1) {
                errMsg("accept");
                continue;
            }
<img src="figs/web/U011.png" alt=""/>        if (getnameinfo((struct sockaddr *) &amp;claddr, addrlen,
                        host, NI_MAXHOST, service, NI_MAXSERV, 0) == 0)
                snprintf(addrStr, ADDRSTRLEN, "(%s, %s)", host, service);
            else
                snprintf(addrStr, ADDRSTRLEN, "(?UNKNOWN?)");
            printf("Connection from %s\n", addrStr);

            /* Read client request, send sequence number back */
<img src="figs/web/U012.png" alt=""/>        if (readLine(cfd, reqLenStr, INT_LEN) &lt;= 0) {
                close(cfd);
                continue;                   /* Failed read; skip request */
            }
<img src="figs/web/U013.png" alt=""/>        reqLen = atoi(reqLenStr);
            if (reqLen &lt;= 0) {              /* Watch for misbehaving clients */
                close(cfd);
                continue;                   /* Bad request; skip it */
            }
<img src="figs/web/U014.png" alt=""/>        snprintf(seqNumStr, INT_LEN, "%d\n", seqNum);
            if (write(cfd, &amp;seqNumStr, strlen(seqNumStr)) != strlen(seqNumStr))
                fprintf(stderr, "Error on write");

    <img src="figs/web/U015.png" alt=""/>        seqNum += reqLen;               /* Update sequence number */

            if (close(cfd) == -1)           /* Close connection */
                errMsg("close");
        }
    }
          <strong class="userinput"><code>sockets/is_seqnum_sv.c</code></strong></pre></div></div></div><div class="sect3" title="Client program"><div class="titlepage"><div><div><h4 class="title" id="client_program-id2">Client program</h4></div></div></div><p>The client program is shown in <a class="xref" href="ch59.html#a_client_that_uses_stream_sockets" title="Example 59-7. A client that uses stream sockets">Example 59-7</a>. This program accepts two
                        arguments. The first argument, which is the name of the host on which the
                        server is running, is mandatory. The optional second argument is the length
                        of the sequence desired by the client. The default length is 1. The client
                        performs the following steps:<a id="IDX-CHP-59-7814" class="indexterm"/><a id="IDX-CHP-59-7815" class="indexterm"/><a id="IDX-CHP-59-7816" class="indexterm"/><a id="IDX-CHP-59-7817" class="indexterm"/><a id="IDX-CHP-59-7818" class="indexterm"/><a id="IDX-CHP-59-7819" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Call <span class="emphasis"><em>getaddrinfo()</em></span> to obtain a set of socket
                                address structures suitable for connecting to a TCP server bound to
                                the specified host <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e153217"/><img src="figs/web/U001.png" alt=""/></span>. For the port number, the client specifies
                                    <code class="literal">PORT_NUM</code>.</p></li><li class="listitem"><p>Enter a loop <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e153229"/><img src="figs/web/U002.png" alt=""/></span> that iterates through the socket address
                                structures returned by the previous step, until the client finds one
                                that can be used to successfully create <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e153235"/><img src="figs/web/U003.png" alt=""/></span> and connect <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e153241"/><img src="figs/web/U004.png" alt=""/></span> a socket to the server. Since the client has
                                not bound its socket, the <span class="emphasis"><em>connect()</em></span> call causes
                                the kernel to assign an ephemeral port to the socket.</p></li><li class="listitem"><p>Send an integer specifying the length of the client’s desired
                                sequence <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e153253"/><img src="figs/web/U005.png" alt=""/></span>. This integer is sent as a newline-terminated
                                string.</p></li><li class="listitem"><p>Read the sequence number sent back by the server (which is
                                likewise a newline-terminated string) <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e153262"/><img src="figs/web/U006.png" alt=""/></span> and print it on standard output
                                    <span class="inlinemediaobject"><a id="I_inlinemediaobject59_d1e153268"/><img src="figs/web/U007.png" alt=""/></span>.</p></li></ul></div><p>When we run the server and the client on the same host, we see the
                        following:</p><a id="I_programlisting59_d1e153276"/><pre class="programlisting">$ <strong class="userinput"><code>./is_seqnum_sv &amp;</code></strong>
[1] 4075
$ <strong class="userinput"><code>./is_seqnum_cl localhost</code></strong>              <em class="lineannotation"><span class="lineannotation">Client 1: requests 1 sequence number</span></em>
Connection from (localhost, 33273)      <em class="lineannotation"><span class="lineannotation">Server displays client address + port</span></em>
Sequence number: 0                      <em class="lineannotation"><span class="lineannotation">Client displays returned sequence number</span></em>
$ <strong class="userinput"><code>./is_seqnum_cl localhost 10</code></strong>           <em class="lineannotation"><span class="lineannotation">Client 2: requests 10 sequence numbers</span></em>
Connection from (localhost, 33274)
Sequence number: 1
$ <strong class="userinput"><code>./is_seqnum_cl localhost</code></strong>              <em class="lineannotation"><span class="lineannotation">Client 3: requests 1 sequence number</span></em>
Connection from (localhost, 33275)
Sequence number: 11</pre><p>Next, we demonstrate the use of <span class="emphasis"><em>telnet</em></span> for debugging
                        this application:</p><a id="I_programlisting59_d1e153311"/><pre class="programlisting">$ <strong class="userinput"><code>telnet localhost 50000</code></strong>                <em class="lineannotation"><span class="lineannotation">Our server uses this port number</span></em>
                                        <em class="lineannotation"><span class="lineannotation">Empty line printed by</span></em> <span class="emphasis"><em>telnet</em></span>
Trying 127.0..0.1...
Connection from (localhost, 33276)
Connected to localhost.
Escape character is '^]'.
<strong class="userinput"><code>1</code></strong>                                       <em class="lineannotation"><span class="lineannotation">Enter length of requested sequence</span></em>
12                                      <span class="emphasis"><em>telnet</em></span> <em class="lineannotation"><span class="lineannotation">displays sequence number and</span></em>
Connection closed by foreign host.      <em class="lineannotation"><span class="lineannotation">detects that server closed connection</span></em></pre><div class="note" title="Note"><h3 class="title">Note</h3><p>In the shell session log, we see that the kernel cycles sequentially
                            through the ephemeral port numbers. (Other implementations exhibit
                            similar behavior.) On Linux, this behavior is the result of an
                            optimization to minimize hash lookups in the kernel’s table of local
                            socket bindings. When the upper limit for these numbers is reached, the
                            kernel recommences allocating an available number starting at the low
                            end of the range (defined by the Linux-specific <code class="literal">/proc/sys/net/ipv4/ip_local_port_range</code> file).<a id="IDX-CHP-59-7820" class="indexterm"/><a id="IDX-CHP-59-7821" class="indexterm"/><a id="IDX-CHP-59-7822" class="indexterm"/></p></div><div class="example"><a id="a_client_that_uses_stream_sockets"/><div class="example-title">Example 59-7. A client that uses stream sockets</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>sockets/is_seqnum_cl.c</code></strong>
    #include &lt;netdb.h&gt;
    #include "is_seqnum.h"

    int
    main(int argc, char *argv[])
    {
        char *reqLenStr;                    /* Requested length of sequence */
        char seqNumStr[INT_LEN];            /* Start of granted sequence */
        int cfd;
        ssize_t numRead;
        struct addrinfo hints;
        struct addrinfo *result, *rp;

        if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)
            usageErr("%s server-host [sequence-len]\n", argv[0]);

        /* Call getaddrinfo() to obtain a list of addresses that
           we can try connecting to */

        memset(&amp;hints, 0, sizeof(struct addrinfo));
        hints.ai_canonname = NULL;
        hints.ai_addr = NULL;
        hints.ai_next = NULL;
        hints.ai_family = AF_UNSPEC;                /* Allows IPv4 or IPv6 */
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_flags = AI_NUMERICSERV;
<img src="figs/web/U001.png" alt=""/>    if (getaddrinfo(argv[1], PORT_NUM, &amp;hints, &amp;result) != 0)
            errExit("getaddrinfo");

        /* Walk through returned list until we find an address structure
           that can be used to successfully connect a socket */
<img src="figs/web/U002.png" alt=""/>    for (rp = result; rp != NULL; rp = rp-&gt;ai_next) {
<img src="figs/web/U003.png" alt=""/>        cfd = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol);
            if (cfd == -1)
                continue;                           /* On error, try next address */
<img src="figs/web/U004.png" alt=""/>        if (connect(cfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen) != -1)
                break;                              /* Success */

                /* Connect failed: close this socket and try next address */

            close(cfd);
        }

        if (rp == NULL)
            fatal("Could not connect socket to any address");

        freeaddrinfo(result);

        /* Send requested sequence length, with terminating newline */
<img src="figs/web/U005.png" alt=""/>    reqLenStr = (argc &gt; 2) ? argv[2] : "1";
        if (write(cfd, reqLenStr, strlen(reqLenStr)) !=  strlen(reqLenStr))
            fatal("Partial/failed write (reqLenStr)");
        if (write(cfd, "\n", 1) != 1)
            fatal("Partial/failed write (newline)");

        /* Read and display sequence number returned by server */
<img src="figs/web/U006.png" alt=""/>    numRead = readLine(cfd, seqNumStr, INT_LEN);
        if (numRead == -1)
            errExit("readLine");
        if (numRead == 0)
            fatal("Unexpected EOF from server");
<img src="figs/web/U007.png" alt=""/>    printf("Sequence number: %s", seqNumStr);           /* Includes '\n' */

        exit(EXIT_SUCCESS);                                 /* Closes 'cfd' */
    }
          <strong class="userinput"><code>sockets/is_seqnum_cl.c</code></strong></pre></div></div></div></div></div><div class="sect1" title="An Internet Domain Sockets Library"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="an_internet_domain_sockets_library">An Internet Domain Sockets Library</h2></div></div></div><p>In this section, we use the functions presented in <a class="xref" href="ch59.html#protocol-independent_host_and_service_co" title="Protocol-Independent Host and Service Conversion">Protocol-Independent Host and Service Conversion</a> to implement a library of
                functions to perform tasks commonly required for Internet domain sockets. (This
                library abstracts many of the steps shown in the example programs presented in <a class="xref" href="ch59.html#client-server_example_open_parenthesis_s" title="Client-Server Example (Stream Sockets)">Client-Server Example (Stream Sockets)</a>.) Since these functions
                employ the protocol-independent <span class="emphasis"><em>getaddrinfo()</em></span> and
                    <span class="emphasis"><em>getnameinfo()</em></span> functions, they can be used with both IPv4
                and IPv6. <a class="xref" href="ch59.html#header_file_for_inet_underscore_sockets" title="Example 59-8. Header file for inet_sockets.c">Example 59-8</a> shows the header
                file that declares these functions.<a id="IDX-CHP-59-7823" class="indexterm"/><a id="IDX-CHP-59-7824" class="indexterm"/><a id="IDX-CHP-59-7825" class="indexterm"/><a id="IDX-CHP-59-7826" class="indexterm"/><a id="IDX-CHP-59-7827" class="indexterm"/><a id="IDX-CHP-59-7828" class="indexterm"/><a id="IDX-CHP-59-7829" class="indexterm"/><a id="IDX-CHP-59-7830" class="indexterm"/><a id="IDX-CHP-59-7831" class="indexterm"/><a id="IDX-CHP-59-7832" class="indexterm"/><a id="IDX-CHP-59-7833" class="indexterm"/><a id="IDX-CHP-59-7834" class="indexterm"/><a id="IDX-CHP-59-7835" class="indexterm"/><a id="IDX-CHP-59-7836" class="indexterm"/><a id="IDX-CHP-59-7837" class="indexterm"/><a id="IDX-CHP-59-7838" class="indexterm"/><a id="IDX-CHP-59-7839" class="indexterm"/><a id="IDX-CHP-59-7840" class="indexterm"/></p><p>Many of the functions in this library have similar arguments:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>host</em></span> argument is a string containing either a
                        hostname or a numeric address (in IPv4 dotted-decimal, or IPv6 hex-string
                        notation). Alternatively, <span class="emphasis"><em>host</em></span> can be specified as a
                            <code class="literal">NULL</code> pointer to indicate that the
                        loopback IP address is to be used.</p></li><li class="listitem"><p>The <span class="emphasis"><em>service</em></span> argument is either a service name or a
                        port number specified as a decimal string.</p></li><li class="listitem"><p>The <span class="emphasis"><em>type</em></span> argument is a socket type, specified as
                        either <code class="literal">SOCK_STREAM</code> or <code class="literal">SOCK_DGRAM</code>.</p></li></ul></div><div class="example"><a id="header_file_for_inet_underscore_sockets"/><div class="example-title">Example 59-8. Header file for <code class="literal">inet_sockets.c</code></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>sockets/inet_sockets.h</code></strong>
#ifndef INET_SOCKETS_H
#define INET_SOCKETS_H          /* Prevent accidental double inclusion */

#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int inetConnect(const char *host, const char *service, int type);

int inetListen(const char *service, int backlog, socklen_t *addrlen);

int inetBind(const char *service, int type, socklen_t *addrlen);

char *inetAddressStr(const struct sockaddr *addr, socklen_t addrlen,
                char *addrStr, int addrStrLen);

#define IS_ADDR_STR_LEN 4096
                        /* Suggested length for string buffer that caller
                           should pass to inetAddressStr(). Must be greater
                           than (NI_MAXHOST + NI_MAXSERV + 4) */
#endif
      <strong class="userinput"><code>sockets/inet_sockets.h</code></strong></pre></div></div><p>The <span class="emphasis"><em>inetConnect()</em></span> function creates a socket with the given
                socket <span class="emphasis"><em>type</em></span>, and connects it to the address specified by
                    <span class="emphasis"><em>host</em></span> and <span class="emphasis"><em>service</em></span>. This function is
                designed for TCP or UDP clients that need to connect their socket to a server
                    socket.<a id="IDX-CHP-59-7841" class="indexterm"/></p><a id="I_programlisting59_d1e153613"/><pre class="programlisting">#include "inet_sockets.h"

int <strong class="userinput"><code>inetConnect</code></strong>(const char *<span class="emphasis"><em>host</em></span>, const char *<span class="emphasis"><em>service</em></span>, int <span class="emphasis"><em>type</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns a file descriptor on success, or -1 on error</p></div><p>The file descriptor for the new socket is returned as the function result.</p><p>The <span class="emphasis"><em>inetListen()</em></span> function creates a listening stream
                    (<code class="literal">SOCK_STREAM</code>) socket bound to the wildcard IP
                address on the TCP port specified by <span class="emphasis"><em>service</em></span>. This function is
                designed for use by TCP servers.<a id="IDX-CHP-59-7842" class="indexterm"/></p><a id="I_programlisting59_d1e153647"/><pre class="programlisting">#include "inet_sockets.h"

int <strong class="userinput"><code>inetListen</code></strong>(const char *<span class="emphasis"><em>service</em></span>, int <span class="emphasis"><em>backlog</em></span>, socklen_t *<span class="emphasis"><em>addrlen</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns a file descriptor on success, or -1 on error</p></div><p>The file descriptor for the new socket is returned as the function result.</p><p>The <span class="emphasis"><em>backlog</em></span> argument specifies the permitted backlog of
                pending connections (as for <span class="emphasis"><em>listen()</em></span>).</p><p>If <span class="emphasis"><em>addrlen</em></span> is specified as a non-<code class="literal">NULL</code> pointer, then the location it points to is used to return the
                size of the socket address structure corresponding to the returned file descriptor.
                This value allows us to allocate a socket address buffer of the appropriate size to
                be passed to a later <span class="emphasis"><em>accept()</em></span> call if we want to obtain the
                address of a connecting client.</p><p>The <span class="emphasis"><em>inetBind()</em></span> function creates a socket of the given
                    <span class="emphasis"><em>type</em></span>, bound to the wildcard IP address on the port
                specified by <span class="emphasis"><em>service</em></span> and <span class="emphasis"><em>type</em></span>. (The socket
                    <span class="emphasis"><em>type</em></span> indicates whether this is a TCP or UDP service.) This
                function is designed (primarily) for UDP servers and clients to create a socket
                bound to a specific address.<a id="IDX-CHP-59-7843" class="indexterm"/></p><a id="I_programlisting59_d1e153708"/><pre class="programlisting">#include "inet_sockets.h"

int <strong class="userinput"><code>inetBind</code></strong>(const char *<span class="emphasis"><em>service</em></span>, int <span class="emphasis"><em>type</em></span>, socklen_t *<span class="emphasis"><em>addrlen</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns a file descriptor on success, or -1 on error</p></div><p>The file descriptor for the new socket is returned as the function result.</p><p>As with <span class="emphasis"><em>inetListen()</em></span>, <span class="emphasis"><em>inetBind()</em></span> returns
                the length of the associated socket address structure for this socket in the
                location pointed to by <span class="emphasis"><em>addrlen</em></span>. This is useful if we want to
                allocate a buffer to pass to <span class="emphasis"><em>recvfrom()</em></span> in order to obtain the
                address of the socket sending a datagram. (Many of the steps required for
                    <span class="emphasis"><em>inetListen()</em></span> and <span class="emphasis"><em>inetBind()</em></span> are the
                same, and these steps are implemented within the library by a single function,
                    <span class="emphasis"><em>inetPassiveSocket()</em></span>.)</p><p>The <span class="emphasis"><em>inetAddressStr()</em></span> function converts an Internet socket
                address to printable form.<a id="IDX-CHP-59-7844" class="indexterm"/></p><a id="I_programlisting59_d1e153760"/><pre class="programlisting">#include "inet_sockets.h"

char *<strong class="userinput"><code>inetAddressStr</code></strong>(const struct sockaddr *<span class="emphasis"><em>addr</em></span>, socklen_t <span class="emphasis"><em>addrlen</em></span>,
                     char *<span class="emphasis"><em>addrStr</em></span>, int <span class="emphasis"><em>addrStrLen</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer to <span class="emphasis"><em>addrStr</em></span>, a string containing host and
                    service name</p></div><p>Given a socket address structure in <span class="emphasis"><em>addr</em></span>, whose length is
                specified in <span class="emphasis"><em>addrlen</em></span>, <span class="emphasis"><em>inetAddressStr()</em></span>
                returns a null-terminated string containing the corresponding hostname and port
                number in the following form:</p><a id="I_programlisting59_d1e153795"/><pre class="programlisting">(hostname, port-number)</pre><p>The string is returned in the buffer pointed to by <span class="emphasis"><em>addrStr</em></span>.
                The caller must specify the size of this buffer in <span class="emphasis"><em>addrStrLen</em></span>.
                If the returned string would exceed (<span class="emphasis"><em>addrStrLen - 1</em></span>) bytes, it
                is truncated. The constant <code class="literal">IS_ADDR_STR_LEN</code>
                defines a suggested size for the <span class="emphasis"><em>addrStr</em></span> buffer that should be
                large enough to handle all possible return strings. As its function result,
                    <span class="emphasis"><em>inetAddressStr()</em></span> returns
                <span class="emphasis"><em>addrStr</em></span>.</p><p>The implementation of the functions described in this section is shown in <a class="xref" href="ch59.html#an_internet_domain_sockets_librar" title="Example 59-9. An Internet domain sockets library">Example 59-9</a>.</p><div class="example"><a id="an_internet_domain_sockets_librar"/><div class="example-title">Example 59-9. An Internet domain sockets library</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>sockets/inet_sockets.c</code></strong>
#define _BSD_SOURCE             /* To get NI_MAXHOST and NI_MAXSERV
                                   definitions from &lt;netdb.h&gt; */
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include "inet_sockets.h"       /* Declares functions defined here */
#include "tlpi_hdr.h"

int
inetConnect(const char *host, const char *service, int type)
{
    struct addrinfo hints;
    struct addrinfo *result, *rp;
    int sfd, s;

    memset(&amp;hints, 0, sizeof(struct addrinfo));
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;
    hints.ai_family = AF_UNSPEC;        /* Allows IPv4 or IPv6 */
    hints.ai_socktype = type;

    s = getaddrinfo(host, service, &amp;hints, &amp;result);
    if (s != 0) {
        errno = ENOSYS;
        return -1;
    }

    /* Walk through returned list until we find an address structure
       that can be used to successfully connect a socket */

    for (rp = result; rp != NULL; rp = rp-&gt;ai_next) {
        sfd = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol);
        if (sfd == -1)
            continue;                   /* On error, try next address */

        if (connect(sfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen) != -1)
            break;                      /* Success */

        /* Connect failed: close this socket and try next address */

        close(sfd);
    }

    freeaddrinfo(result);

    return (rp == NULL) ? -1 : sfd;
}

static int              /* Public interfaces: inetBind() and inetListen() */
inetPassiveSocket(const char *service, int type, socklen_t *addrlen,
                  Boolean doListen, int backlog)
{
    struct addrinfo hints;
    struct addrinfo *result, *rp;
    int sfd, optval, s;

    memset(&amp;hints, 0, sizeof(struct addrinfo));
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;
    hints.ai_socktype = type;
    hints.ai_family = AF_UNSPEC;        /* Allows IPv4 or IPv6 */
    hints.ai_flags = AI_PASSIVE;        /* Use wildcard IP address */

    s = getaddrinfo(NULL, service, &amp;hints, &amp;result);
    if (s != 0)
        return -1;

    /* Walk through returned list until we find an address structure
       that can be used to successfully create and bind a socket */

    optval = 1;
    for (rp = result; rp != NULL; rp = rp-&gt;ai_next) {
        sfd = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol);
        if (sfd == -1)
            continue;                   /* On error, try next address */

        if (doListen) {
            if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval,
                    sizeof(optval)) == -1) {
                close(sfd);
                freeaddrinfo(result);
                return -1;
            }
        }

        if (bind(sfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen) == 0)
            break;                      /* Success */

        /* bind() failed: close this socket and try next address */

        close(sfd);
    }

    if (rp != NULL &amp;&amp; doListen) {
        if (listen(sfd, backlog) == -1) {
            freeaddrinfo(result);
            return -1;
        }
    }

    if (rp != NULL &amp;&amp; addrlen != NULL)
        *addrlen =  rp-&gt;ai_addrlen;     /* Return address structure size */
    freeaddrinfo(result);

    return (rp == NULL) ? -1 : sfd;
}

int
inetListen(const char *service, int backlog, socklen_t *addrlen)
{
    return inetPassiveSocket(service, SOCK_STREAM, addrlen, TRUE, backlog);
}

int
inetBind(const char *service, int type, socklen_t *addrlen)
{
    return inetPassiveSocket(service, type, addrlen, FALSE, 0);
}

char *
inetAddressStr(const struct sockaddr *addr, socklen_t addrlen,
               char *addrStr, int addrStrLen)
{
    char host[NI_MAXHOST], service[NI_MAXSERV];

    if (getnameinfo(addr, addrlen, host, NI_MAXHOST,
                    service, NI_MAXSERV, NI_NUMERICSERV) == 0)
        snprintf(addrStr, addrStrLen, "(%s, %s)", host, service);
    else
        snprintf(addrStr, addrStrLen, "(?UNKNOWN?)");

    addrStr[addrStrLen - 1] = '\0';     /* Ensure result is null-terminated */
    return addrStr;
}
      <strong class="userinput"><code>sockets/inet_sockets.c</code></strong></pre></div></div></div><div class="sect1" title="Obsolete APIs for Host and Service Conversions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="obsolete_apis_for_host_and_service_conve">Obsolete APIs for Host and Service Conversions</h2></div></div></div><p>In the following sections, we describe the older, now obsolete functions for
                converting host names and service names to and from binary and presentation formats.
                Although new programs should perform these conversions using the modern functions
                described earlier in this chapter, a knowledge of the obsolete functions is useful
                because we may encounter them in older code.<a id="IDX-CHP-59-7845" class="indexterm"/><a id="IDX-CHP-59-7846" class="indexterm"/><a id="IDX-CHP-59-7847" class="indexterm"/><a id="IDX-CHP-59-7848" class="indexterm"/></p><div class="sect2" title="The inet_aton() and inet_ntoa() Functions"><div class="titlepage"><div><div><h3 class="title" id="the_inet_underscore_aton_open_parenthesi">The <span class="emphasis"><em>inet_aton()</em></span> and <span class="emphasis"><em>inet_ntoa()</em></span>
                    Functions</h3></div></div></div><p>The <span class="emphasis"><em>inet_aton()</em></span> and <span class="emphasis"><em>inet_ntoa()</em></span>
                    functions convert IPv4 addresses between dotted-decimal notation and binary form
                    (in network byte order). These functions are nowadays made obsolete by
                        <span class="emphasis"><em>inet_pton()</em></span> and
                        <span class="emphasis"><em>inet_ntop()</em></span>.<a id="IDX-CHP-59-7849" class="indexterm"/></p><p>The <span class="emphasis"><em>inet_aton()</em></span> (“ASCII to network”) function converts
                    the dotted-decimal string pointed to by <span class="emphasis"><em>str</em></span> into an IPv4
                    address in network byte order, which is returned in the
                        <span class="emphasis"><em>in_addr</em></span> structure pointed to by
                        <span class="emphasis"><em>addr</em></span>.</p><a id="I_programlisting59_d1e153908"/><pre class="programlisting">#include &lt;arpa/inet.h&gt;

int <strong class="userinput"><code>inet_aton</code></strong>(const char *<span class="emphasis"><em>str</em></span>, struct in_addr *<span class="emphasis"><em>addr</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 1 (true) if <span class="emphasis"><em>str</em></span> is a valid dotted-decimal
                        address, or 0 (false) on error</p></div><p>The <span class="emphasis"><em>inet_aton()</em></span> function returns 1 if the conversion was
                    successful, or 0 if <span class="emphasis"><em>str</em></span> was invalid.</p><p>The numeric components of the string given to <span class="emphasis"><em>inet_aton()</em></span>
                    need not be decimal. They can be octal (specified by a leading 0) or hexadecimal
                    (specified by a leading 0x or 0X). Furthermore, <span class="emphasis"><em>inet_aton()</em></span>
                    supports shorthand forms that allow an address to be specified using fewer than
                    four numeric components. (See the <span class="emphasis"><em>inet(3)</em></span> manual page for
                    details.) The term <span class="emphasis"><em>numbers-and-dots notation</em></span> is used for
                    the more general address strings that employ these features.</p><p>SUSv3 doesn’t specify <span class="emphasis"><em>inet_aton()</em></span>. Nevertheless, this
                    function is available on most implementations. On Linux, we must define one of
                    the feature test macros <code class="literal">_BSD_SOURCE</code>, <code class="literal">_SVID_SOURCE</code>, or <code class="literal">_GNU_SOURCE</code> in order to obtain the declaration of
                        <span class="emphasis"><em>inet_aton()</em></span> from <code class="literal">&lt;arpa/inet.h&gt;</code>.</p><p>The <span class="emphasis"><em>inet_ntoa()</em></span> (“network to ASCII”) function performs
                    the converse of <span class="emphasis"><em>inet_aton()</em></span>.<a id="IDX-CHP-59-7850" class="indexterm"/></p><a id="I_programlisting59_d1e153980"/><pre class="programlisting">#include &lt;arpa/inet.h&gt;

char *<strong class="userinput"><code>inet_ntoa</code></strong>(struct in_addr <span class="emphasis"><em>addr</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer to (statically allocated) dotted-decimal string version of
                            <span class="emphasis"><em>addr</em></span></p></div><p>Given an <span class="emphasis"><em>in_addr</em></span> structure (a 32-bit IPv4 address in
                    network byte order), <span class="emphasis"><em>inet_ntoa()</em></span> returns a pointer to a
                    (statically allocated) string containing the address in dotted-decimal
                        notation.<a id="IDX-CHP-59-7851" class="indexterm"/></p><p>Because the string returned by <span class="emphasis"><em>inet_ntoa()</em></span> is statically
                    allocated, it is overwritten by successive calls.</p></div><div class="sect2" title="The gethostbyname() and gethostbyaddr() Functions"><div class="titlepage"><div><div><h3 class="title" id="the_gethostbyname_open_parenthesis_close">The <span class="emphasis"><em>gethostbyname()</em></span> and
                        <span class="emphasis"><em>gethostbyaddr()</em></span> Functions</h3></div></div></div><p>The <span class="emphasis"><em>gethostbyname()</em></span> and
                        <span class="emphasis"><em>gethostbyaddr()</em></span> functions allow conversion between
                    hostnames and IP addresses. These functions are nowadays made obsolete by
                        <span class="emphasis"><em>getaddrinfo()</em></span> and
                        <span class="emphasis"><em>getnameinfo()</em></span>.<a id="IDX-CHP-59-7854" class="indexterm"/><a id="IDX-CHP-59-7855" class="indexterm"/><a id="IDX-CHP-59-7856" class="indexterm"/><a id="IDX-CHP-59-7857" class="indexterm"/><a id="IDX-CHP-59-7858" class="indexterm"/><a id="IDX-CHP-59-7859" class="indexterm"/><a id="IDX-CHP-59-7860" class="indexterm"/><a id="IDX-CHP-59-7861" class="indexterm"/><a id="IDX-CHP-59-7862" class="indexterm"/><a id="IDX-CHP-59-7863" class="indexterm"/><a id="IDX-CHP-59-7864" class="indexterm"/><a id="IDX-CHP-59-7865" class="indexterm"/><a id="IDX-CHP-59-7866" class="indexterm"/><a id="IDX-CHP-59-7867" class="indexterm"/><a id="IDX-CHP-59-7868" class="indexterm"/><a id="IDX-CHP-59-7852" class="indexterm"/><a id="IDX-CHP-59-7853" class="indexterm"/></p><a id="I_programlisting59_d1e154137"/><pre class="programlisting">#include &lt;netdb.h&gt;

extern int <strong class="userinput"><code>h_errno</code></strong>;

struct hostent *<strong class="userinput"><code>gethostbyname</code></strong>(const char *<span class="emphasis"><em>name</em></span>);
struct hostent *<strong class="userinput"><code>gethostbyaddr</code></strong>(const char *<span class="emphasis"><em>addr</em></span>, socklen_t <span class="emphasis"><em>len</em></span>, int <span class="emphasis"><em>type</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Both return pointer to (statically allocated) <span class="emphasis"><em>hostent</em></span>
                        structure on success, or NULL on error</p></div><p>The <span class="emphasis"><em>gethostbyname()</em></span> function resolves the hostname given
                    in <span class="emphasis"><em>name</em></span>, returning a pointer to a statically allocated
                        <span class="emphasis"><em>hostent</em></span> structure containing information about that
                    hostname. This structure has the following form:<a id="IDX-CHP-59-7869" class="indexterm"/></p><a id="I_programlisting59_d1e154183"/><pre class="programlisting">struct hostent {
    char  *h_name;              /* Official (canonical) name of host */
    char **h_aliases;           /* NULL-terminated array of pointers
                                   to alias strings */
    int    h_addrtype;          /* Address type (AF_INET or AF_INET6) */
    int    h_length;            /* Length (in bytes) of addresses pointed
                                   to by h_addr_list (4 bytes for AF_INET,
                                   16 bytes for AF_INET6) */
    char **h_addr_list;         /* NULL-terminated array of pointers to
                                   host IP addresses (in_addr or in6_addr
                                   structures) in network byte order */
};

#define h_addr  h_addr_list[0]</pre><p>The <span class="emphasis"><em>h_name</em></span> field returns the official name of the host,
                    as a null-terminated string. The <span class="emphasis"><em>h_aliases</em></span> fields points to
                    an array of pointers to null-terminated strings containing aliases (alternative
                    names) for this hostname.</p><p>The <span class="emphasis"><em>h_addr_list</em></span> field is an array of pointers to IP
                    address structures for this host. (A multihomed host has more than one address.)
                    This list consists of either <span class="emphasis"><em>in_addr</em></span> or
                        <span class="emphasis"><em>in6_addr</em></span> structures. We can determine the type of these
                    structures from the <span class="emphasis"><em>h_addrtype</em></span> field, which contains either
                        <code class="literal">AF_INET</code> or <code class="literal">AF_INET6</code>, and their length from the <span class="emphasis"><em>h_length</em></span>
                    field. The <span class="emphasis"><em>h_addr</em></span> definition is provided for backward
                    compatibility with earlier implementations (e.g., 4.2BSD) that returned just one
                    address in the <span class="emphasis"><em>hostent</em></span> structure. Some existing code relies
                    on this name (and thus is not multihomed-host aware).</p><p>With modern versions of <span class="emphasis"><em>gethostbyname()</em></span>,
                        <span class="emphasis"><em>name</em></span> can also be specified as a numeric IP address
                    string; that is, numbers-and-dots notation for IPv4 or hex-string notation for
                    IPv6. In this case, no lookup is performed; instead, <span class="emphasis"><em>name</em></span>
                    is copied into the <span class="emphasis"><em>h_name</em></span> field of the
                        <span class="emphasis"><em>hostent</em></span> structure, and <span class="emphasis"><em>h_addr_list</em></span>
                    is set to the binary equivalent of <span class="emphasis"><em>name</em></span>.</p><p>The <span class="emphasis"><em>gethostbyaddr()</em></span> function performs the converse of
                        <span class="emphasis"><em>gethostbyname()</em></span>. Given a binary IP address, it returns
                    a <span class="emphasis"><em>hostent</em></span> structure containing information about the host
                    with that address.</p><p>On error (e.g., a name could not be resolved), both
                        <span class="emphasis"><em>gethostbyname()</em></span> and
                        <span class="emphasis"><em>gethostbyaddr()</em></span> return a <code class="literal">NULL</code> pointer and set the global variable
                        <span class="emphasis"><em>h_errno</em></span>. As the name suggests, this variable is
                    analogous to <span class="emphasis"><em>errno</em></span> (possible values placed in this variable
                    are described in the <span class="emphasis"><em>gethostbyname(3)</em></span> manual page), and the
                        <span class="emphasis"><em>herror()</em></span> and <span class="emphasis"><em>hstrerror()</em></span> functions
                    are analogous to <span class="emphasis"><em>perror()</em></span> and
                        <span class="emphasis"><em>strerror()</em></span>.<a id="IDX-CHP-59-7870" class="indexterm"/><a id="IDX-CHP-59-7871" class="indexterm"/></p><p>The <span class="emphasis"><em>herror()</em></span> function displays (on standard error) the
                    string given in <span class="emphasis"><em>str</em></span>, followed by a colon (<code class="literal">:</code>), and then a message for the current error in
                        <span class="emphasis"><em>h_errno</em></span>. Alternatively, we can use
                        <span class="emphasis"><em>hstrerror()</em></span> to obtain a pointer to a string
                    corresponding to the error value specified in <span class="emphasis"><em>err</em></span>.</p><a id="I_programlisting59_d1e154322"/><pre class="programlisting">#define _BSD_SOURCE           /* Or _SVID_SOURCE or _GNU_SOURCE */
#include &lt;netdb.h&gt;

void <strong class="userinput"><code>herror</code></strong>(const char *<span class="emphasis"><em>str</em></span>);

const char *<strong class="userinput"><code>hstrerror</code></strong>(int <span class="emphasis"><em>err</em></span>);
Returns pointer to <span class="emphasis"><em>h_errno</em></span> error string corresponding to <span class="emphasis"><em>err</em></span></pre><p><a class="xref" href="ch59.html#using_gethostbyname_open_parenthesis_clo" title="Example 59-10. Using gethostbyname() to retrieve host information">Example 59-10</a> demonstrates the
                    use of <span class="emphasis"><em>gethostbyname()</em></span>. This program displays
                        <span class="emphasis"><em>hostent</em></span> information for each of the hosts named on its
                    command line. The following shell session demonstrates the use of this
                    program:</p><a id="I_programlisting59_d1e154351"/><pre class="programlisting">$ <strong class="userinput"><code>./t_gethostbyname www.jambit.com</code></strong>
Canonical name: jamjam1.jambit.com
        alias(es):      www.jambit.com
        address type:   AF_INET
        address(es):    62.245.207.90</pre><div class="example"><a id="using_gethostbyname_open_parenthesis_clo"/><div class="example-title">Example 59-10. Using <span class="emphasis"><em>gethostbyname()</em></span> to retrieve host
                        information</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>sockets/t_gethostbyname.c</code></strong>
#define _BSD_SOURCE     /* To get hstrerror() declaration from &lt;netdb.h&gt; */
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    struct hostent *h;
    char **pp;
    char str[INET6_ADDRSTRLEN];

    for (argv++; *argv != NULL; argv++) {
        h = gethostbyname(*argv);
        if (h == NULL) {
            fprintf(stderr, "gethostbyname() failed for '%s': %s\n",
                    *argv, hstrerror(h_errno));
            continue;
        }

        printf("Canonical name: %s\n", h-&gt;h_name);

        printf("        alias(es):     ");
        for (pp = h-&gt;h_aliases; *pp != NULL; pp++)
            printf(" %s", *pp);
        printf("\n");

        printf("        address type:   %s\n",
                (h-&gt;h_addrtype == AF_INET) ? "AF_INET" :
                (h-&gt;h_addrtype == AF_INET6) ? "AF_INET6" : "???");

        if (h-&gt;h_addrtype == AF_INET || h-&gt;h_addrtype == AF_INET6) {
            printf("        address(es):   ");
            for (pp = h-&gt;h_addr_list; *pp != NULL; pp++)
                printf(" %s", inet_ntop(h-&gt;h_addrtype, *pp,
                                        str, INET6_ADDRSTRLEN));
            printf("\n");
        }
    }

    exit(EXIT_SUCCESS);
}
     <strong class="userinput"><code>sockets/t_gethostbyname.c</code></strong></pre></div></div></div><div class="sect2" title="The getservbyname() and getservbyport() Functions"><div class="titlepage"><div><div><h3 class="title" id="the_getservbyname_open_parenthesis_close">The <span class="emphasis"><em>getservbyname()</em></span> and
                        <span class="emphasis"><em>getservbyport()</em></span> Functions</h3></div></div></div><p>The <span class="emphasis"><em>getservbyname()</em></span> and
                        <span class="emphasis"><em>getservbyport()</em></span> functions retrieve records from the
                        <code class="literal">/etc/services</code> file (<a class="xref" href="ch59.html#the_solidus_etc_solidus_services_file" title="The /etc/services File">The <code class="literal">/etc/services</code> File</a>). These functions are
                    nowadays made obsolete by <span class="emphasis"><em>getaddrinfo()</em></span> and
                        <span class="emphasis"><em>getnameinfo()</em></span>.<a id="IDX-CHP-59-7874" class="indexterm"/><a id="IDX-CHP-59-7875" class="indexterm"/><a id="IDX-CHP-59-7876" class="indexterm"/><a id="IDX-CHP-59-7877" class="indexterm"/><a id="IDX-CHP-59-7872" class="indexterm"/><a id="IDX-CHP-59-7873" class="indexterm"/></p><a id="I_programlisting59_d1e154434"/><pre class="programlisting">#include &lt;netdb.h&gt;

struct servent *<strong class="userinput"><code>getservbyname</code></strong>(const char *<span class="emphasis"><em>name</em></span>, const char *<span class="emphasis"><em>proto</em></span>);
struct servent *<strong class="userinput"><code>getservbyport</code></strong>(int <span class="emphasis"><em>port</em></span>, const char *<span class="emphasis"><em>proto</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Both return pointer to a (statically allocated)
                            <span class="emphasis"><em>servent</em></span> structure on success, or <code class="literal">NULL</code> on not found or error<a id="IDX-CHP-59-7878" class="indexterm"/></p></div><p>The <span class="emphasis"><em>getservbyname()</em></span> function looks up the record whose
                    service name (or one of its aliases) matches <span class="emphasis"><em>name</em></span> and whose
                    protocol matches <span class="emphasis"><em>proto</em></span>. The <span class="emphasis"><em>proto</em></span>
                    argument is a string such as <span class="emphasis"><em>tcp</em></span> or
                        <span class="emphasis"><em>udp</em></span>, or it can be <code class="literal">NULL</code>. If <span class="emphasis"><em>proto</em></span> is specified as <code class="literal">NULL</code>, any record whose service name matches
                        <span class="emphasis"><em>name</em></span> is returned. (This is usually sufficient since,
                    where both UDP and TCP records with the same name exist in the <code class="literal">/etc/services</code> file, they normally have the same
                    port number.) If a matching record is found, then
                        <span class="emphasis"><em>getservbyname()</em></span> returns a pointer to a statically
                    allocated structure of the following type:</p><a id="I_programlisting59_d1e154509"/><pre class="programlisting">struct servent {
    char  *s_name;          /* Official service name */
    char **s_aliases;       /* Pointers to aliases (NULL-terminated) */
    int    s_port;          /* Port number (in network byte order) */
    char  *s_proto;         /* Protocol */
};</pre><p>Typically, we call <span class="emphasis"><em>getservbyname()</em></span> only in order to
                    obtain the port number, which is returned in the <span class="emphasis"><em>s_port</em></span>
                    field.</p><p>The <span class="emphasis"><em>getservbyport()</em></span> function performs the converse of
                        <span class="emphasis"><em>getservbyname()</em></span>. It returns a
                        <span class="emphasis"><em>servent</em></span> record containing information from the <code class="literal">/etc/services</code> record whose port number matches
                        <span class="emphasis"><em>port</em></span> and whose protocol matches
                        <span class="emphasis"><em>proto</em></span>. Again, we can specify <span class="emphasis"><em>proto</em></span>
                    as <code class="literal">NULL</code>, in which case the call will return
                    any record whose port number matches the one specified in
                        <span class="emphasis"><em>port</em></span>. (This may not return the desired result in the
                    few cases mentioned above where the same port number maps to different service
                    names in UDP and TCP.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>An example of the use of the <span class="emphasis"><em>getservbyname()</em></span> function
                        is provided in the file <code class="literal">files/t_getservbyname.c</code> in the source code distribution for
                        this book.</p></div></div></div><div class="sect1" title="UNIX Versus Internet Domain Sockets"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="unix_versus_internet_domain_sockets">UNIX Versus Internet Domain Sockets</h2></div></div></div><p>When writing applications that communicate over a network, we must necessarily use
                Internet domain sockets. However, when using sockets to communicate between
                applications on the same system, we have the choice of using either Internet or UNIX
                domain sockets. In the case, which domain should we use and why?<a id="IDX-CHP-59-7879" class="indexterm"/><a id="IDX-CHP-59-7880" class="indexterm"/><a id="IDX-CHP-59-7881" class="indexterm"/><a id="IDX-CHP-59-7882" class="indexterm"/><a id="IDX-CHP-59-7883" class="indexterm"/><a id="IDX-CHP-59-7884" class="indexterm"/><a id="IDX-CHP-59-7885" class="indexterm"/><a id="IDX-CHP-59-7886" class="indexterm"/><a id="IDX-CHP-59-7887" class="indexterm"/><a id="IDX-CHP-59-7888" class="indexterm"/><a id="IDX-CHP-59-7889" class="indexterm"/><a id="IDX-CHP-59-7890" class="indexterm"/></p><p>Writing an application using just Internet domain sockets is often the simplest
                approach, since it will work on both a single host and across a network. However,
                there are some reasons why we may choose to use UNIX domain sockets:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>On some implementations, UNIX domain sockets are faster than Internet
                        domain sockets.</p></li><li class="listitem"><p>We can use directory (and, on Linux, file) permissions to control access
                        to UNIX domain sockets, so that only applications with a specified user or
                        group ID can connect to a listening stream socket or send a datagram to a
                        datagram socket. This provides a simple method of authenticating clients.
                        With Internet domain sockets, we need to do rather more work if we wish to
                        authenticate clients.</p></li><li class="listitem"><p>Using UNIX domain sockets, we can pass open file descriptors and sender
                        credentials, as summarized in <a class="xref" href="ch61.html#passing_file_descriptors" title="Passing File Descriptors">Passing File Descriptors</a>.</p></li></ul></div></div><div class="sect1" title="Further Information"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="further_information-id81">Further Information</h2></div></div></div><p>There is a wealth of printed and online resources on TCP/IP and the sockets
                API:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The key book on network programming with the sockets API is [Stevens at
                        al., 2004]. [Snader, 2000] adds some useful guidelines on sockets
                        programming.</p></li><li class="listitem"><p>[Stevens, 1994] and [Wright &amp; Stevens, 1995] describe TCP/IP in
                        detail. [Comer, 2000], [Comer &amp; Stevens, 1999], [Comer &amp;
                        Stevens, 2000], [Kozierok, 2005], and [Goralksi, 2009] also provide good
                        coverage of the same material.</p></li><li class="listitem"><p>[Tanenbaum, 2002] provides general background on computer networks.</p></li><li class="listitem"><p>[Herbert, 2004] describes the details of the Linux 2.6 TCP/IP
                        stack.</p></li><li class="listitem"><p>The GNU C library manual (online at <a class="ulink" href="http://www.gnu.org/" target="_top">http://www.gnu.org/</a>)
                        has an extensive discussion of the sockets API.</p></li><li class="listitem"><p>The IBM Redbook, <span class="emphasis"><em>TCP/IP Tutorial and Technical
                            Overview</em></span>, provides lengthy coverage of networking concepts,
                        TCP/IP internals, the sockets API, and a host of related topics. It is
                        freely downloadable from <a class="ulink" href="http://www.redbooks.ibm.com/" target="_top">http://www.redbooks.ibm.com/</a>.</p></li><li class="listitem"><p>[Gont, 2008] and [Gont, 2009b] provide security assessments of IPv4 and
                        TCP.</p></li><li class="listitem"><p>The Usenet newsgroup <span class="emphasis"><em>comp.protocols.tcp-ip</em></span> is
                        dedicated to questions related to the TCP/IP networking protocols.</p></li><li class="listitem"><p>[Sarolahti &amp; Kuznetsov, 2002] describes congestion control and
                        other details of the Linux TCP implementation.</p></li><li class="listitem"><p>Linux-specific information can be found in the following manual pages:
                            <span class="emphasis"><em>socket(7)</em></span>, <span class="emphasis"><em>ip(7)</em></span>,
                            <span class="emphasis"><em>raw(7)</em></span>, <span class="emphasis"><em>tcp(7)</em></span>,
                            <span class="emphasis"><em>udp(7)</em></span>, and <span class="emphasis"><em>packet(7)</em></span>.</p></li><li class="listitem"><p>See also the RFC list in Section 58.7.</p></li></ul></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id58">Summary</h2></div></div></div><p>Internet domain sockets allow applications on different hosts to communicate via a
                TCP/IP network. An Internet domain socket address consists of an IP address and a
                port number. In IPv4, an IP address is a 32-bit number; in IPv6, it is a 128-bit
                number. Internet domain datagram sockets operate over UDP, providing connectionless,
                unreliable, message-oriented communication. Internet domain stream sockets operate
                over TCP, and provide a reliable, bidirectional, byte-stream communication channel
                between two connected applications.<a id="IDX-CHP-59-7891" class="indexterm"/><a id="IDX-CHP-59-7892" class="indexterm"/></p><p>Different computer architectures use different conventions for representing data
                types. For example, integers may be stored in little-endian or big-endian form, and
                different computers may use different numbers of bytes to represent numeric types
                such as <span class="emphasis"><em>int</em></span> or <span class="emphasis"><em>long</em></span>. These differences
                mean that we need to employ some architecture-independent representation when
                transferring data between heterogeneous machines connected via a network. We noted
                that various marshalling standards exist to deal this problem, and also described a
                simple solution used by many applications: encoding all transmitted data in text
                form, with fields delimited by a designated character (usually a newline).</p><p>We looked at a range of functions that can be used to convert between (numeric)
                string representations of IP addresses (dotted-decimal for IPv4 and hex-string for
                IPv6) and their binary equivalents. However, it is generally preferable to use host
                and service names rather than numbers, since names are easier to remember and
                continue to be usable, even if the corresponding number is changed. We looked at
                various functions that convert host and service names to their numeric equivalents
                and vice versa. The modern function for translating host and service names into
                socket addresses is <span class="emphasis"><em>getaddrinfo()</em></span>, but it is common to see the
                historical functions <span class="emphasis"><em>gethostbyname()</em></span> and
                    <span class="emphasis"><em>getservbyname()</em></span> in existing code.</p><p>Consideration of hostname conversions led us into a discussion of DNS, which
                implements a distributed database for a hierarchical directory service. The
                advantage of DNS is that the management of the database is not centralized. Instead,
                local zone administrators update changes for the hierarchical component of the
                database for which they are responsible, and DNS servers communicate with one
                another in order to resolve a hostname.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id40">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>When reading large quantities of data, the <span class="emphasis"><em>readLine()</em></span>
                        function shown in <a class="xref" href="ch59.html#reading_data_a_line_at_a_time" title="Example 59-1. Reading data a line at a time">Example 59-1</a> is
                        inefficient, since a system call is required to read each character. A more
                        efficient interface would read a block of characters into a buffer and
                        extract a line at a time from this buffer. Such an interface might consist
                        of two functions. The first of these functions, which might be called
                            <span class="emphasis"><em>readLineBufInit(fd</em></span>,
                            <span class="emphasis"><em>&amp;rlbuf)</em></span>, initializes the bookkeeping data
                        structure pointed to by <span class="emphasis"><em>rlbuf</em></span>. This structure includes
                        space for a data buffer, the size of that buffer, and a pointer to the next
                        “unread” character in that buffer. It also includes a copy of the file
                        descriptor given in the argument <span class="emphasis"><em>fd</em></span>. The second
                        function, <span class="emphasis"><em>readLineBuf(&amp;rlbuf)</em></span>, returns the next
                        line from the buffer associated with <span class="emphasis"><em>rlbuf</em></span>. If
                        required, this function reads a further block of data from the file
                        descriptor saved in <span class="emphasis"><em>rlbuf</em></span>. Implement these two
                        functions. Modify the programs in <a class="xref" href="ch59.html#an_iterative_server_that_uses_a_stream_s" title="Example 59-6. An iterative server that uses a stream socket to communicate with clients">Example 59-6</a> (<code class="literal">is_seqnum_sv.c</code>) and <a class="xref" href="ch59.html#a_client_that_uses_stream_sockets" title="Example 59-7. A client that uses stream sockets">Example 59-7</a> (<code class="literal">is_seqnum_cl.c</code>) to use these functions.</p></li><li class="listitem"><p>Modify the programs in <a class="xref" href="ch59.html#an_iterative_server_that_uses_a_stream_s" title="Example 59-6. An iterative server that uses a stream socket to communicate with clients">Example 59-6</a> (<code class="literal">is_seqnum_sv.c</code>) and <a class="xref" href="ch59.html#a_client_that_uses_stream_sockets" title="Example 59-7. A client that uses stream sockets">Example 59-7</a> (<code class="literal">is_seqnum_cl.c</code>) to use the <span class="emphasis"><em>inetListen()</em></span>
                        and <span class="emphasis"><em>inetConnect()</em></span> functions provided in <a class="xref" href="ch59.html#an_internet_domain_sockets_librar" title="Example 59-9. An Internet domain sockets library">Example 59-9</a> (<code class="literal">inet_sockets.c</code>).</p></li><li class="listitem"><p>Write a UNIX domain sockets library with an API similar to the Internet
                        domain sockets library shown in <a class="xref" href="ch59.html#an_internet_domain_sockets_library" title="An Internet Domain Sockets Library">An Internet Domain Sockets Library</a>. Rewrite the programs in
                            <a class="xref" href="ch57.html#a_simple_unix_domain_stream_socket_serve" title="Example 57-3. A simple UNIX domain stream socket server">Example 57-3</a> (<code class="literal">us_xfr_sv.c</code>, in <a class="xref" href="ch57.html#stream_sockets_in_the_unix_domain" title="Stream Sockets in the UNIX Domain">Stream Sockets in the UNIX Domain</a>) and <a class="xref" href="ch57.html#a_simple_unix_domain_stream_socket_clien" title="Example 57-4. A simple UNIX domain stream socket client">Example 57-4</a> (<code class="literal">us_xfr_cl.c</code>, in <a class="xref" href="ch57.html#stream_sockets_in_the_unix_domain" title="Stream Sockets in the UNIX Domain">Stream Sockets in the UNIX Domain</a>) to use this
                        library.</p></li><li class="listitem"><p>Write a network server that stores name-value pairs. The server should
                        allow names to be added, deleted, modified, and retrieved by clients. Write
                        one or more client programs to test the server. Optionally, implement some
                        kind of security mechanism that allows only the client that created the name
                        to delete it or to modify the value associated with it.</p></li><li class="listitem"><p>Suppose that we create two Internet domain datagram sockets, bound to
                        specific addresses, and connect the first socket to the second. What happens
                        if we create a third datagram socket and try to send
                            (<span class="emphasis"><em>sendto()</em></span>) a datagram via that socket to the first
                        socket? Write a program to determine the answer.</p></li></ol></div></div></section></body></html>
