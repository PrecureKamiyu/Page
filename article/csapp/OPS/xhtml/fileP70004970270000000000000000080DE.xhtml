<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>12.2 Concurrent Programming with I/O Multiplexing</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P70004970270000000000000000080DE" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000046BD6" data-uri="chapter12.xhtml#P7000497027000000000000000046BD6" epub:type="title"><span class="pcalibre label pcalibre1">12.2 </span>Concurrent Programming with I/O Multiplexing</h1></header>
<p id="P7000497027000000000000000046BD7" data-uri="chapter12.xhtml#P7000497027000000000000000046BD7" class="pcalibre1 pcalibre calibre2">Suppose you are asked to write an echo server that can also respond to interactive commands that the user types to standard input. In this case, the server must respond to two independent I/O events: (1) a network client making a connection request, and (2) a user typing a command line at the keyboard. Which event do we wait for first? Neither option is ideal. If we are waiting for a connection request in accept, then we cannot respond to input commands. Similarly, if we are waiting for an input command in read, then we cannot respond to any connection requests.</p>
<p id="P7000497027000000000000000046BD8" data-uri="chapter12.xhtml#P7000497027000000000000000046BD8" class="pcalibre1 pcalibre calibre2">One solution to this dilemma is a technique called <i class="calibre5 pcalibre pcalibre1">I/O multiplexing</i>. The basic idea is to use the <code id="P7000497027000000000000000046BD9" data-uri="chapter12.xhtml#P7000497027000000000000000046BD9" class="pcalibre1 calibre8 pcalibre">select</code> function to ask the kernel to suspend the process, returning control to the application only after one or more I/O events have occurred, as in the following examples:</p>
<ul id="P7000497027000000000000000046BDA" data-uri="chapter12.xhtml#P7000497027000000000000000046BDA" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000046BDB" data-uri="chapter12.xhtml#P7000497027000000000000000046BDB" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046BDC" data-uri="chapter12.xhtml#P7000497027000000000000000046BDC" class="pcalibre calibre3 pcalibre1">Return when any descriptor in the set {0, 4} is ready for reading.</p></li>
<li id="P7000497027000000000000000046BDD" data-uri="chapter12.xhtml#P7000497027000000000000000046BDD" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046BDE" data-uri="chapter12.xhtml#P7000497027000000000000000046BDE" class="pcalibre calibre3 pcalibre1">Return when any descriptor in the set {1, 2, 7} is ready for writing.</p></li>
<li id="P7000497027000000000000000046BDF" data-uri="chapter12.xhtml#P7000497027000000000000000046BDF" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046BE0" data-uri="chapter12.xhtml#P7000497027000000000000000046BE0" class="pcalibre calibre3 pcalibre1">Time out if 152.13 seconds have elapsed waiting for an I/O event to occur.</p></li>
</ul>
<p id="P7000497027000000000000000046BE1" data-uri="chapter12.xhtml#P7000497027000000000000000046BE1" class="pcalibre1 pcalibre calibre2"><code id="P7000497027000000000000000046BE2" data-uri="chapter12.xhtml#P7000497027000000000000000046BE2" class="pcalibre1 calibre8 pcalibre">Select</code> is a complicated function with many different usage scenarios. We will only discuss the first scenario: waiting for a set of descriptors to be ready for reading. See [<a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41E">62</a>, <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B480">110</a>] for a complete discussion.</p>
<pre id="P7000497027000000000000000046BE3" data-uri="chapter12.xhtml#P7000497027000000000000000046BE3" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046BE4" data-uri="chapter12.xhtml#P7000497027000000000000000046BE4" class="calibre10 pcalibre pcalibre1">
#include &lt;sys/select.h&gt;
int select(int n, fd_set *fdset, NULL, NULL, NULL);
			   Returns: nonzero count of ready descriptors, --1 on error
FD_ZERO(fd_set *fdset);			/* Clear all bits in fdset */
FD_CLR(int fd, fd_set *fdset);		/* Clear bit fd in fdset */
FD_SET(int fd, fd_set *fdset);		/* Turn on bit fd in fdset */
FD_ISSET(int fd, fd_set *fdset);	/* Is bit fd in fdset on? */
					   Macros for manipulating descriptor sets
</code></pre>
<p id="P7000497027000000000000000046BE5" data-uri="chapter12.xhtml#P7000497027000000000000000046BE5" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000080EF" title="978" data-uri="chapter12.xhtml#P70004970270000000000000000080EF" epub:type="pagebreak"></span>The <code id="P7000497027000000000000000046BE6" data-uri="chapter12.xhtml#P7000497027000000000000000046BE6" class="pcalibre1 calibre8 pcalibre">select</code> function manipulates sets of type <code id="P7000497027000000000000000046BE7" data-uri="chapter12.xhtml#P7000497027000000000000000046BE7" class="pcalibre1 calibre8 pcalibre">fd_set</code>, which are known as <i class="calibre5 pcalibre pcalibre1">descriptor sets</i>. Logically, we think of a descriptor set as a bit vector (introduced in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000002AD_split_000.xhtml#P70004970270000000000000000002AD"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">2.1</span></a>) of size <var class="calibre5 pcalibre pcalibre1">n</var>:</p>
<div class="informalequation pcalibre pcalibre1" id="P7000497027000000000000000046BE8" data-uri="chapter12.xhtml#P7000497027000000000000000046BE8">
<m:math display="block" alttext="" data-uri="" altimg-width="140" altimg-height="20" altimg="../images/ch12-01.png"><m:mrow><m:msub><m:mi>b</m:mi><m:mrow><m:mi>n</m:mi><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:mo>…</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>b</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>b</m:mi><m:mn>0</m:mn></m:msub></m:mrow></m:math>
</div>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046BE9" data-uri="chapter12.xhtml#P7000497027000000000000000046BE9">Each bit <i class="calibre5 pcalibre pcalibre1">b<sub class="pcalibre1 calibre47 pcalibre">k</sub></i> corresponds to descriptor <var class="calibre5 pcalibre pcalibre1">k</var>. Descriptor <var class="calibre5 pcalibre pcalibre1">k</var> is a member of the descriptor set if and only if <i class="calibre5 pcalibre pcalibre1">b<sub class="pcalibre1 calibre47 pcalibre">k</sub></i> = 1. You are only allowed to do three things with descriptor sets: (1) allocate them, (2) assign one variable of this type to another, and (3) modify and inspect them using the FD_ZERO, FD_SET, FD_CLR, and FD_ISSET macros.</p>
<p id="P7000497027000000000000000046BEA" data-uri="chapter12.xhtml#P7000497027000000000000000046BEA" class="pcalibre1 pcalibre calibre2">For our purposes, the select function takes two inputs: a descriptor set (<code id="P7000497027000000000000000046BEB" data-uri="chapter12.xhtml#P7000497027000000000000000046BEB" class="pcalibre1 calibre8 pcalibre">fdset</code>) called the <i class="calibre5 pcalibre pcalibre1">read set</i>, and the cardinality (n) of the read set (actually the maximum cardinality of any descriptor set). The <code id="P7000497027000000000000000046BEC" data-uri="chapter12.xhtml#P7000497027000000000000000046BEC" class="pcalibre1 calibre8 pcalibre">select</code> function blocks until at least one descriptor in the read set is ready for reading. A descriptor <var class="calibre5 pcalibre pcalibre1">k</var> is <i class="calibre5 pcalibre pcalibre1">ready for reading</i> if and only if a request to read 1 byte from that descriptor would not block. As a side effect, <code id="P7000497027000000000000000046BED" data-uri="chapter12.xhtml#P7000497027000000000000000046BED" class="pcalibre1 calibre8 pcalibre">select</code> modifies the <code id="P7000497027000000000000000046BEE" data-uri="chapter12.xhtml#P7000497027000000000000000046BEE" class="pcalibre1 calibre8 pcalibre">fd_set</code> pointed to by argument <code id="P7000497027000000000000000046BEF" data-uri="chapter12.xhtml#P7000497027000000000000000046BEF" class="pcalibre1 calibre8 pcalibre">fdset</code> to indicate a subset of the read set called the <i class="calibre5 pcalibre pcalibre1">ready set</i>, consisting of the descriptors in the read set that are ready for reading. The value returned by the function indicates the cardinality of the ready set. Note that because of the side effect, we must update the read set every time <code id="P7000497027000000000000000046BF0" data-uri="chapter12.xhtml#P7000497027000000000000000046BF0" class="pcalibre1 calibre8 pcalibre">select</code> is called.</p>
<p id="P7000497027000000000000000046BF1" data-uri="chapter12.xhtml#P7000497027000000000000000046BF1" class="pcalibre1 pcalibre calibre2">The best way to understand <code id="P7000497027000000000000000046BF2" data-uri="chapter12.xhtml#P7000497027000000000000000046BF2" class="pcalibre1 calibre8 pcalibre">select</code> is to study a concrete example. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008109"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.6</span></a> shows how we might use <code id="P7000497027000000000000000046BF3" data-uri="chapter12.xhtml#P7000497027000000000000000046BF3" class="pcalibre1 calibre8 pcalibre">select</code> to implement an iterative echo server that also accepts user commands on the standard input. We begin by using the <code id="P7000497027000000000000000046BF4" data-uri="chapter12.xhtml#P7000497027000000000000000046BF4" class="pcalibre1 calibre8 pcalibre">open_listenfd</code> function from <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000007CC1.xhtml#P7000497027000000000000000007E55"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.19</span></a> to open a listening descriptor (line 16), and then using FD_ZERO to create an empty read set (line 18):</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000046BF5" data-uri="chapter12.xhtml#P7000497027000000000000000046BF5">
<img alt="A diagram of read_set (Ø) has 0 within bits 3 (listenfd) to 0 (stdin)." id="P7000497027000000000000000046BF6" data-uri="P700049702700000000000000000B7CC" src="../images/p978-1.png" class="calibre331 pcalibre pcalibre1"/>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046BF7" data-uri="chapter12.xhtml#P7000497027000000000000000046BF7">Next, in lines 19 and 20, we define the read set to consist of descriptor 0 (standard input) and descriptor 3 (the listening descriptor), respectively:</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000046BF8" data-uri="chapter12.xhtml#P7000497027000000000000000046BF8">
<img alt="A diagram of read_set ({0,3}) has 1 within bits 3 (listenfd) to 0 (stdin), and 0 in bits 2 and 1." id="P7000497027000000000000000046BF9" data-uri="P700049702700000000000000000B7CD" src="../images/p978-2.png" class="pcalibre1 pcalibre calibre332"/>
</figure>
<p id="P7000497027000000000000000046BFA" data-uri="chapter12.xhtml#P7000497027000000000000000046BFA" class="pcalibre1 pcalibre calibre2">At this point, we begin the typical server loop. But instead of waiting for a connection request by calling the <code id="P7000497027000000000000000046BFB" data-uri="chapter12.xhtml#P7000497027000000000000000046BFB" class="pcalibre1 calibre8 pcalibre">accept</code> function, we call the <code id="P7000497027000000000000000046BFC" data-uri="chapter12.xhtml#P7000497027000000000000000046BFC" class="pcalibre1 calibre8 pcalibre">select</code> function, which blocks until either the listening descriptor or standard input is ready for reading (line 24). For example, here is the value of <code id="P7000497027000000000000000046BFD" data-uri="chapter12.xhtml#P7000497027000000000000000046BFD" class="pcalibre1 calibre8 pcalibre">ready_set</code> that <code id="P7000497027000000000000000046BFE" data-uri="chapter12.xhtml#P7000497027000000000000000046BFE" class="pcalibre1 calibre8 pcalibre">select</code> would return if the user hit the enter key, thus causing the standard input descriptor to</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000008109" data-uri="chapter12.xhtml#P7000497027000000000000000008109">
<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000810A" title="979" data-uri="chapter12.xhtml#P700049702700000000000000000810A" epub:type="pagebreak"></span>
<p id="P7000497027000000000000000046BFF" data-uri="chapter12.xhtml#P7000497027000000000000000046BFF" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/select.c</i></p>
<pre id="P7000497027000000000000000046C00" data-uri="chapter12.xhtml#P7000497027000000000000000046C00" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046C01" data-uri="chapter12.xhtml#P7000497027000000000000000046C01" class="calibre10 pcalibre pcalibre1">
1	#include "csapp.h"
2	void echo(int connfd);
3	void command(void);
4	
5	int main(int argc, char **argv)
6	{
7		int listenfd, connfd;
8		socklen_t clientlen;
9		struct sockaddr_storage clientaddr;
10		fd_set read_set, ready_set;
11	
12		if (argc != 2) {
13			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
14			exit(0);
15		}
16		listenfd = Open_listenfd(argv[1]);
17	
18		FD_ZERO(&amp;read_set);			/* Clear read set */
19		FD_SET(STDIN_FILENO, &amp;read_set);	/* Add stdin to read set */
20		FD_SET(listenfd, &amp;read_set);		/* Add listenfd to read set */
21	
22		while (1) {
23			ready_set = read_set;
24			Select(listenfd+1, &amp;ready_set, NULL, NULL, NULL);
25			if (FD_ISSET(STDIN_FILENO, &amp;ready_set))
26				command(); /* Read command line from stdin */
27			if (FD_ISSET(listenfd, &amp;ready_set)) {
28				clientlen = sizeof(struct sockaddr_storage);
29				connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);
30				echo(connfd); /* Echo client input until EOF */
31				Close(connfd);
32			}
33		}
34	}
35	
36	void command(void) {
37		char buf[MAXLINE];
38		if (!Fgets(buf, MAXLINE, stdin))
39			exit(0); /* EOF */
40		printf("%s", buf); /* Process the input command */
41	}
</code></pre>
<p id="P7000497027000000000000000046C02" data-uri="chapter12.xhtml#P7000497027000000000000000046C02" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/select.c</i></p>
<figcaption id="P7000497027000000000000000046C03" data-uri="chapter12.xhtml#P7000497027000000000000000046C03" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046C04" data-uri="chapter12.xhtml#P7000497027000000000000000046C04" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.6 </span>An iterative echo server that uses I/O multiplexing.</h1></header>
<div class="caption pcalibre pcalibre1" id="P7000497027000000000000000046C05" data-uri="chapter12.xhtml#P7000497027000000000000000046C05"><p id="P7000497027000000000000000046C06" data-uri="chapter12.xhtml#P7000497027000000000000000046C06" class="pcalibre calibre3 pcalibre1">The server uses <code id="P7000497027000000000000000046C07" data-uri="chapter12.xhtml#P7000497027000000000000000046C07" class="pcalibre1 calibre8 pcalibre">select</code> to wait for connection requests on a listening descriptor and commands on standard input.</p></div></figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046C08" data-uri="chapter12.xhtml#P7000497027000000000000000046C08"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000008115" title="980" data-uri="chapter12.xhtml#P7000497027000000000000000008115" epub:type="pagebreak"></span>become ready for reading:</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000046C09" data-uri="chapter12.xhtml#P7000497027000000000000000046C09">
<img alt="A diagram of read_set ({0}) shows 1 within bit 0 (stdin) and 0 in bits 3 (listenfd) to 1." id="P7000497027000000000000000046C0A" data-uri="P700049702700000000000000000B7CE" src="../images/p980-1.png" class="pcalibre calibre333 pcalibre1"/>
</figure>
<p id="P7000497027000000000000000046C0B" data-uri="chapter12.xhtml#P7000497027000000000000000046C0B" class="pcalibre1 pcalibre calibre2">Once <code id="P7000497027000000000000000046C0C" data-uri="chapter12.xhtml#P7000497027000000000000000046C0C" class="pcalibre1 calibre8 pcalibre">select</code> returns, we use the FD_ISSET macro to determine which descriptors are ready for reading. If standard input is ready (line 25), we call the <code id="P7000497027000000000000000046C0D" data-uri="chapter12.xhtml#P7000497027000000000000000046C0D" class="pcalibre1 calibre8 pcalibre">command</code> function, which reads, parses, and responds to the command before returning to the main routine. If the listening descriptor is ready (line 27), we call <code id="P7000497027000000000000000046C0E" data-uri="chapter12.xhtml#P7000497027000000000000000046C0E" class="pcalibre1 calibre8 pcalibre">accept</code> to get a connected descriptor and then call the echo function from <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000007CC1.xhtml#P7000497027000000000000000007E78"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.22</span></a>, which echoes each line from the client until the client closes its end of the connection.</p>
<p id="P7000497027000000000000000046C0F" data-uri="chapter12.xhtml#P7000497027000000000000000046C0F" class="pcalibre1 pcalibre calibre2">While this program is a good example of using <code id="P7000497027000000000000000046C10" data-uri="chapter12.xhtml#P7000497027000000000000000046C10" class="pcalibre1 calibre8 pcalibre">select</code>, it still leaves something to be desired. The problem is that once it connects to a client, it continues echoing input lines until the client closes its end of the connection. Thus, if you type a command to standard input, you will not get a response until the server is finished with the client. A better approach would be to multiplex at a finer granularity, echoing (at most) one text line each time through the server loop.</p>
<section id="P700049702700000000000000000811E" data-uri="chapter12.xhtml#P700049702700000000000000000811E" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046C11" data-uri="chapter12.xhtml#P7000497027000000000000000046C11" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">12.3 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000046C12" data-uri="chapter12.xhtml#P7000497027000000000000000046C12">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000046C13" data-uri="chapter12.xhtml#P7000497027000000000000000046C13">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000046C14" data-uri="chapter12.xhtml#P7000497027000000000000000046C14"><p id="P7000497027000000000000000046C15" data-uri="chapter12.xhtml#P7000497027000000000000000046C15" class="pcalibre calibre3 pcalibre1">In Linux systems, typing Ctrl+D indicates EOF on standard input. What happens if you type Ctrl+D to the program in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008109"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.6</span></a> while it is blocked in the call to <code id="P7000497027000000000000000046C16" data-uri="chapter12.xhtml#P7000497027000000000000000046C16" class="pcalibre1 calibre8 pcalibre">select</code>?</p></div></li>
</ol>
</section>
<section id="P7000497027000000000000000008125" data-uri="chapter12.xhtml#P7000497027000000000000000008125" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046C17" data-uri="chapter12.xhtml#P7000497027000000000000000046C17" epub:type="title"><span class="pcalibre label pcalibre1">12.2.1 </span>A Concurrent Event-Driven Server Based on I/O Multiplexing</h1></header>
<p id="P7000497027000000000000000046C18" data-uri="chapter12.xhtml#P7000497027000000000000000046C18" class="pcalibre1 pcalibre calibre2">I/O multiplexing can be used as the basis for concurrent <i class="calibre5 pcalibre pcalibre1">event-driven</i> programs, where flows make progress as a result of certain events. The general idea is to model logical flows as state machines. Informally, a <i class="calibre5 pcalibre pcalibre1">state machine</i> is a collection of <i class="calibre5 pcalibre pcalibre1">states</i>, <i class="calibre5 pcalibre pcalibre1">input events</i>, and <i class="calibre5 pcalibre pcalibre1">transitions</i> that map states and input events to states. Each transition maps an (input state, input event) pair to an output state. A <i class="calibre5 pcalibre pcalibre1">self-loop</i> is a transition between the same input and output state. State machines are typically drawn as directed graphs, where nodes represent states, directed arcs represent transitions, and arc labels represent input events. A state machine begins execution in some initial state. Each input event triggers a transition from the current state to the next state.</p>
<p id="P7000497027000000000000000046C19" data-uri="chapter12.xhtml#P7000497027000000000000000046C19" class="pcalibre1 pcalibre calibre2">For each new client <var class="calibre5 pcalibre pcalibre1">k</var>, a concurrent server based on I/O multiplexing creates a new state machine <i class="calibre5 pcalibre pcalibre1">s<sub class="pcalibre1 calibre47 pcalibre">k</sub></i> and associates it with connected descriptor <i class="calibre5 pcalibre pcalibre1">d<sub class="pcalibre1 calibre47 pcalibre">k</sub></i>. As shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008129"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.7</span></a>, each state machine <i class="calibre5 pcalibre pcalibre1">s<sub class="pcalibre1 calibre47 pcalibre">k</sub></i> has one state ("waiting for descriptor <i class="calibre5 pcalibre pcalibre1">d<sub class="pcalibre1 calibre47 pcalibre">k</sub></i> to be ready for reading"), one input event ("descriptor <i class="calibre5 pcalibre pcalibre1">d<sub class="pcalibre1 calibre47 pcalibre">k</sub></i> is ready for reading"), and one transition ("read a text line from descriptor <i class="calibre5 pcalibre pcalibre1">d<sub class="pcalibre1 calibre47 pcalibre">k</sub></i>").</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000008129" data-uri="chapter12.xhtml#P7000497027000000000000000008129">
<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000812A" title="981" data-uri="chapter12.xhtml#P700049702700000000000000000812A" epub:type="pagebreak"></span>
<img alt="A diagram illustrates a state machine." id="P7000497027000000000000000046C1A" data-uri="P700049702700000000000000000B7CF" src="../images/p981-1.png" class="calibre334 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000046C1B" data-uri="chapter12.xhtml#P7000497027000000000000000046C1B" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046C1C" data-uri="chapter12.xhtml#P7000497027000000000000000046C1C" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.7 </span>State machine for a logical flow in a concurrent event-driven echo server.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000026F8C" data-uri="chapter12.xhtml#P7000497027000000000000000026F8C">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000046C1D" data-uri="chapter12.xhtml#P7000497027000000000000000046C1D" class="pcalibre calibre3 pcalibre1">A diagram shows a state machine with State: “waiting for descriptor d<sub class="pcalibre1 calibre47 pcalibre">k</sub> to be ready for reading.” An arrow on the state loops from input event: “descriptor d<sub class="pcalibre1 calibre47 pcalibre">k</sub> is ready for reading,” back to the state a transition: “read a text line from descriptor d<sub class="pcalibre1 calibre47 pcalibre">k</sub>.”</p>
</details>
</figcaption>
</figure>
<p id="P7000497027000000000000000046C1E" data-uri="chapter12.xhtml#P7000497027000000000000000046C1E" class="pcalibre1 pcalibre calibre2">The server uses the I/O multiplexing, courtesy of the <code id="P7000497027000000000000000046C1F" data-uri="chapter12.xhtml#P7000497027000000000000000046C1F" class="pcalibre1 calibre8 pcalibre">select</code> function, to detect the occurrence of input events. As each connected descriptor becomes ready for reading, the server executes the transition for the corresponding state machine—in this case, reading and echoing a text line from the descriptor.</p>
<p id="P7000497027000000000000000046C20" data-uri="chapter12.xhtml#P7000497027000000000000000046C20" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008144"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.8</span></a> shows the complete example code for a concurrent event-driven server based on I/O multiplexing. The set of active clients is maintained in a pool structure (lines 3−11). After initializing the pool by calling <code id="P7000497027000000000000000046C21" data-uri="chapter12.xhtml#P7000497027000000000000000046C21" class="pcalibre1 calibre8 pcalibre">init_pool</code> (line 27), the server enters an infinite loop. During each iteration of this loop, the server calls the <code id="P7000497027000000000000000046C22" data-uri="chapter12.xhtml#P7000497027000000000000000046C22" class="pcalibre1 calibre8 pcalibre">select</code> function to detect two different kinds of input events: (1) a connection request arriving from a new client, and (2) a connected descriptor for an existing client being ready for reading. When a connection request arrives (line 35), the server opens the connection (line 37) and calls the <code id="P7000497027000000000000000046C23" data-uri="chapter12.xhtml#P7000497027000000000000000046C23" class="pcalibre1 calibre8 pcalibre">add_client</code> function to add the client to the pool (line 38). Finally, the server calls the <code id="P7000497027000000000000000046C24" data-uri="chapter12.xhtml#P7000497027000000000000000046C24" class="pcalibre1 calibre8 pcalibre">check_clients</code> function to echo a single text line from each ready connected descriptor (line 42).</p>
<p id="P7000497027000000000000000046C25" data-uri="chapter12.xhtml#P7000497027000000000000000046C25" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000046C26" data-uri="chapter12.xhtml#P7000497027000000000000000046C26" class="pcalibre1 calibre8 pcalibre">init_pool</code> function (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000814E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.9</span></a>) initializes the client pool. The <code id="P7000497027000000000000000046C27" data-uri="chapter12.xhtml#P7000497027000000000000000046C27" class="pcalibre1 calibre8 pcalibre">clientfd</code> array represents a set of connected descriptors, with the integer −1 denoting an available slot. Initially, the set of connected descriptors is empty (lines 5−7), and the listening descriptor is the only descriptor in the <code id="P7000497027000000000000000046C28" data-uri="chapter12.xhtml#P7000497027000000000000000046C28" class="pcalibre1 calibre8 pcalibre">select</code> read set (lines 10−12).</p>
<p id="P7000497027000000000000000046C29" data-uri="chapter12.xhtml#P7000497027000000000000000046C29" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000046C2A" data-uri="chapter12.xhtml#P7000497027000000000000000046C2A" class="pcalibre1 calibre8 pcalibre">add_client</code> function (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008157"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.10</span></a>) adds a new client to the pool of active clients. After finding an empty slot in the <code id="P7000497027000000000000000046C2B" data-uri="chapter12.xhtml#P7000497027000000000000000046C2B" class="pcalibre1 calibre8 pcalibre">clientfd</code> array, the server adds the connected descriptor to the array and initializes a corresponding R<span class="smallcaps pcalibre pcalibre1">io </span>read buffer so that we can call <code id="P7000497027000000000000000046C2C" data-uri="chapter12.xhtml#P7000497027000000000000000046C2C" class="pcalibre1 calibre8 pcalibre">rio_readlineb</code> on the descriptor (lines 8−9). We then add the connected descriptor to the <code id="P7000497027000000000000000046C2D" data-uri="chapter12.xhtml#P7000497027000000000000000046C2D" class="pcalibre1 calibre8 pcalibre">select</code> read set (line 12), and we update some global properties of the pool. The <code id="P7000497027000000000000000046C2E" data-uri="chapter12.xhtml#P7000497027000000000000000046C2E" class="pcalibre1 calibre8 pcalibre">maxfd</code> variable (lines 15−16) keeps track of the largest file descriptor for <code id="P7000497027000000000000000046C2F" data-uri="chapter12.xhtml#P7000497027000000000000000046C2F" class="pcalibre1 calibre8 pcalibre">select</code>. The maxi variable (lines 17−18) keeps track of the largest index into the <code id="P7000497027000000000000000046C30" data-uri="chapter12.xhtml#P7000497027000000000000000046C30" class="pcalibre1 calibre8 pcalibre">clientfd</code> array so that the <code id="P7000497027000000000000000046C31" data-uri="chapter12.xhtml#P7000497027000000000000000046C31" class="pcalibre1 calibre8 pcalibre">check_clients</code> function does not have to search the entire array.</p>
<p id="P7000497027000000000000000046C32" data-uri="chapter12.xhtml#P7000497027000000000000000046C32" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000046C33" data-uri="chapter12.xhtml#P7000497027000000000000000046C33" class="pcalibre1 calibre8 pcalibre">check_clients</code> function in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000815F"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.11</span></a> echoes a text line from each ready connected descriptor. If we are successful in reading a text line from the descriptor, then we echo that line back to the client (lines 15−18). Notice that in line 15, we are maintaining a cumulative count of total bytes received from all clients. If we detect EOF because the client has closed its end of the connection, then we close our end of the connection (line 23) and remove the descriptor from the pool (lines 24−25).</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000008144" data-uri="chapter12.xhtml#P7000497027000000000000000008144">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000008145" title="982" data-uri="chapter12.xhtml#P7000497027000000000000000008145" epub:type="pagebreak"></span>
<p id="P7000497027000000000000000046C34" data-uri="chapter12.xhtml#P7000497027000000000000000046C34" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/echoservers.c</i></p>
<pre id="P7000497027000000000000000046C35" data-uri="chapter12.xhtml#P7000497027000000000000000046C35" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046C36" data-uri="chapter12.xhtml#P7000497027000000000000000046C36" class="calibre10 pcalibre pcalibre1">
1	#include "csapp.h"
2	
3	typedef struct {	/* Represents a pool of connected descriptors */
4	int maxfd;		/* Largest descriptor in read_set */
5	fd_set read_set;	/* Set of all active descriptors */
6	fd_set ready_set;	/* Subset of descriptors ready for reading */
7	int nready;		/* Number of ready descriptors from select */
8	int maxi;		/* High water index into client array */
9	int clientfd[FD_SETSIZE];	/* Set of active descriptors */
10	rio_t clientrio[FD_SETSIZE];	/* Set of active read buffers */
11	} pool;
12	
13	int byte_cnt = 0;	/* Counts total bytes received by server */
14	
15	int main(int argc, char **argv)
16	{
17		int listenfd, connfd;
18		socklen_t clientlen;
19		struct sockaddr_storage clientaddr;
20		static pool pool;
21	
22		if (argc != 2) {
23			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
24			exit(0);
25		}
26		listenfd = Open_listenfd(argv[1]);
27		init_pool(listenfd, &amp;pool); 28
29		while (1) {
30			/* Wait for listening/connected descriptor(s) to become ready */
31			pool.ready_set = pool.read_set;
32			pool.nready = Select(pool.maxfd+1, &amp;pool.ready_set, NULL, NULL, NULL);
33	
34			/* If listening descriptor ready, add new client to pool */
35			if (FD_ISSET(listenfd, &amp;pool.ready_set)) {
36				clientlen = sizeof(struct sockaddr_storage);
37				connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);
38				add_client(connfd, &amp;pool);
39			}
40	
41			/* Echo a text line from each ready connected descriptor */
42			check_clients(&amp;pool);
43		}
44	}
</code></pre>
<p id="P7000497027000000000000000046C37" data-uri="chapter12.xhtml#P7000497027000000000000000046C37" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/echoservers.c</i></p>
<figcaption id="P7000497027000000000000000046C38" data-uri="chapter12.xhtml#P7000497027000000000000000046C38" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046C39" data-uri="chapter12.xhtml#P7000497027000000000000000046C39" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.8 </span>Concurrent echo server based on I/O multiplexing.</h1></header>
<div class="caption pcalibre pcalibre1" id="P7000497027000000000000000046C3A" data-uri="chapter12.xhtml#P7000497027000000000000000046C3A"><p id="P7000497027000000000000000046C3B" data-uri="chapter12.xhtml#P7000497027000000000000000046C3B" class="pcalibre calibre3 pcalibre1">Each server iteration echoes a text line from each ready descriptor.</p></div></figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P700049702700000000000000000814E" data-uri="chapter12.xhtml#P700049702700000000000000000814E">
<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000814F" title="983" data-uri="chapter12.xhtml#P700049702700000000000000000814F" epub:type="pagebreak"></span>
<p id="P7000497027000000000000000046C3C" data-uri="chapter12.xhtml#P7000497027000000000000000046C3C" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/echoservers.c</i></p>
<pre id="P7000497027000000000000000046C3D" data-uri="chapter12.xhtml#P7000497027000000000000000046C3D" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046C3E" data-uri="chapter12.xhtml#P7000497027000000000000000046C3E" class="calibre10 pcalibre pcalibre1">
1	void init_pool(int listenfd, pool *p)
2	{
3		/* Initially, there are no connected descriptors */
4		int i;
5		p-&gt;maxi = −1;
6		for (i=0; i&lt; FD_SETSIZE; i++)
7			p-&gt;clientfd[i] = −1;
8	
9		/* Initially, listenfd is only member of select read set */
10		p-&gt;maxfd = listenfd;
11		FD_ZERO(&amp;p-&gt;read_set);
12		FD_SET(listenfd, &amp;p-&gt;read_set);
13	}
</code></pre>
<p id="P7000497027000000000000000046C3F" data-uri="chapter12.xhtml#P7000497027000000000000000046C3F" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/echoservers.c</i></p>
<figcaption id="P7000497027000000000000000046C40" data-uri="chapter12.xhtml#P7000497027000000000000000046C40" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046C41" data-uri="chapter12.xhtml#P7000497027000000000000000046C41" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">12.9 </span><code id="P7000497027000000000000000046C42" data-uri="chapter12.xhtml#P7000497027000000000000000046C42" class="pcalibre1 calibre8 pcalibre">init_pool</code> initializes the pool of active clients.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000008157" data-uri="chapter12.xhtml#P7000497027000000000000000008157">
<p id="P7000497027000000000000000046C43" data-uri="chapter12.xhtml#P7000497027000000000000000046C43" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/echoservers.c</i></p>
<pre id="P7000497027000000000000000046C44" data-uri="chapter12.xhtml#P7000497027000000000000000046C44" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046C45" data-uri="chapter12.xhtml#P7000497027000000000000000046C45" class="calibre10 pcalibre pcalibre1">
1	void add_client(int connfd, pool *p)
2	{
3		int i;
4		p-&gt;nready−;
5		for (i = 0; i &lt; FD_SETSIZE; i++) /* Find an available slot */
6			if (p-&gt;clientfd[i] &lt; 0) {
7				/* Add connected descriptor to the pool */
8				p-&gt;clientfd[i] = connfd;
9				Rio_readinitb(&amp;p-&gt;clientrio[i], connfd);
10	
11				/* Add the descriptor to descriptor set */
12				FD_SET(connfd, &amp;p-&gt;read_set);
13	
14				/* Update max descriptor and pool high water mark */
15				if (connfd &gt; p-&gt;maxfd)
16					p-&gt;maxfd = connfd;
17				if (i &gt; p-&gt;maxi)
18					p-&gt;maxi = i;
19				break;
20			}
21		if (i == FD_SETSIZE) /* Couldn't find an empty slot */
22			app_error("add_client error: Too many clients");
23	}
</code></pre>
<p id="P7000497027000000000000000046C46" data-uri="chapter12.xhtml#P7000497027000000000000000046C46" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/echoservers.c</i></p>
<figcaption id="P7000497027000000000000000046C47" data-uri="chapter12.xhtml#P7000497027000000000000000046C47" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046C48" data-uri="chapter12.xhtml#P7000497027000000000000000046C48" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">12.10 </span><code id="P7000497027000000000000000046C49" data-uri="chapter12.xhtml#P7000497027000000000000000046C49" class="pcalibre1 calibre8 pcalibre">add_client</code> adds a new client connection to the pool.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P700049702700000000000000000815F" data-uri="chapter12.xhtml#P700049702700000000000000000815F">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000008160" title="984" data-uri="chapter12.xhtml#P7000497027000000000000000008160" epub:type="pagebreak"></span>
<p id="P7000497027000000000000000046C4A" data-uri="chapter12.xhtml#P7000497027000000000000000046C4A" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/echoservers.c</i></p>
<pre id="P7000497027000000000000000046C4B" data-uri="chapter12.xhtml#P7000497027000000000000000046C4B" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046C4C" data-uri="chapter12.xhtml#P7000497027000000000000000046C4C" class="calibre10 pcalibre pcalibre1">
1	void check_clients(pool *p)
2	{
3		int i, connfd, n;
4		char buf[MAXLINE];
5		rio_t rio;
6	
7		for (i = 0; (i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready &gt; 0); i++) {
8			connfd = p-&gt;clientfd[i];
9			rio = p-&gt;clientrio[i];
10	
11			/* If the descriptor is ready, echo a text line from it */
12			if ((connfd &gt; 0) &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;ready_set))) {
13				p-&gt;nready−;
14				if ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) {
15					byte_cnt += n;
16					printf("Server received %d (%d total) bytes on fd %d\n",
17						n, byte_cnt, connfd);
18					Rio_writen(connfd, buf, n);
19				}
20	
21				/* EOF detected, remove descriptor from pool */
22				else {
23					Close(connfd);
24					FD_CLR(connfd, &amp;p-&gt;read_set);
25					p-&gt;clientfd[i] = −1;
26				}
27			}
28		}
29	}
</code></pre>
<p id="P7000497027000000000000000046C4D" data-uri="chapter12.xhtml#P7000497027000000000000000046C4D" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/echoservers.c</i></p>
<figcaption id="P7000497027000000000000000046C4E" data-uri="chapter12.xhtml#P7000497027000000000000000046C4E" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046C4F" data-uri="chapter12.xhtml#P7000497027000000000000000046C4F" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">12.11 </span><code id="P7000497027000000000000000046C50" data-uri="chapter12.xhtml#P7000497027000000000000000046C50" class="pcalibre1 calibre8 pcalibre">check_clients</code> services ready client connections.</h1></header>
</figcaption>
</figure>
<p id="P7000497027000000000000000046C51" data-uri="chapter12.xhtml#P7000497027000000000000000046C51" class="pcalibre1 pcalibre calibre2">In terms of the finite state model in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008129"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.7</span></a>, the <code id="P7000497027000000000000000046C52" data-uri="chapter12.xhtml#P7000497027000000000000000046C52" class="pcalibre1 calibre8 pcalibre">select</code> function detects input events, and the <code id="P7000497027000000000000000046C53" data-uri="chapter12.xhtml#P7000497027000000000000000046C53" class="pcalibre1 calibre8 pcalibre">add_client</code> function creates a new logical flow (state machine). The <code id="P7000497027000000000000000046C54" data-uri="chapter12.xhtml#P7000497027000000000000000046C54" class="pcalibre1 calibre8 pcalibre">check_clients</code> function performs state transitions by echoing input lines, and it also deletes the state machine when the client has finished sending text lines.</p>
<section id="P700049702700000000000000000816C" data-uri="chapter12.xhtml#P700049702700000000000000000816C" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000046C55" data-uri="chapter12.xhtml#P7000497027000000000000000046C55" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">12.4 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000046C56" data-uri="chapter12.xhtml#P7000497027000000000000000046C56">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000046C57" data-uri="chapter12.xhtml#P7000497027000000000000000046C57">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000046C58" data-uri="chapter12.xhtml#P7000497027000000000000000046C58"><p id="P7000497027000000000000000046C59" data-uri="chapter12.xhtml#P7000497027000000000000000046C59" class="pcalibre calibre3 pcalibre1">In the server in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008144"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.8</span></a>, we are careful to reinitialize the <code id="P7000497027000000000000000046C5A" data-uri="chapter12.xhtml#P7000497027000000000000000046C5A" class="pcalibre1 calibre8 pcalibre">pool.ready_set</code> variable immediately before every call to <code id="P7000497027000000000000000046C5B" data-uri="chapter12.xhtml#P7000497027000000000000000046C5B" class="pcalibre1 calibre8 pcalibre">select</code>. Why?</p></div></li>
</ol>
</section>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000008174" data-uri="chapter12.xhtml#P7000497027000000000000000008174"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000046C5C" data-uri="chapter12.xhtml#P7000497027000000000000000046C5C" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000008176" title="985" data-uri="chapter12.xhtml#P7000497027000000000000000008176" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>Event-driven Web servers</h1></header>
<p id="P7000497027000000000000000046C5D" data-uri="chapter12.xhtml#P7000497027000000000000000046C5D" class="pcalibre calibre3 pcalibre1">Despite the disadvantages outlined in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008178"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">12.2.2</span></a>, modern high-performance servers such as Node.js, nginx, and Tornado use event-driven programming based on I/O multiplexing, mainly because of the significant performance advantage compared to processes and threads.</p>
</aside>
</section>
<section id="P7000497027000000000000000008178" data-uri="chapter12.xhtml#P7000497027000000000000000008178" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046C5E" data-uri="chapter12.xhtml#P7000497027000000000000000046C5E" epub:type="title"><span class="pcalibre label pcalibre1">12.2.2 </span>Pros and Cons of I/O Multiplexing</h1></header>
<p id="P7000497027000000000000000046C5F" data-uri="chapter12.xhtml#P7000497027000000000000000046C5F" class="pcalibre1 pcalibre calibre2">The server in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008144"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.8</span></a> provides a nice example of the advantages and disadvantages of event-driven programming based on I/O multiplexing. One advantage is that event-driven designs give programmers more control over the behavior of their programs than process-based designs. For example, we can imagine writing an event-driven concurrent server that gives preferred service to some clients, which would be difficult for a concurrent server based on processes.</p>
<p id="P7000497027000000000000000046C60" data-uri="chapter12.xhtml#P7000497027000000000000000046C60" class="pcalibre1 pcalibre calibre2">Another advantage is that an event-driven server based on I/O multiplexing runs in the context of a single process, and thus every logical flow has access to the entire address space of the process. This makes it easy to share data between flows. A related advantage of running as a single process is that you can debug your concurrent server as you would any sequential program, using a familiar debugging tool such as <span class="smallcaps pcalibre pcalibre1">gdb</span>. Finally, event-driven designs are often significantly more efficient than process-based designs because they do not require a process context switch to schedule a new flow.</p>
<p id="P7000497027000000000000000046C61" data-uri="chapter12.xhtml#P7000497027000000000000000046C61" class="pcalibre1 pcalibre calibre2">A significant disadvantage of event-driven designs is coding complexity. Our event-driven concurrent echo server requires three times more code than the process-based server. Unfortunately, the complexity increases as the granularity of the concurrency decreases. By <i class="calibre5 pcalibre pcalibre1">granularity</i>, we mean the number of instructions that each logical flow executes per time slice. For instance, in our example concurrent server, the granularity of concurrency is the number of instructions required to read an entire text line. As long as some logical flow is busy reading a text line, no other logical flow can make progress. This is fine for our example, but it makes our event-driven server vulnerable to a malicious client that sends only a partial text line and then halts. Modifying an event-driven server to handle partial text lines is a nontrivial task, but it is handled cleanly and automatically by a process-based design. Another significant disadvantage of event-based designs is that they cannot fully utilize multi-core processors.</p>
</section>
</section></body></html>
