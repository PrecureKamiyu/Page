<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Practice Exercises</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part340.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part342.htm">下一个 &gt;</a></p><p class="s45" style="padding-top: 4pt;padding-left: 73pt;text-indent: 0pt;text-align: left;"><a name="bookmark392">Practice Exercises</a><a name="bookmark433">&zwnj;</a></p><p class="s46" style="padding-top: 11pt;padding-left: 155pt;text-indent: -29pt;text-align: justify;">18.1 <span class="p">Show that the two-phase locking protocol ensures conﬂict serializability and that transactions can be serialized according to their lock points.</span></p><p class="s46" style="padding-top: 6pt;padding-left: 125pt;text-indent: 0pt;text-align: left;">18.2 <span class="p">Consider the following two transactions:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 84pt;text-indent: 0pt;text-align: center;"><i>T</i><span class="s98">34</span>: <span class="s49">read</span>(<i>A</i>);</p><p style="padding-left: 84pt;text-indent: 0pt;text-align: center;"><span class="s49">read</span>(<i>B</i>);</p><p class="s13" style="padding-left: 282pt;text-indent: 0pt;text-align: left;"><b>if </b>A <span class="s15">= </span><span class="p">0 </span><b>then </b>B <span class="p">:= </span>B <span class="p">+ 1;</span></p><p style="padding-left: 84pt;text-indent: 0pt;text-align: center;"><span class="s49">write</span>(<i>B</i>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 84pt;text-indent: 0pt;text-align: center;"><i>T</i><span class="s98">35</span>: <span class="s49">read</span>(<i>B</i>);</p><p style="padding-left: 84pt;text-indent: 0pt;text-align: center;"><span class="s49">read</span>(<i>A</i>);</p><p class="s13" style="padding-left: 282pt;text-indent: 0pt;text-align: left;"><b>if </b>B <span class="s15">= </span><span class="p">0 </span><b>then </b>A <span class="p">:= </span>A <span class="p">+ 1;</span></p><p style="padding-left: 84pt;text-indent: 0pt;text-align: center;"><span class="s49">write</span>(<i>A</i>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 155pt;text-indent: 0pt;text-align: justify;"><span class="p">Add lock and unlock instructions to transactions </span>T<span class="s93">31 </span><span class="s94">and </span>T<span class="s93">32 </span><span class="s94">so that they ob- serve the two-phase locking protocol. Can the execution of these transactions result in a deadlock?</span></p><p class="s46" style="padding-top: 6pt;padding-left: 155pt;text-indent: -30pt;text-align: justify;">18.3 <span class="p">What beneﬁt does rigorous two-phase locking provide? How does it compare with other forms of two-phase locking?</span></p><p class="s46" style="padding-top: 6pt;padding-left: 155pt;text-indent: -30pt;text-align: justify;">18.4  <span class="p">Consider a database organized in the form of a rooted tree. Suppose that we insert a dummy vertex between each pair of vertices. Show that, if we follow the tree protocol on the new tree, we get better concurrency than if we follow the tree protocol on the original tree.</span></p><p class="s46" style="padding-top: 6pt;padding-left: 155pt;text-indent: -30pt;text-align: justify;">18.5  <span class="p">Show by example that there are schedules possible under the tree protocol that are not possible under the two-phase locking protocol, and vice versa.</span></p><p class="s46" style="padding-top: 6pt;padding-left: 155pt;text-indent: -30pt;text-align: justify;">18.6 <span class="p">Locking is not done explicitly in persistent programming languages. Rather, objects (or the corresponding pages) must be locked when the objects are ac- cessed. Most modern operating systems allow the user to set access protections (no access, read, write) on pages, and memory access that violate the access</span></p><p style="padding-left: 155pt;text-indent: 0pt;line-height: 87%;text-align: justify;">protections result in a protection violation (see the Unix <span class="s445">mprotect </span>command, for example). Describe how the access-protection mechanism can be used for</p><p style="padding-left: 155pt;text-indent: 0pt;text-align: justify;">page-level locking in a persistent programming language.</p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: -30pt;text-align: justify;"><b>18.7  </b>Consider a database system that includes an atomic <b>increment </b>operation, in addition to the <span class="s49">read </span>and <span class="s49">write </span>operations. Let <i>V </i>be the value of data item <i>X</i>.</p><p style="padding-left: 155pt;text-indent: 0pt;text-align: justify;">The operation</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 285pt;text-indent: 0pt;text-align: left;"><b>increment</b>(<i>X</i>) by <i>C</i></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 124pt;text-indent: 0pt;text-align: left;">sets the value of <i>X </i>to <i>V </i>+ <i>C </i>in an atomic step. The value of <i>X </i>is not available to the transaction unless the latter executes a <span class="s49">read</span>(<i>X</i>).</p><p style="padding-left: 124pt;text-indent: 0pt;text-align: left;">Assume that increment operations lock the item in increment mode using the compatibility matrix in Figure 18.25.</p><p style="padding-top: 8pt;padding-left: 150pt;text-indent: -18pt;text-align: left;">a.  Show that, if all transactions lock the data that they access in the corre- sponding mode, then two-phase locking ensures serializability.</p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: -19pt;text-align: left;">b. Show that the inclusion of <b>increment </b>mode locks allows for increased concurrency.</p><p style="padding-top: 8pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;"><b>18.8  </b>In timestamp ordering, <b>W-timestamp</b>(<i>Q</i>) denotes the largest timestamp of any transaction that executed <span class="s49">write</span>(<i>Q</i>) successfully. Suppose that, instead, we de- ﬁned it to be the timestamp of the most recent transaction to execute <span class="s49">write</span>(<i>Q</i>) successfully. Would this change in wording make any diﬀerence? Explain your answer.</p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;">18.9 <span class="p">Use of multiple-granularity locking may require more or fewer locks than an equivalent system with a single lock granularity. Provide examples of both sit- uations, and compare the relative amount of concurrency allowed.</span></p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -34pt;text-align: justify;">18.10  <span class="p">For each of the following protocols, describe aspects of practical applications that would lead you to suggest using the protocol, and aspects that would sug- gest not using the protocol:</span></p><p class="s39" style="padding-top: 5pt;padding-left: 127pt;text-indent: 0pt;text-align: left;">• <span class="s40">Two-phase locking</span></p><p class="s39" style="padding-top: 3pt;padding-left: 127pt;text-indent: 0pt;text-align: left;">• <span class="s40">Two-phase locking with multiple-granularity locking.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 127pt;text-indent: 0pt;text-align: left;">• <span class="s40">The tree protocol</span></p><p class="s39" style="padding-top: 3pt;padding-left: 127pt;text-indent: 0pt;text-align: left;">• <span class="s40">Timestamp ordering</span></p><p class="s39" style="padding-top: 3pt;padding-left: 127pt;text-indent: 0pt;text-align: left;">• <span class="s40">Validation</span></p><p class="s39" style="padding-top: 3pt;padding-left: 127pt;text-indent: 0pt;text-align: left;">• <span class="s40">Multiversion timestamp ordering</span></p><p class="s39" style="padding-top: 3pt;padding-left: 127pt;text-indent: 0pt;text-align: left;">• <span class="s40">Multiversion two-phase locking</span></p><p style="padding-top: 7pt;padding-left: 124pt;text-indent: -34pt;text-align: justify;"><b>18.11 </b>Explain why the following technique for transaction execution may provide better performance than just using strict two-phase locking: First execute the transaction without acquiring any locks and without performing any writes to the database as in the validation-based techniques, but unlike the validation techniques do not perform either validation or writes on the database. Instead, rerun the transaction using strict two-phase locking. (Hint: Consider waits for disk <span class="s44">I/O</span>.)</p><p style="padding-top: 6pt;padding-left: 124pt;text-indent: -35pt;text-align: justify;"><b>18.12  </b>Consider the timestamp-ordering protocol, and two transactions, one that writes two data items <i>p </i>and <i>q</i>, and another that reads the same two data items.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 155pt;text-indent: 0pt;text-align: justify;">Give a schedule whereby the timestamp test for a <span class="s49">write </span>operation fails and causes the ﬁrst transaction to be restarted, in turn causing a cascading abort of the other transaction. Show how this could result in starvation of both trans- actions. (Such a situation, where two or more processes carry out actions, but are unable to complete their task because of interaction with the other pro- cesses, is called a <span class="s63">livelock</span>.)</p><p class="s46" style="padding-top: 6pt;padding-left: 120pt;text-indent: 0pt;text-align: justify;">18.13  <span class="p">Devise a timestamp-based protocol that avoids the phantom phenomenon.</span></p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: -34pt;text-align: justify;"><b>18.14  </b>Suppose that we use the tree protocol of Section 18.1.5 to manage concurrent access to a B<span class="s181">+</span>-tree. Since a split may occur on an insert that aﬀects the root, it appears that an insert operation cannot release any locks until it has completed the entire operation. Under what circumstances is it possible to release a lock earlier?</p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: -35pt;text-align: justify;"><b>18.15  </b>The snapshot isolation protocol uses a validation step which, before perform- ing a write of a data item by transaction <i>T </i>, checks if a transaction concurrent with <i>T </i>has already written the data item.</p><p style="padding-top: 9pt;padding-left: 181pt;text-indent: -18pt;text-align: justify;">a.  A straightforward implementation uses a start timestamp and a commit timestamp for each transaction, in addition to an <i>update set</i>, that, is the set of data items updated by the transaction. Explain how to perform validation for the ﬁrst-committer-wins scheme by using the transaction timestamps along with the update sets. You may assume that validation and other commit processing steps are executed serially, that is, for one transaction at a time,</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -19pt;text-align: justify;">b.  Explain how the validation step can be implemented as part of commit processing for the ﬁrst-committer-wins scheme, using a modiﬁcation of the above scheme, where instead of using update sets, each data item has a write timestamp associated with it. Again, you may assume that validation and other commit processing steps are executed serially.</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -18pt;text-align: justify;">c. The ﬁrst-updater-wins scheme can be implemented using timestamps as described above, except that validation is done immediately after acquir- ing an exclusive lock, instead of being done at commit time.</p><p style="padding-top: 6pt;padding-left: 197pt;text-indent: -16pt;text-align: left;">i. Explain how to assign write timestamps to data items to implement the ﬁrst-updater-wins scheme.</p><p style="padding-top: 5pt;padding-left: 197pt;text-indent: -19pt;text-align: left;">ii.  Show that as a result of locking, if the validation is repeated at com- mit time the result would not change.</p><p style="padding-top: 5pt;padding-left: 197pt;text-indent: -22pt;text-align: left;">iii.  Explain why there is no need to perform validation and other commit processing steps serially in this case.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3054.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3055.png"/></span></p><p style="padding-top: 9pt;padding-left: 155pt;text-indent: -34pt;text-align: justify;"><b>18.16 </b>Consider functions <i>insert latchfree</i>() and <i>delete latchfree</i>(), shown in Figure 18.23.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 131pt;text-indent: 0pt;text-align: justify;">a.  Explain how the ABA problem can occur if a deleted node is reinserted.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3056.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3057.png"/></span></p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: -19pt;text-align: justify;">b.  Suppose that adjacent to <i>head </i>we store a counter <i>cnt</i>. Also suppose that DCAS((<i>head,cnt</i>), (<i>oldhead, oldcnt</i>), (<i>newhead, newcnt</i>)) atomically per- forms a compare-and-swap on the 128 bit value (<i>head,cnt</i>). Modify the <i>in- sert latchfree</i>() and <i>delete latchfree</i>() to use the DCAS operation to avoid the ABA problem.</p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: -18pt;text-align: justify;">c.  Since most processors use only 48 bits of a 64 bit address to actually address memory, explain how the other 16 bits can be used to implement a counter, in case the DCAS operation is not supported.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part340.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part342.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
