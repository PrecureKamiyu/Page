<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>11.6 Putting It Together: The Tiny Web Server</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000007F64" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000046AA2" data-uri="chapter11.xhtml#P7000497027000000000000000046AA2" epub:type="title"><span class="pcalibre label pcalibre1">11.6 </span>Putting It Together: The T<span class="smallcaps pcalibre pcalibre1">iny </span>Web Server</h1></header>
<p id="P7000497027000000000000000046AA3" data-uri="chapter11.xhtml#P7000497027000000000000000046AA3" class="pcalibre1 pcalibre calibre2">We conclude our discussion of network programming by developing a small but functioning Web server called T<span class="smallcaps pcalibre pcalibre1">iny</span>. T<span class="smallcaps pcalibre pcalibre1">iny </span>is an interesting program. It combines many of the ideas that we have learned about, such as process control, Unix I/O, the sockets interface, and HTTP, in only 250 lines of code. While it lacks the functionality, robustness, and security of a real server, it is powerful enough to serve both static and dynamic content to real Web browsers. We encourage you to study it and implement it yourself. It is quite exciting (even for the authors!) to point a real browser at your own server and watch it display a complicated Web page with text and graphics.</p>
<section id="P7000497027000000000000000007F67" data-uri="chapter11.xhtml#P7000497027000000000000000007F67" class="pcalibre halftitlepage pcalibre1">
<section id="P7000497027000000000000000007F68" data-uri="chapter11.xhtml#P7000497027000000000000000007F68" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000046AA4" data-uri="chapter11.xhtml#P7000497027000000000000000046AA4" epub:type="title">The T<span class="smallcaps pcalibre pcalibre1">iny </span><code id="P7000497027000000000000000046AA5" data-uri="chapter11.xhtml#P7000497027000000000000000046AA5" class="calibre55 pcalibre pcalibre1">main</code> Routine</h1></header>
<p id="P7000497027000000000000000046AA6" data-uri="chapter11.xhtml#P7000497027000000000000000046AA6" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007F74"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.29</span></a> shows T<span class="smallcaps pcalibre pcalibre1">iny's </span>main routine. T<span class="smallcaps pcalibre pcalibre1">iny </span>is an iterative server that listens for connection requests on the port that is passed in the command line. After opening a listening socket by calling the <code id="P7000497027000000000000000046AA7" data-uri="chapter11.xhtml#P7000497027000000000000000046AA7" class="pcalibre1 calibre8 pcalibre">open_listenfd</code> function, T<span class="smallcaps pcalibre pcalibre1">iny </span>executes the typical infinite server loop, repeatedly accepting a connection request (line 32), performing a transaction (line 36), and closing its end of the connection (line 37).</p>
</section>
<section id="P7000497027000000000000000007F6D" data-uri="chapter11.xhtml#P7000497027000000000000000007F6D" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000046AA8" data-uri="chapter11.xhtml#P7000497027000000000000000046AA8" epub:type="title">The <code id="P7000497027000000000000000046AA9" data-uri="chapter11.xhtml#P7000497027000000000000000046AA9" class="calibre55 pcalibre pcalibre1">doit</code> Function</h1></header>
<p id="P7000497027000000000000000046AAA" data-uri="chapter11.xhtml#P7000497027000000000000000046AAA" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000046AAB" data-uri="chapter11.xhtml#P7000497027000000000000000046AAB" class="pcalibre1 calibre8 pcalibre">doit</code> function in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007F7A"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.30</span></a> handles one HTTP transaction. First, we read and parse the request line (lines 11âˆ’14). Notice that we are using the <code id="P7000497027000000000000000046AAC" data-uri="chapter11.xhtml#P7000497027000000000000000046AAC" class="pcalibre1 calibre8 pcalibre">rio_readlineb</code> function from Figure <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000007975.xhtml#P70004970270000000000000000079F7"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">10.8</span></a> to read the request line.</p>
<p id="P7000497027000000000000000046AAD" data-uri="chapter11.xhtml#P7000497027000000000000000046AAD" class="pcalibre1 pcalibre calibre2">T<span class="smallcaps pcalibre pcalibre1">iny </span>supports only the GET method. If the client requests another method (such as POST), we send it an error message and return to the main routine</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007F74" data-uri="chapter11.xhtml#P7000497027000000000000000007F74">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007F75" title="957" data-uri="chapter11.xhtml#P7000497027000000000000000007F75" epub:type="pagebreak"></span>
<pre id="P7000497027000000000000000046AAE" data-uri="chapter11.xhtml#P7000497027000000000000000046AAE" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046AAF" data-uri="chapter11.xhtml#P7000497027000000000000000046AAF" class="calibre10 pcalibre pcalibre1">
1	/*
2	* tiny.c - A simple, iterative HTTP/1.0 Web server that uses the
3	* GET method to serve static and dynamic content
4	*/
5	#include "csapp.h"
6	
7	void doit(int fd);
8	void read_requesthdrs(rio_t *rp);
9	int parse_uri(char *uri, char *filename, char *cgiargs);
10	void serve_static(int fd, char *filename, int filesize);
11	void get_filetype(char *filename, char *filetype);
12	void serve_dynamic(int fd, char *filename, char *cgiargs);
13	void clienterror(int fd, char *cause, char *errnum,
14	char *shortmsg, char *longmsg);
15	
16	int main(int argc, char **argv)
17	{
18	int listenfd, connfd;
19	char hostname[MAXLINE], port[MAXLINE];
20	socklen_t clientlen;
21	struct sockaddr_storage clientaddr;
22	
23	/* Check command-line args */
24	if (argc != 2) {
25	fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
26	exit(1);
27	}
28	
29	listenfd = Open_listenfd(argv[1]);
30	while (1) {
31	clientlen = sizeof(clientaddr);
32	connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);
33	Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE,
34	port, MAXLINE, 0);
35	printf("Accepted connection from (%s, %s)\n", hostname, port);
36	doit(connfd);
37	Close(connfd);
38	}
39	}
</code></pre>
<figcaption id="P7000497027000000000000000046AB0" data-uri="chapter11.xhtml#P7000497027000000000000000046AB0" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046AB1" data-uri="chapter11.xhtml#P7000497027000000000000000046AB1" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">11.29 </span>The T<span class="smallcaps1 pcalibre pcalibre1">iny </span>Web server.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007F7A" data-uri="chapter11.xhtml#P7000497027000000000000000007F7A">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007F7B" title="958" data-uri="chapter11.xhtml#P7000497027000000000000000007F7B" epub:type="pagebreak"></span>
<pre id="P7000497027000000000000000046AB2" data-uri="chapter11.xhtml#P7000497027000000000000000046AB2" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046AB3" data-uri="chapter11.xhtml#P7000497027000000000000000046AB3" class="calibre10 pcalibre pcalibre1">
1	void doit(int fd)
2	{
3	int is_static;
4	struct stat sbuf;
5	char buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];
6	char filename[MAXLINE], cgiargs[MAXLINE];
7	rio_t rio;
8
9	/* Read request line and headers */
10	Rio_readinitb(&amp;rio, fd);
11	Rio_readlineb(&amp;rio, buf, MAXLINE);
12	printf("Request headers:\n");
13	printf("%s", buf);
14	sscanf(buf, "%s %s %s", method, uri, version);
15	if (strcasecmp(method, "GET")) {
16	clienterror(fd, method, "501", "Not implemented",
17	"Tiny does not implement this method");
18	return;
19	}
20	read_requesthdrs(&amp;rio);
21	
22	/* Parse URI from GET request */
23	is_static = parse_uri(uri, filename, cgiargs);
24	if (stat(filename, &amp;sbuf) &lt; 0) {
25	clienterror(fd, filename, "404", "Not found",
26	"Tiny couldn't find this file");
27	return;
28	}
29	
30	if (is_static) { /* Serve static content */
31	if (!(S_ISREG(sbuf.st_mode))	|	| !(S_IRUSR &amp; sbuf.st_mode)) {
32	clienterror(fd, filename, "403", "Forbidden",
33	"Tiny couldn't read the file");
34	return;
35	}
36	serve_static(fd, filename, sbuf.st_size);
37	}
38	else { /* Serve dynamic content */
39	if (!(S_ISREG(sbuf.st_mode))	|	| !(S_IXUSR &amp; sbuf.st_mode)) {
40	clienterror(fd, filename, "403", "Forbidden",
41	"Tiny couldn't run the CGI program");
42	return;
43	}
44	serve_dynamic(fd, filename, cgiargs);
45	}
46	}
</code></pre>
<figcaption id="P7000497027000000000000000046AB4" data-uri="chapter11.xhtml#P7000497027000000000000000046AB4" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046AB5" data-uri="chapter11.xhtml#P7000497027000000000000000046AB5" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">11.30 </span><code id="P7000497027000000000000000046AB6" data-uri="chapter11.xhtml#P7000497027000000000000000046AB6" class="pcalibre1 calibre8 pcalibre">T<span class="smallcaps1 pcalibre pcalibre1">iny </span>doit</code> handles one HTTP transaction.</h1></header>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046AB7" data-uri="chapter11.xhtml#P7000497027000000000000000046AB7"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007F82" title="959" data-uri="chapter11.xhtml#P7000497027000000000000000007F82" epub:type="pagebreak"></span>(lines 15âˆ’19), which then closes the connection and awaits the next connection request. Otherwise, we read and (as we shall see) ignore any request headers (line 20).</p>
<p id="P7000497027000000000000000046AB8" data-uri="chapter11.xhtml#P7000497027000000000000000046AB8" class="pcalibre1 pcalibre calibre2">Next, we parse the URI into a filename and a possibly empty CGI argument string, and we set a flag that indicates whether the request is for static or dynamic content (line 23). If the file does not exist on disk, we immediately send an error message to the client and return.</p>
<p id="P7000497027000000000000000046AB9" data-uri="chapter11.xhtml#P7000497027000000000000000046AB9" class="pcalibre1 pcalibre calibre2">Finally, if the request is for static content, we verify that the file is a regular file and that we have read permission (line 31). If so, we serve the static content (line 36) to the client. Similarly, if the request is for dynamic content, we verify that the file is executable (line 39), and, if so, we go ahead and serve the dynamic content (line 44).</p>
</section>
<section id="P7000497027000000000000000007F85" data-uri="chapter11.xhtml#P7000497027000000000000000007F85" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000046ABA" data-uri="chapter11.xhtml#P7000497027000000000000000046ABA" epub:type="title">The <code id="P7000497027000000000000000046ABB" data-uri="chapter11.xhtml#P7000497027000000000000000046ABB" class="calibre55 pcalibre pcalibre1">clienterror</code> Function</h1></header>
<p id="P7000497027000000000000000046ABC" data-uri="chapter11.xhtml#P7000497027000000000000000046ABC" class="pcalibre1 pcalibre calibre2">T<span class="smallcaps pcalibre pcalibre1">iny </span>lacks many of the error-handling features of a real server. However, it does check for some obvious errors and reports them to the client. The <code id="P7000497027000000000000000046ABD" data-uri="chapter11.xhtml#P7000497027000000000000000046ABD" class="pcalibre1 calibre8 pcalibre">clienterror</code> function in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007F8A"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.31</span></a> sends an HTTP response to the client with the appropriate</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007F8A" data-uri="chapter11.xhtml#P7000497027000000000000000007F8A">
<pre id="P7000497027000000000000000046ABE" data-uri="chapter11.xhtml#P7000497027000000000000000046ABE" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046ABF" data-uri="chapter11.xhtml#P7000497027000000000000000046ABF" class="calibre10 pcalibre pcalibre1">
1	void clienterror(int fd, char *cause, char *errnum,
2			char *shortmsg, char *longmsg)
3	{
4		char buf[MAXLINE], body[MAXBUF];
5	
6		/* Build the HTTP response body */
7		sprintf(body, "&lt;html&gt;&lt;title&gt;Tiny Error&lt;/title&gt;");
8		sprintf(body, "%s&lt;body bgcolor=""ffffff""&gt;\r\n", body);
9		sprintf(body, "%s%s: %s\r\n", body, errnum, shortmsg);
10		sprintf(body, "%s&lt;p&gt;%s: %s\r\n", body, longmsg, cause);
11		sprintf(body, "%s&lt;hr&gt;&lt;em&gt;The Tiny Web server&lt;/em&gt;\r\n", body);
12	
13		/* Print the HTTP response */
14		sprintf(buf, "HTTP/1.0 %s %s\r\n", errnum, shortmsg);
15		Rio_writen(fd, buf, strlen(buf));
16		sprintf(buf, "Content-type: text/html\r\n");
17		Rio_writen(fd, buf, strlen(buf));
18		sprintf(buf, "Content-length: %d\r\n\r\n", (int)strlen(body));
19		Rio_writen(fd, buf, strlen(buf));
20		Rio_writen(fd, body, strlen(body));
21	}
</code></pre>
<figcaption id="P7000497027000000000000000046AC0" data-uri="chapter11.xhtml#P7000497027000000000000000046AC0" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046AC1" data-uri="chapter11.xhtml#P7000497027000000000000000046AC1" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">11.31 </span><code id="P7000497027000000000000000046AC2" data-uri="chapter11.xhtml#P7000497027000000000000000046AC2" class="pcalibre1 calibre8 pcalibre">T<span class="smallcaps1 pcalibre pcalibre1">iny </span>clienterror</code> sends an error message to the client.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007F90" data-uri="chapter11.xhtml#P7000497027000000000000000007F90">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007F91" title="960" data-uri="chapter11.xhtml#P7000497027000000000000000007F91" epub:type="pagebreak"></span>
<pre id="P7000497027000000000000000046AC3" data-uri="chapter11.xhtml#P7000497027000000000000000046AC3" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046AC4" data-uri="chapter11.xhtml#P7000497027000000000000000046AC4" class="calibre10 pcalibre pcalibre1">
1	void read_requesthdrs(rio_t *rp)
2	{
3		char buf[MAXLINE];
4
5		Rio_readlineb(rp, buf, MAXLINE);
6		while(strcmp(buf, "\r\n")) {
7			Rio_readlineb(rp, buf, MAXLINE);
8			printf("%s", buf);
9		}
10		return;
11	}
</code></pre>
<figcaption id="P7000497027000000000000000046AC5" data-uri="chapter11.xhtml#P7000497027000000000000000046AC5" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046AC6" data-uri="chapter11.xhtml#P7000497027000000000000000046AC6" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">11.32 </span><code id="P7000497027000000000000000046AC7" data-uri="chapter11.xhtml#P7000497027000000000000000046AC7" class="pcalibre1 calibre8 pcalibre">T<span class="smallcaps1 pcalibre pcalibre1">iny </span>read_requesthdrs</code> reads and ignores request headers.</h1></header>
<div class="caption pcalibre pcalibre1" id="P7000497027000000000000000046AC8" data-uri="chapter11.xhtml#P7000497027000000000000000046AC8"><p id="P7000497027000000000000000046AC9" data-uri="chapter11.xhtml#P7000497027000000000000000046AC9" class="pcalibre calibre3 pcalibre1"></p></div></figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046ACA" data-uri="chapter11.xhtml#P7000497027000000000000000046ACA">status code and status message in the response line, along with an HTML file in the response body that explains the error to the browser's user.</p>
<p id="P7000497027000000000000000046ACB" data-uri="chapter11.xhtml#P7000497027000000000000000046ACB" class="pcalibre1 pcalibre calibre2">Recall that an HTML response should indicate the size and type of the content in the body. Thus, we have opted to build the HTML content as a single string so that we can easily determine its size. Also, notice that we are using the robust <code id="P7000497027000000000000000046ACC" data-uri="chapter11.xhtml#P7000497027000000000000000046ACC" class="pcalibre1 calibre8 pcalibre">rio_writen</code> function from <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000007975.xhtml#P70004970270000000000000000079BE"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">10.4</span></a> for all output.</p>
</section>
<section id="P7000497027000000000000000007F9C" data-uri="chapter11.xhtml#P7000497027000000000000000007F9C" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000046ACD" data-uri="chapter11.xhtml#P7000497027000000000000000046ACD" epub:type="title">The <code id="P7000497027000000000000000046ACE" data-uri="chapter11.xhtml#P7000497027000000000000000046ACE" class="calibre55 pcalibre pcalibre1">read_requesthdrs</code> Function</h1></header>
<p id="P7000497027000000000000000046ACF" data-uri="chapter11.xhtml#P7000497027000000000000000046ACF" class="pcalibre1 pcalibre calibre2">T<span class="smallcaps pcalibre pcalibre1">iny </span>does not use any of the information in the request headers. It simply reads and ignores them by calling the <code id="P7000497027000000000000000046AD0" data-uri="chapter11.xhtml#P7000497027000000000000000046AD0" class="pcalibre1 calibre8 pcalibre">read_requesthdrs</code> function in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007F90"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.32</span></a>. Notice that the empty text line that terminates the request headers consists of a carriage return and line feed pair, which we check for in line 6.</p>
</section>
<section id="P7000497027000000000000000007FA1" data-uri="chapter11.xhtml#P7000497027000000000000000007FA1" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000046AD1" data-uri="chapter11.xhtml#P7000497027000000000000000046AD1" epub:type="title">The <code id="P7000497027000000000000000046AD2" data-uri="chapter11.xhtml#P7000497027000000000000000046AD2" class="calibre55 pcalibre pcalibre1">parse_uri</code> Function</h1></header>
<p id="P7000497027000000000000000046AD3" data-uri="chapter11.xhtml#P7000497027000000000000000046AD3" class="pcalibre1 pcalibre calibre2">T<span class="smallcaps pcalibre pcalibre1">iny </span>assumes that the home directory for static content is its current directory and that the home directory for executables is <code id="P7000497027000000000000000046AD4" data-uri="chapter11.xhtml#P7000497027000000000000000046AD4" class="pcalibre1 calibre8 pcalibre">./cgi-bin</code>. Any URI that contains the string <code id="P7000497027000000000000000046AD5" data-uri="chapter11.xhtml#P7000497027000000000000000046AD5" class="pcalibre1 calibre8 pcalibre">cgi-bin</code> is assumed to denote a request for dynamic content. The default filename is <code id="P7000497027000000000000000046AD6" data-uri="chapter11.xhtml#P7000497027000000000000000046AD6" class="pcalibre1 calibre8 pcalibre">./home.html</code>.</p>
<p id="P7000497027000000000000000046AD7" data-uri="chapter11.xhtml#P7000497027000000000000000046AD7" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000046AD8" data-uri="chapter11.xhtml#P7000497027000000000000000046AD8" class="pcalibre1 calibre8 pcalibre">parse_uri</code> function in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007FAB"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.33</span></a> implements these policies. It parses the URI into a filename and an optional CGI argument string. If the request is for static content (line 5), we clear the CGI argument string (line 6) and then convert the URI into a relative Linux pathname such as <code id="P7000497027000000000000000046AD9" data-uri="chapter11.xhtml#P7000497027000000000000000046AD9" class="pcalibre1 calibre8 pcalibre">./index.html</code> (lines 7âˆ’8). If the URI ends with a `/' character (line 9), then we append the default filename (line 10). On the other hand, if the request is for dynamic content (line 13), we extract any CGI arguments (lines 14âˆ’20) and convert the remaining portion of the URI to a relative Linux filename (lines 21âˆ’22).</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007FAB" data-uri="chapter11.xhtml#P7000497027000000000000000007FAB">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007FAC" title="961" data-uri="chapter11.xhtml#P7000497027000000000000000007FAC" epub:type="pagebreak"></span>
<pre id="P7000497027000000000000000046ADA" data-uri="chapter11.xhtml#P7000497027000000000000000046ADA" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046ADB" data-uri="chapter11.xhtml#P7000497027000000000000000046ADB" class="calibre10 pcalibre pcalibre1">
1	int parse_uri(char *uri, char *filename, char *cgiargs)
2	{
3		char *ptr;
4	
5		if (!strstr(uri, "cgi-bin")) { /* Static content */
6			strcpy(cgiargs, "");
7			strcpy(filename, ".");
8			strcat(filename, uri);
9			if (uri[strlen(uri)-1] == `/')
10				strcat(filename, "home.html");
11			return 1;
12		}
13		else { /* Dynamic content */
14			ptr = index(uri, `?');
15			if (ptr) {
16				strcpy(cgiargs, ptr+1);
17				*ptr = `\0';
18			}
19			else
20				strcpy(cgiargs, "");
21			strcpy(filename, ".");
22			strcat(filename, uri);
23			return 0;
24		}
25	}
</code></pre>
<figcaption id="P7000497027000000000000000046ADC" data-uri="chapter11.xhtml#P7000497027000000000000000046ADC" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046ADD" data-uri="chapter11.xhtml#P7000497027000000000000000046ADD" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">11.33 </span>T<span class="smallcaps1 pcalibre pcalibre1">iny </span>parse_uri parses an HTTP URI.</h1></header>
</figcaption>
</figure>
</section>
<section id="P7000497027000000000000000007FB1" data-uri="chapter11.xhtml#P7000497027000000000000000007FB1" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000046ADE" data-uri="chapter11.xhtml#P7000497027000000000000000046ADE" epub:type="title">The <code id="P7000497027000000000000000046ADF" data-uri="chapter11.xhtml#P7000497027000000000000000046ADF" class="calibre55 pcalibre pcalibre1">serve_static</code> Function</h1></header>
<p id="P7000497027000000000000000046AE0" data-uri="chapter11.xhtml#P7000497027000000000000000046AE0" class="pcalibre1 pcalibre calibre2">T<span class="smallcaps pcalibre pcalibre1">iny </span>serves five common types of static content: HTML files, unformatted text files, and images encoded in GIF, PNG, and JPEG formats.</p>
<p id="P7000497027000000000000000046AE1" data-uri="chapter11.xhtml#P7000497027000000000000000046AE1" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000046AE2" data-uri="chapter11.xhtml#P7000497027000000000000000046AE2" class="pcalibre1 calibre8 pcalibre">serve_static</code> function in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007FBD"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.34</span></a> sends an HTTP response whose body contains the contents of a local file. First, we determine the file type by inspecting the suffix in the filename (line 7) and then send the response line and response headers to the client (lines 8âˆ’13). Notice that a blank line terminates the headers.</p>
<p id="P7000497027000000000000000046AE3" data-uri="chapter11.xhtml#P7000497027000000000000000046AE3" class="pcalibre1 pcalibre calibre2">Next, we send the response body by copying the contents of the requested file to the connected descriptor <code id="P7000497027000000000000000046AE4" data-uri="chapter11.xhtml#P7000497027000000000000000046AE4" class="pcalibre1 calibre8 pcalibre">fd</code>. The code here is somewhat subtle and needs to be studied carefully. Line 18 opens <code id="P7000497027000000000000000046AE5" data-uri="chapter11.xhtml#P7000497027000000000000000046AE5" class="pcalibre1 calibre8 pcalibre">filename</code> for reading and gets its descriptor. In line 19, the Linux <code id="P7000497027000000000000000046AE6" data-uri="chapter11.xhtml#P7000497027000000000000000046AE6" class="pcalibre1 calibre8 pcalibre">mmap</code> function maps the requested file to a virtual memory area. Recall from our discussion of <code id="P7000497027000000000000000046AE7" data-uri="chapter11.xhtml#P7000497027000000000000000046AE7" class="pcalibre1 calibre8 pcalibre">mmap</code> in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000072B5.xhtml#P70004970270000000000000000072B5"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">9.8</span></a> that the call to <code id="P7000497027000000000000000046AE8" data-uri="chapter11.xhtml#P7000497027000000000000000046AE8" class="pcalibre1 calibre8 pcalibre">mmap</code> maps the</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007FBD" data-uri="chapter11.xhtml#P7000497027000000000000000007FBD">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007FBE" title="962" data-uri="chapter11.xhtml#P7000497027000000000000000007FBE" epub:type="pagebreak"></span>
<pre id="P7000497027000000000000000046AE9" data-uri="chapter11.xhtml#P7000497027000000000000000046AE9" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046AEA" data-uri="chapter11.xhtml#P7000497027000000000000000046AEA" class="calibre10 pcalibre pcalibre1">
1	void serve_static(int fd, char *filename, int filesize)
2	{
3		int srcfd;
4		char *srcp, filetype[MAXLINE], buf[MAXBUF];
5	
6		/* Send response headers to client */
7		get_filetype(filename, filetype);
8		sprintf(buf, "HTTP/1.0 200 OK\r\n");
9		sprintf(buf, "%sServer: Tiny Web Server\r\n", buf);
10		sprintf(buf, "%sConnection: close\r\n", buf);
11		sprintf(buf, "%sContent-length: %d\r\n", buf, filesize);
12		sprintf(buf, "%sContent-type: %s\r\n\r\n", buf, filetype);
13		Rio_writen(fd, buf, strlen(buf));
14		printf("Response headers:\n");
15		printf("%s", buf);
16	
17		/* Send response body to client */
18		srcfd = Open(filename, O_RDONLY, 0);
19		srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0);
20		Close(srcfd);
21		Rio_writen(fd, srcp, filesize);
22		Munmap(srcp, filesize);
23	}
24	
25	/*
26	* get_filetype - Derive file type from filename
27	*/
28	void get_filetype(char *filename, char *filetype)
29	{
30		if (strstr(filename, ".html"))
31			strcpy(filetype, "text/html");
32		else if (strstr(filename, ".gif"))
33			strcpy(filetype, "image/gif");
34		else if (strstr(filename, ".png"))
35			strcpy(filetype, "image/png");
36		else if (strstr(filename, ".jpg"))
37			strcpy(filetype, "image/jpeg");
38		else
39			strcpy(filetype, "text/plain");
40	}
</code></pre>
<figcaption id="P7000497027000000000000000046AEB" data-uri="chapter11.xhtml#P7000497027000000000000000046AEB" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046AEC" data-uri="chapter11.xhtml#P7000497027000000000000000046AEC" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">11.34 </span>T<span class="smallcaps1 pcalibre pcalibre1">iny </span>serve_static serves static content to a client.</h1></header>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046AED" data-uri="chapter11.xhtml#P7000497027000000000000000046AED"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007FC4" title="963" data-uri="chapter11.xhtml#P7000497027000000000000000007FC4" epub:type="pagebreak"></span>first <code id="P7000497027000000000000000046AEE" data-uri="chapter11.xhtml#P7000497027000000000000000046AEE" class="pcalibre1 calibre8 pcalibre">filesize</code> bytes of file <code id="P7000497027000000000000000046AEF" data-uri="chapter11.xhtml#P7000497027000000000000000046AEF" class="pcalibre1 calibre8 pcalibre">srcfd</code> to a private read-only area of virtual memory that starts at address <code id="P7000497027000000000000000046AF0" data-uri="chapter11.xhtml#P7000497027000000000000000046AF0" class="pcalibre1 calibre8 pcalibre">srcp</code>.</p>
<p id="P7000497027000000000000000046AF1" data-uri="chapter11.xhtml#P7000497027000000000000000046AF1" class="pcalibre1 pcalibre calibre2">Once we have mapped the file to memory, we no longer need its descriptor, so we close the file (line 20). Failing to do this would introduce a potentially fatal memory leak. Line 21 performs the actual transfer of the file to the client. The <code id="P7000497027000000000000000046AF2" data-uri="chapter11.xhtml#P7000497027000000000000000046AF2" class="pcalibre1 calibre8 pcalibre">rio_writen</code> function copies the <code id="P7000497027000000000000000046AF3" data-uri="chapter11.xhtml#P7000497027000000000000000046AF3" class="pcalibre1 calibre8 pcalibre">filesize</code> bytes starting at location <code id="P7000497027000000000000000046AF4" data-uri="chapter11.xhtml#P7000497027000000000000000046AF4" class="pcalibre1 calibre8 pcalibre">srcp</code> (which of course is mapped to the requested file) to the client's connected descriptor. Finally, line 22 frees the mapped virtual memory area. This is important to avoid a potentially fatal memory leak.</p>
</section>
<section id="P7000497027000000000000000007FCC" data-uri="chapter11.xhtml#P7000497027000000000000000007FCC" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000046AF5" data-uri="chapter11.xhtml#P7000497027000000000000000046AF5" epub:type="title">The <code id="P7000497027000000000000000046AF6" data-uri="chapter11.xhtml#P7000497027000000000000000046AF6" class="calibre55 pcalibre pcalibre1">serve_dynamic</code> Function</h1></header>
<p id="P7000497027000000000000000046AF7" data-uri="chapter11.xhtml#P7000497027000000000000000046AF7" class="pcalibre1 pcalibre calibre2">T<span class="smallcaps pcalibre pcalibre1">iny </span>serves any type of dynamic content by forking a child process and then running a CGI program in the context of the child.</p>
<p id="P7000497027000000000000000046AF8" data-uri="chapter11.xhtml#P7000497027000000000000000046AF8" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000046AF9" data-uri="chapter11.xhtml#P7000497027000000000000000046AF9" class="pcalibre1 calibre8 pcalibre">serve_dynamic</code> function in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007FD4"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.35</span></a> begins by sending a response line indicating success to the client, along with an informational <code id="P7000497027000000000000000046AFA" data-uri="chapter11.xhtml#P7000497027000000000000000046AFA" class="pcalibre1 calibre8 pcalibre">Server</code> header. The CGI program is responsible for sending the rest of the response. Notice that this is not as robust as we might wish, since it doesn't allow for the possibility that the CGI program might encounter some error.</p>
<p id="P7000497027000000000000000046AFB" data-uri="chapter11.xhtml#P7000497027000000000000000046AFB" class="pcalibre1 pcalibre calibre2">After sending the first part of the response, we fork a new child process (line 11). The child initializes the QUERY_STRING environment variable with the CGI arguments from the request URI (line 13). Notice that a real server would</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007FD4" data-uri="chapter11.xhtml#P7000497027000000000000000007FD4">
<pre id="P7000497027000000000000000046AFC" data-uri="chapter11.xhtml#P7000497027000000000000000046AFC" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046AFD" data-uri="chapter11.xhtml#P7000497027000000000000000046AFD" class="calibre10 pcalibre pcalibre1">
1	void serve_dynamic(int fd, char *filename, char *cgiargs)
2	{
3		char buf[MAXLINE], *emptylist[] = { NULL };
4	
5		/* Return first part of HTTP response */
6		sprintf(buf, "HTTP/1.0 200 OK\r\n");
7		Rio_writen(fd, buf, strlen(buf));
8		sprintf(buf, "Server: Tiny Web Server\r\n");
9		Rio_writen(fd, buf, strlen(buf));
10	
11		if (Fork() == 0) { /* Child */
12			/* Real server would set all CGI vars here */
13			setenv("QUERY_STRING", cgiargs, 1);
14			Dup2(fd, STDOUT_FILENO); /* Redirect stdout to client */
15			Execve(filename, emptylist, environ); /* Run CGI program */
16		}
17		Wait(NULL); /* Parent waits for and reaps child */
18	}
</code></pre>
<figcaption id="P7000497027000000000000000046AFE" data-uri="chapter11.xhtml#P7000497027000000000000000046AFE" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046AFF" data-uri="chapter11.xhtml#P7000497027000000000000000046AFF" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">11.35 </span>T<span class="smallcaps1 pcalibre pcalibre1">iny </span>serve_dynamic serves dynamic content to a client.</h1></header>
</figcaption>
</figure>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000007FD9" data-uri="chapter11.xhtml#P7000497027000000000000000007FD9"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000046B00" data-uri="chapter11.xhtml#P7000497027000000000000000046B00" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007FDB" title="964" data-uri="chapter11.xhtml#P7000497027000000000000000007FDB" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>Dealing with prematurely closed connections</h1></header>
<p id="P7000497027000000000000000046B01" data-uri="chapter11.xhtml#P7000497027000000000000000046B01" class="pcalibre calibre3 pcalibre1">Although the basic functions of a Web server are quite simple, we don't want to give you the false impression that writing a real Web server is easy. Building a robust Web server that runs for extended periods without crashing is a difficult task that requires a deeper understanding of Linux systems programming than we've learned here. For example, if a server writes to a connection that has already been closed by the client (say, because you clicked the "Stop" button on your browser), then the first such write returns normally, but the second write causes the delivery of a SIGPIPE signal whose default behavior is to terminate the process. If the SIGPIPE signal is caught or ignored, then the second write operation returns âˆ’1 with <code id="P7000497027000000000000000046B02" data-uri="chapter11.xhtml#P7000497027000000000000000046B02" class="pcalibre1 calibre8 pcalibre">errno</code> set to EPIPE. The <code id="P7000497027000000000000000046B03" data-uri="chapter11.xhtml#P7000497027000000000000000046B03" class="pcalibre1 calibre8 pcalibre">strerr</code> and <code id="P7000497027000000000000000046B04" data-uri="chapter11.xhtml#P7000497027000000000000000046B04" class="pcalibre1 calibre8 pcalibre">perror</code> functions report the EPIPE error as a "Broken pipe," a nonintuitive message that has confused generations of students. The bottom line is that a robust server must catch these SIGPIPE signals and check <code id="P7000497027000000000000000046B05" data-uri="chapter11.xhtml#P7000497027000000000000000046B05" class="pcalibre1 calibre8 pcalibre">write</code> function calls for EPIPE errors.</p>
</aside>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046B06" data-uri="chapter11.xhtml#P7000497027000000000000000046B06">set the other CGI environment variables here as well. For brevity, we have omitted this step.</p>
<p id="P7000497027000000000000000046B07" data-uri="chapter11.xhtml#P7000497027000000000000000046B07" class="pcalibre1 pcalibre calibre2">Next, the child redirects the child's standard output to the connected file descriptor (line 14) and then loads and runs the CGI program (line 15). Since the CGI program runs in the context of the child, it has access to the same open files and environment variables that existed before the call to the <code id="P7000497027000000000000000046B08" data-uri="chapter11.xhtml#P7000497027000000000000000046B08" class="pcalibre1 calibre8 pcalibre">execve</code> function. Thus, everything that the CGI program writes to standard output goes directly to the client process, without any intervention from the parent process. Meanwhile, the parent blocks in a call to <code id="P7000497027000000000000000046B09" data-uri="chapter11.xhtml#P7000497027000000000000000046B09" class="pcalibre1 calibre8 pcalibre">wait</code>, waiting to reap the child when it terminates (line 17).</p>
</section>
</section>
</section></body></html>
