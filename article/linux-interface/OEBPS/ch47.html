<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 47. System V Semaphores</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch46.html" title="Chapter 46. System V Message Queues"/><link rel="next" href="ch48.html" title="Chapter 48. System V Shared Memory"/></head><body><section class="chapter" title="Chapter 47. System V Semaphores" epub:type="chapter" id="system_v_semaphores"><div class="titlepage"><div><div><h2 class="title">Chapter 47. System V Semaphores</h2></div></div></div><p>This chapter describes System V semaphores. Unlike the IPC mechanisms described in
            previous chapters, System V semaphores are not used to transfer data between processes.
            Instead, they allow processes to synchronize their actions. One common use of a
            semaphore is to synchronize access to a block of shared memory, in order to prevent one
            process from accessing the shared memory at the same time as another process is updating
            it.</p><p>A semaphore is a kernel-maintained integer whose value is restricted to being greater
            than or equal to 0. Various operations (i.e., system calls) can be performed on a
            semaphore, including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>setting the semaphore to an absolute value;</p></li><li class="listitem"><p>adding a number to the current value of the semaphore;</p></li><li class="listitem"><p>subtracting a number from the current value of the semaphore; and</p></li><li class="listitem"><p>waiting for the semaphore value to be equal to 0.</p></li></ul></div><p>The last two of these operations may cause the calling process to block. When lowering
            a semaphore value, the kernel blocks any attempt to decrease the value below 0.
            Similarly, waiting for a semaphore to equal 0 blocks the calling process if the
            semaphore value is not currently 0. In both cases, the calling process remains blocked
            until some other process alters the semaphore to a value that allows the operation to
            proceed, at which point the kernel wakes the blocked process. <a class="xref" href="ch47.html#using_a_semaphore_to_synchronize_two_pro" title="Figure 47-1. Using a semaphore to synchronize two processes">Figure 47-1</a> shows the use of a semaphore to
            synchronize the actions of two processes that alternately move the semaphore value
            between 0 and 1.</p><div class="figure"><a id="using_a_semaphore_to_synchronize_two_pro"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject47_d1e124411"/><img src="figs/web/47-1_SVSEM-sems.png.jpg" alt="Using a semaphore to synchronize two processes"/></div></div><div class="figure-title">Figure 47-1. Using a semaphore to synchronize two processes</div></div><p>In terms of controlling the actions of a process, a semaphore has no meaning in and of
            itself. Its meaning is determined only by the associations given to it by the processes
            using the semaphore. Typically, processes agree on a convention that associates a
            semaphore with a shared resource, such as a region of shared memory. Other uses of
            semaphores are also possible, such as synchronization between parent and child processes
            after <span class="emphasis"><em>fork()</em></span>. (In <a class="xref" href="ch24.html#avoiding_race_conditions_by_synchronizin" title="Avoiding Race Conditions by Synchronizing with Signals">Avoiding Race Conditions by Synchronizing with Signals</a>, we looked at the use of
            signals to accomplish the same task.)</p><div class="sect1" title="Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="overview-id12">Overview</h2></div></div></div><p>The general steps for using a System V semaphore are the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Create or open a semaphore set using <span class="emphasis"><em>semget()</em></span>.</p></li><li class="listitem"><p>Initialize the semaphores in the set using the
                            <span class="emphasis"><em>semctl()</em></span>
                        <code class="literal">SETVAL</code> or <code class="literal">SETALL</code> operation. (Only one process should do this.)</p></li><li class="listitem"><p>Perform operations on semaphore values using <span class="emphasis"><em>semop()</em></span>.
                        The processes using the semaphore typically use these operations to indicate
                        acquisition and release of a shared resource.</p></li><li class="listitem"><p>When all processes have finished using the semaphore set, remove the set
                        using the <span class="emphasis"><em>semctl()</em></span>
                        <code class="literal">IPC_RMID</code> operation. (Only one process
                        should do this.)</p></li></ul></div><p>Most operating systems provide some type of semaphore primitive for use in
                application programs. However, System V semaphores are rendered unusually complex by
                the fact that they are allocated in groups called <span class="emphasis"><em>semaphore
                    sets</em></span>. The number of semaphores in a set is specified when the set is
                created using the <span class="emphasis"><em>semget()</em></span> system call. While it is common to
                operate on a single semaphore at a time, the <span class="emphasis"><em>semop()</em></span> system
                call allows us to atomically perform a group of operations on multiple semaphores in
                the same set.</p><p>Because System V semaphores are created and initialized in separate steps, race
                conditions can result if two processes try to perform these steps at the same time.
                Describing this race condition and how to avoid it requires that we describe
                    <span class="emphasis"><em>semctl()</em></span> before describing <span class="emphasis"><em>semop()</em></span>,
                which means that there is quite a lot of material to cover before we have all of the
                details required to fully understand semaphores.</p><p>In the meantime, we provide <a class="xref" href="ch47.html#creating_and_operating_on_system_v_semap" title="Example 47-1. Creating and operating on System V semaphores">Example 47-1</a> as a simple example of the
                use of the various semaphore system calls. This program operates in two
                modes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Given a single integer command-line argument, the program creates a new
                        semaphore set containing a single semaphore, and initializes the semaphore
                        to the value supplied in the command-line argument. The program displays the
                        identifier of the new semaphore set.</p></li><li class="listitem"><p>Given two command-line arguments, the program interprets them as (in
                        order) the identifier of an existing semaphore set and a value to be added
                        to the first semaphore (numbered 0) in that set. The program carries out the
                        specified operation on that semaphore. To enable us to monitor the semaphore
                        operation, the program prints messages before and after the operation. Each
                        of these messages begins with the process ID, so that we can distinguish the
                        output of multiple instances of the program.</p></li></ul></div><p>The following shell session log demonstrates the use of the program in <a class="xref" href="ch47.html#creating_and_operating_on_system_v_semap" title="Example 47-1. Creating and operating on System V semaphores">Example 47-1</a>. We begin by creating a
                semaphore that is initialized to 0:</p><a id="I_programlisting47_d1e124496"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_demo 0</code></strong>
Semaphore ID = 98307                    <em class="lineannotation"><span class="lineannotation">ID of new semaphore set</span></em></pre><p>We then execute a background command that tries to decrease the semaphore value by
                2:</p><a id="I_programlisting47_d1e124505"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_demo 98307 -2 &amp;</code></strong>
23338: about to semop at  10:19:42
[1] 23338</pre><p>This command blocked, because the value of the semaphore can’t be decreased below
                0. Now, we execute a command that adds 3 to the semaphore value:</p><a id="I_programlisting47_d1e124513"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_demo 98307 +3</code></strong>
23339: about to semop at  10:19:55
23339: semop completed at 10:19:55
23338: semop completed at 10:19:55
[1]+  Done              ./svsem_demo 98307 -2</pre><p>The semaphore increment operation succeeded immediately, and caused the semaphore
                decrement operation in the background command to proceed, since that operation could
                now be performed without leaving the semaphore’s value below 0.</p><div class="example"><a id="creating_and_operating_on_system_v_semap"/><div class="example-title">Example 47-1. Creating and operating on System V semaphores</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svsem/svsem_demo.c</code></strong>
#include &lt;sys/types.h&gt;
#include &lt;sys/sem.h&gt;
#include &lt;sys/stat.h&gt;
#include "curr_time.h"                  /* Declaration of currTime() */
#include "semun.h"                      /* Definition of semun union */
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    int semid;

    if (argc &lt; 2 || argc &gt; 3 || strcmp(argv[1], "--help") == 0)
        usageErr("%s init-value\n"
                 "   or: %s semid operation\n", argv[0], argv[0]);

    if (argc == 2) {            /* Create and initialize semaphore */
        union semun arg;

        semid = semget(IPC_PRIVATE, 1, S_IRUSR | S_IWUSR);
        if (semid == -1)
            errExit("semid");

        arg.val = getInt(argv[1], 0, "init-value");
        if (semctl(semid, /* semnum= */ 0, SETVAL, arg) == -1)
            errExit("semctl");

        printf("Semaphore ID = %d\n", semid);

    } else {                    /* Perform an operation on first semaphore */

        struct sembuf sop;              /* Structure defining operation */

        semid = getInt(argv[1], 0, "semid");

        sop.sem_num = 0;                /* Specifies first semaphore in set */
        sop.sem_op = getInt(argv[2], 0, "operation");
                                        /* Add, subtract, or wait for 0 */
        sop.sem_flg = 0;                /* No special options for operation */

        printf("%ld: about to semop at  %s\n", (long) getpid(), currTime("%T"));
        if (semop(semid, &amp;sop, 1) == -1)
            errExit("semop");

        printf("%ld: semop completed at %s\n", (long) getpid(), currTime("%T"));
    }

    exit(EXIT_SUCCESS);
}
     <strong class="userinput"><code>svsem/svsem_demo.c</code></strong></pre></div></div></div><div class="sect1" title="Creating or Opening a Semaphore Set"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="creating_or_opening_a_semaphore_set">Creating or Opening a Semaphore Set</h2></div></div></div><p>The <span class="emphasis"><em>semget()</em></span> system call creates a new semaphore set or
                obtains the identifier of an existing set.<a id="IDX-CHP-47-6410" class="indexterm"/></p><a id="I_programlisting47_d1e124541"/><pre class="programlisting">#include &lt;sys/types.h&gt;        /* For portability */
#include &lt;sys/sem.h&gt;

int <strong class="userinput"><code>semget</code></strong>(key_t <span class="emphasis"><em>key</em></span>, int <span class="emphasis"><em>nsems</em></span>, int <span class="emphasis"><em>semflg</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns semaphore set identifier on success, or -1 on error</p></div><p>The <span class="emphasis"><em>key</em></span> argument is a key generated using one of the methods
                described in <a class="xref" href="ch45.html#ipc_keys" title="IPC Keys">IPC Keys</a> (i.e., usually the value <code class="literal">IPC_PRIVATE</code> or a key returned by
                    <span class="emphasis"><em>ftok()</em></span>).</p><p>If we are using <span class="emphasis"><em>semget()</em></span> to create a new semaphore set, then
                    <span class="emphasis"><em>nsems</em></span> specifies the number of semaphores in that set, and
                must be greater than 0. If we are using <span class="emphasis"><em>semget()</em></span> to obtain the
                identifier of an existing set, then <span class="emphasis"><em>nsems</em></span> must be less than or
                equal to the size of the set (or the error <code class="literal">EINVAL</code>
                results). It is not possible to change the number of semaphores in an existing
                set.</p><p>The <span class="emphasis"><em>semflg</em></span> argument is a bit mask specifying the permissions
                to be placed on a new semaphore set or checked against an existing set. These
                permissions are specified in the same manner as for files (<a class="xref" href="ch15.html#constants_for_file_permission_bits" title="Table 15-4. Constants for file permission bits">Table 15-4</a>, in <a class="xref" href="ch15.html#permissions_on_regular_files" title="Permissions on Regular Files">Permissions on Regular Files</a>). In addition, zero or more of the
                following flags can be ORed (|) in <span class="emphasis"><em>semflg</em></span> to control the
                operation of <span class="emphasis"><em>semget()</em></span>:</p><div class="variablelist"><dl><dt><span class="term">
                        <code class="literal">IPC_CREAT</code>
                    </span></dt><dd><p>If no semaphore set with the specified <span class="emphasis"><em>key</em></span>
                            exists, create a new set.</p></dd><dt><span class="term">
                        <code class="literal">IPC_EXCL</code>
                    </span></dt><dd><p>If <code class="literal">IPC_CREAT</code> was also specified,
                            and a semaphore set with the specified <span class="emphasis"><em>key</em></span> already
                            exists, fail with the error <code class="literal">EEXIST</code>.</p></dd></dl></div><p>These flags are described in more detail in Section 45.1.</p><p>On success, <span class="emphasis"><em>semget()</em></span> returns the identifier for the new or
                existing semaphore set. Subsequent system calls referring to individual semaphores
                must specify both the semaphore set identifier and the number of the semaphore
                within that set. The semaphores within a set are numbered starting at 0.</p></div><div class="sect1" title="Semaphore Control Operations"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="semaphore_control_operations">Semaphore Control Operations</h2></div></div></div><p>The <span class="emphasis"><em>semctl()</em></span> system call performs a variety of control
                operations on a semaphore set or on an individual semaphore within a set.<a id="IDX-CHP-47-6411" class="indexterm"/><a id="IDX-CHP-47-6412" class="indexterm"/><a id="IDX-CHP-47-6413" class="indexterm"/><a id="IDX-CHP-47-6414" class="indexterm"/><a id="IDX-CHP-47-6415" class="indexterm"/><a id="IDX-CHP-47-6416" class="indexterm"/><a id="IDX-CHP-47-6417" class="indexterm"/><a id="IDX-CHP-47-6418" class="indexterm"/><a id="IDX-CHP-47-6419" class="indexterm"/><a id="IDX-CHP-47-6420" class="indexterm"/><a id="IDX-CHP-47-6421" class="indexterm"/></p><a id="I_programlisting47_d1e124704"/><pre class="programlisting">#include &lt;sys/types.h&gt;        /* For portability */
#include &lt;sys/sem.h&gt;

int <strong class="userinput"><code>semctl</code></strong>(int <span class="emphasis"><em>semid</em></span>, int <span class="emphasis"><em>semnum</em></span>, int <span class="emphasis"><em>cmd</em></span>, ... /* union semun <span class="emphasis"><em>arg</em></span> */);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns nonnegative integer on success (see text); returns -1 on error</p></div><p>The <span class="emphasis"><em>semid</em></span> argument is the identifier of the semaphore set on
                which the operation is to be performed. For those operations performed on a single
                semaphore, the <span class="emphasis"><em>semnum</em></span> argument identifies a particular
                semaphore within the set. For other operations, this argument is ignored, and we can
                specify it as 0. The cmd argument specifies the operation to be performed.</p><p>Certain operations require a fourth argument to <span class="emphasis"><em>semctl()</em></span>,
                which we refer to by the name <span class="emphasis"><em>arg</em></span> in the remainder of this
                section. This argument is a union defined as shown in <a class="xref" href="ch47.html#definition_of_the_semun_union" title="Example 47-2. Definition of the semun union">Example 47-2</a>. We must explicitly define this union
                in our programs. We do this in our example programs by including the header file in
                    <a class="xref" href="ch47.html#definition_of_the_semun_union" title="Example 47-2. Definition of the semun union">Example 47-2</a>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Although placing the definition of the <span class="emphasis"><em>semun</em></span> union in a
                    standard header file would be sensible, SUSv3 requires the programmer to
                    explicitly define it instead. Nevertheless, some UNIX implementations do provide
                    this definition in <code class="literal">&lt;sys/sem.h&gt;</code>.
                    Older versions of <span class="emphasis"><em>glibc</em></span> (up to and including version 2.0)
                    also provided this definition. In conformance with SUSv3, more recent versions
                    of <span class="emphasis"><em>glibc</em></span> do not, and the macro <code class="literal">_SEM_SEMUN_UNDEFINED</code> is defined with the value 1 in <code class="literal">&lt;sys/sem.h&gt;</code> to indicate this fact
                    (i.e., an application compiled against <span class="emphasis"><em>glibc</em></span> can test this
                    macro to determine if the program must itself define the
                        <span class="emphasis"><em>semun</em></span> union).<a id="IDX-CHP-47-6422" class="indexterm"/></p></div><div class="example"><a id="definition_of_the_semun_union"/><div class="example-title">Example 47-2. Definition of the <span class="emphasis"><em>semun</em></span> union</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svsem/semun.h</code></strong>
#ifndef SEMUN_H
#define SEMUN_H                 /* Prevent accidental double inclusion */

#include &lt;sys/types.h&gt;          /* For portability */
#include &lt;sys/sem.h&gt;

union semun {                   /* Used in calls to semctl() */
    int                 val;
    struct semid_ds *   buf;
    unsigned short *    array;
#if defined(__linux__)
    struct seminfo *    __buf;
#endif
};

#endif
      <strong class="userinput"><code>svsem/semun.h</code></strong></pre></div></div><p>SUSv2 and SUSv3 specify that the final argument to <span class="emphasis"><em>semctl()</em></span>
                is optional. However, a few (mainly older) UNIX implementations (and older versions
                of <span class="emphasis"><em>glibc</em></span>) prototyped <span class="emphasis"><em>semctl()</em></span> as
                follows:</p><a id="I_programlisting47_d1e124800"/><pre class="programlisting">int semctl(int semid, int semnum, int cmd, union semun arg);</pre><p>This meant that the fourth argument was required even in the cases where it is not
                actually used (e.g., the <code class="literal">IPC_RMID</code> and <code class="literal">GETVAL</code> operations described below). For full
                portability, we specify a dummy final argument to <span class="emphasis"><em>semctl()</em></span> in
                those calls where it is not required.</p><p>In the remainder of this section, we consider the various control operations that
                can be specified for <span class="emphasis"><em>cmd</em></span>.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="generic_control_operations"/></div></div></div><div class="sect3" title="Generic control operations"><div class="titlepage"><div><div><h4 class="title" id="generic_control_operations-id1">Generic control operations</h4></div></div></div><p>The following operations are the same ones that can be applied to other
                        types of System V IPC objects. In each case, the <span class="emphasis"><em>semnum</em></span>
                        argument is ignored. Further details about these operations, including the
                        privileges and permissions required by the calling process, are provided in
                        Section 45.3.</p><div class="variablelist"><dl><dt><span class="term">
                                <code class="literal">IPC_RMID</code>
                            </span></dt><dd><p>Immediately remove the semaphore set and its associated
                                        <span class="emphasis"><em>semid_ds</em></span> data structure. Any processes
                                    blocked in <span class="emphasis"><em>semop()</em></span> calls waiting on
                                    semaphores in this set are immediately awakened, with
                                        <span class="emphasis"><em>semop()</em></span> reporting the error <code class="literal">EIDRM</code>. The
                                        <span class="emphasis"><em>arg</em></span> argument is not required.<a id="IDX-CHP-47-6423" class="indexterm"/></p></dd><dt><span class="term">
                                <code class="literal">IPC_STAT</code>
                            </span></dt><dd><p>Place a copy of the <span class="emphasis"><em>semid_ds</em></span> data
                                    structure associated with this semaphore set in the buffer
                                    pointed to by <span class="emphasis"><em>arg.buf</em></span>. We describe the
                                        <span class="emphasis"><em>semid_ds</em></span> structure in Section
                                        47.4.<a id="IDX-CHP-47-6424" class="indexterm"/></p></dd><dt><span class="term">
                                <code class="literal">IPC_SET</code>
                            </span></dt><dd><p>Update selected fields of the <span class="emphasis"><em>semid_ds</em></span>
                                    data structure associated with this semaphore set using values
                                    in the buffer pointed to by <span class="emphasis"><em>arg.buf</em></span>.</p></dd></dl></div></div><div class="sect3" title="Retrieving and initializing semaphore values"><div class="titlepage"><div><div><h4 class="title" id="retrieving_and_initializing_semaphore_va">Retrieving and initializing semaphore values</h4></div></div></div><p>The following operations retrieve or initialize the value(s) of an
                        individual semaphore or of all semaphores in a set. Retrieving a semaphore
                        value requires read permission on the semaphore, while initializing the
                        value requires alter (write) permission.<a id="IDX-CHP-47-6425" class="indexterm"/><a id="IDX-CHP-47-6426" class="indexterm"/><a id="IDX-CHP-47-6427" class="indexterm"/><a id="IDX-CHP-47-6428" class="indexterm"/><a id="IDX-CHP-47-6429" class="indexterm"/><a id="IDX-CHP-47-6430" class="indexterm"/><a id="IDX-CHP-47-6431" class="indexterm"/><a id="IDX-CHP-47-6432" class="indexterm"/><a id="IDX-CHP-47-6433" class="indexterm"/><a id="IDX-CHP-47-6434" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term">
                                <code class="literal">GETVAL</code>
                            </span></dt><dd><p>As its function result, <span class="emphasis"><em>semctl()</em></span> returns
                                    the value of the <span class="emphasis"><em>semnum</em></span>-th semaphore in the
                                    semaphore set specified by <span class="emphasis"><em>semid</em></span>. The
                                        <span class="emphasis"><em>arg</em></span> argument is not required.</p></dd><dt><span class="term">
                                <code class="literal">SETVAL</code>
                            </span></dt><dd><p>The value of the <span class="emphasis"><em>semnum</em></span>-th semaphore in
                                    the set referred to by <span class="emphasis"><em>semid</em></span> is initialized
                                    to the value specified in <span class="emphasis"><em>arg.val</em></span>.</p></dd><dt><span class="term">
                                <code class="literal">GETALL</code>
                            </span></dt><dd><p>Retrieve the values of all of the semaphores in the set
                                    referred to by <span class="emphasis"><em>semid</em></span>, placing them in the
                                    array pointed to by <span class="emphasis"><em>arg.array</em></span>. The
                                    programmer must ensure that this array is of sufficient size.
                                    (The number of semaphores in a set can be obtained from the
                                        <span class="emphasis"><em>sem_nsems</em></span> field of the
                                        <span class="emphasis"><em>semid_ds</em></span> data structure retrieved by an
                                        <code class="literal">IPC_STAT</code> operation.) The
                                        <span class="emphasis"><em>semnum</em></span> argument is ignored. An example
                                    of the use of the <code class="literal">GETALL</code>
                                    operation is provided in <a class="xref" href="ch47.html#a_semaphore_monitoring_program" title="Example 47-3. A semaphore monitoring program">Example 47-3</a>.</p></dd><dt><span class="term">
                                <code class="literal">SETALL</code>
                            </span></dt><dd><p>Initialize all semaphores in the set referred to by
                                        <span class="emphasis"><em>semid</em></span>, using the values supplied in the
                                    array pointed to by <span class="emphasis"><em>arg.array</em></span>. The
                                        <span class="emphasis"><em>semnum</em></span> argument is ignored. <a class="xref" href="ch47.html#using_the_setall_operation_to_initialize" title="Example 47-4. Using the SETALL operation to initialize a System V semaphore set">Example 47-4</a>
                                    demonstrates the use of the <code class="literal">SETALL</code> operation.</p></dd></dl></div><p>If another process is waiting to perform an operation on the semaphore(s)
                        modified by the <code class="literal">SETVAL</code> or <code class="literal">SETALL</code> operations, and the change(s) made
                        would permit that operation to proceed, then the kernel wakes up that
                        process.</p><p>Changing the value of a semaphore with <code class="literal">SETVAL</code> or <code class="literal">SETALL</code> clears
                        the undo entries for that semaphore in all processes. We describe semaphore
                        undo entries in Section 47.8.</p><p>Note that the information returned by <code class="literal">GETVAL</code> and <code class="literal">GETALL</code> may
                        already be out of date by the time the calling process comes to use it. Any
                        program that depends on the information returned by these operations being
                        unchanged may be subject to time-of-check, time-of-use race conditions
                            (<a class="xref" href="ch38.html#beware_of_signals_and_race_conditions" title="Beware of Signals and Race Conditions">Beware of Signals and Race Conditions</a>).</p></div><div class="sect3" title="Retrieving per-semaphore information"><div class="titlepage"><div><div><h4 class="title" id="retrieving_per-semaphore_information">Retrieving per-semaphore information</h4></div></div></div><p>The following operations return (via the function result value)
                        information about the <span class="emphasis"><em>semnum</em></span>-th semaphore of the set
                        referred to by <span class="emphasis"><em>semid</em></span>. For all of these operations, read
                        permission is required on the semaphore set, and the
                            <span class="emphasis"><em>arg</em></span> argument is not required.<a id="IDX-CHP-47-6435" class="indexterm"/><a id="IDX-CHP-47-6436" class="indexterm"/><a id="IDX-CHP-47-6437" class="indexterm"/><a id="IDX-CHP-47-6438" class="indexterm"/><a id="IDX-CHP-47-6439" class="indexterm"/><a id="IDX-CHP-47-6440" class="indexterm"/><a id="IDX-CHP-47-6441" class="indexterm"/><a id="IDX-CHP-47-6442" class="indexterm"/><a id="IDX-CHP-47-6443" class="indexterm"/><a id="IDX-CHP-47-6444" class="indexterm"/><a id="IDX-CHP-47-6445" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term">
                                <code class="literal">GETPID</code>
                            </span></dt><dd><p>Return the process ID of the last process to perform a
                                        <span class="emphasis"><em>semop()</em></span> on this semaphore; this is
                                    referred to as the <span class="emphasis"><em>sempid</em></span> value. If no
                                    process has yet performed a <span class="emphasis"><em>semop()</em></span> on this
                                    semaphore, 0 is returned.<a id="IDX-CHP-47-6446" class="indexterm"/><a id="IDX-CHP-47-6447" class="indexterm"/></p></dd><dt><span class="term">
                                <code class="literal">GETNCNT</code>
                            </span></dt><dd><p>Return the number of processes currently waiting for the value
                                    of this semaphore to increase; this is referred to as the
                                        <span class="emphasis"><em>semncnt</em></span> value.<a id="IDX-CHP-47-6448" class="indexterm"/></p></dd><dt><span class="term">
                                <code class="literal">GETZCNT</code>
                            </span></dt><dd><p>Return the number of processes currently waiting for the value
                                    of this semaphore to become 0; this is referred to as the
                                        <span class="emphasis"><em>semzcnt</em></span> value.<a id="IDX-CHP-47-6449" class="indexterm"/></p></dd></dl></div><p>As with the <code class="literal">GETVAL</code> and <code class="literal">GETALL</code> operations described above, the
                        information returned by the <code class="literal">GETPID</code>,
                            <code class="literal">GETNCNT</code>, and <code class="literal">GETZCNT</code> operations may already be out of date by the time the
                        calling process comes to use it.</p><p><a class="xref" href="ch47.html#a_semaphore_monitoring_program" title="Example 47-3. A semaphore monitoring program">Example 47-3</a> demonstrates the use of
                        these three operations.</p></div></div></div><div class="sect1" title="Semaphore Associated Data Structure"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="semaphore_associated_data_structure">Semaphore Associated Data Structure</h2></div></div></div><p>Each semaphore set has an associated <span class="emphasis"><em>semid_ds</em></span> data structure
                of the following form:</p><a id="I_programlisting47_d1e125217"/><pre class="programlisting">struct semid_ds {
    struct ipc_perm sem_perm;       /* Ownership and permissions */
    time_t          sem_otime;      /* Time of last semop() */
    time_t          sem_ctime;      /* Time of last change */
    unsigned long   sem_nsems;      /* Number of semaphores in set */
};</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 requires all of the fields that we show in the
                        <span class="emphasis"><em>semid_ds</em></span> structure. Some other UNIX implementations
                    include additional nonstandard fields. On Linux 2.4 and later, the
                        <span class="emphasis"><em>sem_nsems</em></span> field is typed as <span class="emphasis"><em>unsigned
                        long</em></span>. SUSv3 specifies the type of this field as
                        <span class="emphasis"><em>unsigned short</em></span>, and it is so defined in Linux 2.2 and
                    on most other UNIX implementations.<a id="IDX-CHP-47-6450" class="indexterm"/></p></div><p>The fields of the <span class="emphasis"><em>semid_ds</em></span> structure are implicitly updated
                by various semaphore system calls, and certain subfields of the
                    <span class="emphasis"><em>sem_perm</em></span> field can be explicitly updated using the
                    <span class="emphasis"><em>semctl()</em></span>
                <code class="literal">IPC_SET</code> operation. The details are as
                follows:</p><div class="variablelist"><dl><dt><span class="term">
                        <span class="emphasis"><em>sem_perm</em></span>
                    </span></dt><dd><p>When the semaphore set is created, the fields of this substructure are
                            initialized as described in Section 45.3. The <span class="emphasis"><em>uid</em></span>,
                                <span class="emphasis"><em>gid</em></span>, and <span class="emphasis"><em>mode</em></span> subfields
                            can be updated via <code class="literal">IPC_SET</code>.</p></dd><dt><span class="term">
                        <span class="emphasis"><em>sem_otime</em></span>
                    </span></dt><dd><p>This field is set to 0 when the semaphore set is created, and then set
                            to the current time on each successful <span class="emphasis"><em>semop()</em></span>, or
                            when the semaphore value is modified as a consequence of a <code class="literal">SEM_UNDO</code> operation (<a class="xref" href="ch47.html#semaphore_undo_values" title="Semaphore Undo Values">Semaphore Undo Values</a>). This field and
                                <span class="emphasis"><em>sem_ctime</em></span> are typed as
                                <span class="emphasis"><em>time_t</em></span>, and store time in seconds since the
                                Epoch.<a id="IDX-CHP-47-6451" class="indexterm"/></p></dd><dt><span class="term">
                        <span class="emphasis"><em>sem_ctime</em></span>
                    </span></dt><dd><p>This field is set to the current time when the semaphore set is
                            created and on each successful <code class="literal">IPC_SET</code>, <code class="literal">SETALL</code>, or
                                <code class="literal">SETVAL</code> operation. (On some UNIX
                            implementations, the <code class="literal">SETALL</code> and
                                <code class="literal">SETVAL</code> operations don’t modify
                                <span class="emphasis"><em>sem_ctime</em></span>.)</p></dd><dt><span class="term">
                        <span class="emphasis"><em>sem_nsems</em></span>
                    </span></dt><dd><p>When the set is created, this field is initialized to the number of
                            semaphores in the set.</p></dd></dl></div><p>In the remainder of this section, we show two example programs that make use of
                the <span class="emphasis"><em>semid_ds</em></span> data structure and some of the
                    <span class="emphasis"><em>semctl()</em></span> operations described in Section 47.3. We
                demonstrate the use of both of these programs in Section 47.6.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="monitoring_a_semaphore_set"/></div></div></div><div class="sect3" title="Monitoring a semaphore set"><div class="titlepage"><div><div><h4 class="title" id="monitoring_a_semaphore_set-id1">Monitoring a semaphore set</h4></div></div></div><p>The program in <a class="xref" href="ch47.html#a_semaphore_monitoring_program" title="Example 47-3. A semaphore monitoring program">Example 47-3</a> makes use
                        of various <span class="emphasis"><em>semctl()</em></span> operations to display information
                        about the existing semaphore set whose identifier is provided as its
                        command-line argument. The program first displays the time fields from the
                            <span class="emphasis"><em>semid_ds</em></span> data structure. Then, for each semaphore
                        in the set, the program displays the semaphore’s current value, as well as
                        its <span class="emphasis"><em>sempid</em></span>, <span class="emphasis"><em>semncnt</em></span>, and
                            <span class="emphasis"><em>semzcnt</em></span> values.<a id="IDX-CHP-47-6452" class="indexterm"/><a id="IDX-CHP-47-6453" class="indexterm"/><a id="IDX-CHP-47-6454" class="indexterm"/><a id="IDX-CHP-47-6455" class="indexterm"/><a id="IDX-CHP-47-6456" class="indexterm"/><a id="IDX-CHP-47-6457" class="indexterm"/></p><div class="example"><a id="a_semaphore_monitoring_program"/><div class="example-title">Example 47-3. A semaphore monitoring program</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svsem/svsem_mon.c</code></strong>
#include &lt;sys/types.h&gt;
#include &lt;sys/sem.h&gt;
#include &lt;time.h&gt;
#include "semun.h"                      /* Definition of semun union */
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    struct semid_ds ds;
    union semun arg, dummy;             /* Fourth argument for semctl() */
    int semid, j;

    if (argc != 2 || strcmp(argv[1], "--help") == 0)
        usageErr("%s semid\n", argv[0]);

    semid = getInt(argv[1], 0, "semid");

    arg.buf = &amp;ds;
    if (semctl(semid, 0, IPC_STAT, arg) == -1)
        errExit("semctl");

    printf("Semaphore changed: %s", ctime(&amp;ds.sem_ctime));
    printf("Last semop():      %s", ctime(&amp;ds.sem_otime));

    /* Display per-semaphore information */

    arg.array = calloc(ds.sem_nsems, sizeof(arg.array[0]));
    if (arg.array == NULL)
        errExit("calloc");
    if (semctl(semid, 0, GETALL, arg) == -1)
        errExit("semctl-GETALL");

    printf("Sem #  Value  SEMPID  SEMNCNT  SEMZCNT\n");

    for (j = 0; j &lt; ds.sem_nsems; j++)
        printf("%3d   %5d   %5d  %5d    %5d\n", j, arg.array[j],
                semctl(semid, j, GETPID, dummy),
                semctl(semid, j, GETNCNT, dummy),
                semctl(semid, j, GETZCNT, dummy));

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>svsem/svsem_mon.c</code></strong></pre></div></div></div><div class="sect3" title="Initializing all semaphores in a set"><div class="titlepage"><div><div><h4 class="title" id="initializing_all_semaphores_in_a_set">Initializing all semaphores in a set</h4></div></div></div><p>The program in <a class="xref" href="ch47.html#using_the_setall_operation_to_initialize" title="Example 47-4. Using the SETALL operation to initialize a System V semaphore set">Example 47-4</a>
                        provides a command-line interface for initializing all of the semaphores in
                        an existing set. The first command-line argument is the identifier of the
                        semaphore set to be initialized. The remaining command-line arguments
                        specify the values to which the semaphores are to be initialized (there must
                        be as many of these arguments as there are semaphores in the set).<a id="IDX-CHP-47-6458" class="indexterm"/><a id="IDX-CHP-47-6459" class="indexterm"/><a id="IDX-CHP-47-6460" class="indexterm"/><a id="IDX-CHP-47-6461" class="indexterm"/><a id="IDX-CHP-47-6462" class="indexterm"/><a id="IDX-CHP-47-6463" class="indexterm"/><a id="IDX-CHP-47-6464" class="indexterm"/><a id="IDX-CHP-47-6465" class="indexterm"/><a id="IDX-CHP-47-6466" class="indexterm"/><a id="IDX-CHP-47-6467" class="indexterm"/><a id="IDX-CHP-47-6468" class="indexterm"/></p><div class="example"><a id="using_the_setall_operation_to_initialize"/><div class="example-title">Example 47-4. Using the <code class="literal">SETALL</code> operation to
                            initialize a System V semaphore set</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svsem/svsem_setall.c</code></strong>
#include &lt;sys/types.h&gt;
#include &lt;sys/sem.h&gt;
#include "semun.h"                      /* Definition of semun union */
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    struct semid_ds ds;
    union semun arg;                    /* Fourth argument for semctl() */
    int j, semid;

    if (argc &lt; 3 || strcmp(argv[1], "--help") == 0)
        usageErr("%s semid val...\n", argv[0]);

    semid = getInt(argv[1], 0, "semid");

    /* Obtain size of semaphore set */

    arg.buf = &amp;ds;
    if (semctl(semid, 0, IPC_STAT, arg) == -1)
        errExit("semctl");

    if (ds.sem_nsems != argc - 2)
        cmdLineErr("Set contains %ld semaphores, but %d values were supplied\n",
                (long) ds.sem_nsems, argc - 2);

    /* Set up array of values; perform semaphore initialization */

    arg.array = calloc(ds.sem_nsems, sizeof(arg.array[0]));
    if (arg.array == NULL)
        errExit("calloc");

    for (j = 2; j &lt; argc; j++)
        arg.array[j - 2] = getInt(argv[j], 0, "val");

    if (semctl(semid, 0, SETALL, arg) == -1)
        errExit("semctl-SETALL");
    printf("Semaphore values changed (PID=%ld)\n", (long) getpid());

    exit(EXIT_SUCCESS);
}
     <strong class="userinput"><code>svsem/svsem_setall.c</code></strong></pre></div></div></div></div></div><div class="sect1" title="Semaphore Initialization"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="semaphore_initialization">Semaphore Initialization</h2></div></div></div><p>According to SUSv3, an implementation is not required to initialize the values of
                the semaphores in a set created by <span class="emphasis"><em>semget()</em></span>. Instead, the
                programmer must explicitly initialize the semaphores using the
                    <span class="emphasis"><em>semctl()</em></span> system call. (On Linux, the semaphores returned by
                    <span class="emphasis"><em>semget()</em></span> are in fact initialized to 0, but we can’t
                portably rely on this.) As stated earlier, the fact that semaphore creation and
                initialization must be performed by separate system calls, instead of in a single
                atomic step, leads to possible race conditions when initializing a semaphore. In
                this section, we detail the nature of the race and look at a method of avoiding it
                based on an idea described in [Stevens, 1999].<a id="IDX-CHP-47-6470" class="indexterm"/><a id="IDX-CHP-47-6471" class="indexterm"/><a id="IDX-CHP-47-6472" class="indexterm"/><a id="IDX-CHP-47-6473" class="indexterm"/><a id="IDX-CHP-47-6474" class="indexterm"/><a id="IDX-CHP-47-6475" class="indexterm"/><a id="IDX-CHP-47-6476" class="indexterm"/><a id="IDX-CHP-47-6477" class="indexterm"/><a id="IDX-CHP-47-6478" class="indexterm"/><a id="IDX-CHP-47-6479" class="indexterm"/><a id="IDX-CHP-47-6480" class="indexterm"/><a id="IDX-CHP-47-6481" class="indexterm"/><a id="IDX-CHP-47-6482" class="indexterm"/><a id="IDX-CHP-47-6469" class="indexterm"/></p><p>Suppose that we have an application consisting of multiple peer processes
                employing a semaphore to coordinate their actions. Since no single process is
                guaranteed to be the first to use the semaphore (this is what is meant by the term
                    <span class="emphasis"><em>peer</em></span>), each process must be prepared to create and
                initialize the semaphore if it doesn’t already exist. For this purpose, we might
                consider employing the code shown in <a class="xref" href="ch47.html#incorrectly_initializing_a_system_v_sema" title="Example 47-5. Incorrectly initializing a System V semaphore">Example 47-5</a>.</p><div class="example"><a id="incorrectly_initializing_a_system_v_sema"/><div class="example-title">Example 47-5. Incorrectly initializing a System V semaphore</div><div class="example-contents"><pre class="programlisting"><span class="emphasis"><em>from</em></span> <strong class="userinput"><code>svsem/svsem_bad_init.c</code></strong>
    /* Create a set containing 1 semaphore */

    semid = semget(key, 1, IPC_CREAT | IPC_EXCL | perms);

    if (semid != -1) {                  /* Successfully created the semaphore */
        union semun arg;

        /* XXXX */

        arg.val = 0;                    /* Initialize semaphore */
        if (semctl(semid, 0, SETVAL, arg) == -1)
            errExit("semctl");

    } else {                            /* We didn't create the semaphore */
        if (errno != EEXIST) {          /* Unexpected error from semget() */
            errExit("semget");

        semid = semget(key, 1, perms);  /* Retrieve ID of existing set */
        if (semid == -1)
           errExit("semget");
    }

    /* Now perform some operation on the semaphore */

    sops[0].sem_op = 1;                 /* Add 1... */
    sops[0].sem_num = 0;                /* to semaphore 0 */
    sops[0].sem_flg = 0;
    if (semop(semid, sops, 1) == -1)
        errExit("semop");
      <span class="emphasis"><em>from</em></span> <strong class="userinput"><code>svsem/svsem_bad_init.c</code></strong></pre></div></div><p>The problem with the code in <a class="xref" href="ch47.html#incorrectly_initializing_a_system_v_sema" title="Example 47-5. Incorrectly initializing a System V semaphore">Example 47-5</a> is that if two processes
                execute it at the same time, then the sequence shown in <a class="xref" href="ch47.html#two_processes_racing_to_initialize_the_s" title="Figure 47-2. Two processes racing to initialize the same semaphore">Figure 47-2</a> could occur, if the first
                process’s time slice happens to expire at the point marked <code class="literal">XXXX</code> in the code. This sequence is problematic for two reasons.
                First, process B performs a <span class="emphasis"><em>semop()</em></span> on an uninitialized
                semaphore (i.e., one whose value is arbitrary). Second, the
                    <span class="emphasis"><em>semctl()</em></span> call in process A overwrites the changes made by
                process B.</p><p>The solution to this problem relies on a historical, and now standardized, feature
                of the initialization of the <span class="emphasis"><em>sem_otime</em></span> field in the
                    <span class="emphasis"><em>semid_ds</em></span> data structure associated with the semaphore set.
                When a semaphore set is first created, the <span class="emphasis"><em>sem_otime</em></span> field is
                initialized to 0, and it is changed only by a subsequent
                    <span class="emphasis"><em>semop()</em></span> call. We can exploit this feature to eliminate the
                race condition described above. We do this by inserting extra code to force the
                second process (i.e., the one that does not create the semaphore) to wait until the
                first process has both initialized the semaphore <span class="emphasis"><em>and</em></span> executed a
                    <span class="emphasis"><em>semop()</em></span> call that updates the
                    <span class="emphasis"><em>sem_otime</em></span> field, but does not modify the semaphore’s value.
                The modified code is shown in <a class="xref" href="ch47.html#initializing_a_system_v_semaphore" title="Example 47-6. Initializing a System V semaphore">Example 47-6</a>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Unfortunately, the solution to the initialization problem described in the
                    main text doesn’t work on all UNIX implementations. In some versions of the
                    modern BSD derivatives, <span class="emphasis"><em>semop()</em></span> doesn’t update the
                        <span class="emphasis"><em>sem_otime</em></span> field.</p></div><div class="example"><a id="initializing_a_system_v_semaphore"/><div class="example-title">Example 47-6. Initializing a System V semaphore</div><div class="example-contents"><pre class="programlisting"><span class="emphasis"><em>from</em></span> <strong class="userinput"><code>svsem/svsem_good_init.c</code></strong>
    semid = semget(key, 1, IPC_CREAT | IPC_EXCL | perms);

    if (semid != -1) {                  /* Successfully created the semaphore */
        union semun arg;
        struct sembuf sop;

        arg.val = 0;                    /* So initialize it to 0 */
        if (semctl(semid, 0, SETVAL, arg) == -1)
            errExit("semctl");

        /* Perform a "no-op" semaphore operation - changes sem_otime
           so other processes can see we've initialized the set. */

        sop.sem_num = 0;                /* Operate on semaphore 0 */
        sop.sem_op = 0;                 /* Wait for value to equal 0 */
        sop.sem_flg = 0;
        if (semop(semid, &amp;sop, 1) == -1)
            errExit("semop");

    } else {                            /* We didn't create the semaphore set */
        const int MAX_TRIES = 10;
        int j;
        union semun arg;
        struct semid_ds ds;

        if (errno != EEXIST) {          /* Unexpected error from semget() */
            errExit("semget");

        semid = semget(key, 1, perms);  /* Retrieve ID of existing set */
        if (semid == -1)
            errExit("semget");

        /* Wait until another process has called semop() */

        arg.buf = &amp;ds;
        for (j = 0; j &lt; MAX_TRIES; j++) {
            if (semctl(semid, 0, IPC_STAT, arg) == -1)
                errExit("semctl");
            if (ds.sem_otime != 0)      /* semop() performed? */
                break;                  /* Yes, quit loop */
            sleep(1);                   /* If not, wait and retry */
        }

        if (ds.sem_otime == 0)          /* Loop ran to completion! */
            fatal("Existing semaphore not initialized");
    }

    /* Now perform some operation on the semaphore */
      <span class="emphasis"><em>from</em></span> <strong class="userinput"><code>svsem/svsem_good_init.c</code></strong></pre></div></div><p>We can use variations of the technique shown in <a class="xref" href="ch47.html#initializing_a_system_v_semaphore" title="Example 47-6. Initializing a System V semaphore">Example 47-6</a> to ensure that multiple semaphores
                in a set are correctly initialized, or that a semaphore is initialized to a nonzero
                value.</p><p>This rather complex solution to the race problem is not required in all
                applications. We don’t need it if one process is guaranteed to be able to create and
                initialize the semaphore before any other processes attempt to use it. This would be
                the case, for example, if a parent creates and initializes the semaphore before
                creating child processes with which it shares the semaphore. In such cases, it is
                sufficient for the first process to follow its <span class="emphasis"><em>semget()</em></span> call by
                a <span class="emphasis"><em>semctl()</em></span>
                <code class="literal">SETVAL</code> or <code class="literal">SETALL</code> operation.</p><div class="figure"><a id="two_processes_racing_to_initialize_the_s"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject47_d1e125711"/><img src="figs/web/47-2_SVSEM-init-race.png.jpg" alt="Two processes racing to initialize the same semaphore"/></div></div><div class="figure-title">Figure 47-2. Two processes racing to initialize the same semaphore</div></div></div><div class="sect1" title="Semaphore Operations"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="semaphore_operations">Semaphore Operations</h2></div></div></div><p>The <span class="emphasis"><em>semop()</em></span> system call performs one or more operations on
                the semaphores in the semaphore set identified by
                    <span class="emphasis"><em>semid</em></span>.<a id="IDX-CHP-47-6483" class="indexterm"/><a id="IDX-CHP-47-6484" class="indexterm"/><a id="IDX-CHP-47-6485" class="indexterm"/><a id="IDX-CHP-47-6486" class="indexterm"/><a id="IDX-CHP-47-6487" class="indexterm"/><a id="IDX-CHP-47-6488" class="indexterm"/><a id="IDX-CHP-47-6489" class="indexterm"/><a id="IDX-CHP-47-6490" class="indexterm"/><a id="IDX-CHP-47-6491" class="indexterm"/><a id="IDX-CHP-47-6492" class="indexterm"/><a id="IDX-CHP-47-6493" class="indexterm"/><a id="IDX-CHP-47-6494" class="indexterm"/><a id="IDX-CHP-47-6495" class="indexterm"/></p><a id="I_programlisting47_d1e125799"/><pre class="programlisting">#include &lt;sys/types.h&gt;        /* For portability */
#include &lt;sys/sem.h&gt;

int <strong class="userinput"><code>semop</code></strong>(int <span class="emphasis"><em>semid</em></span>, struct sembuf *<span class="emphasis"><em>sops</em></span>, unsigned int <span class="emphasis"><em>nsops</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>sops</em></span> argument is a pointer to an array that contains the
                operations to be performed, and <span class="emphasis"><em>nsops</em></span> gives the size of this
                array (which must contain at least one element). The operations are performed
                atomically and in array order. The elements of the <span class="emphasis"><em>sops</em></span> array
                are structures of the following form:</p><a id="I_programlisting47_d1e125827"/><pre class="programlisting">struct sembuf {
    unsigned short sem_num;     /* Semaphore number */
    short          sem_op;      /* Operation to be performed */
    short          sem_flg;     /* Operation flags (IPC_NOWAIT and SEM_UNDO) */
};</pre><p>The <span class="emphasis"><em>sem_num</em></span> field identifies the semaphore within the set
                upon which the operation is to be performed. The <span class="emphasis"><em>sem_op</em></span> field
                specifies the operation to be performed:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If <span class="emphasis"><em>sem_op</em></span> is greater than 0, the value of
                            <span class="emphasis"><em>sem_op</em></span> is added to the semaphore value. As a
                        result, other processes waiting to decrease the semaphore value may be
                        awakened and perform their operations. The calling process must have alter
                        (write) permission on the semaphore.</p></li><li class="listitem"><p>If <span class="emphasis"><em>sem_op</em></span> equals 0, the value of the semaphore is
                        checked to see whether it currently equals 0. If it does, the operation
                        completes immediately; otherwise, <span class="emphasis"><em>semop()</em></span> blocks until
                        the semaphore value becomes 0. The calling process must have read permission
                        on the semaphore.</p></li><li class="listitem"><p>If <span class="emphasis"><em>sem_op</em></span> is less than 0, decrease the value of the
                        semaphore by the amount specified in <span class="emphasis"><em>sem_op</em></span>. If the
                        current value of the semaphore is greater than or equal to the absolute
                        value of <span class="emphasis"><em>sem_op</em></span>, the operation completes immediately.
                        Otherwise, <span class="emphasis"><em>semop()</em></span> blocks until the semaphore value has
                        been increased to a level that permits the operation to be performed without
                        resulting in a negative value. The calling process must have alter
                        permission on the semaphore.</p></li></ul></div><p>Semantically, increasing the value of a semaphore corresponds to making a resource
                available so that others can use it, while decreasing the value of a semaphore
                corresponds to reserving a resource for (exclusive) use by this process. When
                decreasing the value of a semaphore, the operation is blocked if the semaphore value
                is too low—that is, if some other process has already reserved the resource.</p><p>When a <span class="emphasis"><em>semop()</em></span> call blocks, the process remains blocked until
                one of the following occurs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Another process modifies the value of the semaphore such that the
                        requested operation can proceed.</p></li><li class="listitem"><p>A signal interrupts the <span class="emphasis"><em>semop()</em></span> call. In this case,
                        the error <code class="literal">EINTR</code> results. (As noted in
                            <a class="xref" href="ch21.html#interruption_and_restarting_of_system_ca" title="Interruption and Restarting of System Calls">Interruption and Restarting of System Calls</a>,
                            <span class="emphasis"><em>semop()</em></span> is never automatically restarted after
                        being interrupted by a signal handler.)</p></li><li class="listitem"><p>Another process deletes the semaphore referred to by
                            <span class="emphasis"><em>semid</em></span>. In this case, <span class="emphasis"><em>semop()</em></span>
                        fails with the error <code class="literal">EIDRM</code>.</p></li></ul></div><p>We can prevent <span class="emphasis"><em>semop()</em></span> from blocking when performing an
                operation on a particular semaphore by specifying the <code class="literal">IPC_NOWAIT</code> flag in the corresponding <span class="emphasis"><em>sem_flg</em></span>
                field. In this case, if <span class="emphasis"><em>semop()</em></span> would have blocked, it instead
                fails with the error <code class="literal">EAGAIN</code>.</p><p>While it is usual to operate on a single semaphore at a time, it is possible to
                make a <span class="emphasis"><em>semop()</em></span> call that performs operations on multiple
                semaphores in a set. The key point to note is that this group of operations is
                performed atomically; that is, <span class="emphasis"><em>semop()</em></span> either performs all of
                the operations immediately, if possible, or blocks until it would be possible to
                perform all of the operations simultaneously.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Few systems document the fact that <span class="emphasis"><em>semop()</em></span> performs
                    operations in array order, although all systems known to the author do so, and a
                    few applications depend on this behavior. SUSv4 adds text that explicitly
                    requires this behavior.</p></div><p><a class="xref" href="ch47.html#using_semop_open_parenthesis_close_paren" title="Example 47-7. Using semop() to perform operations on multiple System V semaphores">Example 47-7</a> demonstrates the use of
                    <span class="emphasis"><em>semop()</em></span> to perform operations on three semaphores in a set.
                The operations on semaphores 0 and 2 may not be able to proceed immediately,
                depending on the current values of the semaphores. If the operation on semaphore 0
                can’t be performed immediately, then none of the requested operations is performed,
                and <span class="emphasis"><em>semop()</em></span> blocks. On the other hand, if the operation on
                semaphore 0 could be performed immediately, but the operation on semaphore 2 could
                not, then—because the <code class="literal">IPC_NOWAIT</code> flag was
                specified—none of the requested operations is performed, and
                    <span class="emphasis"><em>semop()</em></span> returns immediately with the error <code class="literal">EAGAIN</code>.</p><p>The <span class="emphasis"><em>semtimedop()</em></span> system call performs the same task as
                    <span class="emphasis"><em>semop()</em></span>, except that the <span class="emphasis"><em>timeout</em></span>
                argument specifies an upper limit on the time for which the call will
                    block.<a id="IDX-CHP-47-6496" class="indexterm"/></p><a id="I_programlisting47_d1e125973"/><pre class="programlisting">#define _GNU_SOURCE
#include &lt;sys/types.h&gt;        /* For portability */
#include &lt;sys/sem.h&gt;

int <strong class="userinput"><code>semtimedop</code></strong>(int <span class="emphasis"><em>semid</em></span>, struct sembuf *<span class="emphasis"><em>sops</em></span>, unsigned int <span class="emphasis"><em>nsops</em></span>,
               struct timespec *<span class="emphasis"><em>timeout</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>timeout</em></span> argument is a pointer to a
                    <span class="emphasis"><em>timespec</em></span> structure (<a class="xref" href="ch23.html#high-resolution_sleeping_colon_nanosleep" title="High-Resolution Sleeping: nanosleep()">High-Resolution Sleeping: <span class="emphasis"><em>nanosleep()</em></span></a>), which allows a time
                interval to be expressed as a number of seconds and nanoseconds. If the specified
                time interval expires before it is possible to complete the semaphore operation,
                    <span class="emphasis"><em>semtimedop()</em></span> fails with the error <code class="literal">EAGAIN</code>. If <span class="emphasis"><em>timeout</em></span> is specified as <code class="literal">NULL</code>, <span class="emphasis"><em>semtimedop()</em></span> is exactly the
                same as <span class="emphasis"><em>semop()</em></span>.<a id="IDX-CHP-47-6497" class="indexterm"/></p><p>The <span class="emphasis"><em>semtimedop()</em></span> system call is provided as a more efficient
                method of setting a timeout on a semaphore operation than using
                    <span class="emphasis"><em>setitimer()</em></span> plus <span class="emphasis"><em>semop()</em></span>. The small
                performance benefit that this confers is significant for certain applications
                (notably, some database systems) that need to frequently perform such operations.
                However, <span class="emphasis"><em>semtimedop()</em></span> is not specified in SUSv3 and is present
                on only a few other UNIX implementations.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>semtimedop()</em></span> system call appeared as a new feature in
                    Linux 2.6 and was subsequently back-ported into Linux 2.4, starting with kernel
                    2.4.22.</p></div><div class="example"><a id="using_semop_open_parenthesis_close_paren"/><div class="example-title">Example 47-7. Using <span class="emphasis"><em>semop()</em></span> to perform operations on multiple System V
                    semaphores</div><div class="example-contents"><pre class="programlisting">struct sembuf sops[3];

   sops[0].sem_num = 0;                 /* Subtract 1 from semaphore 0 */
   sops[0].sem_op = -1;
   sops[0].sem_flg = 0;

   sops[1].sem_num = 1;                 /* Add 2 to semaphore 1 */
   sops[1].sem_op = 2;
   sops[1].sem_flg = 0;

   sops[2].sem_num = 2;                 /* Wait for semaphore 2 to equal 0 */
   sops[2].sem_op = 0;
   sops[2].sem_flg = IPC_NOWAIT;        /* But don't block if operation
                                           can't be performed immediately */
   if (semop(semid, sops, 3) == -1) {
       if (errno == EAGAIN)             /* Semaphore 2 would have blocked */
           printf("Operation would have blocked\n");
       else
           errExit("semop");            /* Some other error */
   }</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="example_program-id63"/></div></div></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id64">Example program</h4></div></div></div><p>The program in <a class="xref" href="ch47.html#performing_system_v_semaphore_operations" title="Example 47-8. Performing System V semaphore operations with semop()">Example 47-8</a>
                        provides a command-line interface to the <span class="emphasis"><em>semop()</em></span> system
                        call. The first argument to this program is the identifier of the semaphore
                        set upon which operations are to be performed.<a id="IDX-CHP-47-6498" class="indexterm"/><a id="IDX-CHP-47-6499" class="indexterm"/><a id="IDX-CHP-47-6500" class="indexterm"/><a id="IDX-CHP-47-6501" class="indexterm"/><a id="IDX-CHP-47-6502" class="indexterm"/><a id="IDX-CHP-47-6503" class="indexterm"/></p><p>Each of the remaining command-line arguments specifies a group of
                        semaphore operations to be performed in a single
                            <span class="emphasis"><em>semop()</em></span> call. The operations within a single
                        command-line argument are delimited by commas. Each operation has one of the
                        following forms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>semnum</em></span><code class="literal">+</code><span class="emphasis"><em>value</em></span>: add
                                    <span class="emphasis"><em>value</em></span> to semaphore
                                    <span class="emphasis"><em>semnum</em></span>.</p></li><li class="listitem"><p><span class="emphasis"><em>semnum</em></span><code class="literal">-</code><span class="emphasis"><em>value</em></span>: subtract
                                    <span class="emphasis"><em>value</em></span> from semaphore
                                    <span class="emphasis"><em>semnum</em></span>.</p></li><li class="listitem"><p><span class="emphasis"><em>semnum</em></span><code class="literal">=0</code>:
                                test semaphore <span class="emphasis"><em>semnum</em></span> to see if it equals
                                0.</p></li></ul></div><p>At the end of each operation, we can optionally include an
                            <span class="emphasis"><em>n</em></span>, a <span class="emphasis"><em>u</em></span>, or both. The letter
                            <span class="emphasis"><em>n</em></span> means include <code class="literal">IPC_NOWAIT</code> in the <span class="emphasis"><em>sem_flg</em></span> value for this
                        operation. The letter <span class="emphasis"><em>u</em></span> means include <code class="literal">SEM_UNDO</code> in <span class="emphasis"><em>sem_flg</em></span>. (We
                        describe the <code class="literal">SEM_UNDO</code> flag in Section
                        47.8.)</p><p>The following command line specifies two <span class="emphasis"><em>semop()</em></span>
                        calls on the semaphore set whose identifier is 0:</p><a id="I_programlisting47_d1e126191"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_op 0 0=0 0-1,1-2n</code></strong></pre><p>The first command-line argument specifies a <span class="emphasis"><em>semop()</em></span>
                        call that waits until semaphore zero equals 0. The second argument specifies
                        a <span class="emphasis"><em>semop()</em></span> call that subtracts 1 from semaphore 0, and
                        subtracts 2 from semaphore 1. For the operation on semaphore 0,
                            <span class="emphasis"><em>sem_flg</em></span> is 0; for the operation on semaphore 1,
                            <span class="emphasis"><em>sem_flg</em></span> is <code class="literal">IPC_NOWAIT</code>.</p><div class="example"><a id="performing_system_v_semaphore_operations"/><div class="example-title">Example 47-8. Performing System V semaphore operations with
                                <span class="emphasis"><em>semop()</em></span></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svsem/svsem_op.c</code></strong>
#include &lt;sys/types.h&gt;
#include &lt;sys/sem.h&gt;
#include &lt;ctype.h&gt;
#include "curr_time.h"          /* Declaration of currTime() */
#include "tlpi_hdr.h"

#define MAX_SEMOPS 1000         /* Maximum operations that we permit for
                                   a single semop() */

static void
usageError(const char *progName)
{
    fprintf(stderr, "Usage: %s semid op[,op...] ...\n\n", progName);
    fprintf(stderr, "'op' is either: &lt;sem#&gt;{+|-}&lt;value&gt;[n][u]\n");
    fprintf(stderr, "            or: &lt;sem#&gt;=0[n]\n");
    fprintf(stderr, "       \"n\" means include IPC_NOWAIT in 'op'\n");
    fprintf(stderr, "       \"u\" means include SEM_UNDO in 'op'\n\n");
    fprintf(stderr, "The operations in each argument are "
                    "performed in a single semop() call\n\n");
    fprintf(stderr, "e.g.: %s 12345 0+1,1-2un\n", progName);
    fprintf(stderr, "      %s 12345 0=0n 1+1,2-1u 1=0\n", progName);
    exit(EXIT_FAILURE);
}

/* Parse comma-delimited operations in 'arg', returning them in the
   array 'sops'. Return number of operations as function result. */

static int
parseOps(char *arg, struct sembuf sops[])
{
    char *comma, *sign, *remaining, *flags;
    int numOps;                 /* Number of operations in 'arg' */

    for (numOps = 0, remaining = arg; ; numOps++) {
        if (numOps &gt;= MAX_SEMOPS)
            cmdLineErr("Too many operations (maximum=%d): \"%s\"\n",
                        MAX_SEMOPS, arg);

        if (*remaining == '\0')
            fatal("Trailing comma or empty argument: \"%s\"", arg);
        if (!isdigit((unsigned char) *remaining))
            cmdLineErr("Expected initial digit: \"%s\"\n", arg);

        sops[numOps].sem_num = strtol(remaining, &amp;sign, 10);

        if (*sign == '\0' || strchr("+-=", *sign) == NULL)
            cmdLineErr("Expected '+', '-', or '=' in \"%s\"\n", arg);
        if (!isdigit((unsigned char) *(sign + 1)))
            cmdLineErr("Expected digit after '%c' in \"%s\"\n", *sign, arg);

        sops[numOps].sem_op = strtol(sign + 1, &amp;flags, 10);

        if (*sign == '-')                       /* Reverse sign of operation */
            sops[numOps].sem_op = - sops[numOps].sem_op;
        else if (*sign == '=')                  /* Should be '=0' */
            if (sops[numOps].sem_op != 0)
                cmdLineErr("Expected \"=0\" in \"%s\"\n", arg);

        sops[numOps].sem_flg = 0;
        for (;; flags++) {
            if (*flags == 'n')
                sops[numOps].sem_flg |= IPC_NOWAIT;
            else if (*flags == 'u')
                sops[numOps].sem_flg |= SEM_UNDO;
            else
                break;
        }

        if (*flags != ',' &amp;&amp; *flags != '\0')
            cmdLineErr("Bad trailing character (%c) in \"%s\"\n", *flags, arg);

        comma = strchr(remaining, ',');
        if (comma == NULL)
            break;                              /* No comma --&gt; no more ops */
        else
            remaining = comma + 1;
    }

    return numOps + 1;
}

int
main(int argc, char *argv[])
{
    struct sembuf sops[MAX_SEMOPS];
    int ind, nsops;

    if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)
        usageError(argv[0]);

    for (ind = 2; argv[ind] != NULL; ind++) {
        nsops = parseOps(argv[ind], sops);

        printf("%5ld, %s: about to semop()  [%s]\n", (long) getpid(),
                currTime("%T"), argv[ind]);

        if (semop(getInt(argv[1], 0, "semid"), sops, nsops) == -1)
            errExit("semop (PID=%ld)", (long) getpid());

        printf("%5ld, %s: semop() completed [%s]\n", (long) getpid(),
                currTime("%T"), argv[ind]);
    }

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>svsem/svsem_op.c</code></strong></pre></div></div><p>Using the program in <a class="xref" href="ch47.html#performing_system_v_semaphore_operations" title="Example 47-8. Performing System V semaphore operations with semop()">Example 47-8</a>, along with various
                        others shown in this chapter, we can study the operation of System V
                        semaphores, as demonstrated in the following shell session. We begin by
                        using a program that creates a semaphore set containing two semaphores,
                        which we initialize to 1 and 0:</p><a id="I_programlisting47_d1e126227"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_create -p 2</code></strong>
32769                                               <em class="lineannotation"><span class="lineannotation">ID of semaphore set</span></em>
$ <strong class="userinput"><code>./svsem_setall 32769 1 0</code></strong>
Semaphore values changed (PID=3658)</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>We don’t show the code of the <code class="literal">svsem/svsem_create.c</code> program in this chapter, but it is
                            provided in the source code distribution for this book. This program
                            performs the same function for semaphores as the program in <a class="xref" href="ch46.html#using_msgget_open_parenthesis_close_pare" title="Example 46-1. Using msgget()">Example 46-1</a> (in <a class="xref" href="ch46.html#creating_or_opening_a_message_queue" title="Creating or Opening a Message Queue">Creating or Opening a Message Queue</a>) performs for
                            message queues; that is, it creates a semaphore set. The only notable
                            difference is that <code class="literal">svsem_create.c</code>
                            takes an additional argument specifying the size of the semaphore set to
                            be created.<a id="IDX-CHP-47-6504" class="indexterm"/></p></div><p>Next, we start three background instances of the program in <a class="xref" href="ch47.html#performing_system_v_semaphore_operations" title="Example 47-8. Performing System V semaphore operations with semop()">Example 47-8</a> to perform
                            <span class="emphasis"><em>semop()</em></span> operations on the semaphore set. The
                        program prints messages before and after each semaphore operation. These
                        messages include the time, so that we can see when each operation starts and
                        when it completes, and the process ID, so that we can track the operation of
                        multiple instances of the program. The first command makes a request to
                        decrease both semaphores by 1:</p><a id="I_programlisting47_d1e126263"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_op 32769 0-1,1-1 &amp;</code></strong>                        <em class="lineannotation"><span class="lineannotation">Operation 1</span></em>
 3659, 16:02:05: about to semop()  [0-1,1-1]
[1] 3659</pre><p>In the above output, we see that the program printed a message saying that
                        the <span class="emphasis"><em>semop()</em></span> operation is about to be performed, but did
                        not print any further messages, because the <span class="emphasis"><em>semop()</em></span>
                        call blocks. The call blocks because semaphore 1 has the value 0.</p><p>Next, we execute a command that makes a request to decrease semaphore 1 by
                        1:</p><a id="I_programlisting47_d1e126281"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_op 32769 1-1 &amp;</code></strong>                            <em class="lineannotation"><span class="lineannotation">Operation 2</span></em>
 3660, 16:02:22: about to semop()  [1-1]
[2] 3660</pre><p>This command also blocks. Next, we execute a command that waits for the
                        value of semaphore 0 to equal 0:</p><a id="I_programlisting47_d1e126291"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_op 32769 0=0 &amp;</code></strong>                            <em class="lineannotation"><span class="lineannotation">Operation 3</span></em>
 3661, 16:02:27: about to semop()  [0=0]
[3] 3661</pre><p>Again, this command blocks, in this case because the value of semaphore 0
                        is currently 1.</p><p>Now, we use the program in <a class="xref" href="ch47.html#a_semaphore_monitoring_program" title="Example 47-3. A semaphore monitoring program">Example 47-3</a> to inspect the semaphore set:</p><a id="I_programlisting47_d1e126305"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_mon 32769</code></strong>
Semaphore changed: Sun Jul 25 16:01:53 2010
Last semop():      Thu Jan  1 01:00:00 1970
Sem #  Value  SEMPID  SEMNCNT  SEMZCNT
  0       1       0      1        1
  1       0       0      2        0</pre><p>When a semaphore set is created, the <span class="emphasis"><em>sem_otime</em></span> field
                        of the associated <span class="emphasis"><em>semid_ds</em></span> data structure is
                        initialized to 0. A calendar time value of 0 corresponds to the Epoch (<a class="xref" href="ch10.html#calendar_time" title="Calendar Time">Calendar Time</a>), and <span class="emphasis"><em>ctime()</em></span> displays
                        this as 1 AM, 1 January 1970, since the local timezone is Central Europe,
                        one hour ahead of UTC.</p><p>Examining the output further, we can see that, for semaphore 0, the
                            <span class="emphasis"><em>semncnt</em></span> value is 1 because operation 1 is waiting
                        to decrease the semaphore value, and <span class="emphasis"><em>semzcnt</em></span> is 1
                        because operation 3 is waiting for this semaphore to equal 0. For semaphore
                        1, the semncnt value of 2 reflects the fact that operation 1 and operation 2
                        are waiting to decrease the semaphore value.<a id="IDX-CHP-47-6505" class="indexterm"/></p><p>Next, we try a nonblocking operation on the semaphore set. This operation
                        waits for semaphore 0 to equal 0. Since this operation can’t be immediately
                        performed, <span class="emphasis"><em>semop()</em></span> fails with the error <code class="literal">EAGAIN</code>:</p><a id="I_programlisting47_d1e126345"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_op 32769 0=0n</code></strong>                             <em class="lineannotation"><span class="lineannotation">Operation 4</span></em>
 3673, 16:03:13: about to semop()  [0=0n]
ERROR [EAGAIN/EWOULDBLOCK Resource temporarily unavailable] semop (PID=3673)</pre><p>Now we add 1 to semaphore 1. This causes two of the earlier blocked
                        operations (1 and 3) to unblock:</p><a id="I_programlisting47_d1e126355"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_op 32769 1+1</code></strong>                              <em class="lineannotation"><span class="lineannotation">Operation 5</span></em>
 3674, 16:03:29: about to semop()  [1+1]
 3659, 16:03:29: semop() completed [0-1,1-1]        <em class="lineannotation"><span class="lineannotation">Operation 1 completes</span></em>
 3661, 16:03:29: semop() completed [0=0]            <em class="lineannotation"><span class="lineannotation">Operation 3 completes</span></em>
 3674, 16:03:29: semop() completed [1+1]            <em class="lineannotation"><span class="lineannotation">Operation 5 completes</span></em>
[1]   Done              ./svsem_op 32769 0-1,1-1
[3]+  Done              ./svsem_op 32769 0=0</pre><p>When we use our monitoring program to inspect the state of the semaphore
                        set, we see that the <span class="emphasis"><em>sem_otime</em></span> field of the associated
                            <span class="emphasis"><em>semid_ds</em></span> data structure has been updated, and the
                            <span class="emphasis"><em>sempid</em></span> values of both semaphores have been updated.
                        We also see that the <span class="emphasis"><em>semncnt</em></span> value for semaphore 1 is
                        1, since operation 2 is still blocked, waiting to decrease the value of this
                        semaphore:</p><a id="I_programlisting47_d1e126386"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_mon 32769</code></strong>
Semaphore changed: Sun Jul 25 16:01:53 2010
Last semop():      Sun Jul 25 16:03:29 2010
Sem #  Value  SEMPID  SEMNCNT  SEMZCNT
  0       0    3661      0        0
  1       0    3659      1        0</pre><p>From the above output, we see that the <span class="emphasis"><em>sem_otime</em></span>
                        value has been updated. We also see that semaphore 0 was last operated on by
                        process ID 3661 (operation 3) and semaphore 1 was last operated on by
                        process ID 3659 (operation 1).</p><p>Finally, we remove the semaphore set. This causes the still blocked
                        operation 2 to fail with the error <code class="literal">EIDRM</code>:</p><a id="I_programlisting47_d1e126401"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_rm 32769</code></strong>
ERROR [EIDRM Identifier removed] semop (PID=3660)</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>We don’t show the source code for the <code class="literal">svsem/svsem_rm.c</code> program in this chapter, but it is
                            provided in the source code distribution for this book. This program
                            removes the semaphore set identified by its command-line
                            argument.</p></div></div></div></div><div class="sect1" title="Handling of Multiple Blocked Semaphore Operations"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="handling_of_multiple_blocked_semaphore_o">Handling of Multiple Blocked Semaphore Operations</h2></div></div></div><p>If multiple processes are blocked trying to decrease the value of a semaphore by
                the same amount, then it is indeterminate which process will be permitted to perform
                the operation first when it becomes possible (i.e., which process is able to perform
                the operation will depend on vagaries of the kernel process scheduling
                algorithm).</p><p>On the other hand, if processes are blocked trying to decrease a semaphore value
                by different amounts, then the requests are served in the order in which they become
                possible. Suppose that a semaphore currently has the value 0, and process A requests
                to decrease the semaphore’s value by 2, and then process B requests to decrease the
                value by 1. If a third process then adds 1 to the semaphore, process B would be the
                first to unblock and perform its operation, even though process A was the first to
                request an operation against the semaphore. In poorly designed applications, such
                scenarios can lead to <span class="emphasis"><em>starvation</em></span>, whereby a process remains
                blocked forever because the state of the semaphore is never such that the requested
                operation proceeds. Continuing our example, we can envisage scenarios where multiple
                processes adjust the semaphore in such a way that its value is never more than 1,
                with the result that process A remains blocked forever.<a id="IDX-CHP-47-6506" class="indexterm"/></p><p>Starvation can also occur if a process is blocked trying to perform operations on
                multiple semaphores. Consider the following scenario, performed on a pair of
                semaphores, both of which initially have the value 0:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Process A makes a request to subtract 1 from semaphores 0 and 1
                            (<span class="emphasis"><em>blocks</em></span>).</p></li><li class="listitem"><p>Process B makes a request to subtract 1 from semaphore 0
                            (<span class="emphasis"><em>blocks</em></span>).</p></li><li class="listitem"><p>Process C adds 1 to semaphore 0.</p></li></ol></div><p>At this point, process B unblocks and completes its request, even though it placed
                its request later than process A. Again, it is possible to devise scenarios in which
                process A is starved while other processes adjust and block on the values of the
                individual semaphores.</p></div><div class="sect1" title="Semaphore Undo Values"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="semaphore_undo_values">Semaphore Undo Values</h2></div></div></div><p>Suppose that, having adjusted the value of a semaphore (e.g., decreased the
                semaphore value so that it is now 0), a process then terminates, either deliberately
                or accidentally. By default, the semaphore’s value is left unchanged. This may
                constitute a problem for other processes using the semaphore, since they may be
                blocked waiting on that semaphore—that is, waiting for the now-terminated process to
                undo the change it made.<a id="IDX-CHP-47-6507" class="indexterm"/><a id="IDX-CHP-47-6508" class="indexterm"/><a id="IDX-CHP-47-6509" class="indexterm"/><a id="IDX-CHP-47-6510" class="indexterm"/><a id="IDX-CHP-47-6511" class="indexterm"/></p><p>To avoid such problems, we can employ the <code class="literal">SEM_UNDO</code> flag when changing the value of a semaphore via
                    <span class="emphasis"><em>semop()</em></span>. When this flag is specified, the kernel records
                the effect of the semaphore operation, and then undoes the operation if the process
                terminates. The undo happens regardless of whether the process terminates normally
                or abnormally.</p><p>The kernel doesn’t need to keep a record of all operations performed using
                    <code class="literal">SEM_UNDO</code>. It suffices to record the
                    <span class="emphasis"><em>sum</em></span> of all of the semaphore adjustments performed using
                    <code class="literal">SEM_UNDO</code> in a per-semaphore, per-process
                integer total called the <span class="emphasis"><em>semadj</em></span> (semaphore adjustment) value.
                When the process terminates, all that is necessary is to subtract this total from
                the semaphore’s current value.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Since Linux 2.6, processes (threads) created using
                        <span class="emphasis"><em>clone()</em></span> share <span class="emphasis"><em>semadj</em></span> values if the
                        <code class="literal">CLONE_SYSVSEM</code> flag is employed. Such
                    sharing is required for a conforming implementation of POSIX threads. The NPTL
                    threading implementation employs <code class="literal">CLONE_SYSVSEM</code> for the implementation of
                        <span class="emphasis"><em>pthread_create()</em></span>.<a id="IDX-CHP-47-6512" class="indexterm"/></p></div><p>When a semaphore value is set using the <span class="emphasis"><em>semctl()</em></span>
                <code class="literal">SETVAL</code> or <code class="literal">SETALL</code> operation, the corresponding <span class="emphasis"><em>semadj</em></span>
                values are cleared (i.e., set to 0) in all processes using the semaphore. This makes
                sense, since absolutely setting the value of a semaphore destroys the value
                associated with the historical record maintained in the <span class="emphasis"><em>semadj</em></span>
                total.</p><p>A child created via <span class="emphasis"><em>fork()</em></span> doesn’t inherit its parent’s
                    <span class="emphasis"><em>semadj</em></span> values; it doesn’t make sense for a child to undo
                its parent’s semaphore operations. On the other hand, <span class="emphasis"><em>semadj</em></span>
                values are preserved across an <span class="emphasis"><em>exec()</em></span>. This permits us to
                adjust a semaphore value using <code class="literal">SEM_UNDO</code>, and then
                    <span class="emphasis"><em>exec()</em></span> a program that performs no operation on the
                semaphore, but does automatically adjust the semaphore on process termination. (This
                can be used as a technique that allows another process to discover when this process
                terminates.)</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="example_of_the_effect_of_sem_under"/></div></div></div><div class="sect3" title="Example of the effect of SEM_UNDO"><div class="titlepage"><div><div><h4 class="title" id="example_of_the_effect_of_sem_under-id1">Example of the effect of <code class="literal">SEM_UNDO</code></h4></div></div></div><p>The following shell session log shows the effect of performing operations
                        on two semaphores: one operation with the <code class="literal">SEM_UNDO</code> flag and one without. We begin by creating a set
                        containing two semaphores:<a id="IDX-CHP-47-6513" class="indexterm"/><a id="IDX-CHP-47-6514" class="indexterm"/><a id="IDX-CHP-47-6515" class="indexterm"/><a id="IDX-CHP-47-6516" class="indexterm"/></p><a id="I_programlisting47_d1e126595"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_create -p 2</code></strong>
131073</pre><p>Next, we execute a command that adds 1 to both semaphores and then
                        terminates. The operation on semaphore 0 specifies the <code class="literal">SEM_UNDO</code> flag:</p><a id="I_programlisting47_d1e126605"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_op 131073 0+1u 1+1</code></strong>
 2248, 06:41:56: about to semop()
 2248, 06:41:56: semop() completed</pre><p>Now, we use the program in <a class="xref" href="ch47.html#a_semaphore_monitoring_program" title="Example 47-3. A semaphore monitoring program">Example 47-3</a> to check the state of the semaphores:</p><a id="I_programlisting47_d1e126614"/><pre class="programlisting">$ <strong class="userinput"><code>./svsem_mon 131073</code></strong>
Semaphore changed: Sun Jul 25 06:41:34 2010
Last semop():      Sun Jul 25 06:41:56 2010
Sem #  Value  SEMPID  SEMNCNT  SEMZCNT
  0       0    2248      0        0
  1       1    2248      0        0</pre><p>Looking at the semaphore values in the last two lines of the above output,
                        we can see that the operation on semaphore 0 was undone, but the operation
                        on semaphore 1 was not undone.</p></div><div class="sect3" title="Limitations of SEM_UNDO"><div class="titlepage"><div><div><h4 class="title" id="limitations_of_sem_underscore_undo">Limitations of <code class="literal">SEM_UNDO</code></h4></div></div></div><p>We conclude by noting that the <code class="literal">SEM_UNDO</code>
                        flag is less useful than it first appears, for two reasons. One is that
                        because modifying a semaphore typically corresponds to acquiring or
                        releasing some shared resource, the use of <code class="literal">SEM_UNDO</code> on its own may be insufficient to allow a
                        multiprocess application to recover in the event that a process unexpectedly
                        terminates. Unless process termination also automatically returns the shared
                        resource state to a consistent state (unlikely in many scenarios), undoing a
                        semaphore operation is probably insufficient to allow the application to
                        recover.</p><p>The second factor limiting the utility of <code class="literal">SEM_UNDO</code> is that, in some cases, it is not possible to
                        perform semaphore adjustments when a process terminates. Consider the
                        following scenario, applied to a semaphore whose initial value is 0:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Process A increases the value of a semaphore by 2, specifying the
                                    <code class="literal">SEM_UNDO</code> flag for the
                                operation.</p></li><li class="listitem"><p>Process B decreases the value of the semaphore by 1, so that it
                                has the value 1.</p></li><li class="listitem"><p>Process A terminates.</p></li></ol></div><p>At this point, it is impossible to completely undo the effect of process
                        A’s operation in step 1, since the value of the semaphore is too low. There
                        are three possible ways to resolve this situation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Force the process to block until the semaphore adjustment is
                                possible.</p></li><li class="listitem"><p>Decrease the semaphore value as far as possible (i.e., to 0) and
                                exit.</p></li><li class="listitem"><p>Exit without performing any semaphore adjustment.</p></li></ul></div><p>The first solution is infeasible since it might force a terminating
                        process to block forever. Linux adopts the second solution. Some other UNIX
                        implementations adopt the third solution. SUSv3 is silent on what an
                        implementation should do in this situation.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>An undo operation that attempts to raise a semaphore’s value above its
                            permitted maximum value of 32,767 (the <code class="literal">SEMVMX</code> limit, described <a class="xref" href="ch47.html#semaphore_limits" title="Semaphore Limits">Semaphore Limits</a>) also causes anomalous behavior. In this case, the kernel always
                            performs the adjustment, thus (illegitimately) raising the semaphore’s
                            value above <code class="literal">SEMVMX</code>.<a id="IDX-CHP-47-6517" class="indexterm"/></p></div></div></div></div><div class="sect1" title="Implementing a Binary Semaphores Protocol"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="implementing_a_binary_semaphores_protoco">Implementing a Binary Semaphores Protocol</h2></div></div></div><p>The API for System V semaphores is complex, both because semaphore values can be
                adjusted by arbitrary amounts, and because semaphores are allocated and operated
                upon in sets. Both of these features provide more functionality than is typically
                needed within applications, and so it is useful to implement some simpler protocols
                (APIs) on top of System V semaphores.<a id="IDX-CHP-47-6518" class="indexterm"/><a id="IDX-CHP-47-6519" class="indexterm"/><a id="IDX-CHP-47-6520" class="indexterm"/><a id="IDX-CHP-47-6521" class="indexterm"/><a id="IDX-CHP-47-6522" class="indexterm"/><a id="IDX-CHP-47-6523" class="indexterm"/><a id="IDX-CHP-47-6524" class="indexterm"/><a id="IDX-CHP-47-6525" class="indexterm"/><a id="IDX-CHP-47-6526" class="indexterm"/><a id="IDX-CHP-47-6527" class="indexterm"/><a id="IDX-CHP-47-6528" class="indexterm"/><a id="IDX-CHP-47-6529" class="indexterm"/><a id="IDX-CHP-47-6530" class="indexterm"/><a id="IDX-CHP-47-6531" class="indexterm"/></p><p>One commonly used protocol is binary semaphores. A binary semaphore has two
                values: <span class="emphasis"><em>available</em></span> (free) and <span class="emphasis"><em>reserved</em></span> (in
                use). Two operations are defined for binary semaphores:<a id="IDX-CHP-47-6532" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Reserve</em></span>: Attempt to reserve this semaphore for
                        exclusive use. If the semaphore is already reserved by another process, then
                        block until the semaphore is released.</p></li><li class="listitem"><p><span class="emphasis"><em>Release</em></span>: Free a currently reserved semaphore, so that
                        it can be reserved by another process.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In academic computer science, these two operations often go by the
                            names <span class="emphasis"><em>P</em></span> and <span class="emphasis"><em>V</em></span>, the first
                            letters of the Dutch terms for these operations. This nomenclature was
                            coined by the late Dutch computer scientist Edsger Dijkstra, who
                            produced much of the early theoretical work on semaphores. The terms
                                <span class="emphasis"><em>down</em></span> (decrement the semaphore) and
                                <span class="emphasis"><em>up</em></span> (increment the semaphore) are also used.
                            POSIX terms the two operations <span class="emphasis"><em>wait</em></span> and
                                <span class="emphasis"><em>post</em></span>.</p></div></li></ul></div><p>A third operation is also sometimes defined:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Reserve conditionally</em></span>: Make a nonblocking attempt to
                        reserve this semaphore for exclusive use. If the semaphore is already
                        reserved, then immediately return a status indicating that the semaphore is
                        unavailable.</p></li></ul></div><p>In implementing binary semaphores, we must choose how to represent the
                    <span class="emphasis"><em>available</em></span> and <span class="emphasis"><em>reserved</em></span> states, and how
                to implement the above operations. A moment’s reflection leads us to realize that
                the best way to represent the states is to use the value 1 for
                    <span class="emphasis"><em>free</em></span> and the value 0 for <span class="emphasis"><em>reserved</em></span>,
                with the <span class="emphasis"><em>reserve</em></span> and <span class="emphasis"><em>release</em></span> operations
                decrementing and incrementing the semaphore value by one.</p><p><a class="xref" href="ch47.html#header_file_for_binary_underscore_sems.c" title="Example 47-9. Header file for binary_sems.c">Example 47-9</a> and <a class="xref" href="ch47.html#implementing_binary_semaphores_using_sys" title="Example 47-10. Implementing binary semaphores using System V semaphores">Example 47-10</a> provide an implementation
                of binary semaphores using System V semaphores. As well as providing the prototypes
                of the functions in the implementation, the header file in <a class="xref" href="ch47.html#header_file_for_binary_underscore_sems.c" title="Example 47-9. Header file for binary_sems.c">Example 47-9</a> declares two global Boolean
                variables exposed by the implementation. The <span class="emphasis"><em>bsUseSemUndo</em></span>
                variable controls whether the implementation uses the <code class="literal">SEM_UNDO</code> flag in <span class="emphasis"><em>semop()</em></span> calls. The
                    <span class="emphasis"><em>bsRetryOnEintr</em></span> variable controls whether the implementation
                restarts <span class="emphasis"><em>semop()</em></span> calls that are interrupted by signals.</p><div class="example"><a id="header_file_for_binary_underscore_sems.c"/><div class="example-title">Example 47-9. Header file for <code class="literal">binary_sems.c</code></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svsem/binary_sems.h</code></strong>
#ifndef BINARY_SEMS_H           /* Prevent accidental double inclusion */
#define BINARY_SEMS_H

#include "tlpi_hdr.h"

/* Variables controlling operation of functions below */

extern Boolean bsUseSemUndo;            /* Use SEM_UNDO during semop()? */
extern Boolean bsRetryOnEintr;          /* Retry if semop() interrupted by
                                           signal handler? */

int initSemAvailable(int semId, int semNum);

int initSemInUse(int semId, int semNum);

int reserveSem(int semId, int semNum);

int releaseSem(int semId, int semNum);

#endif
     <strong class="userinput"><code>svsem/binary_sems.h</code></strong></pre></div></div><p><a class="xref" href="ch47.html#implementing_binary_semaphores_using_sys" title="Example 47-10. Implementing binary semaphores using System V semaphores">Example 47-10</a> shows the
                implementation of the binary semaphore functions. Each function in this
                implementation takes two arguments, which identify a semaphore set and the number of
                a semaphore within that set. (These functions don’t deal with the creation and
                deletion of semaphore sets; nor do they handle the race condition described in
                Section 47.5.) We employ these functions in the example programs shown in Section
                48.4.</p><div class="example"><a id="implementing_binary_semaphores_using_sys"/><div class="example-title">Example 47-10. Implementing binary semaphores using System V semaphores</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svsem/binary_sems.c</code></strong>
#include &lt;sys/types.h&gt;
#include &lt;sys/sem.h&gt;
#include "semun.h"                      /* Definition of semun union */
#include "binary_sems.h"

Boolean bsUseSemUndo = FALSE;
Boolean bsRetryOnEintr = TRUE;

int                     /* Initialize semaphore to 1 (i.e., "available") */
initSemAvailable(int semId, int semNum)
{
    union semun arg;

    arg.val = 1;
    return semctl(semId, semNum, SETVAL, arg);
}

int                     /* Initialize semaphore to 0 (i.e., "in use") */
initSemInUse(int semId, int semNum)
{
    union semun arg;

    arg.val = 0;
    return semctl(semId, semNum, SETVAL, arg);
}

/* Reserve semaphore (blocking), return 0 on success, or -1 with 'errno'
   set to EINTR if operation was interrupted by a signal handler */

int                     /* Reserve semaphore - decrement it by 1 */
reserveSem(int semId, int semNum)
{
    struct sembuf sops;

    sops.sem_num = semNum;
    sops.sem_op = -1;
    sops.sem_flg = bsUseSemUndo ? SEM_UNDO : 0;

    while (semop(semId, &amp;sops, 1) == -1)
        if (errno != EINTR || !bsRetryOnEintr)
            return -1;

    return 0;
}

int                     /* Release semaphore - increment it by 1 */
releaseSem(int semId, int semNum)
{
    struct sembuf sops;

    sops.sem_num = semNum;
    sops.sem_op = 1;
    sops.sem_flg = bsUseSemUndo ? SEM_UNDO : 0;

    return semop(semId, &amp;sops, 1);
}
     <strong class="userinput"><code>svsem/binary_sems.c</code></strong></pre></div></div></div><div class="sect1" title="Semaphore Limits"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="semaphore_limits">Semaphore Limits</h2></div></div></div><p>Most UNIX implementations impose various limits on the operation of System V
                semaphores. The following is a list of the Linux semaphore limits. The system call
                affected by the limit and the error that results if the limit is reached are noted
                in parentheses.<a id="IDX-CHP-47-6533" class="indexterm"/><a id="IDX-CHP-47-6534" class="indexterm"/><a id="IDX-CHP-47-6535" class="indexterm"/><a id="IDX-CHP-47-6536" class="indexterm"/><a id="IDX-CHP-47-6537" class="indexterm"/><a id="IDX-CHP-47-6538" class="indexterm"/><a id="IDX-CHP-47-6539" class="indexterm"/><a id="IDX-CHP-47-6540" class="indexterm"/><a id="IDX-CHP-47-6541" class="indexterm"/><a id="IDX-CHP-47-6542" class="indexterm"/><a id="IDX-CHP-47-6543" class="indexterm"/><a id="IDX-CHP-47-6544" class="indexterm"/><a id="IDX-CHP-47-6545" class="indexterm"/><a id="IDX-CHP-47-6546" class="indexterm"/><a id="IDX-CHP-47-6547" class="indexterm"/><a id="IDX-CHP-47-6548" class="indexterm"/><a id="IDX-CHP-47-6549" class="indexterm"/><a id="IDX-CHP-47-6550" class="indexterm"/><a id="IDX-CHP-47-6551" class="indexterm"/><a id="IDX-CHP-47-6552" class="indexterm"/><a id="IDX-CHP-47-6553" class="indexterm"/><a id="IDX-CHP-47-6554" class="indexterm"/><a id="IDX-CHP-47-6555" class="indexterm"/><a id="IDX-CHP-47-6556" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term">
                        <code class="literal">SEMAEM</code>
                    </span></dt><dd><p>This is the maximum value that can be recorded in a
                                <span class="emphasis"><em>semadj</em></span> total. <code class="literal">SEMAEM</code> is defined to have the same value as <code class="literal">SEMVMX</code> (described below).
                                (<span class="emphasis"><em>semop()</em></span>, <code class="literal">ERANGE</code>)<a id="IDX-CHP-47-6557" class="indexterm"/></p></dd><dt><span class="term">
                        <code class="literal">SEMMNI</code>
                    </span></dt><dd><p>This is a system-wide limit on the number of semaphore identifiers (in
                            other words, semaphore sets) that can be created.
                                (<span class="emphasis"><em>semget()</em></span>, <code class="literal">ENOSPC</code>)<a id="IDX-CHP-47-6558" class="indexterm"/></p></dd><dt><span class="term">
                        <code class="literal">SEMMSL</code>
                    </span></dt><dd><p>This is the maximum number of semaphores that can be allocated in a
                            semaphore set. (<span class="emphasis"><em>semget()</em></span>, <code class="literal">EINVAL</code>)</p></dd><dt><span class="term">
                        <code class="literal">SEMMNS</code>
                    </span></dt><dd><p>This is a system-wide limit on the number of semaphores in all
                            semaphore sets. The number of semaphores on the system is also limited
                            by <code class="literal">SEMMNI</code> and <code class="literal">SEMMSL</code>; in fact, the default value for
                                <code class="literal">SEMMNS</code> is the product of the
                            defaults for these two limits. (<span class="emphasis"><em>semget()</em></span>, <code class="literal">ENOSPC</code>)</p></dd><dt><span class="term">
                        <code class="literal">SEMOPM</code>
                    </span></dt><dd><p>This is the maximum number of operations per
                                <span class="emphasis"><em>semop()</em></span> call. (<span class="emphasis"><em>semop()</em></span>,
                                <code class="literal">E2BIG</code>)</p></dd><dt><span class="term">
                        <code class="literal">SEMVMX</code>
                    </span></dt><dd><p>This is the maximum value for a semaphore.
                                (<span class="emphasis"><em>semop()</em></span>, <code class="literal">ERANGE</code>)</p></dd></dl></div><p>The limits above appear on most UNIX implementations. Some UNIX implementations
                (but not Linux) impose the following additional limits relating to semaphore undo
                operations (<a class="xref" href="ch47.html#semaphore_undo_values" title="Semaphore Undo Values">Semaphore Undo Values</a>):</p><div class="variablelist"><dl><dt><span class="term">
                        <code class="literal">SEMMNU</code>
                    </span></dt><dd><p>This is a system-wide limit on the total number of semaphore undo
                            structures. Undo structures are allocated to store
                                <span class="emphasis"><em>semadj</em></span> values.</p></dd><dt><span class="term">
                        <code class="literal">SEMUME</code>
                    </span></dt><dd><p>This is the maximum number of undo entries per semaphore undo
                            structure.</p></dd></dl></div><p>At system startup, the semaphore limits are set to default values. These defaults
                may vary across kernel versions. (Some distributors’ kernels set different defaults
                from those provided by vanilla kernels.) Some of these limits can be modified by
                changing the values stored in the Linux-specific <code class="literal">/proc/sys/kernel/sem</code> file. This file contains four space-delimited
                numbers defining, in order, the limits <code class="literal">SEMMSL</code>,
                    <code class="literal">SEMMNS</code>, <code class="literal">SEMOPM</code>, and <code class="literal">SEMMNI</code>. (The <code class="literal">SEMVMX</code> and <code class="literal">SEMAEM</code>
                limits can’t be changed; both are fixed at 32,767.) As an example, here are the
                default limits that we see for Linux 2.6.31 on one x86-32 system:<a id="IDX-CHP-47-6559" class="indexterm"/></p><a id="I_programlisting47_d1e127178"/><pre class="programlisting">$ <strong class="userinput"><code>cd /proc/sys/kernel</code></strong>
$ <strong class="userinput"><code>cat sem</code></strong>
250     32000   32      128</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>The formats employed in the Linux <code class="literal">/proc</code>
                    file system are inconsistent for the three System V IPC mechanisms. For message
                    queues and shared memory, each configurable limit is controlled by a separate
                    file. For semaphores, one file holds all configurable limits. This is a
                    historical accident that occurred during the development of these APIs and is
                    difficult to rectify for compatibility reasons.</p></div><p><a class="xref" href="ch47.html#system_v_semaphore_limits" title="Table 47-1. System V semaphore limits">Table 47-1</a> shows the maximum value to which each
                limit can be raised on the x86-32 architecture. Note the following supplementary
                information to this table:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>It is possible to raise <code class="literal">SEMMSL</code> to
                        values larger than 65,536, and create semaphore sets up to that larger size.
                        However, it isn’t possible to use <span class="emphasis"><em>semop()</em></span> to adjust
                        semaphores in the set beyond the 65,536th element.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Because of certain limitations in the current implementation, the
                            practical recommended upper limit on the size of a semaphore set is
                            around 8000.</p></div></li><li class="listitem"><p>The practical ceiling for the <code class="literal">SEMMNS</code>
                        limit is governed by the amount of RAM available on the system.<a id="IDX-CHP-47-6560" class="indexterm"/></p></li><li class="listitem"><p>The ceiling value for the <code class="literal">SEMOPM</code> limit
                        is determined by memory allocation primitives used within the kernel. The
                        recommended maximum is 1000. In practical usage, it is rarely useful to
                        perform more than a few operations in a single <span class="emphasis"><em>semop()</em></span>
                            call.<a id="IDX-CHP-47-6561" class="indexterm"/></p></li></ul></div><div class="table"><a id="system_v_semaphore_limits"/><div class="table-title">Table 47-1. System V semaphore limits</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Limit</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                <p>Ceiling value (x86-32)</p>
                            </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">SEMMNI</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">32768 (IPCMNI)</code>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">SEMMSL</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">65536</code>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">SEMMNS</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">2147483647 (INT_MAX)</code>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">SEMOPM</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; ">
                                <p>See text</p>
                            </td></tr></tbody></table></div></div><p>The Linux-specific <span class="emphasis"><em>semctl()</em></span>
                <code class="literal">IPC_INFO</code> operation retrieves a structure of type
                    <span class="emphasis"><em>seminfo</em></span>, which contains the values of the various semaphore
                limits:</p><a id="I_programlisting47_d1e127295"/><pre class="programlisting">union semun arg;
struct seminfo buf;

arg.__buf = &amp;buf;
semctl(0, 0, IPC_INFO, arg);</pre><p>A related Linux-specific operation, <code class="literal">SEM_INFO</code>,
                retrieves a <span class="emphasis"><em>seminfo</em></span> structure that contains information about
                actual resources used for semaphore objects. An example of the use of <code class="literal">SEM_INFO</code> is provided in the file <code class="literal">svsem/svsem_info.c</code> in the source code distribution for
                this book.<a id="IDX-CHP-47-6562" class="indexterm"/></p><p>Details about <code class="literal">IPC_INFO</code>, <code class="literal">SEM_INFO</code>, and the <span class="emphasis"><em>seminfo</em></span>
                structure can be found in the <span class="emphasis"><em>semctl(2)</em></span> manual page.</p></div><div class="sect1" title="Disadvantages of System V Semaphores"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="disadvantages_of_system_v_semaphores">Disadvantages of System V Semaphores</h2></div></div></div><p>System V semaphores have many of the same disadvantages as message queues (<a class="xref" href="ch46.html#disadvantages_of_system_v_message_queues" title="Disadvantages of System V Message Queues">Disadvantages of System V Message Queues</a>), including the
                    following:<a id="IDX-CHP-47-6563" class="indexterm"/><a id="IDX-CHP-47-6564" class="indexterm"/><a id="IDX-CHP-47-6565" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Semaphores are referred to by identifiers, rather than the file
                        descriptors used by most other UNIX I/O and IPC mechanisms. This makes it
                        difficult to perform operations such as simultaneously waiting both on a
                        semaphore and on input from a file descriptor. (It is possible to resolve
                        this difficulty by creating a child process or thread that operates on the
                        semaphore and writes messages to a pipe monitored, along with other file
                        descriptors, using one of the methods described in <a class="xref" href="ch63.html" title="Chapter 63. Alternative I/O Models">Chapter 63</a>.)</p></li><li class="listitem"><p>The use of keys, rather than filenames, to identify semaphores results in
                        additional programming complexity.</p></li><li class="listitem"><p>The use of separate system calls for creating and initializing semaphores
                        means that, in some cases, we must do extra programming work to avoid race
                        conditions when initializing a semaphore.</p></li><li class="listitem"><p>The kernel doesn’t maintain a count of the number of processes referring
                        to a semaphore set. This complicates the decision about when it is
                        appropriate to delete a semaphore set and makes it difficult to ensure that
                        an unused set is deleted.</p></li><li class="listitem"><p>The programming interface provided by System V is overly complex. In the
                        common case, a program operates on a single semaphore. The ability to
                        simultaneously operate on multiple semaphores in a set is
                        unnecessary.</p></li><li class="listitem"><p>There are various limits on the operation of semaphores. These limits are
                        configurable, but if an application operates outside the range of the
                        default limits, this nevertheless requires extra work when installing the
                        application.</p></li></ul></div><p>However, unlike the situation with message queues, there are fewer alternatives to
                System V semaphores, and consequently there are more situations in which we may
                choose to employ them. One alternative to the use of semaphores is record locking,
                which we describe in <a class="xref" href="ch55.html" title="Chapter 55. File Locking">Chapter 55</a>. Also, from kernel 2.6 onward,
                Linux supports the use of POSIX semaphores for process synchronization. We describe
                POSIX semaphores in <a class="xref" href="ch53.html" title="Chapter 53. POSIX Semaphores">Chapter 53</a>.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id46">Summary</h2></div></div></div><p>System V semaphores allow processes to synchronize their actions. This is useful
                when a process must gain exclusive access to some shared resource, such as a region
                of shared memory.</p><p>Semaphores are created and operated upon in sets containing one or more
                semaphores. Each semaphore within a set is an integer whose value is always greater
                than or equal to 0. The <span class="emphasis"><em>semop()</em></span> system call allows the caller
                to add an integer to a semaphore, subtract an integer from a semaphore, or wait for
                a semaphore to equal 0. The last two of these operations may cause the caller to
                block.</p><p>A semaphore implementation is not required to initialize the members of a new
                semaphore set, so an application must initialize the set after creating it. When any
                of a number of peer processes may try to create and initialize the semaphore,
                special care must be taken to avoid the race condition that results from the fact
                that these two steps are performed via separate system calls.</p><p>Where multiple processes are trying to decrease a semaphore by the same amount, it
                is indeterminate which process will actually be permitted to perform the operation
                first. However, where different processes are trying to decrease a semaphore by
                different amounts, the operations complete in the order in which they become
                possible, and we may need to take care to avoid scenarios where a process is starved
                because the semaphore value never reaches a level that would allow the process’s
                operation to proceed.</p><p>The <code class="literal">SEM_UNDO</code> flag allows a process’s semaphore
                operations to be automatically undone on process termination. This can be useful to
                avoid scenarios where a process accidentally terminates, leaving a semaphore in a
                state that causes other processes to block indefinitely waiting for the semaphore’s
                value to be changed by the terminated process.</p><p>System V semaphores are allocated and operated upon in sets, and can be increased
                and decreased by arbitrary amounts. This provides more functionality than is needed
                by most applications. A common requirement is for individual binary semaphores,
                which take on only the values 0 and 1. We showed how to implement binary semaphores
                on top of System V semaphores.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="further_information-id63"/></div></div></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id64">Further information</h4></div></div></div><p>[Bovet &amp; Cesati, 2005] and [Maxwell, 1999] provide some background
                        on the implementation of semaphores on Linux. [Dijkstra, 1968] is a classic
                        early paper on semaphore theory.<a id="IDX-CHP-47-6566" class="indexterm"/><a id="IDX-CHP-47-6567" class="indexterm"/><a id="IDX-CHP-47-6568" class="indexterm"/></p></div></div></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id32">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Experiment with the program in <a class="xref" href="ch47.html#performing_system_v_semaphore_operations" title="Example 47-8. Performing System V semaphore operations with semop()">Example 47-8</a> (<code class="literal">svsem_op.c</code>) to confirm your understanding of
                        the <span class="emphasis"><em>semop()</em></span> system call.</p></li><li class="listitem"><p>Modify the program in <a class="xref" href="ch24.html#using_signals_to_synchronize_process_act" title="Example 24-6. Using signals to synchronize process actions">Example 24-6</a> (<code class="literal">fork_sig_sync.c</code>, in <a class="xref" href="ch24.html#avoiding_race_conditions_by_synchronizin" title="Avoiding Race Conditions by Synchronizing with Signals">Avoiding Race Conditions by Synchronizing with Signals</a>) to use semaphores
                        instead of signals to synchronize the parent and child processes.</p></li><li class="listitem"><p>Experiment with the program in <a class="xref" href="ch47.html#performing_system_v_semaphore_operations" title="Example 47-8. Performing System V semaphore operations with semop()">Example 47-8</a> (<code class="literal">svsem_op.c</code>) and the other semaphore programs
                        provided in this chapter to see what happens to the
                            <span class="emphasis"><em>sempid</em></span> value if an exiting process performs a
                            <code class="literal">SEM_UNDO</code> adjustment to a
                        semaphore.</p></li><li class="listitem"><p>Add a <span class="emphasis"><em>reserveSemNB()</em></span> function to the code in <a class="xref" href="ch47.html#implementing_binary_semaphores_using_sys" title="Example 47-10. Implementing binary semaphores using System V semaphores">Example 47-10</a> (<code class="literal">binary_sems.c</code>) to implement the
                            <span class="emphasis"><em>reserve conditionally</em></span> operation, using the <code class="literal">IPC_NOWAIT</code> flag.</p></li><li class="listitem"><p>For the VMS operating system, Digital provided a synchronization method
                        similar to a binary semaphore, called an <span class="emphasis"><em>event flag</em></span>. An
                        event flag has two possible values, <span class="emphasis"><em>clear</em></span> and
                            <span class="emphasis"><em>set</em></span>, and the following four operations can be
                        performed: <span class="emphasis"><em>setEventFlag</em></span>, to set the flag;
                            <span class="emphasis"><em>clearEventFlag</em></span>, to clear the flag;
                            <span class="emphasis"><em>waitForEventFlag</em></span>, to block until the flag is set;
                        and <span class="emphasis"><em>getFlagState</em></span>, to obtain the current state of the
                        flag. Devise an implementation of event flags using System V semaphores.
                        This implementation will require two arguments for each of the functions
                        above: a semaphore identifier and a semaphore number. (Consideration of the
                            <span class="emphasis"><em>waitForEventFlag</em></span> operation will lead you to realize
                        that the values chosen for <span class="emphasis"><em>clear</em></span> and
                            <span class="emphasis"><em>set</em></span> are not the obvious choices.)</p></li><li class="listitem"><p>Implement a binary semaphores protocol using named pipes. Provide
                        functions to reserve, release, and conditionally reserve the
                        semaphore.</p></li><li class="listitem"><p>Write a program, analogous to the program in <a class="xref" href="ch46.html#displaying_all_system_v_message_queues_o" title="Example 46-6. Displaying all System V message queues on the system">Example 46-6</a> (<code class="literal">svmsg_ls.c</code>, in <a class="xref" href="ch46.html#client-server_programming_with_message_q" title="Client-Server Programming with Message Queues">Client-Server Programming with Message Queues</a>), that uses the
                            <span class="emphasis"><em>semctl()</em></span>
                        <code class="literal">SEM_INFO</code> and <code class="literal">SEM_STAT</code> operations to obtain and display a list of all
                        semaphore sets on the system.</p></li></ol></div></div></section></body></html>
