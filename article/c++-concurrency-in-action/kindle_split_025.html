<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mbp="Kindle">
  <head>
    <title>C++ Concurrency in Action, Second Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h2 class="part" id="app04">Appendix D. <a id="app04__title" class="calibre3"></a>C++ Thread Library reference
      </h2>
      
      
      
      
      <h3 id="app04lev1sec1" class="chapter"><a id="app04lev1sec1__title" class="calibre3"></a>D.1. The &lt;chrono&gt; header
      </h3>
      
      <p class="noind"><a id="iddle1086" class="calibre4"></a><a id="iddle1088" class="calibre4"></a><a id="iddle1102" class="calibre4"></a><a id="iddle1103" class="calibre4"></a><a id="iddle2036" class="calibre4"></a><a id="iddle2068" class="calibre4"></a><a id="iddle2235" class="calibre4"></a>The <kbd class="calibre17">&lt;chrono&gt;</kbd> header provides classes for representing points in time, <kbd class="calibre17">duration</kbd>s, and clock classes, which act as a source of <kbd class="calibre17">time_point</kbd>s. Each clock has an <kbd class="calibre17">is_steady</kbd> static data member, which indicates whether it’s a <i class="calibre6">steady</i> clock that advances at a uniform rate (and can’t be adjusted). The <kbd class="calibre17">std::chrono::steady_clock</kbd> class is the only clock guaranteed to be steady.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Header contents</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">namespace std
{
   namespace chrono
   {
       template&lt;typename Rep,typename Period = ratio&lt;1&gt;&gt;
       class duration;
       template&lt;
           typename Clock,
           typename Duration = typename Clock::duration&gt;
       class time_point;
       class system_clock;
       class steady_clock;
       typedef unspecified-clock-type high_resolution_clock;
   }
}</pre>
            </li>
         
      </ul>
      
      
      <h4 id="app04lev2sec1" class="calibre23">D.1.1. <a id="app04lev2sec1__title" class="calibre4"></a>std::chrono::duration class template
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::chrono::duration</kbd> class template provides a facility for representing durations. The template parameters <kbd class="calibre17">Rep</kbd> and <kbd class="calibre17">Period</kbd> are the data type to store the duration value and an instantiation of the <kbd class="calibre17">std::ratio</kbd> class template indicating the length of time (as a fraction of a second) between successive “ticks,” respectively. Thus <kbd class="calibre17">std::chrono::duration&lt;int, std::milli&gt;</kbd> is a count of milliseconds stored in a value of type <kbd class="calibre17">int</kbd>, whereas <kbd class="calibre17">std::chrono::duration&lt;short, std::ratio&lt;1,50&gt;&gt;</kbd> is a count of fiftieths of a second stored in a value of type <kbd class="calibre17">short</kbd>, and <kbd class="calibre17">std::chrono:: d-uration &lt;long long, std::ratio&lt;60,1&gt;&gt;</kbd> is a count of minutes stored in a value of type <kbd class="calibre17">long long</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class Rep, class Period=ratio&lt;1&gt; &gt;
class duration
{
public:
    typedef Rep rep;
    typedef Period period;

    constexpr duration() = default;
    ~duration() = default;

    duration(const duration&amp;) = default;
    duration&amp; operator=(const duration&amp;) = default;

    template &lt;class Rep2&gt;
    constexpr explicit duration(const Rep2&amp; r);

    template &lt;class Rep2, class Period2&gt;
    constexpr duration(const duration&lt;Rep2, Period2&gt;&amp; d);

    constexpr rep count() const;
    constexpr duration operator+() const;
    constexpr duration operator-() const;
    duration&amp; operator++();
    duration operator++(int);
    duration&amp; operator--();
    duration operator--(int);
    duration&amp; operator+=(const duration&amp; d);
    duration&amp; operator-=(const duration&amp; d);
    duration&amp; operator*=(const rep&amp; rhs);
    duration&amp; operator/=(const rep&amp; rhs);
    duration&amp; operator%=(const rep&amp; rhs);
    duration&amp; operator%=(const duration&amp; rhs);
    static constexpr duration zero();
    static constexpr duration min();
    static constexpr duration max();
};

template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator==(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);

template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator!=(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);

template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator&lt;(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);

template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator&lt;=(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);

template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator&gt;(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);

template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator&gt;=(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);

template &lt;class ToDuration, class Rep, class Period&gt;
constexpr ToDuration duration_cast(const duration&lt;Rep, Period&gt;&amp; d);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2039" class="calibre4"></a><a id="iddle2062" class="calibre4"></a><a id="iddle2063" class="calibre4"></a><i class="calibre6">Requirements</i>
            <kbd class="calibre17">Rep</kbd> must be a built-in numeric type, or a number-like user-defined type. <kbd class="calibre17">Period</kbd> must be an instantiation of <kbd class="calibre17">std::ratio&lt;&gt;</kbd>.
         </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec1"><a id="app04lev3sec1__title" class="calibre4"></a>std::chrono::duration::rep typedef
      </h5>
      
      <p class="noind">This is a typedef for the type used to hold the number of ticks in a <kbd class="calibre17">duration</kbd> value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">typedef Rep rep;</pre>
            
            <kbd class="calibre17">rep</kbd> is the type of value used to hold the internal representation of the <kbd class="calibre17">duration</kbd> object.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec2"><a id="app04lev3sec2__title" class="calibre4"></a>std::chrono::duration::period typedef
      </h5>
      
      <p class="noind">This typedef is for an instantiation of the <kbd class="calibre17">std::ratio</kbd> class template that specifies the fraction of a second represented by the duration count. For example, if <kbd class="calibre17">period</kbd> is <kbd class="calibre17">std::ratio&lt;1,50&gt;</kbd>, a <kbd class="calibre17">duration</kbd> value with a <kbd class="calibre17">count()</kbd> of <i class="calibre6">N</i> represents <i class="calibre6">N</i> fiftieths of a second.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">typedef Period period;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec3"><a id="app04lev3sec3__title" class="calibre4"></a>std::chrono::duration default constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::chrono::duration</kbd> instance with a default value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">constexpr duration() = default;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            The internal value of the <kbd class="calibre17">duration</kbd> (of type <kbd class="calibre17">rep</kbd>) is default initialized.
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec4"><a id="app04lev3sec4__title" class="calibre4"></a>std::chrono::duration converting constructor from a count value
      </h5>
      
      <p class="noind"><a id="iddle1214" class="calibre4"></a><a id="iddle1215" class="calibre4"></a><a id="iddle1222" class="calibre4"></a><a id="iddle2037" class="calibre4"></a><a id="iddle2038" class="calibre4"></a><a id="iddle2046" class="calibre4"></a><a id="iddle2047" class="calibre4"></a>Constructs an <kbd class="calibre17">std::chrono::duration</kbd> instance with a specified count.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class Rep2&gt;
constexpr explicit duration(const Rep2&amp; r);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            The internal value of the <kbd class="calibre17">duration</kbd> object is initialized with <kbd class="calibre17">static_cast&lt;rep&gt;(r)</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Requirements</i>
            This constructor only participates in overload resolution if <kbd class="calibre17">Rep2</kbd> is implicitly convertible to <kbd class="calibre17">Rep</kbd> and either <kbd class="calibre17">Rep</kbd> is a floating point type or <kbd class="calibre17">Rep2</kbd> is <i class="calibre6">not</i> a floating point type.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postcondition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;count()==static_cast&lt;rep&gt;(r)</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec5"><a id="app04lev3sec5__title" class="calibre4"></a>std::chrono::duration converting constructor from another std::ch- hrono::duration value
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::chrono::duration</kbd> instance by scaling the count value of another <kbd class="calibre17">std::chrono::duration</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class Rep2, class Period2&gt;
constexpr duration(const duration&lt;Rep2,Period2&gt;&amp; d);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            The internal value of the <kbd class="calibre17">duration</kbd> object is initialized with <kbd class="calibre17">duration_cast&lt;duration &lt;Rep,Period&gt;&gt;(d).count()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Requirements</i>
            This constructor only participates in overload resolution if <kbd class="calibre17">Rep</kbd> is a floating point type or <kbd class="calibre17">Rep2</kbd> is <i class="calibre6">not</i> a floating point type and <kbd class="calibre17">Period2</kbd> is a whole number multiple of <kbd class="calibre17">Period</kbd> (that is, <kbd class="calibre17">ratio_divide&lt;Period2,Period&gt;::den==1</kbd>). This avoids accidental truncation (and corresponding loss of precision) from storing a duration with small periods in a
            variable representing a duration with a longer period.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postcondition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;count()==duration_cast&lt;duration&lt;Rep,Period&gt;&gt;(d).count()</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Examples</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration&lt;int,ratio&lt;1,1000&gt;&gt; ms(5);       <b class="calibre24"><i class="calibre6">1</i></b>
duration&lt;int,ratio&lt;1,1&gt;&gt; s(ms);          <b class="calibre24"><i class="calibre6">2</i></b>
duration&lt;double,ratio&lt;1,1&gt;&gt; s2(ms);      <b class="calibre24"><i class="calibre6">3</i></b>
duration&lt;int,ratio&lt;1,1000000&gt;&gt; us(ms);   <b class="calibre24"><i class="calibre6">4</i></b></pre>
            
            <p class="calibre19"></p>
            <ul class="calibre30">
               
               <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Five milliseconds</b></li>
               
               <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> Error: can’t store ms as integral seconds</b></li>
               
               <li class="calibre22"><b class="calibre24"><i class="calibre6">3</i> OK: s2.count()==0.005</b></li>
               
               <li class="calibre22"><b class="calibre24"><i class="calibre6">4</i> OK: us.count()==5000</b></li>
               
            </ul>
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec6"><a id="app04lev3sec6__title" class="calibre4"></a>std::chrono::duration::count member function
      </h5>
      
      <p class="noind"><a id="iddle1440" class="calibre4"></a><a id="iddle2051" class="calibre4"></a><a id="iddle2052" class="calibre4"></a><a id="iddle2056" class="calibre4"></a><a id="iddle2057" class="calibre4"></a><a id="iddle2059" class="calibre4"></a>Retrieves the value of the duration.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">constexpr rep count() const;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            The internal value of the <kbd class="calibre17">duration</kbd> object, as a value of type <kbd class="calibre17">rep</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec7"><a id="app04lev3sec7__title" class="calibre4"></a>std::chrono::duration::operator+ unary plus operator
      </h5>
      
      <p class="noind">This is a no-op: it just returns a copy of <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">constexpr duration operator+() const;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">*this</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec8"><a id="app04lev3sec8__title" class="calibre4"></a>std::chrono::duration::operator- unary minus operator
      </h5>
      
      <p class="noind">Returns a duration such that the <kbd class="calibre17">count()</kbd> value is the negative value of <kbd class="calibre17">this-&gt; count()</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">constexpr duration operator-() const;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration(-this-&gt;count());</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec9"><a id="app04lev3sec9__title" class="calibre4"></a>std::chrono::duration::operator++ pre-increment operator
      </h5>
      
      <p class="noind">Increments the internal count.</p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration&amp; operator++();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">++this-&gt;internal_count;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">*this</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec10"><a id="app04lev3sec10__title" class="calibre4"></a>std::chrono::duration::operator++ post-increment operator
      </h5>
      
      <p class="noind">Increments the internal count and returns the value of *<kbd class="calibre17">this</kbd> prior to the increment.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration operator++(int);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration temp(*this);
++(*this);
return temp;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec11"><a id="app04lev3sec11__title" class="calibre4"></a>std::chrono::duration::operator-- pre-decrement operator
      </h5>
      
      <p class="noind">Decrements the internal count.</p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration&amp; operator--();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2050" class="calibre4"></a><a id="iddle2053" class="calibre4"></a><a id="iddle2054" class="calibre4"></a><a id="iddle2060" class="calibre4"></a><a id="iddle2061" class="calibre4"></a><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">--this-&gt;internal_count;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">*this</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec12"><a id="app04lev3sec12__title" class="calibre4"></a>std::chrono::duration::operator-- post-decrement operator
      </h5>
      
      <p class="noind">Decrements the internal count and returns the value of *<kbd class="calibre17">this</kbd> prior to the decrement.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration operator--(int);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration temp(*this);
--(*this);
return temp;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec13"><a id="app04lev3sec13__title" class="calibre4"></a>std::chrono::duration::operator+= compound assignment operator
      </h5>
      
      <p class="noind">Adds the count for another <kbd class="calibre17">duration</kbd> object to the internal count for <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration&amp; operator+=(duration const&amp; other);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">internal_count+=other.count();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">*this</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec14"><a id="app04lev3sec14__title" class="calibre4"></a>std::chrono::duration::operator-= compound assignment operator
      </h5>
      
      <p class="noind">Subtracts the count for another <kbd class="calibre17">duration</kbd> object from the internal count for <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration&amp; operator-=(duration const&amp; other);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">internal_count-=other.count();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">*this</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec15"><a id="app04lev3sec15__title" class="calibre4"></a>std::chrono::duration::operator*= compound assignment operator
      </h5>
      
      <p class="noind">Multiplies the internal count for <kbd class="calibre17">*this</kbd> by the specified value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration&amp; operator*=(rep const&amp; rhs);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">internal_count*=rhs;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">*this</pre>
            </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec16"><a id="app04lev3sec16__title" class="calibre4"></a>std::chrono::duration::operator/= compound assignment operator
      </h5>
      
      <p class="noind"><a id="iddle2049" class="calibre4"></a><a id="iddle2055" class="calibre4"></a><a id="iddle2064" class="calibre4"></a>Divides the internal count for <kbd class="calibre17">*this</kbd> by the specified value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration&amp; operator/=(rep const&amp; rhs);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">internal_count/=rhs;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">*this</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec17"><a id="app04lev3sec17__title" class="calibre4"></a>std::chrono::duration::operator%= compound assignment operator
      </h5>
      
      <p class="noind">Adjusts the internal count for <kbd class="calibre17">*this</kbd> to be the remainder when divided by the specified value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration&amp; operator%=(rep const&amp; rhs);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">internal_count%=rhs;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">*this</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec18"><a id="app04lev3sec18__title" class="calibre4"></a>std::chrono::duration::operator%= compound assignment operator
      </h5>
      
      <p class="noind">Adjusts the internal count for <kbd class="calibre17">*this</kbd> to be the remainder when divided by the count of the other <kbd class="calibre17">duration</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration&amp; operator%=(duration const&amp; rhs);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">internal_count%=rhs.count();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">*this</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec19"><a id="app04lev3sec19__title" class="calibre4"></a>std::chrono::duration::zero static member function
      </h5>
      
      <p class="noind">Returns a <kbd class="calibre17">duration</kbd> object representing a value of zero.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">constexpr duration zero();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration(duration_values&lt;rep&gt;::zero());</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec20"><a id="app04lev3sec20__title" class="calibre4"></a>std::chrono::duration::min static member function
      </h5>
      
      <p class="noind">Returns a <kbd class="calibre17">duration</kbd> object holding the minimum possible value for the specified instantiation.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">constexpr duration min();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2040" class="calibre4"></a><a id="iddle2043" class="calibre4"></a><a id="iddle2044" class="calibre4"></a><a id="iddle2048" class="calibre4"></a><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration(duration_values&lt;rep&gt;::min());</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec21"><a id="app04lev3sec21__title" class="calibre4"></a>std::chrono::duration::max static member function
      </h5>
      
      <p class="noind">Returns a <kbd class="calibre17">duration</kbd> object holding the maximum possible value for the specified instantiation.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">constexpr duration max();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration(duration_values&lt;rep&gt;::max());</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec22"><a id="app04lev3sec22__title" class="calibre4"></a>std::chrono::duration equality comparison operator
      </h5>
      
      <p class="noind">Compares two <kbd class="calibre17">duration</kbd> objects for equality, even if they have distinct representations and/or periods.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator==(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Requirements</i>
            Either <kbd class="calibre17">lhs</kbd> must be implicitly convertible to <kbd class="calibre17">rhs</kbd>, or vice versa. If neither can be implicitly converted to the other, or they are distinct instantiations of <kbd class="calibre17">duration</kbd> but each can implicitly convert to the other, the expression is ill-formed.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            If <kbd class="calibre17">CommonDuration</kbd> is a synonym for <kbd class="calibre17">std::common_type&lt; duration&lt; Rep1, Period1&gt;, duration&lt; Rep2, Period2&gt;&gt;::type</kbd>, then <kbd class="calibre17">lhs==rhs</kbd> returns <kbd class="calibre17">CommonDuration(lhs).count()==CommonDuration(rhs).count()</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec23"><a id="app04lev3sec23__title" class="calibre4"></a>std::chrono::duration inequality comparison operator
      </h5>
      
      <p class="noind">Compares two <kbd class="calibre17">duration</kbd> objects for inequality, even if they have distinct representations and/or periods.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator!=(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Requirements</i>
            Either <kbd class="calibre17">lhs</kbd> must be implicitly convertible to <kbd class="calibre17">rhs</kbd>, or vice versa. If neither can be implicitly converted to the other, or they are distinct instantiations of <kbd class="calibre17">duration</kbd> but each can implicitly convert to the other, the expression is ill-formed.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">!(lhs==rhs)</pre>
            </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec24"><a id="app04lev3sec24__title" class="calibre4"></a>std::chrono::duration less-than comparison operator
      </h5>
      
      <p class="noind"><a id="iddle1127" class="calibre4"></a><a id="iddle2041" class="calibre4"></a><a id="iddle2045" class="calibre4"></a>Compares two <kbd class="calibre17">duration</kbd> objects to see if one is less than the other, even if they have distinct representations and/or periods.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator&lt;(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Requirements</i>
            Either <kbd class="calibre17">lhs</kbd> must be implicitly convertible to <kbd class="calibre17">rhs</kbd>, or vice versa. If neither can be implicitly converted to the other, or they are distinct instantiations of <kbd class="calibre17">duration</kbd> but each can implicitly converted to the other, the expression is ill-formed.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            If <kbd class="calibre17">CommonDuration</kbd> is a synonym for <kbd class="calibre17">std::common_type&lt; duration&lt; Rep1, Period1&gt;, duration&lt; Rep2, Period2&gt;&gt;::type</kbd>, then <kbd class="calibre17">lhs&lt;rhs</kbd> returns <kbd class="calibre17">CommonDuration(lhs).count()&lt;CommonDuration(rhs).count()</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec25"><a id="app04lev3sec25__title" class="calibre4"></a>std::chrono::duration greater-than comparison operator
      </h5>
      
      <p class="noind">Compares two <kbd class="calibre17">duration</kbd> objects to see if one is greater than the other, even if they have distinct representations and/or periods.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator&gt;(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Requirements</i>
            Either <kbd class="calibre17">lhs</kbd> must be implicitly convertible to <kbd class="calibre17">rhs</kbd>, or vice versa. If neither can be implicitly converted to the other, or they are distinct instantiations of <kbd class="calibre17">duration</kbd> but each can implicitly convert to the other, the expression is ill-formed.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">rhs&lt;lhs</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec26"><a id="app04lev3sec26__title" class="calibre4"></a>std::chrono::duration less-than-or-equals comparison operator
      </h5>
      
      <p class="noind">Compares two <kbd class="calibre17">duration</kbd> objects to see if one is less than or equal to the other, even if they have distinct representations and/or periods.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator&lt;=(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Requirements</i>
            Either <kbd class="calibre17">lhs</kbd> must be implicitly convertible to <kbd class="calibre17">rhs</kbd>, or vice versa. If neither can be implicitly converted to the other, or they are distinct instantiations of <kbd class="calibre17">duration</kbd> but each can implicitly convert to the other, the expression is ill-formed.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1107" class="calibre4"></a><a id="iddle1306" class="calibre4"></a><a id="iddle2042" class="calibre4"></a><a id="iddle2065" class="calibre4"></a><a id="iddle2084" class="calibre4"></a><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">!(rhs&lt;lhs)</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec27"><a id="app04lev3sec27__title" class="calibre4"></a>std::chrono::duration greater-than-or-equals comparison operator
      </h5>
      
      <p class="noind">Compares two <kbd class="calibre17">duration</kbd> objects to see if one is greater than or equal to the other, even if they have distinct representations and/or periods.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr bool operator&gt;=(
    const duration&lt;Rep1, Period1&gt;&amp; lhs,
    const duration&lt;Rep2, Period2&gt;&amp; rhs);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Requirements</i>
            Either <kbd class="calibre17">lhs</kbd> must be implicitly convertible to <kbd class="calibre17">rhs</kbd>, or vice versa. If neither can be implicitly converted to the other, or they are distinct instantiations of <kbd class="calibre17">duration</kbd> but each can implicitly convert to the other, the expression is ill-formed.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">!(lhs&lt;rhs)</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec28"><a id="app04lev3sec28__title" class="calibre4"></a>std::chrono::duration_cast nonmember function
      </h5>
      
      <p class="noind">Explicitly converts an <kbd class="calibre17">std::chrono::duration</kbd> object to a specific <kbd class="calibre17">std::chrono:: duration</kbd> instantiation.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class ToDuration, class Rep, class Period&gt;
constexpr ToDuration duration_cast(const duration&lt;Rep, Period&gt;&amp; d);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Requirements</i>
            <kbd class="calibre17">ToDuration</kbd> must be an instantiation of <kbd class="calibre17">std::chrono::duration</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            The duration, <kbd class="calibre17">d</kbd> converted to the duration type specified by <kbd class="calibre17">ToDuration</kbd>. This is done in such a way as to minimize any loss of precision resulting from conversions between different scales and
            representation types.
         </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec2" class="calibre23">D.1.2. <a id="app04lev2sec2__title" class="calibre4"></a>std::chrono::time_point class template
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::chrono::time_point</kbd> class template represents a point in time, as measured by a particular clock. It’s specified as a duration since the epoch
         of that particular clock. The template parameter <kbd class="calibre17">Clock</kbd> identifies the clock (each distinct clock must have a unique type), whereas the <kbd class="calibre17">Duration</kbd> template parameter is the type to use for measuring the duration since the epoch and must be an instantiation of the <kbd class="calibre17">std::chrono::duration</kbd> class template. The <kbd class="calibre17">Duration</kbd> defaults to the default duration type of the <kbd class="calibre17">Clock</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class Clock,class Duration = typename Clock::duration&gt;
class time_point
{
public:
    typedef Clock clock;
    typedef Duration duration;
    typedef typename duration::rep rep;
    typedef typename duration::period period;

    time_point();
    explicit time_point(const duration&amp; d);

    template &lt;class Duration2&gt;
    time_point(const time_point&lt;clock, Duration2&gt;&amp; t);

    duration time_since_epoch() const;

    time_point&amp; operator+=(const duration&amp; d);
    time_point&amp; operator-=(const duration&amp; d);

    static constexpr time_point min();
    static constexpr time_point max();
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec29"><a id="app04lev3sec29__title" class="calibre4"></a>std::chrono::time_point default constructor
      </h5>
      
      <p class="noind"><a id="iddle1309" class="calibre4"></a><a id="iddle2085" class="calibre4"></a><a id="iddle2086" class="calibre4"></a><a id="iddle2087" class="calibre4"></a><a id="iddle2592" class="calibre4"></a>Constructs a <kbd class="calibre17">time_point</kbd> representing the epoch of the associated <kbd class="calibre17">Clock</kbd>; the internal duration is initialized with <kbd class="calibre17">Duration::zero()</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">time_point();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postcondition</i>
            For a newly default-constructed <kbd class="calibre17">time_point</kbd> object, <kbd class="calibre17">tp</kbd>, <kbd class="calibre17">tp.time_since_epoch() == tp::duration::zero()</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec30"><a id="app04lev3sec30__title" class="calibre4"></a>std::chrono::time_point duration constructor
      </h5>
      
      <p class="noind">Constructs a <kbd class="calibre17">time_point</kbd> representing the specified duration since the epoch of the associated <kbd class="calibre17">Clock</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">explicit time_point(const duration&amp; d);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postcondition</i>
            For a <kbd class="calibre17">time_point</kbd> object, <kbd class="calibre17">tp</kbd>, constucted with <kbd class="calibre17">tp(d)</kbd> for some duration, <kbd class="calibre17">d</kbd>, <kbd class="calibre17">tp.time_since_epoch()==d</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec31"><a id="app04lev3sec31__title" class="calibre4"></a>std::chrono::time_point conversion constructor
      </h5>
      
      <p class="noind">Constructs a <kbd class="calibre17">time_point</kbd> object from another <kbd class="calibre17">time_point</kbd> object with the same <kbd class="calibre17">Clock</kbd> but a distinct <kbd class="calibre17">Duration</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class Duration2&gt;
time_point(const time_point&lt;clock, Duration2&gt;&amp; t);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Requirements</i>
            <kbd class="calibre17">Duration2</kbd> shall be implicitly convertible to <kbd class="calibre17">Duration</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            As-if <kbd class="calibre17">time_point(t.time_since_epoch())</kbd>
            The value returned from <kbd class="calibre17">t.time_since_epoch()</kbd> is implicitly converted to an object of the <kbd class="calibre17">Duration</kbd> type, and that value is stored in the newly constructed <kbd class="calibre17">time_point</kbd> object.
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec32"><a id="app04lev3sec32__title" class="calibre4"></a>std::chrono::time_point::time_since_epoch member function
      </h5>
      
      <p class="noind"><a id="iddle2088" class="calibre4"></a><a id="iddle2089" class="calibre4"></a><a id="iddle2090" class="calibre4"></a><a id="iddle2091" class="calibre4"></a><a id="iddle2092" class="calibre4"></a>Retrieves the duration since the clock epoch for a particular <kbd class="calibre17">time_point</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">duration time_since_epoch() const;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            The <kbd class="calibre17">duration</kbd> value stored in <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec33"><a id="app04lev3sec33__title" class="calibre4"></a>std::chrono::time_point::operator+= compound assignment operator
      </h5>
      
      <p class="noind">Adds the specified <kbd class="calibre17">duration</kbd> to the value stored in the specified <kbd class="calibre17">time_point</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">time_point&amp; operator+=(const duration&amp; d);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Adds <kbd class="calibre17">d</kbd> to the internal <kbd class="calibre17">duration</kbd> object of <kbd class="calibre17">*this</kbd>, as-if
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;internal_duration += d;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">*this</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec34"><a id="app04lev3sec34__title" class="calibre4"></a>std::chrono::time_point::operator-= compound assignment operator
      </h5>
      
      <p class="noind">Subtracts the specified <kbd class="calibre17">duration</kbd> from the value stored in the specified <kbd class="calibre17">time_point</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">time_point&amp; operator-=(const duration&amp; d);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Subtracts <kbd class="calibre17">d</kbd> from the internal <kbd class="calibre17">duration</kbd> object of <kbd class="calibre17">*this</kbd>, as-if
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;internal_duration -= d;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">*this</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec35"><a id="app04lev3sec35__title" class="calibre4"></a>std::chrono::time_point::min static member function
      </h5>
      
      <p class="noind">Obtains a <kbd class="calibre17">time_point</kbd> object representing the minimum possible value for its type.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">static constexpr time_point min();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">time_point(time_point::duration::min()) (see 11.1.1.15)</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec36"><a id="app04lev3sec36__title" class="calibre4"></a>std::chrono::time_point::max static member function
      </h5>
      
      <p class="noind">Obtains a <kbd class="calibre17">time_point</kbd> object representing the maximum possible value for its type.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">static constexpr time_point max();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">time_point(time_point::duration::max()) (see 11.1.1.16)</pre>
            </li>
         
      </ul>
      
      
      
      
      
      <h4 id="app04lev2sec3" class="calibre23">D.1.3. <a id="app04lev2sec3__title" class="calibre4"></a>std::chrono::system_clock class
      </h4>
      
      <p class="noind"><a id="iddle1106" class="calibre4"></a><a id="iddle2076" class="calibre4"></a><a id="iddle2077" class="calibre4"></a><a id="iddle2080" class="calibre4"></a><a id="iddle2081" class="calibre4"></a>The <kbd class="calibre17">std::chrono::system_clock</kbd> class provides a means of obtaining the current wall-clock time from the system-wide real-time clock. The current time can
         be obtained by calling <kbd class="calibre17">std::chrono::system_clock::now()</kbd>. Instances of <kbd class="calibre17">std::chrono::system_clock::time_point</kbd> can be converted to and from <kbd class="calibre17">time_t</kbd> with the <kbd class="calibre17">std::chrono:: system_clock::to_time_t()</kbd> and <kbd class="calibre17">std::chrono::system_clock::to_time_point()</kbd> functions. The system clock isn’t <i class="calibre6">steady</i>, so a subsequent call to <kbd class="calibre17">std::chrono::system_clock::now()</kbd> may return an earlier time than a previous call (for example, if the operating system clock is manually adjusted or synchronized
         with an external clock).
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">class system_clock
{
public:
    typedef <i class="calibre6">unspecified-integral-type</i> rep;
    typedef std::ratio&lt;<i class="calibre6">unspecified</i>,<i class="calibre6">unspecified</i>&gt; period;
    typedef std::chrono::duration&lt;rep,period&gt; duration;
    typedef std::chrono::time_point&lt;system_clock&gt; time_point;
    static const bool is_steady=<i class="calibre6">unspecified</i>;

    static time_point now() noexcept;

    static time_t to_time_t(const time_point&amp; t) noexcept;
    static time_point from_time_t(time_t t) noexcept;
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec37"><a id="app04lev3sec37__title" class="calibre4"></a>std::chrono::system_clock::rep typedef
      </h5>
      
      <p class="noind">A typedef for an integral type used to hold the number of ticks in a <kbd class="calibre17">duration</kbd> value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">typedef unspecified-integral-type rep;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec38"><a id="app04lev3sec38__title" class="calibre4"></a>std::chrono::system_clock::period typedef
      </h5>
      
      <p class="noind">A typedef for an instantiation of the <kbd class="calibre17">std::ratio</kbd> class template that specifies the smallest number of seconds (or fractions of a second) between distinct values of <kbd class="calibre17">duration</kbd> or <kbd class="calibre17">time_point</kbd>. The <kbd class="calibre17">period</kbd> specifies the <i class="calibre6">precision</i> of the clock, not the tick frequency.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">typedef std::ratio&lt;<i class="calibre6">unspecified</i>,<i class="calibre6">unspecified</i>&gt; period;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec39"><a id="app04lev3sec39__title" class="calibre4"></a>std::chrono::system_clock::duration typedef
      </h5>
      
      <p class="noind">An instantiation of the <kbd class="calibre17">std::chrono::duration</kbd> class template that can hold the difference between any two time points returned by the system-wide real-time clock.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">typedef std::chrono::duration&lt;
    std::chrono::system_clock::rep,
    std::chrono::system_clock::period&gt; duration;</pre>
            </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec40"><a id="app04lev3sec40__title" class="calibre4"></a>std::chrono::system_clock::time_point typedef
      </h5>
      
      <p class="noind"><a id="iddle1105" class="calibre4"></a><a id="iddle2069" class="calibre4"></a><a id="iddle2078" class="calibre4"></a><a id="iddle2079" class="calibre4"></a><a id="iddle2082" class="calibre4"></a><a id="iddle2083" class="calibre4"></a>An instantiation of the <kbd class="calibre17">std::chrono::time_point</kbd> class template that can hold time points returned by the system-wide real-time clock.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">typedef std::chrono::time_point&lt;std::chrono::system_clock&gt; time_point;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec41"><a id="app04lev3sec41__title" class="calibre4"></a>std::chrono::system_clock::now static member function
      </h5>
      
      <p class="noind">Obtains the current wall-clock time from the system-wide real-time clock.</p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">time_point now() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            A <kbd class="calibre17">time_point</kbd> representing the current time of the system-wide real-time clock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if an error occurs.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec42"><a id="app04lev3sec42__title" class="calibre4"></a>std::chrono::system_clock::to_time_t static member function
      </h5>
      
      <p class="noind">Converts an instance of <kbd class="calibre17">time_point</kbd> to <kbd class="calibre17">time_t</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">time_t to_time_t(time_point const&amp; t) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            A <kbd class="calibre17">time_t</kbd> value that represents the same point in time as <kbd class="calibre17">t</kbd>, rounded or truncated to seconds precision.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if an error occurs.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec43"><a id="app04lev3sec43__title" class="calibre4"></a>std::chrono::system_clock::from_time_t static member function
      </h5>
      
      <p class="noind">Converts an instance of <kbd class="calibre17">time_t</kbd> to <kbd class="calibre17">time_point</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">time_point from_time_t(time_t const&amp; t) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            A <kbd class="calibre17">time_point</kbd> value that represents the same point in time as <kbd class="calibre17">t</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if an error occurs.
         </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec4" class="calibre23">D.1.4. <a id="app04lev2sec4__title" class="calibre4"></a>std::chrono::steady_clock class
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::chrono::steady_clock</kbd> class provides access to the system-wide steady clock. The current time can be obtained by calling <kbd class="calibre17">std::chrono::steady_clock::now()</kbd>. There is no fixed relationship between values returned by <kbd class="calibre17">std::chrono::steady_clock::now()</kbd> and wall-clock time. A steady clock can’t go backwards, so if one call to <kbd class="calibre17">std::chrono::steady_clock::now()</kbd> happens-before another call to <kbd class="calibre17">std::chrono::steady_clock::now()</kbd>, the second call must return a time point equal to or later than the first. The clock advances at a uniform rate as far as
         possible.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2070" class="calibre4"></a><a id="iddle2071" class="calibre4"></a><a id="iddle2072" class="calibre4"></a><a id="iddle2073" class="calibre4"></a><a id="iddle2074" class="calibre4"></a><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">class steady_clock
{
public:
    typedef <i class="calibre6">unspecified-integral-type</i> rep;
    typedef std::ratio&lt;
        <i class="calibre6">unspecified</i>,<i class="calibre6">unspecified</i>&gt; period;
    typedef std::chrono::duration&lt;rep,period&gt; duration;
    typedef std::chrono::time_point&lt;steady_clock&gt;
        time_point;
    static const bool is_steady=true;

    static time_point now() noexcept;
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec44"><a id="app04lev3sec44__title" class="calibre4"></a>std::chrono::steady_clock::rep typedef
      </h5>
      
      <p class="noind">This typedef is for an integral type used to hold the number of ticks in a <kbd class="calibre17">duration</kbd> value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">typedef <i class="calibre6">unspecified-integral-type</i> rep;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec45"><a id="app04lev3sec45__title" class="calibre4"></a>std::chrono::steady_clock::period typedef
      </h5>
      
      <p class="noind">This is a typedef for an instantiation of the <kbd class="calibre17">std::ratio</kbd> class template that specifies the smallest number of seconds (or fractions of a second) between distinct values of <kbd class="calibre17">duration</kbd> or <kbd class="calibre17">time_point</kbd>. The <kbd class="calibre17">period</kbd> specifies the <i class="calibre6">precision</i> of the clock, not the tick frequency.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">typedef std::ratio&lt;<i class="calibre6">unspecified</i>,<i class="calibre6">unspecified</i>&gt; period;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec46"><a id="app04lev3sec46__title" class="calibre4"></a>std::chrono::steady_clock::duration typedef
      </h5>
      
      <p class="noind">This is an instantiation of the <kbd class="calibre17">std::chrono::duration</kbd> class template that can hold the difference between any two time points returned by the system-wide steady clock.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">typedef std::chrono::duration&lt;
    std::chrono::steady_clock::rep,
    std::chrono::steady_clock::period&gt; duration;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec47"><a id="app04lev3sec47__title" class="calibre4"></a>std::chrono::steady_clock::time_point typedef
      </h5>
      
      <p class="noind">This instantiation of the <kbd class="calibre17">std::chrono::time_point</kbd> class template can hold time points returned by the system-wide steady clock.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">typedef std::chrono::time_point&lt;std::chrono::steady_clock&gt; time_point;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec48"><a id="app04lev3sec48__title" class="calibre4"></a>std::chrono::steady_clock::now static member function
      </h5>
      
      <p class="noind">Obtains the current time from the system-wide steady clock.</p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">time_point now() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1089" class="calibre4"></a><a id="iddle1104" class="calibre4"></a><a id="iddle1197" class="calibre4"></a><a id="iddle2066" class="calibre4"></a><i class="calibre6">Returns</i>
            A <kbd class="calibre17">time_point</kbd> representing the current time of the system-wide steady clock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if an error occurs.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            If one call to <kbd class="calibre17">std::chrono::steady_clock::now()</kbd> happens-before another, the <kbd class="calibre17">time_point</kbd> returned by the first call shall compare less-than or equal-to the <kbd class="calibre17">time_point</kbd> returned by the second call.
         </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec5" class="calibre23">D.1.5. <a id="app04lev2sec5__title" class="calibre4"></a>std::chrono::high_resolution_clock typedef
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::chrono::high_resolution_clock</kbd> class provides access to the system-wide clock with the highest resolution. As for all clocks, the current time can be obtained
         by calling <kbd class="calibre17">std::chrono::high_resolution_clock::now()</kbd>. <kbd class="calibre17">std::chrono::high_resolution_clock</kbd> may be a typedef for the <kbd class="calibre17">std::chrono::system_clock</kbd> class or the <kbd class="calibre17">std::chrono::steady_clock</kbd> class, or it may be a separate type.
      </p>
      
      <p class="noind">Although <kbd class="calibre17">std::chrono::high_resolution_clock</kbd> has the highest resolution of all the library-supplied clocks, <kbd class="calibre17">std::chrono::high_resolution_clock::now()</kbd> still takes a finite amount of time. You must take care to account for the overhead of calling <kbd class="calibre17">std::chrono::high_resolution_clock::now()</kbd> when timing short operations.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">class high_resolution_clock
{
public:
    typedef <i class="calibre6">unspecified-integral-type</i> rep;
    typedef std::ratio&lt;
        <i class="calibre6">unspecified</i>,<i class="calibre6">unspecified</i>&gt; period;
    typedef std::chrono::duration&lt;rep,period&gt; duration;
    typedef std::chrono::time_point&lt;
        <i class="calibre6">unspecified</i>&gt; time_point;
    static const bool is_steady=<i class="calibre6">unspecified</i>;

    static time_point now() noexcept;
};</pre>
            </li>
         
      </ul>
      
      
      
      
      <h3 id="app04lev1sec2" class="chapter"><a id="app04lev1sec2__title" class="calibre3"></a>D.2. &lt;condition_variable&gt; header
      </h3>
      
      <p class="noind">The <kbd class="calibre17">&lt;condition_variable&gt;</kbd> header provides condition variables. These are basic-level synchronization mechanisms that allow a thread to block until
         notified that some condition is true or a timeout period has elapsed.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Header contents</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">namespace std
{
    enum class cv_status { timeout, no_timeout };

    class condition_variable;
    class condition_variable_any;
}</pre>
            </li>
         
      </ul>
      
      
      
      <h4 id="app04lev2sec6" class="calibre23">D.2.1. <a id="app04lev2sec6__title" class="calibre4"></a>std::condition_variable class
      </h4>
      
      <p class="noind"><a id="iddle1198" class="calibre4"></a><a id="iddle2094" class="calibre4"></a><a id="iddle2095" class="calibre4"></a>The <kbd class="calibre17">std::condition_variable</kbd> class allows a thread to wait for a condition to become <kbd class="calibre17">true</kbd>. Instances of <kbd class="calibre17">std::condition_variable</kbd> aren’t <kbd class="calibre17">CopyAssignable</kbd>, <kbd class="calibre17">CopyConstructible</kbd>, <kbd class="calibre17">MoveAssignable</kbd>, or <kbd class="calibre17">MoveConstructible</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">class condition_variable
{
public:
    condition_variable();
    ~condition_variable();

    condition_variable(condition_variable const&amp; ) = delete;
    condition_variable&amp; operator=(condition_variable const&amp; ) = delete;

    void notify_one() noexcept;
    void notify_all() noexcept;

    void wait(std::unique_lock&lt;std::mutex&gt;&amp; lock);

    template &lt;typename Predicate&gt;
    void wait(std::unique_lock&lt;std::mutex&gt;&amp; lock,Predicate pred);

    template &lt;typename Clock, typename Duration&gt;
    cv_status wait_until(
        std::unique_lock&lt;std::mutex&gt;&amp; lock,
        const std::chrono::time_point&lt;Clock, Duration&gt;&amp; absolute_time);

    template &lt;typename Clock, typename Duration, typename Predicate&gt;
    bool wait_until(
        std::unique_lock&lt;std::mutex&gt;&amp; lock,
        const std::chrono::time_point&lt;Clock, Duration&gt;&amp; absolute_time,
        Predicate pred);

    template &lt;typename Rep, typename Period&gt;
    cv_status wait_for(
        std::unique_lock&lt;std::mutex&gt;&amp; lock,
        const std::chrono::duration&lt;Rep, Period&gt;&amp; relative_time);

    template &lt;typename Rep, typename Period, typename Predicate&gt;
    bool wait_for(
        std::unique_lock&lt;std::mutex&gt;&amp; lock,
        const std::chrono::duration&lt;Rep, Period&gt;&amp; relative_time,
        Predicate pred);
};

void notify_all_at_thread_exit(condition_variable&amp;,unique_lock&lt;mutex&gt;);</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec49"><a id="app04lev3sec49__title" class="calibre4"></a>std::condition_variable default constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::condition_variable</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">condition_variable();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs a new <kbd class="calibre17">std::condition_variable</kbd> instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2096" class="calibre4"></a><a id="iddle2101" class="calibre4"></a><a id="iddle2102" class="calibre4"></a><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if the condition variable could not be constructed.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec50"><a id="app04lev3sec50__title" class="calibre4"></a>std::condition_variable destructor
      </h5>
      
      <p class="noind">Destroys an <kbd class="calibre17">std::condition_variable</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~condition_variable();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            There are no threads blocked on <kbd class="calibre17">*this</kbd> in a call to <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, or <kbd class="calibre17">wait_until()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Destroys <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec51"><a id="app04lev3sec51__title" class="calibre4"></a>std::condition_variable::notify_one member function
      </h5>
      
      <p class="noind">Wakes one of the threads currently waiting on a <kbd class="calibre17">std::condition_variable</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void notify_one() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Wakes one of the threads waiting on <kbd class="calibre17">*this</kbd> at the point of the call. If there are no threads waiting, the call has no effect.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            <kbd class="calibre17">std::system_error</kbd> if the effects can’t be achieved.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will only wake threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec52"><a id="app04lev3sec52__title" class="calibre4"></a>std::condition_variable::notify_all member function
      </h5>
      
      <p class="noind">Wake all of the threads currently waiting on a <kbd class="calibre17">std::condition_variable</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void notify_all() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Wakes all of the threads waiting on <kbd class="calibre17">*this</kbd> at the point of the call. If there are no threads waiting, the call has no effect.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            <kbd class="calibre17">std::system_error</kbd> if the effects can’t be achieved.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will only wake threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec53"><a id="app04lev3sec53__title" class="calibre4"></a>std::condition_variable::wait member function
      </h5>
      
      <p class="noind"><a id="iddle1791" class="calibre4"></a><a id="iddle2103" class="calibre4"></a>Waits until <kbd class="calibre17">std::condition_variable</kbd> is woken by a call to <kbd class="calibre17">notify_one()</kbd>, a call to <kbd class="calibre17">notify_all()</kbd>, or a spurious wakeup.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void wait(std::unique_lock&lt;std::mutex&gt;&amp; lock);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">lock.owns_lock()</kbd> is <kbd class="calibre17">true</kbd>, and the lock is owned by the calling thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically unlocks the supplied <kbd class="calibre17">lock</kbd> object and block until the thread is woken by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> by another thread, or the thread is woken spuriously. The <kbd class="calibre17">lock</kbd> object is locked again before the call to <kbd class="calibre17">wait()</kbd> returns.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            <kbd class="calibre17">std::system_error</kbd> if the effects can’t be achieved. If the <kbd class="calibre17">lock</kbd> object is unlocked during the call to <kbd class="calibre17">wait()</kbd>, it’s locked again on exit, even if the function exits via an exception.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note01">Note</h5>
      
      
      <p class="noindclose">The spurious wakeups mean that a thread calling <kbd class="calibre17">wait()</kbd> may wake even though no thread has called <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd>. It’s therefore recommended that the overload of <kbd class="calibre17">wait()</kbd> that takes a predicate is used in preference where possible. Otherwise, it’s recommended that <kbd class="calibre17">wait()</kbd> be called in a loop that tests the predicate associated with the condition variable.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will only wake threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec54"><a id="app04lev3sec54__title" class="calibre4"></a>std::condition_variable::wait member function overload that takes a predicate
      </h5>
      
      <p class="noind">Waits until <kbd class="calibre17">std::condition_variable</kbd> is woken by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd>, and the predicate is <kbd class="calibre17">true</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Predicate&gt;
void wait(std::unique_lock&lt;std::mutex&gt;&amp; lock,Predicate pred);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The expression <kbd class="calibre17">pred()</kbd> shall be valid and shall return a value convertible to <kbd class="calibre17">bool</kbd>. <kbd class="calibre17">lock.owns_lock()</kbd> shall be <kbd class="calibre17">true</kbd>, and the lock shall be owned by the thread calling <kbd class="calibre17">wait()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            As-if
            
            
            <div class="calibre15"></div><pre class="calibre5">while(!pred())
{
    wait(lock);
}</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2104" class="calibre4"></a><i class="calibre6">Throws</i>
            Any exception thrown by a call to <kbd class="calibre17">pred</kbd>, or <kbd class="calibre17">std::system_error</kbd> if the effects couldn’t be achieved.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note02">Note</h5>
      
      
      <p class="noindclose">The potential for spurious wakeups means that it’s unspecified how many times <kbd class="calibre17">pred</kbd> will be called. <kbd class="calibre17">pred</kbd> will always be invoked with the mutex referenced by <kbd class="calibre17">lock</kbd> locked, and the function shall return if (and only if) an evaluation of <kbd class="calibre17">(bool)pred()</kbd> returns <kbd class="calibre17">true</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd> and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will only wake threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec55"><a id="app04lev3sec55__title" class="calibre4"></a>std::condition_variable::wait_for member function
      </h5>
      
      <p class="noind">Waits until <kbd class="calibre17">std::condition_variable</kbd> is notified by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd>, or until a specified time period has elapsed or the thread is woken spuriously.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Rep,typename Period&gt;
cv_status wait_for(
    std::unique_lock&lt;std::mutex&gt;&amp; lock,
    std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">lock.owns_lock()</kbd> is <kbd class="calibre17">true</kbd>, and the lock is owned by the calling thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically unlocks the supplied <kbd class="calibre17">lock</kbd> object and block until the thread is woken by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> by another thread, or the time period specified by <kbd class="calibre17">relative_time</kbd> has elapsed, or the thread is woken spuriously. The <kbd class="calibre17">lock</kbd> object is locked again before the call to <kbd class="calibre17">wait_for()</kbd> returns.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">std::cv_status::no_timeout</kbd> if the thread was woken by a call to <kbd class="calibre17">notify_one()</kbd>, a call to <kbd class="calibre17">notify_all()</kbd>, or a spurious wakeup, <kbd class="calibre17">std::cv_status::timeout</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            <kbd class="calibre17">std::system_error</kbd> if the effects can’t be achieved. If the <kbd class="calibre17">lock</kbd> object is unlocked during the call to <kbd class="calibre17">wait_for()</kbd>, it’s locked again on exit, even if the function exits via an exception.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note03">Note</h5>
      
      
      <p class="noindclose">The spurious wakeups mean that a thread calling <kbd class="calibre17">wait_for()</kbd> may wake even though no thread has called <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd>. It’s therefore recommended that the overload of <kbd class="calibre17">wait_for()</kbd> that takes a predicate is used in preference where possible. Otherwise, it’s recommended that <kbd class="calibre17">wait_for()</kbd> be called in a loop that tests the predicate associated with the condition variable. Care must be taken when doing this to
         ensure that the timeout is still valid; <kbd class="calibre17">wait_until()</kbd> may be more appropriate in many circumstances. <a id="iddle1792" class="calibre4"></a>The thread may be blocked for longer than the specified duration. Where possible, the elapsed time is determined by a steady
         clock.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will only wake threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec56"><a id="app04lev3sec56__title" class="calibre4"></a>std::condition_variable::wait_for member function overload that t- takes a predicate
      </h5>
      
      <p class="noind">Wait until <kbd class="calibre17">std::condition_variable</kbd> is woken by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> and the predicate is <kbd class="calibre17">true</kbd>, or until the specified time period has elapsed.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Rep,typename Period,typename Predicate&gt;
bool wait_for(
    std::unique_lock&lt;std::mutex&gt;&amp; lock,
    std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time,
    Predicate pred);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The expression <kbd class="calibre17">pred()</kbd> shall be valid and shall return a value that’s convertible to <kbd class="calibre17">bool</kbd>. <kbd class="calibre17">lock.owns_lock()</kbd> shall be <kbd class="calibre17">true</kbd>, and the lock shall be owned by the thread calling <kbd class="calibre17">wait()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            As-if
            
            
            <div class="calibre15"></div><pre class="calibre5">internal_clock::time_point end=internal_clock::now()+relative_time;
while(!pred())
{
    std::chrono::duration&lt;Rep,Period&gt; remaining_time=
        end-internal_clock::now();
    if(wait_for(lock,remaining_time)==std::cv_status::timeout)
        return pred();
}
return true;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if the most recent call to <kbd class="calibre17">pred()</kbd> returned <kbd class="calibre17">true</kbd>, <kbd class="calibre17">false</kbd> if the time period specified by <kbd class="calibre17">relative_time</kbd> has elapsed and <kbd class="calibre17">pred()</kbd> returned <kbd class="calibre17">false</kbd>.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note04">Note</h5>
      
      
      <p class="noindclose">The potential for spurious wakeups means that it’s unspecified how many times <kbd class="calibre17">pred</kbd> will be called. <kbd class="calibre17">pred</kbd> will always be invoked with the mutex referenced by <kbd class="calibre17">lock</kbd> locked, and the function shall return if (and only if) an evaluation of <kbd class="calibre17">(bool)pred()</kbd> returns <kbd class="calibre17">true</kbd> or the time period specified by <kbd class="calibre17">relative_time</kbd> has elapsed. The thread may be blocked for longer than the specified duration. Where possible, the elapsed time is determined
         by a steady clock.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exception thrown by a call to <kbd class="calibre17">pred</kbd>, or <kbd class="calibre17">std::system_error</kbd> if the effects couldn’t be achieved.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2105" class="calibre4"></a><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will only wake threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec57"><a id="app04lev3sec57__title" class="calibre4"></a>std::condition_variable::wait_until member function
      </h5>
      
      <p class="noind">Waits until <kbd class="calibre17">std::condition_variable</kbd> is notified by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd>, until a specified time has been reached, or the thread is woken spuriously.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Clock,typename Duration&gt;
cv_status wait_until(
    std::unique_lock&lt;std::mutex&gt;&amp; lock,
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">lock.owns_lock()</kbd> is <kbd class="calibre17">true</kbd>, and the lock is owned by the calling thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically unlocks the supplied <kbd class="calibre17">lock</kbd> object and block until the thread is woken by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> by another thread, or <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd> or the thread is woken spuriously. The <kbd class="calibre17">lock</kbd> object is locked again before the call to <kbd class="calibre17">wait_until()</kbd> returns.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">std::cv_status::no_timeout</kbd> if the thread was woken by a call to <kbd class="calibre17">notify_one()</kbd>, a call to <kbd class="calibre17">notify_all()</kbd>, or a spurious wakeup, <kbd class="calibre17">std::cv_status::timeout</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            <kbd class="calibre17">std::system_error</kbd> if the effects can’t be achieved. If the <kbd class="calibre17">lock</kbd> object is unlocked during the call to <kbd class="calibre17">wait_until()</kbd>, it’s locked again on exit, even if the function exits via an exception.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note05">Note</h5>
      
      
      <p class="noindclose">The spurious wakeups mean that a thread calling <kbd class="calibre17">wait_until()</kbd> may wake even though no thread has called <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd>. It’s therefore recommended that the overload of <kbd class="calibre17">wait_until()</kbd> that takes a predicate is used in preference where possible. Otherwise, it’s recommended that <kbd class="calibre17">wait_until()</kbd> be called in a loop that tests the predicate associated with the condition variable. There’s no guarantee as to how long
         the calling thread will be blocked, only that if the function returns <kbd class="calibre17">false</kbd>, then <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd> at the point at which the thread became unblocked.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will only wake threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec58"><a id="app04lev3sec58__title" class="calibre4"></a>std::condition_variable::wait_until member function overload that- t takes a predicate
      </h5>
      
      <p class="noind"><a id="iddle1793" class="calibre4"></a>Wait until <kbd class="calibre17">std::condition_variable</kbd> is woken by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> and the predicate is <kbd class="calibre17">true</kbd>, or until the specified time has been reached.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Clock,typename Duration,typename Predicate&gt;
bool wait_until(
    std::unique_lock&lt;std::mutex&gt;&amp; lock,
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time,
    Predicate pred);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The expression <kbd class="calibre17">pred()</kbd> shall be valid and shall return a value convertible to <kbd class="calibre17">bool</kbd>. <kbd class="calibre17">lock.owns_lock()</kbd> shall be <kbd class="calibre17">true</kbd>, and the lock shall be owned by the thread calling <kbd class="calibre17">wait()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            As-if
            
            
            <div class="calibre15"></div><pre class="calibre5">while(!pred())
{
    if(wait_until(lock,absolute_time)==std::cv_status::timeout)
        return pred();
}
return true;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if the most recent call to <kbd class="calibre17">pred()</kbd> returned <kbd class="calibre17">true</kbd>, <kbd class="calibre17">false</kbd> if a call to <kbd class="calibre17">Clock::now()</kbd> returned a time equal to or later than the time specified by <kbd class="calibre17">absolute_time</kbd> and <kbd class="calibre17">pred()</kbd> returned <kbd class="calibre17">false</kbd>.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note06">Note</h5>
      
      
      <p class="noindclose">The potential for spurious wakeups means that it’s unspecified how many times <kbd class="calibre17">pred</kbd> will be called. <kbd class="calibre17">pred</kbd> will always be invoked with the mutex referenced by <kbd class="calibre17">lock</kbd> locked, and the function shall return if (and only if) an evaluation of <kbd class="calibre17">(bool)pred()</kbd> returns <kbd class="calibre17">true</kbd> or <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd>. There’s no guarantee as to how long the calling thread will be blocked, only that if the function returns <kbd class="calibre17">false</kbd>, then <kbd class="calibre17">Clock:: now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd> at the point at which the thread became unblocked.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exception thrown by a call to <kbd class="calibre17">pred</kbd>, or <kbd class="calibre17">std::system_error</kbd> if the effects couldn’t be achieved.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_until()</kbd>, and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will wake only threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec59"><a id="app04lev3sec59__title" class="calibre4"></a>std::notify_all_at_thread_exit nonmember function
      </h5>
      
      <p class="noind"><a id="iddle1199" class="calibre4"></a><a id="iddle2106" class="calibre4"></a><a id="iddle2200" class="calibre4"></a>Wake all of the threads waiting on a specific a <kbd class="calibre17">std::condition_variable</kbd> when the current thread exits.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void notify_all_at_thread_exit(
    condition_variable&amp; cv,unique_lock&lt;mutex&gt; lk);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">lk.owns_lock()</kbd> is <kbd class="calibre17">true</kbd>, and the lock is owned by the calling thread. <kbd class="calibre17">lk.mutex()</kbd> shall return the same value as for any of the lock objects supplied to <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, or <kbd class="calibre17">wait_until()</kbd> on <kbd class="calibre17">cv</kbd> from concurrently waiting threads.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Transfers ownership of the lock held by <kbd class="calibre17">lk</kbd> into internal storage and schedules <kbd class="calibre17">cv</kbd> to be notified when the calling thread exits. This notification shall be as-if
            
            
            <div class="calibre15"></div><pre class="calibre5">lk.unlock();
cv.notify_all();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            <kbd class="calibre17">std::system_error</kbd> if the effects can’t be achieved.
            
            <table cellspacing="5" width="100%" border="1" class="calibre7">
               <colgroup class="calibre28">
                  <col width="550" class="calibre9"/>
               </colgroup>
               <tbody class="calibre10">
                  <tr class="calibre11">
                     <td class="calibre29"/>
                  </tr>
               </tbody>
            </table>
            <h5 class="notetitle" id="app04note07">Note</h5>
            
            
            <p class="noindclose">The lock is held until the thread exits, so care must be taken to avoid deadlock. It’s recommended that the calling thread
               should exit as soon as possible and that no blocking operations be performed on this thread.
            </p>
            
            <table cellspacing="5" width="100%" border="1" class="calibre7">
               <colgroup class="calibre28">
                  <col width="550" class="calibre9"/>
               </colgroup>
               <tbody class="calibre10">
                  <tr class="calibre11">
                     <td class="calibre29"/>
                  </tr>
               </tbody>
            </table>
            The user should ensure that waiting threads don’t erroneously assume that the thread has exited when they are woken, particularly
            with the potential for spurious wakeups. This can be achieved by testing a predicate on the waiting thread that’s only made
            <kbd class="calibre17">true</kbd> by the notifying thread under the protection of the mutex and without releasing the lock on the mutex prior to the call of
            <kbd class="calibre17">notify_all_at_thread_exit.std::condition_variable_any class</kbd>.
         </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec7" class="calibre23">D.2.2. <a id="app04lev2sec7__title" class="calibre4"></a>std::condition_variable_any class
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::condition_variable_any</kbd> class allows a thread to wait for a condition to become <kbd class="calibre17">true</kbd>. Whereas <kbd class="calibre17">std::condition_variable</kbd> can be used only with <kbd class="calibre17">std::unique_lock&lt;std::mutex&gt;</kbd>, <kbd class="calibre17">std::condition_variable_any</kbd> can be used with <i class="calibre6">any</i> type that meets the <kbd class="calibre17">Lockable</kbd> requirements.
      </p>
      
      <p class="noind">Instances of <kbd class="calibre17">std::condition_variable_any</kbd> aren’t <kbd class="calibre17">CopyAssignable</kbd>, <kbd class="calibre17">CopyConstructible</kbd>, <kbd class="calibre17">MoveAssignable</kbd>, or <kbd class="calibre17">MoveConstructible</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">class condition_variable_any
{
public:
    condition_variable_any();
    ~condition_variable_any();

    condition_variable_any(
        condition_variable_any const&amp; ) = delete;
    condition_variable_any&amp; operator=(
        condition_variable_any const&amp; ) = delete;

    void notify_one() noexcept;
    void notify_all() noexcept;

    template&lt;typename Lockable&gt;
    void wait(Lockable&amp; lock);

    template &lt;typename Lockable, typename Predicate&gt;
    void wait(Lockable&amp; lock, Predicate pred);

    template &lt;typename Lockable, typename Clock,typename Duration&gt;
    std::cv_status wait_until(
        Lockable&amp; lock,
        const std::chrono::time_point&lt;Clock, Duration&gt;&amp; absolute_time);

    template &lt;
        typename Lockable, typename Clock,
        typename Duration, typename Predicate&gt;
    bool wait_until(
        Lockable&amp; lock,
        const std::chrono::time_point&lt;Clock, Duration&gt;&amp; absolute_time,
        Predicate pred);

    template &lt;typename Lockable, typename Rep, typename Period&gt;
    std::cv_status wait_for(
        Lockable&amp; lock,
        const std::chrono::duration&lt;Rep, Period&gt;&amp; relative_time);

    template &lt;
        typename Lockable, typename Rep,
        typename Period, typename Predicate&gt;
    bool wait_for(
        Lockable&amp; lock,
        const std::chrono::duration&lt;Rep, Period&gt;&amp; relative_time,
        Predicate pred);
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec60"><a id="app04lev3sec60__title" class="calibre4"></a>std::condition_variable_any default constructor
      </h5>
      
      <p class="noind"><a id="iddle2107" class="calibre4"></a><a id="iddle2108" class="calibre4"></a>Constructs an <kbd class="calibre17">std::condition_variable_any</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">condition_variable_any();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs a new <kbd class="calibre17">std::condition_variable_any</kbd> instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if the condition variable couldn’t be constructed.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec61"><a id="app04lev3sec61__title" class="calibre4"></a>std::condition_variable_any destructor
      </h5>
      
      <p class="noind">Destroys an <kbd class="calibre17">std::condition_variable_any</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~condition_variable_any();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2112" class="calibre4"></a><a id="iddle2113" class="calibre4"></a><a id="iddle2114" class="calibre4"></a><i class="calibre6">Preconditions</i>
            There are no threads blocked on <kbd class="calibre17">*this</kbd> in a call to <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, or <kbd class="calibre17">wait_until()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Destroys <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec62"><a id="app04lev3sec62__title" class="calibre4"></a>std::condition_variable_any::notify_one member function
      </h5>
      
      <p class="noind">Wakes one of the threads currently waiting on a specific a <kbd class="calibre17">std::condition_variable_any</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void notify_one() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Wakes one of the threads waiting on <kbd class="calibre17">*this</kbd> at the point of the call. If there are no threads waiting, the call has no effect.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            <kbd class="calibre17">std::system_error</kbd> if the effects can’t be achieved.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable_any</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will only wake threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec63"><a id="app04lev3sec63__title" class="calibre4"></a>std::condition_variable_any::notify_all member function
      </h5>
      
      <p class="noind">Wakes all of the threads currently waiting on a specific a <kbd class="calibre17">std::condition_variable_any</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void notify_all() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Wakes all of the threads waiting on <kbd class="calibre17">*this</kbd> at the point of the call. If there are no threads waiting, the call has no effect.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            <kbd class="calibre17">std::system_error</kbd> if the effects can’t be achieved.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable_any</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will only wake threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec64"><a id="app04lev3sec64__title" class="calibre4"></a>std::condition_variable_any::wait member function
      </h5>
      
      <p class="noind">Waits until <kbd class="calibre17">std::condition_variable_any</kbd> is woken by a call to <kbd class="calibre17">notify_one()</kbd>, a call to <kbd class="calibre17">notify_all()</kbd>, or a spurious wakeup.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Lockable&gt;
void wait(Lockable&amp; lock);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1794" class="calibre4"></a><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">Lockable</kbd> meets the <kbd class="calibre17">Lockable</kbd> requirements, and <kbd class="calibre17">lock</kbd> owns a lock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically unlocks the supplied <kbd class="calibre17">lock</kbd> object and block until the thread is woken by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> by another thread, or the thread is woken spuriously. The <kbd class="calibre17">lock</kbd> object is locked again before the call to <kbd class="calibre17">wait()</kbd> returns.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            <kbd class="calibre17">std::system_error</kbd> if the effects can’t be achieved. If the <kbd class="calibre17">lock</kbd> object is unlocked during the call to <kbd class="calibre17">wait()</kbd>, it’s locked again on exit, even if the function exits via an exception.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note08">Note</h5>
      
      
      <p class="noindclose">The spurious wakeups mean that a thread calling <kbd class="calibre17">wait()</kbd> may wake even though no thread has called <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd>. It’s therefore recommended that the overload of <kbd class="calibre17">wait()</kbd> that takes a predicate is used in preference where possible. Otherwise, it’s recommended that <kbd class="calibre17">wait()</kbd> be called in a loop that tests the predicate associated with the condition variable.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable_any</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will only wake threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec65"><a id="app04lev3sec65__title" class="calibre4"></a>std::condition_variable_any::wait member function overload that t- takes a predicate
      </h5>
      
      <p class="noind">Waits until <kbd class="calibre17">std::condition_variable_any</kbd> is woken by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> and the predicate is <kbd class="calibre17">true</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Lockable,typename Predicate&gt;
void wait(Lockable&amp; lock,Predicate pred);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The expression <kbd class="calibre17">pred()</kbd> shall be valid and shall return a value that’s convertible to <kbd class="calibre17">bool</kbd>. <kbd class="calibre17">Lockable</kbd> meets the <kbd class="calibre17">Lockable</kbd> requirements, and <kbd class="calibre17">lock</kbd> owns a lock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            As-if
            
            
            <div class="calibre15"></div><pre class="calibre5">while(!pred())
{
    wait(lock);
}</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exception thrown by a call to <kbd class="calibre17">pred</kbd>, or <kbd class="calibre17">std::system_error</kbd> if the effects could not be achieved.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note09">Note</h5>
      
      
      <p class="noindclose">The potential for spurious wakeups means that it’s unspecified how many times <kbd class="calibre17">pred</kbd> will be called. <kbd class="calibre17">pred</kbd> will always be invoked with the mutex referenced by <kbd class="calibre17">lock</kbd> locked, and the function shall return if (and only if) an evaluation of <kbd class="calibre17">(bool)pred()</kbd> returns <kbd class="calibre17">true</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2115" class="calibre4"></a><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable_any</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will only wake threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec66"><a id="app04lev3sec66__title" class="calibre4"></a>std::condition_variable_any::wait_for member function
      </h5>
      
      <p class="noind">Waits until <kbd class="calibre17">std::condition_variable_any</kbd> is notified by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd>, until a specified time period has elapsed, or the thread is woken spuriously.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Lockable,typename Rep,typename Period&gt;
std::cv_status wait_for(
    Lockable&amp; lock,
    std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">Lockable</kbd> meets the <kbd class="calibre17">Lockable</kbd> requirements, and <kbd class="calibre17">lock</kbd> owns a lock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically unlocks the supplied <kbd class="calibre17">lock</kbd> object and block until the thread is woken by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> by another thread or the time period specified by <kbd class="calibre17">relative_time</kbd> has elapsed or the thread is woken spuriously. The <kbd class="calibre17">lock</kbd> object is locked again before the call to <kbd class="calibre17">wait_for()</kbd> returns.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">std::cv_status::no_timeout</kbd> if the thread was woken by a call to <kbd class="calibre17">notify_one()</kbd>, a call to <kbd class="calibre17">notify_all()</kbd>, or a spurious wakeup, <kbd class="calibre17">std::cv_status::timeout</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            <kbd class="calibre17">std::system_error</kbd> if the effects can’t be achieved. If the <kbd class="calibre17">lock</kbd> object is unlocked during the call to <kbd class="calibre17">wait_for()</kbd>, it’s locked again on exit, even if the function exits via an exception.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note10">Note</h5>
      
      
      <p class="noindclose">The spurious wakeups mean that a thread calling <kbd class="calibre17">wait_for()</kbd> may wake even though no thread has called <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd>. It’s therefore recommended that the overload of <kbd class="calibre17">wait_for()</kbd> that takes a predicate is used in preference where possible. Otherwise, it’s recommended that <kbd class="calibre17">wait_for()</kbd> be called in a loop that tests the predicate associated with the condition variable. Care must be taken when doing this to
         ensure that the timeout is still valid; <kbd class="calibre17">wait_until()</kbd> may be more appropriate in many circumstances. The thread may be blocked for longer than the specified duration. Where possible,
         the elapsed time is determined by a steady clock.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable_any</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will only wake threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec67"><a id="app04lev3sec67__title" class="calibre4"></a>std::condition_variable_any::wait_for member function overload th- hat takes a predicate
      </h5>
      
      <p class="noind"><a id="iddle1795" class="calibre4"></a>Waits until <kbd class="calibre17">std::condition_variable_any</kbd> is woken by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> and the predicate is <kbd class="calibre17">true</kbd>, or until the specified time period has elapsed.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Lockable,typename Rep,
    typename Period, typename Predicate&gt;
bool wait_for(
    Lockable&amp; lock,
    std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time,
    Predicate pred);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The expression <kbd class="calibre17">pred()</kbd> shall be valid and shall return a value that’s convertible to <kbd class="calibre17">bool</kbd>. <kbd class="calibre17">Lockable</kbd> meets the <kbd class="calibre17">Lockable</kbd> requirements, and <kbd class="calibre17">lock</kbd> owns a lock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            As-if
            
            
            <div class="calibre15"></div><pre class="calibre5">internal_clock::time_point end=internal_clock::now()+relative_time;
while(!pred())
{
    std::chrono::duration&lt;Rep,Period&gt; remaining_time=
        end-internal_clock::now();
    if(wait_for(lock,remaining_time)==std::cv_status::timeout)
        return pred();
}
return true;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if the most recent call to <kbd class="calibre17">pred()</kbd> returned <kbd class="calibre17">true</kbd>, <kbd class="calibre17">false</kbd> if the time period specified by <kbd class="calibre17">relative_time</kbd> has elapsed and <kbd class="calibre17">pred()</kbd> returned <kbd class="calibre17">false</kbd>.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note11">Note</h5>
      
      
      <p class="noindclose">The potential for spurious wakeups means that it’s unspecified how many times <kbd class="calibre17">pred</kbd> will be called. <kbd class="calibre17">pred</kbd> will always be invoked with the mutex referenced by <kbd class="calibre17">lock</kbd> locked, and the function shall return if (and only if) an evaluation of <kbd class="calibre17">(bool)pred()</kbd> returns <kbd class="calibre17">true</kbd> or the time period specified by <kbd class="calibre17">relative_time</kbd> has elapsed. The thread may be blocked for longer than the specified duration. Where possible, the elapsed time is determined
         by a steady clock.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exception thrown by a call to <kbd class="calibre17">pred</kbd>, or <kbd class="calibre17">std::system_error</kbd> if the effects couldn’t be achieved.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable_any</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will only wake threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec68"><a id="app04lev3sec68__title" class="calibre4"></a>std::condition_variable_any::wait_until member function
      </h5>
      
      <p class="noind"><a id="iddle1796" class="calibre4"></a><a id="iddle2116" class="calibre4"></a>Waits until <kbd class="calibre17">std::condition_variable_any</kbd> is notified by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd>, until a specified time has been reached, or the thread is woken spuriously.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Lockable,typename Clock,typename Duration&gt;
std::cv_status wait_until(
    Lockable&amp; lock,
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">Lockable</kbd> meets the <kbd class="calibre17">Lockable</kbd> requirements, and <kbd class="calibre17">lock</kbd> owns a lock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically unlocks the supplied <kbd class="calibre17">lock</kbd> object and block until the thread is woken by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> by another thread, <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd>, or the thread is woken spuriously. The <kbd class="calibre17">lock</kbd> object is locked again before the call to <kbd class="calibre17">wait_until()</kbd> returns.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">std::cv_status::no_timeout</kbd> if the thread was woken by a call to <kbd class="calibre17">notify_one()</kbd>, a call to <kbd class="calibre17">notify_all()</kbd>, or a spurious wakeup, <kbd class="calibre17">std::cv_status::timeout</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            <kbd class="calibre17">std::system_error</kbd> if the effects can’t be achieved. If the <kbd class="calibre17">lock</kbd> object is unlocked during the call to <kbd class="calibre17">wait_until()</kbd>, it’s locked again on exit, even if the function exits via an exception.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note12">Note</h5>
      
      
      <p class="noindclose">The spurious wakeups mean that a thread calling <kbd class="calibre17">wait_until()</kbd> may wake even though no thread has called <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd>. It’s therefore recommended that the overload of <kbd class="calibre17">wait_until()</kbd> that takes a predicate is used in preference where possible. Otherwise, it’s recommended that <kbd class="calibre17">wait_until()</kbd> be called in a loop that tests the predicate associated with the condition variable. There’s no guarantee as to how long
         the calling thread will be blocked, only that if the function returns <kbd class="calibre17">false</kbd>, then <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd> at the point at which the thread became unblocked.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_for()</kbd>, and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable_any</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will only wake threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec69"><a id="app04lev3sec69__title" class="calibre4"></a>std::condition_variable_any::wait_until member function overload -  that takes a predicate
      </h5>
      
      <p class="noind">Waits until <kbd class="calibre17">std::condition_variable_any</kbd> is woken by a call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> and the predicate is <kbd class="calibre17">true</kbd>, or until the specified time has been reached.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Lockable,typename Clock,
    typename Duration, typename Predicate&gt;
bool wait_until(
    Lockable&amp; lock,
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time,
    Predicate pred);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1045" class="calibre4"></a><a id="iddle1087" class="calibre4"></a><i class="calibre6">Preconditions</i>
            The expression <kbd class="calibre17">pred()</kbd> shall be valid, and shall return a value that’s convertible to <kbd class="calibre17">bool</kbd>. <kbd class="calibre17">Lockable</kbd> meets the <kbd class="calibre17">Lockable</kbd> requirements, and <kbd class="calibre17">lock</kbd> owns a lock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            As-if
            
            
            <div class="calibre15"></div><pre class="calibre5">while(!pred())
{
    if(wait_until(lock,absolute_time)==std::cv_status::timeout)
        return pred();
}
return true;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if the most recent call to <kbd class="calibre17">pred()</kbd> returned <kbd class="calibre17">true</kbd>, <kbd class="calibre17">false</kbd> if a call to <kbd class="calibre17">Clock:: now()</kbd> returned a time equal to or later than the time specified by <kbd class="calibre17">absolute_time</kbd>, and <kbd class="calibre17">pred()</kbd> returned <kbd class="calibre17">false</kbd>.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note13">Note</h5>
      
      
      <p class="noindclose">The potential for spurious wakeups means that it’s unspecified how many times <kbd class="calibre17">pred</kbd> will be called. <kbd class="calibre17">pred</kbd> will always be invoked with the mutex referenced by <kbd class="calibre17">lock</kbd> locked, and the function shall return if (and only if) an evaluation of <kbd class="calibre17">(bool)pred()</kbd> returns <kbd class="calibre17">true</kbd> or <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd>. There’s no guarantee as to how long the calling thread will be blocked, only that if the function returns <kbd class="calibre17">false</kbd>, then <kbd class="calibre17">Clock:: now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd> at the point at which the thread became unblocked.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exception thrown by a call to <kbd class="calibre17">pred</kbd>, or <kbd class="calibre17">std::system_error</kbd> if the effects couldn’t be achieved.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Calls to <kbd class="calibre17">notify_one()</kbd>, <kbd class="calibre17">notify_all()</kbd>, <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">wait_until()</kbd>, and <kbd class="calibre17">wait_until()</kbd> on a single <kbd class="calibre17">std::condition_variable_any</kbd> instance are serialized. A call to <kbd class="calibre17">notify_one()</kbd> or <kbd class="calibre17">notify_all()</kbd> will only wake threads that started waiting <i class="calibre6">prior</i> to that call.
         </li>
         
      </ul>
      
      
      
      
      
      <h3 id="app04lev1sec3" class="chapter"><a id="app04lev1sec3__title" class="calibre3"></a>D.3. &lt;atomic&gt; header
      </h3>
      
      <p class="noind">The <kbd class="calibre17">&lt;atomic&gt;</kbd> header provides the set of basic atomic types and operations on those types and a class template for constructing an atomic
         version of a user-defined type that meets certain criteria.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Header contents</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">#define ATOMIC_BOOL_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_CHAR_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_SHORT_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_INT_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_LONG_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_LLONG_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_CHAR16_T_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_CHAR32_T_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_WCHAR_T_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_POINTER_LOCK_FREE <i class="calibre6">see description</i>

#define ATOMIC_VAR_INIT(value) <i class="calibre6">see description</i>

namespace std
{
    enum memory_order;

    struct atomic_flag;
    typedef <i class="calibre6">see description</i> atomic_bool;
    typedef <i class="calibre6">see description</i> atomic_char;
    typedef <i class="calibre6">see description</i> atomic_char16_t;
    typedef <i class="calibre6">see description</i> atomic_char32_t;
    typedef <i class="calibre6">see description</i> atomic_schar;
    typedef <i class="calibre6">see description</i> atomic_uchar;
    typedef <i class="calibre6">see description</i> atomic_short;
    typedef <i class="calibre6">see description</i> atomic_ushort;
    typedef <i class="calibre6">see description</i> atomic_int;
    typedef <i class="calibre6">see description</i> atomic_uint;
    typedef <i class="calibre6">see description</i> atomic_long;
    typedef <i class="calibre6">see description</i> atomic_ulong;
    typedef <i class="calibre6">see description</i> atomic_llong;
    typedef <i class="calibre6">see description</i> atomic_ullong;
    typedef <i class="calibre6">see description</i> atomic_wchar_t;

    typedef <i class="calibre6">see description</i> atomic_int_least8_t;
    typedef <i class="calibre6">see description</i> atomic_uint_least8_t;
    typedef <i class="calibre6">see description</i> atomic_int_least16_t;
    typedef <i class="calibre6">see description</i> atomic_uint_least16_t;
    typedef <i class="calibre6">see description</i> atomic_int_least32_t;
    typedef <i class="calibre6">see description</i> atomic_uint_least32_t;
    typedef <i class="calibre6">see description</i> atomic_int_least64_t;
    typedef <i class="calibre6">see description</i> atomic_uint_least64_t;
    typedef <i class="calibre6">see description</i> atomic_int_fast8_t;
    typedef <i class="calibre6">see description</i> atomic_uint_fast8_t;
    typedef <i class="calibre6">see description</i> atomic_int_fast16_t;
    typedef <i class="calibre6">see description</i> atomic_uint_fast16_t;
    typedef <i class="calibre6">see description</i> atomic_int_fast32_t;
    typedef <i class="calibre6">see description</i> atomic_uint_fast32_t;
    typedef <i class="calibre6">see description</i> atomic_int_fast64_t;
    typedef <i class="calibre6">see description</i> atomic_uint_fast64_t;
    typedef <i class="calibre6">see description</i> atomic_int8_t;
    typedef <i class="calibre6">see description</i> atomic_uint8_t;
    typedef <i class="calibre6">see description</i> atomic_int16_t;
    typedef <i class="calibre6">see description</i> atomic_uint16_t;
    typedef <i class="calibre6">see description</i> atomic_int32_t;
    typedef <i class="calibre6">see description</i> atomic_uint32_t;
    typedef <i class="calibre6">see description</i> atomic_int64_t;
    typedef <i class="calibre6">see description</i> atomic_uint64_t;
    typedef <i class="calibre6">see description</i> atomic_intptr_t;
    typedef <i class="calibre6">see description</i> atomic_uintptr_t;
    typedef <i class="calibre6">see description</i> atomic_size_t;
    typedef <i class="calibre6">see description</i> atomic_ssize_t;
    typedef <i class="calibre6">see description</i> atomic_ptrdiff_t;
    typedef <i class="calibre6">see description</i> atomic_intmax_t;
    typedef <i class="calibre6">see description</i> atomic_uintmax_t;

    template&lt;typename T&gt;
    struct atomic;

    extern "C" void atomic_thread_fence(memory_order order);
    extern "C" void atomic_signal_fence(memory_order order);

    template&lt;typename T&gt;
    T kill_dependency(T);
}</pre>
            </li>
         
      </ul>
      
      
      <h4 id="app04lev2sec8" class="calibre23">D.3.1. <a id="app04lev2sec8__title" class="calibre4"></a>std::atomic_xxx typedefs
      </h4>
      
      <p class="noind"><a id="iddle1053" class="calibre4"></a><a id="iddle2030" class="calibre4"></a>For compatibility with the forthcoming C Standard, typedefs for the atomic integral types are provided. For C++17, these must
         be typedefs to the corresponding <kbd class="calibre17">std:: atomic&lt;T&gt;</kbd> specialization; for prior C++ standards, they may instead be a base class of that specialization with the same interface.
      </p>
      
      <h5 class="notetitle" id="app04table01">Table D.1. <a id="app04table01__title" class="calibre4"></a>Atomic typedefs and their corresponding <kbd class="calibre17">std::atomic&lt;&gt;</kbd> specializations
      </h5>
      <table cellspacing="5" frame="hsides" rules="groups" cellpadding="8" width="100%" class="calibre25">
         <colgroup span="2" class="calibre8">
            <col width="300" class="calibre9"/>
            <col width="300" class="calibre9"/>
         </colgroup>
         <thead class="calibre26">
            <tr class="calibre11">
               <th class="doctablecell1" scope="col" valign="top">
                  <p class="noind">std::atomic_itype</p>
               </th>
               <th class="doctablecell1" scope="col" valign="top">
                  <p class="noind">std::atomic&lt;&gt; specialization</p>
               </th>
            </tr>
         </thead>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="doctablecell">std::atomic_char</td>
               <td class="doctablecell">std::atomic&lt;char&gt;</td>
            </tr>
            <tr class="calibre11">
               <td class="doctablecell">std::atomic_schar</td>
               <td class="doctablecell">std::atomic&lt;signed char&gt;</td>
            </tr>
            <tr class="calibre11">
               <td class="doctablecell">std::atomic_uchar</td>
               <td class="doctablecell">std::atomic&lt;unsigned char&gt;</td>
            </tr>
            <tr class="calibre11">
               <td class="doctablecell">std::atomic_short</td>
               <td class="doctablecell">std::atomic&lt;short&gt;</td>
            </tr>
            <tr class="calibre11">
               <td class="doctablecell">std::atomic_ushort</td>
               <td class="doctablecell">std::atomic&lt;unsigned short&gt;</td>
            </tr>
            <tr class="calibre11">
               <td class="doctablecell">std::atomic_int</td>
               <td class="doctablecell">std::atomic&lt;int&gt;</td>
            </tr>
            <tr class="calibre11">
               <td class="doctablecell">std::atomic_uint</td>
               <td class="doctablecell">std::atomic&lt;unsigned int&gt;</td>
            </tr>
            <tr class="calibre11">
               <td class="doctablecell">std::atomic_long</td>
               <td class="doctablecell">std::atomic&lt;long&gt;</td>
            </tr>
            <tr class="calibre11">
               <td class="doctablecell">std::atomic_ulong</td>
               <td class="doctablecell">std::atomic&lt;unsigned long&gt;</td>
            </tr>
            <tr class="calibre11">
               <td class="doctablecell">std::atomic_llong</td>
               <td class="doctablecell">std::atomic&lt;long long&gt;</td>
            </tr>
            <tr class="calibre11">
               <td class="doctablecell">std::atomic_ullong</td>
               <td class="doctablecell">std::atomic&lt;unsigned long long&gt;</td>
            </tr>
            <tr class="calibre11">
               <td class="doctablecell">std::atomic_wchar_t</td>
               <td class="doctablecell">std::atomic&lt;wchar_t&gt;</td>
            </tr>
            <tr class="calibre11">
               <td class="doctablecell">std::atomic_char16_t</td>
               <td class="doctablecell">std::atomic&lt;char16_t&gt;</td>
            </tr>
            <tr class="calibre11">
               <td class="doctablecell">std::atomic_char32_t</td>
               <td class="doctablecell">std::atomic&lt;char32_t&gt;</td>
            </tr>
         </tbody>
      </table>
      
      
      
      
      <h4 id="app04lev2sec9" class="calibre23">D.3.2. <a id="app04lev2sec9__title" class="calibre4"></a>ATOMIC_xxx_LOCK_FREE macros
      </h4>
      
      <p class="noind"><a id="iddle1046" class="calibre4"></a><a id="iddle1059" class="calibre4"></a>These macros specify whether the atomic types corresponding to particular built-in types are lock-free.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Macro declarations</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">#define ATOMIC_BOOL_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_CHAR_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_SHORT_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_INT_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_LONG_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_LLONG_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_CHAR16_T_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_CHAR32_T_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_WCHAR_T_LOCK_FREE <i class="calibre6">see description</i>
#define ATOMIC_POINTER_LOCK_FREE <i class="calibre6">see description</i></pre>
            
            The value of <kbd class="calibre17">ATOMIC_xxx_LOCK_FREE</kbd> is either 0, 1, or 2. A value of 0 means that operations on both the signed and unsigned atomic types corresponding to the
            named type are never lock-free, a value of 1 means that the operations may be lock-free for particular instances of those
            types and not for others, and a value of 2 means that the operations are always lock-free. For example, if <kbd class="calibre17">ATOMIC_INT_LOCK_FREE</kbd> is 2, operations on instances of <kbd class="calibre17">std::atomic&lt;int&gt;</kbd> and <kbd class="calibre17">std::atomic &lt;unsigned&gt;</kbd> are always lock-free.
            The <kbd class="calibre17">ATOMIC_POINTER_LOCK_FREE</kbd> macro describes the lock-free property of operations on the atomic pointer specializations <kbd class="calibre17">std::atomic&lt;T*&gt;</kbd>.
         </li>
         
      </ul>
      
      
      
      <h4 id="app04lev2sec10" class="calibre23">D.3.3. <a id="app04lev2sec10__title" class="calibre4"></a>ATOMIC_VAR_INIT macro
      </h4>
      
      <p class="noind">The <kbd class="calibre17">ATOMIC_VAR_INIT</kbd> macro provides a means of initializing an atomic variable to a particular value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">#define ATOMIC_VAR_INIT(value) <i class="calibre6">see description</i></pre>
            
            The macro expands to a token sequence that can be used to initialize one of the standard atomic types with the specified value
            in an expression of the following form:
            
            <div class="calibre15"></div><pre class="calibre5">std::atomic&lt;<i class="calibre6">type</i>&gt; x = ATOMIC_VAR_INIT(val);</pre>
            
            The specified value must be compatible with the nonatomic type corresponding to the atomic variable; for example:
            
            <div class="calibre15"></div><pre class="calibre5">std::atomic&lt;int&gt; i = ATOMIC_VAR_INIT(42);
std::string s;
std::atomic&lt;std::string*&gt; p = ATOMIC_VAR_INIT(&amp;s);</pre>
            
            This initialization is not atomic, and any access by another thread to the variable being initialized where the initialization
            doesn’t happen-before that access is a data race and thus undefined behavior.</li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec11" class="calibre23">D.3.4. <a id="app04lev2sec11__title" class="calibre4"></a>std::memory_order enumeration
      </h4>
      
      <p class="noind"><a id="iddle1052" class="calibre4"></a><a id="iddle1054" class="calibre4"></a><a id="iddle2029" class="calibre4"></a><a id="iddle2180" class="calibre4"></a><a id="iddle2181" class="calibre4"></a><a id="iddle2183" class="calibre4"></a><a id="iddle2185" class="calibre4"></a><a id="iddle2186" class="calibre4"></a><a id="iddle2187" class="calibre4"></a>The <kbd class="calibre17">std::memory_order</kbd> enumeration is used to specify the ordering constraints of atomic operations.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">typedef enum memory_order
{
    memory_order_relaxed,memory_order_consume,
    memory_order_acquire,memory_order_release,
    memory_order_acq_rel,memory_order_seq_cst
} memory_order;</pre>
            
            Operations tagged with the various memory order values behave as follows (see <a href="kindle_split_015.html#ch05" class="calibre4">chapter 5</a> for detailed descriptions of the ordering constraints).
         </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec70"><a id="app04lev3sec70__title" class="calibre4"></a>std::memory_order_relaxed
      </h5>
      
      <p class="noind">The operation doesn’t provide any additional ordering constraints.</p>
      
      
      
      <h5 class="notetitle" id="app04lev3sec71"><a id="app04lev3sec71__title" class="calibre4"></a>std::memory_order_release
      </h5>
      
      <p class="noind">The operation is a release operation on the specified memory location. This therefore synchronizes-with an acquire operation
         on the same memory location that reads the stored value.
      </p>
      
      
      
      <h5 class="notetitle" id="app04lev3sec72"><a id="app04lev3sec72__title" class="calibre4"></a>std::memory_order_acquire
      </h5>
      
      <p class="noind">The operation is an acquire operation on the specified memory location. If the stored value was written by a release operation,
         that store synchronizes-with this operation.
      </p>
      
      
      
      <h5 class="notetitle" id="app04lev3sec73"><a id="app04lev3sec73__title" class="calibre4"></a>std::memory_order_acq_rel
      </h5>
      
      <p class="noind">The operation must be a read-modify-write operation, and it behaves as both <kbd class="calibre17">std:: memory_order_acquire</kbd> and <kbd class="calibre17">std::memory_order_release</kbd> on the specified location.
      </p>
      
      
      
      <h5 class="notetitle" id="app04lev3sec74"><a id="app04lev3sec74__title" class="calibre4"></a>std::memory_order_seq_cst
      </h5>
      
      <p class="noind">The operation forms part of the single global total order of sequentially consistent operations. In addition, if it’s a store,
         it behaves like an <kbd class="calibre17">std::memory_order_release</kbd> operation; if it’s a load, it behaves like an <kbd class="calibre17">std::memory_order_acquire</kbd> operation; and if it’s a read-modify-write operation, it behaves as both <kbd class="calibre17">std::memory_order_acquire</kbd> and <kbd class="calibre17">std::memory_order_release</kbd>. This is the default for all operations.
      </p>
      
      
      
      <h5 class="notetitle" id="app04lev3sec75"><a id="app04lev3sec75__title" class="calibre4"></a>std::memory_order_consume
      </h5>
      
      <p class="noind">The operation is a consume operation on the specified memory location. The C++17 Standard states that this memory ordering
         should not be used.
      </p>
      
      
      
      
      <h4 id="app04lev2sec12" class="calibre23">D.3.5. <a id="app04lev2sec12__title" class="calibre4"></a>std::atomic_thread_fence function
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::atomic_thread_fence()</kbd> function inserts a “memory barrier” or “fence” in the code to force memory-ordering constraints between operations.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">extern "C" void atomic_thread_fence(std::memory_order order);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1050" class="calibre4"></a><a id="iddle1051" class="calibre4"></a><a id="iddle1985" class="calibre4"></a><a id="iddle2016" class="calibre4"></a><i class="calibre6">Effects</i>
            Inserts a fence with the required memory-ordering constraints.
            A fence with an <kbd class="calibre17">order</kbd> of <kbd class="calibre17">std::memory_order_release</kbd>, <kbd class="calibre17">std::memory_order_acq_rel</kbd>, or <kbd class="calibre17">std::memory_order_seq_cst</kbd> synchronizes-with an acquire operation on the same memory location if that acquire operation reads a value stored by an atomic
            operation following the fence on the same thread as the fence.
            A release operation synchronizes-with a fence with an <kbd class="calibre17">order</kbd> of <kbd class="calibre17">std::memory_order_acquire</kbd>, <kbd class="calibre17">std::memory_order_acq_rel</kbd>, or <kbd class="calibre17">std::memory_order_seq_cst</kbd> if that release operation stores a value that’s read by an atomic operation prior to the fence on the same thread as the
            fence.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h4 id="app04lev2sec13" class="calibre23">D.3.6. <a id="app04lev2sec13__title" class="calibre4"></a>std::atomic_signal_fence function
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::atomic_signal_fence()</kbd> function inserts a memory barrier or fence in the code to force memory ordering constraints between operations on a thread
         and operations in a signal handler on that thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">extern "C" void atomic_signal_fence(std::memory_order order);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Inserts a fence with the required memory-ordering constraints. This is equivalent to <kbd class="calibre17">std::atomic_thread_fence(order)</kbd> except that the constraints apply only between a thread and a signal handler on the same thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h4 id="app04lev2sec14" class="calibre23">D.3.7. <a id="app04lev2sec14__title" class="calibre4"></a>std::atomic_flag class
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::atomic_flag</kbd> class provides a simple bare-bones atomic flag. It’s the only data type that’s guaranteed to be lock-free by the C++11 Standard
         (although many atomic types will be lock-free in most implementations).
      </p>
      
      <p class="noind">An instance of <kbd class="calibre17">std::atomic_flag</kbd> is either <i class="calibre6">set</i> or <i class="calibre6">clear</i>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">struct atomic_flag
{
    atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&amp;) = delete;
    atomic_flag&amp; operator=(const atomic_flag&amp;) = delete;
    atomic_flag&amp; operator=(const atomic_flag&amp;) volatile = delete;

    bool test_and_set(memory_order = memory_order_seq_cst) volatile
     noexcept;
    bool test_and_set(memory_order = memory_order_seq_cst) noexcept;
    void clear(memory_order = memory_order_seq_cst) volatile noexcept;
    void clear(memory_order = memory_order_seq_cst) noexcept;
};

bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
bool atomic_flag_test_and_set(atomic_flag*) noexcept;
bool atomic_flag_test_and_set_explicit(
    volatile atomic_flag*, memory_order) noexcept;
bool atomic_flag_test_and_set_explicit(
    atomic_flag*, memory_order) noexcept;
void atomic_flag_clear(volatile atomic_flag*) noexcept;
void atomic_flag_clear(atomic_flag*) noexcept;
void atomic_flag_clear_explicit(
    volatile atomic_flag*, memory_order) noexcept;
void atomic_flag_clear_explicit(
    atomic_flag*, memory_order) noexcept;

#define ATOMIC_FLAG_INIT <i class="calibre6">unspecified</i></pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec76"><a id="app04lev3sec76__title" class="calibre4"></a>std::atomic_flag default constructor
      </h5>
      
      <p class="noind"><a id="iddle1055" class="calibre4"></a><a id="iddle1465" class="calibre4"></a><a id="iddle1986" class="calibre4"></a><a id="iddle1987" class="calibre4"></a><a id="iddle1992" class="calibre4"></a>It’s unspecified whether a default-constructed instance of <kbd class="calibre17">std::atomic_flag</kbd> is clear or set. For objects of static storage duration, initialization shall be static initialization.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">std::atomic_flag() noexcept = default;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs a new <kbd class="calibre17">std::atomic_flag</kbd> object in an unspecified state.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      </body></html>
