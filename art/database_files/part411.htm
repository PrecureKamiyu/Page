<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Practice Exercises</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part410.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part412.htm">下一个 &gt;</a></p><p class="s45" style="padding-top: 4pt;padding-left: 73pt;text-indent: 0pt;text-align: left;">Practice Exercises</p><p class="s46" style="padding-top: 12pt;padding-left: 156pt;text-indent: -30pt;text-align: left;">22.1  <span class="p">What form of parallelism (interquery, interoperation, or intraoperation) is likely to be the most important for each of the following tasks?</span></p><p style="padding-top: 8pt;padding-left: 163pt;text-indent: 0pt;text-align: justify;">a. Increasing the throughput of a system with many small queries</p><p style="padding-top: 6pt;padding-left: 182pt;text-indent: -19pt;text-align: justify;">b.  Increasing the throughput of a system with a few large queries when the number of disks and processors is large</p><p class="s46" style="padding-top: 8pt;padding-left: 125pt;text-indent: 0pt;text-align: left;">22.2 <span class="p">Describe how partial aggregation can be implemented for the </span>count <span class="p">and </span>avg</p><p style="padding-left: 156pt;text-indent: 0pt;text-align: left;">aggregate functions to reduce data transfer.</p><p class="s46" style="padding-top: 6pt;padding-left: 156pt;text-indent: -31pt;text-align: left;">22.3  <span class="p">With pipelined parallelism, it is often a good idea to perform several operations in a pipeline on a single processor, even when many processors are available.</span></p><p style="padding-top: 8pt;padding-left: 163pt;text-indent: 0pt;text-align: justify;">a. Explain why.</p><p style="padding-top: 6pt;padding-left: 182pt;text-indent: -19pt;text-align: justify;">b.  Would the arguments you advanced in part <i>a </i>hold if the machine has a shared-memory architecture? Explain why or why not.</p><p style="padding-top: 6pt;padding-left: 182pt;text-indent: -18pt;text-align: justify;">c.  Would the arguments in part <i>a </i>hold with independent parallelism? (That is, are there cases where, even if the operations are not pipelined and there are many processors available, it is still a good idea to perform several operations on the same processor?)</p><p class="s13" style="padding-top: 9pt;padding-left: 156pt;text-indent: -31pt;line-height: 92%;text-align: justify;"><b>22.4  </b><span class="p">Consider join processing using symmetric fragment and replicate with range partitioning. How can you optimize the evaluation if the join condition is of the form </span><span class="s15">∣ </span>r<span class="s83">.</span>A <span class="s15">− </span>s<span class="s83">.</span>B <span class="s15">∣  </span><span class="s86">≤ </span>k<span class="p">, where </span>k <span class="p">is a small constant? Here, </span><span class="s15">∣ </span>x <span class="s15">∣ </span><span class="p">denotes</span></p><p style="padding-left: 156pt;text-indent: 0pt;line-height: 8pt;text-align: justify;">the absolute value of <i>x</i>. A join with such a join condition is called a <span class="s63">band join</span>.</p><p style="padding-top: 6pt;padding-left: 156pt;text-indent: -31pt;text-align: justify;"><b>22.5  </b>Suppose relation <i>r </i>is stored partitioned and indexed on <i>A</i>, and <i>s </i>is stored par- titioned and indexed on <i>B</i>. Consider the query:</p><p class="s109" style="padding-left: 184pt;text-indent: 0pt;text-align: left;">r<span class="s126">.</span>C <span class="s117">γ</span><span class="s119">count(</span>s<span class="s126">.</span>D<span class="s119">)</span><span class="s120">( (</span><span class="s117">σ</span>A<span class="s126">&gt;</span><span class="s119">5</span><span class="s120">(</span><span class="s121">r</span><span class="s122">)) </span><span class="s138">⋈</span>r<span class="s126">.</span>B<span class="s118">=</span>s<span class="s126">.</span>B <span class="s139">s </span><span class="s122">)</span></p><p style="padding-left: 182pt;text-indent: -18pt;text-align: justify;">a. Give a parallel query plan using the exchange operator, for computing the subtree of the query involving only the select and join operators.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 150pt;text-indent: -19pt;text-align: justify;">b. Now extend the above to compute the aggregate. Make sure to use pre- aggregation to minimize the data transfer.</p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: -18pt;text-align: justify;">c. Skew during aggregation is a serious problem. Explain how pre- aggregation as above can also signiﬁcantly reduce the eﬀect of skew dur- ing aggregation.</p><p style="padding-top: 10pt;padding-left: 124pt;text-indent: -31pt;line-height: 12pt;text-align: justify;"><b>22.6  </b>Suppose relation <i>r </i>is stored partitioned and indexed on <i>A</i>, and <i>s </i>is stored parti-</p><p class="s149" style="padding-top: 1pt;padding-left: 124pt;text-indent: 0pt;line-height: 69%;text-align: justify;"><span class="p">tioned and indexed on </span><span class="s13">B</span><span class="p">. Consider the join </span><span class="s13">r </span><span class="s86">⋈</span>r<span class="s167">.</span>B<span class="s136">=</span>s<span class="s167">.</span>B <span class="s168">s</span><span class="p">. Suppose </span><span class="s13">s </span><span class="p">is relatively small, but not small enough to make asymmetric fragment-and-replicate join</span></p><p style="padding-top: 1pt;padding-left: 124pt;text-indent: 0pt;text-align: justify;">the best choice, and <i>r </i>is large, with most <i>r </i>tuples not matching any <i>s </i>tuple. A hash-join can be performed but with a semijoin ﬁlter used to reduce the data transfer. Explain how semijoin ﬁltering using Bloom ﬁlters would work in this parallel join setting.</p><p class="s123" style="padding-top: 3pt;padding-left: 93pt;text-indent: 0pt;text-align: left;"><b>22.7  </b><span class="p">Suppose you want to compute </span><span class="s13">r </span><span class="s15">⟕</span>r<span class="s124">.</span>A<span class="s137">=</span>s<span class="s124">.</span>A<span class="s13"> s</span><span class="p">.</span></p><p class="s13" style="padding-top: 5pt;padding-left: 150pt;text-indent: -18pt;line-height: 70%;text-align: justify;"><span class="p">a. Suppose </span>s <span class="p">is a small relation, while </span>r <span class="p">is stored partitioned on </span>r<span class="s83">.</span>B<span class="p">. Give an eﬃcient parallel algorithm for computing the left outer join.</span></p><p class="s13" style="padding-top: 9pt;padding-left: 150pt;text-indent: -19pt;line-height: 76%;text-align: justify;"><span class="p">b.  Now suppose that </span>r <span class="p">is a small relation, and </span>s <span class="p">is a large relation, stored partitioned on attribute </span>s<span class="s83">.</span>B<span class="p">. Give an eﬃcient parallel algorithm for com- puting the above left outer join.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 124pt;text-indent: -31pt;line-height: 65%;text-align: justify;"><b>22.8 </b><span class="p">Suppose you want to compute </span><span class="s169">A</span><span class="s93">,</span><span class="s169">B</span><span class="s15">γ</span><span class="s123">sum</span><span class="s98">(</span><span class="s123">C</span><span class="s98">)</span><span class="p"> on a relation </span>s <span class="p">which is stored par- titioned on </span>s<span class="s83">.</span>B<span class="p">. Explain how you would do it eﬃciently, minimizing/avoiding repartitioning, if the number of distinct </span>s<span class="s83">.</span>B <span class="p">values is large, and the distribution of number of tuples with each </span>s<span class="s83">.</span>B <span class="p">value is relatively uniform.</span></p><p class="s46" style="padding-top: 3pt;padding-left: 124pt;text-indent: -31pt;text-align: justify;">22.9 <span class="p">MapReduce implementations provide fault tolerance, where you can reexecute only failed mappers or reducers. By default, a partitioned parallel join execu- tion would have to be rerun completely in case of even one node failure. It is possible to modify a parallel partitioned join execution to add fault tolerance in a manner similar to MapReduce, so failure of a node does not require full reexecution of the query, but only actions related to that node. Explain what needs to be done at the time of partitioning at the sending node and receiving node to do this.</span></p><p style="padding-top: 6pt;padding-left: 124pt;text-indent: -35pt;text-align: justify;"><b>22.10  </b>If a parallel data-store is used to store two relations <i>r </i>and <i>s </i>and we need to join <i>r </i>and <i>s</i>, it may be useful to maintain the join as a materialized view. What are the beneﬁts and overheads in terms of overall throughput, use of space, and response time to user queries?</p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -35pt;text-align: justify;">22.11 <span class="p">Explain how each of the following join algorithms can be implemented using the MapReduce framework:</span></p><p style="padding-top: 10pt;padding-left: 132pt;text-indent: 0pt;text-align: left;">a.  Broadcast join (also known as asymmetric fragment-and-replicate join).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 182pt;text-indent: -19pt;text-align: left;">b.  Indexed nested loop join, where the inner relation is stored in a parallel data-store.</p><p style="padding-top: 6pt;padding-left: 163pt;text-indent: 0pt;text-align: left;">c. Partitioned join.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part410.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part412.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
