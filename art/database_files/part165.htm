<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Exercises</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part164.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part166.htm">下一个 &gt;</a></p><p class="s45" style="padding-top: 4pt;padding-left: 67pt;text-indent: 0pt;text-align: left;">Exercises</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 120pt;text-indent: 0pt;text-align: justify;"><b>7.21  </b>Give a lossless decomposition into <span class="s44">BCNF </span>of schema <i>R </i>of Exercise 7.1.</p><p style="padding-top: 6pt;padding-left: 149pt;text-indent: -30pt;text-align: justify;"><b>7.22  </b>Give a lossless, dependency-preserving decomposition into <span class="s44">3NF </span>of schema <i>R </i>of Exercise 7.1.</p><p style="padding-top: 6pt;padding-left: 149pt;text-indent: -30pt;text-align: justify;"><b>7.23 </b>Explain what is meant by <i>repetition of information </i>and <i>inability to represent in- formation</i>. Explain why each of these properties may indicate a bad relational- database design.</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><b>7.24  </b>Why are certain functional dependencies called <i>trivial </i>functional dependencies?</p><p class="s46" style="padding-top: 6pt;padding-left: 149pt;text-indent: -30pt;text-align: justify;">7.25  <span class="p">Use the deﬁnition of functional dependency to argue that each of Armstrong’s axioms (reﬂexivity, augmentation, and transitivity) is sound.</span></p><p class="s15" style="padding-top: 7pt;padding-left: 149pt;text-indent: -30pt;line-height: 77%;text-align: justify;"><span class="s46">7.26  </span><span class="p">Consider the following proposed rule for functional dependencies: If </span>α <span class="s86">→ </span>β <span class="p">and </span>γ <span class="s86">→ </span>β<span class="p">, then </span>α <span class="s86">→ </span>γ<span class="p">. Prove that this rule is </span><span class="s13">not </span><span class="p">sound by showing a relation </span><span class="s13">r </span><span class="p">that satisﬁes </span>α <span class="s86">→ </span>β <span class="p">and </span>γ <span class="s86">→ </span>β<span class="p">, but does not satisfy </span>α <span class="s86">→ </span>γ<span class="p">.</span></p><p class="s46" style="padding-top: 4pt;padding-left: 120pt;text-indent: 0pt;text-align: justify;">7.27  <span class="p">Use Armstrong’s axioms to prove the soundness of the decomposition rule.</span></p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><b>7.28  </b>Using the functional dependencies of Exercise 7.6, compute <i>B</i><span class="s181">+</span>.</p><p style="padding-top: 6pt;padding-left: 149pt;text-indent: -30pt;text-align: justify;"><b>7.29  </b>Show that the following decomposition of the schema <i>R </i>of Exercise 7.1 is not a lossless decomposition:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 300pt;text-indent: 0pt;text-align: left;">(<i>A</i>, <i>B</i>, <i>C</i>)</p><p style="padding-left: 300pt;text-indent: 0pt;text-align: left;">(<i>C</i>, <i>D</i>, <i>E</i>).</p><p style="padding-top: 10pt;padding-left: 149pt;text-indent: 0pt;text-align: left;"><i>Hint</i>: Give an example of a relation <i>r </i>(<i>R</i>) such that <span class="s15">Π</span><i>A</i><span class="s98">,</span> <i>B</i><span class="s98">,</span> <i>C</i><i> </i>(<i>r</i>) <span class="s86">⋈ </span><span class="s15">Π</span><i>C</i><span class="s98">,</span> <i>D</i><span class="s98">,</span> <i>E</i><i> </i>(<i>r</i>) <span class="s86">≠ </span><i>r</i></p><p style="padding-top: 3pt;padding-left: 149pt;text-indent: -30pt;text-align: justify;"><b>7.30  </b>Consider the following set <i>F </i>of functional dependencies on the relation schema (<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>, <i>E</i>, <i>G</i>):</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 301pt;text-indent: 0pt;line-height: 77%;text-align: left;">A <span class="s86">→ </span>BCD BC <span class="s86">→ </span>DE</p><p class="s13" style="padding-left: 301pt;text-indent: 0pt;line-height: 77%;text-align: left;">B <span class="s86">→ </span>D D <span class="s86">→ </span>A</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 125pt;text-indent: 0pt;text-align: left;">a. Compute <i>B</i><span class="s181">+</span>.</p><p style="padding-top: 6pt;padding-left: 125pt;text-indent: 0pt;text-align: left;">b. Prove (using Armstrong’s axioms) that <i>AG </i>is a superkey.</p><p style="padding-top: 6pt;padding-left: 144pt;text-indent: -18pt;text-align: left;">c.  Compute a canonical cover for this set of functional dependencies <i>F </i>; give each step of your derivation with an explanation.</p><p style="padding-top: 6pt;padding-left: 144pt;text-indent: -19pt;text-align: left;">d.  Give a <span class="s44">3NF </span>decomposition of the given schema based on a canonical cover.</p><p style="padding-top: 6pt;padding-left: 125pt;text-indent: 0pt;text-align: left;">e.  Give a <span class="s44">BCNF </span>decomposition of the given schema using the original set <i>F</i></p><p style="padding-left: 144pt;text-indent: 0pt;text-align: left;">of functional dependencies.</p><p style="padding-top: 7pt;padding-left: 118pt;text-indent: -29pt;text-align: justify;"><b>7.31  </b>Consider the schema <i>R </i><span class="s15">= </span>(<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>, <i>E</i>, <i>G</i>) and the set <i>F </i>of functional depen- dencies:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 266pt;text-indent: 0pt;line-height: 15pt;text-align: left;">AB <span class="s86">→ </span>CD</p><p class="s13" style="padding-left: 266pt;text-indent: 0pt;line-height: 77%;text-align: left;">B <span class="s86">→ </span>D DE <span class="s86">→ </span>B</p><p class="s13" style="padding-left: 266pt;text-indent: 0pt;line-height: 77%;text-align: left;">DEG <span class="s86">→ </span>AB AC <span class="s86">→ </span>DE</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 118pt;text-indent: 0pt;line-height: 84%;text-align: justify;"><i>R </i>is not in <span class="s44">BCNF </span>for many reasons, one of which arises from the functional dependency <i>AB </i><span class="s86">→ </span><i>CD</i>. Explain why <i>AB </i><span class="s86">→ </span><i>CD </i>shows that <i>R </i>is not in <span class="s44">BCNF </span>and then use the <span class="s44">BCNF </span>decomposition algorithm starting with <i>AB </i><span class="s86">→ </span><i>CD </i>to generate a <span class="s44">BCNF </span>decomposition of <i>R</i>. Once that is done, determine whether</p><p style="padding-left: 118pt;text-indent: 0pt;text-align: justify;">your result is or is not dependency preserving, and explain your reasoning.</p><p style="padding-top: 6pt;padding-left: 118pt;text-indent: -30pt;text-align: justify;"><b>7.32  </b>Consider the schema <i>R </i><span class="s15">= </span>(<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>, <i>E</i>, <i>G</i>) and the set <i>F </i>of functional depen- dencies:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 269pt;text-indent: 0pt;line-height: 77%;text-align: justify;">A <span class="s86">→ </span>BC BD <span class="s86">→ </span>E CD <span class="s86">→ </span>AB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 144pt;text-indent: -18pt;text-align: justify;">a.  Find a nontrivial functional dependency containing no extraneous at- tributes that is logically implied by the above three dependencies and ex- plain how you found it.</p><p style="padding-top: 7pt;padding-left: 144pt;text-indent: -19pt;line-height: 90%;text-align: left;">b.  Use the <span class="s44">BCNF </span>decomposition algorithm to ﬁnd a <span class="s44">BCNF </span>decomposition of <i>R</i>. Start with <i>A </i><span class="s86">→ </span><i>BC</i>. Explain your steps.</p><p style="padding-top: 4pt;padding-left: 125pt;text-indent: 0pt;text-align: left;">c.  For your decomposition, state whether it is lossless and explain why.</p><p style="padding-top: 6pt;padding-left: 144pt;text-indent: -19pt;text-align: left;">d. For your decomposition, state whether it is dependency preserving and explain why.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 150pt;text-indent: -30pt;text-align: justify;"><b>7.33  </b>Consider the schema <i>R </i><span class="s15">= </span>(<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>, <i>E</i>, <i>G</i>) and the set <i>F </i>of functional depen- dencies:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 293pt;text-indent: 0pt;line-height: 77%;text-align: left;">AB <span class="s86">→ </span>CD ADE <span class="s86">→ </span>GDE B <span class="s86">→ </span>GC</p><p class="s13" style="padding-left: 293pt;text-indent: 0pt;line-height: 14pt;text-align: left;">G <span class="s86">→ </span>DE</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 149pt;text-indent: 0pt;text-align: justify;">Use the <span class="s44">3NF </span>decomposition algorithm to generate a <span class="s44">3NF </span>decomposition of <i>R</i>, and show your work. This means:</p><p style="padding-top: 7pt;padding-left: 157pt;text-indent: 0pt;text-align: left;">a. A list of all candidate keys</p><p style="padding-top: 6pt;padding-left: 175pt;text-indent: -19pt;text-align: left;">b. A canonical cover for <i>F </i>, along with an explanation of the steps you took to generate it</p><p style="padding-top: 6pt;padding-left: 157pt;text-indent: 0pt;text-align: left;">c. The remaining steps of the algorithm, with explanation</p><p style="padding-top: 6pt;padding-left: 156pt;text-indent: 0pt;text-align: left;">d. The ﬁnal decomposition</p><p style="padding-top: 8pt;padding-left: 149pt;text-indent: -30pt;text-align: justify;"><b>7.34  </b>Consider the schema <i>R </i><span class="s15">= </span>(<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>, <i>E</i>, <i>G</i>, <i>H </i>) and the set <i>F </i>of functional de- pendencies:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 296pt;text-indent: 0pt;line-height: 15pt;text-align: left;">AB <span class="s86">→ </span>CD</p><p class="s13" style="padding-left: 296pt;text-indent: 0pt;line-height: 77%;text-align: left;">D <span class="s86">→ </span>C DE <span class="s86">→ </span>B</p><p class="s13" style="padding-left: 296pt;text-indent: 0pt;line-height: 77%;text-align: left;">DEH <span class="s86">→ </span>AB AC <span class="s86">→ </span>DC</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 149pt;text-indent: 0pt;text-align: justify;">Use the <span class="s44">3NF </span>decomposition algorithm to generate a <span class="s44">3NF </span>decomposition of <i>R</i>, and show your work. This means:</p><p style="padding-top: 8pt;padding-left: 157pt;text-indent: 0pt;text-align: left;">a. A list of all candidate keys</p><p style="padding-top: 6pt;padding-left: 156pt;text-indent: 0pt;text-align: left;">b. A canonical cover for <i>F</i></p><p style="padding-top: 6pt;padding-left: 157pt;text-indent: 0pt;text-align: left;">c. The steps of the algorithm, with explanation</p><p style="padding-top: 6pt;padding-left: 156pt;text-indent: 0pt;text-align: left;">d. The ﬁnal decomposition</p><p style="padding-top: 8pt;padding-left: 150pt;text-indent: -30pt;text-align: justify;"><b>7.35  </b>Although the <span class="s44">BCNF </span>algorithm ensures that the resulting decomposition is loss- less, it is possible to have a schema and a decomposition that was not generated by the algorithm, that is in <span class="s44">BCNF</span>, and is not lossless. Give an example of such a schema and its decomposition.</p><p class="s46" style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">7.36 <span class="p">Show that every schema consisting of exactly two attributes must be in </span><span class="s44">BCNF</span></p><p style="padding-left: 150pt;text-indent: 0pt;text-align: justify;">regardless of the given set <i>F </i>of functional dependencies.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 118pt;text-indent: -29pt;text-align: justify;"><a name="bookmark146">7.37 </a><span class="p">List the three design goals for relational databases, and explain why each is desirable.</span><a name="bookmark174">&zwnj;</a></p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><b>7.38  </b>In designing a relational database, why might we choose a non-<span class="s44">BCNF </span>design?</p><p style="padding-top: 6pt;padding-left: 118pt;text-indent: -30pt;text-align: justify;"><b>7.39  </b>Given the three goals of relational database design, is there any reason to design a database schema that is in <span class="s44">2NF</span>, but is in no higher-order normal form? (See Exercise 7.19 for the deﬁnition of <span class="s44">2NF</span>.)</p><p class="s13" style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;line-height: 15pt;text-align: justify;"><b>7.40 </b><span class="p">Given a relational schema </span>r<span class="p">(</span>A<span class="p">, </span>B<span class="p">, </span>C<span class="p">, </span>D<span class="p">), does </span>A <span class="s86">→→ </span>BC <span class="p">logically imply </span>A <span class="s86">→→ </span>B</p><p class="s13" style="padding-left: 118pt;text-indent: 0pt;line-height: 15pt;text-align: justify;"><span class="p">and </span>A <span class="s86">→→ </span>C<span class="p">? If yes prove it, or else give a counter example.</span></p><p style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><b>7.41  </b>Explain why <span class="s44">4NF </span>is a normal form more desirable than <span class="s44">BCNF</span>.</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><b>7.42  </b>Normalize the following schema, with given constraints, to <span class="s44">4NF</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 189pt;text-indent: 0pt;text-align: left;">books<span class="p">(</span>accessionno<span class="p">, </span>isbn<span class="p">, </span>title<span class="p">, </span>author<span class="p">, </span>publisher<span class="p">) </span>users<span class="p">(</span>userid<span class="p">, </span>name<span class="p">, </span>deptid<span class="p">, </span>deptname<span class="p">) </span>accessionno <span class="s86">→ </span>isbn</p><p class="s13" style="padding-left: 189pt;text-indent: 0pt;line-height: 11pt;text-align: left;">isbn <span class="s86">→ </span>title</p><p class="s13" style="padding-left: 189pt;text-indent: 0pt;line-height: 77%;text-align: left;">isbn <span class="s86">→ </span>publisher isbn <span class="s86">→→ </span>author userid <span class="s86">→ </span>name userid <span class="s86">→ </span>deptid deptid <span class="s86">→ </span>deptname</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 118pt;text-indent: -30pt;text-align: justify;"><b>7.43 </b>Although <span class="s44">SQL </span>does not support functional dependency constraints, if the database system supports constraints on materialized views, and materialized views are maintained immediately, it is possible to enforce functional depen- dency constraints in <span class="s44">SQL</span>. Given a relation <i>r</i>(<i>A</i>, <i>B</i>, <i>C</i>), explain how constraints on materialized views can be used to enforce the functional dependency <i>B </i><span class="s86">→ </span><i>C</i>.</p><p style="padding-top: 3pt;padding-left: 118pt;text-indent: -30pt;text-align: justify;"><b>7.44  </b>Given two relations <i>r</i>(<i>A</i>, <i>B</i>, <i>validtime</i>) and <i>s</i>(<i>B</i>, <i>C</i>, <i>validtime</i>), where <i>validtime </i>de- notes the valid time interval, write an <span class="s44">SQL </span>query to compute the temporal nat- ural join of the two relations. You can use the &amp;&amp; operator to check if two intervals overlap and the <span class="s15">∗ </span>operator to compute the intersection of two inter- vals.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part164.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part166.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
