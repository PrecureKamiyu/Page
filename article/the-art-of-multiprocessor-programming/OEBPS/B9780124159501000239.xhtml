<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:mml="http://www.w3.org/1998/Math/MathML" lang="EN" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="default-style"/><title>The Art of Multiprocessor Programming</title><link href="Elsevier_eBook.css" rel="stylesheet" type="text/css"/><link href="math.css" rel="stylesheet" type="text/css"/><link href="media.css" media="only screen" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4f1c4a5b-a3e2-48ff-98f3-ff17812cd57a" name="Adept.expected.resource"/></head><body><section epub:type="chapter" role="doc-chapter"><div aria-label="Page 305" epub:type="pagebreak" id="page_305" role="doc-pagebreak"/><div id="CN"><a id="c0010tit1"/></div><header><hgroup><h1 class="chaptitle" id="c0010tit">Chapter 13: Concurrent hashing and natural parallelism</h1></hgroup><section epub:type="preamble"><div class="abstract"><h2 class="h1hd" id="ab0010"><a id="st0010"/>Abstract</h2><p class="abspara">This chapter studies concurrent hash table implementations. A hash table can use either closed or open addressing. Closed-address hashing allows the reuse or adaptation of concurrent data structures (most notably lists) from previous chapters, and can result in highly scalable, even lock-free algorithms. The chapter also shows how to craft highly scalable hash tables with open addressing.</p><p class="abspara">Any practical hash table must guarantee constant time overhead of insert, lookup, and remove operations, regardless of the number of elements it stores. This creates an additional challenge for concurrent hash tables: resizing is fundamental operation, but it is rare in practice. The chapter explores techniques that leverage quiescence to “stop-the-world” during a resize. It also presents the a lock-free closed-address hash table that allows resizing to proceed concurrently with other operations.</p></div></section><section id="ks0010"><h3 class="h2hd" id="st0015">Keywords</h3><p class="keywords">closed-address hashing; open-address hashing; resizable hash table; split-ordered list; cuckoo hashing; quiescence; stop-the-world</p></section></header><section><h2 class="h1hd" id="s0010"><a id="st0020"/>13.1 Introduction</h2><p class="textfl" id="p0010">In earlier chapters, we studied how to extract parallelism from data structures like queues, stacks, and counters, which seemed to provide few opportunities for parallelism. In this chapter we take the opposite approach. We study <i>concurrent hashing</i>, a problem that seems to be “naturally parallelizable” or, using a more technical term, <i>disjoint-access-parallel</i>, meaning that concurrent method calls are likely to access disjoint locations, implying that there is little need for synchronization.</p><p class="text" id="p0015">We study hashing in the context of <img alt="Image" height="9" src="images/B9780124159501000239/fx001.jpg" width="19"/> implementations. Recall that the <img alt="Image" height="9" src="images/B9780124159501000239/fx001.jpg" width="19"/> interface provides the following methods:</p><div><ul><li class="bulllist" id="u0010">•  <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(<i>x</i>) adds <i>x</i> to the set, and returns <i>true</i> if <i>x</i> was absent, and <i>false</i> otherwise;</li><li class="bulllist" id="u0015">•  <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>(<i>x</i>) removes <i>x</i> from the set, and returns <i>true</i> if <i>x</i> was present, and <i>false</i> otherwise; and</li><li class="bulllist" id="u0020">•  <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>(<i>x</i>) returns <i>true</i> if <i>x</i> is present, and <i>false</i> otherwise.</li></ul></div><p class="textfl"> In sequential programming, hashing is often used to implement these methods with constant average time complexity. In this chapter, we aim to do the same for concurrent <img alt="Image" height="9" src="images/B9780124159501000239/fx001.jpg" width="19"/> implementations. (By contrast, the <img alt="Image" height="9" src="images/B9780124159501000239/fx001.jpg" width="19"/> implementations of Chapter <a href="B9780124159501000197.xhtml">9</a> require time linear in the size of the set.) Although hashing seems naturally parallelizable, devising an effective concurrent hash-based <img alt="Image" height="9" src="images/B9780124159501000239/fx001.jpg" width="19"/> implementations is far from trivial.</p><p class="text" id="p0035">When designing <img alt="Image" height="9" src="images/B9780124159501000239/fx001.jpg" width="19"/> implementations, we should keep the following principle in mind: <i>We can buy more memory, but we cannot buy more time.</i> Between a fast algorithm that consumes more memory and a slower algorithm that consumes less memory, we tend to prefer the faster algorithm (within reason).</p><p class="text" id="p0040">A <i>hash set</i> (sometimes called a <i>hash table</i>) is an efficient way to implement a set. A hash set is typically implemented as an array, called the <i>table</i>. Each table entry is a reference to zero or more <i>items</i>. A <i>hash function</i> maps items to integers so that distinct items usually map to distinct values. (Java provides each object with a <img alt="Image" height="9" src="images/B9780124159501000239/fx005.jpg" width="52"/>() method that serves this purpose.) To add, remove, or test an item for membership, apply the hash function to the item (modulo the table size) to identify the table entry associated with that item. (We call this step <i>hashing</i> the item.)</p><p class="text" id="p0045">Any hash set algorithm must deal with <i>collisions</i>: what to do when distinct items hash to the same table entry. <i>Closed addressing</i> simply stores a set of items, traditionally called a <i>bucket</i>, at each entry. <i>Open addressing</i> attempts to find an alternative table entry for the item, for example by applying alternative hash functions.</p><p class="text" id="p0050"><span aria-label="Page 306" epub:type="pagebreak" id="page_306" role="doc-pagebreak"/>It is sometimes necessary to <i>resize</i> the table. In closed-address hash sets, buckets may become too large to search efficiently. In open-address hash sets, the table may become too full to find alternative table entries.</p><p class="text" id="p0055">Anecdotal evidence suggests that in most applications, sets are subject to the following distribution of method calls: 90% <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>(), 9% <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(), and 1% <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>() calls. As a practical matter, sets are more likely to grow than to shrink, so we focus here on <i>extensible hashing</i>, in which hash sets only grow (shrinking them is a problem for the exercises).</p></section><section><h2 class="h1hd" id="s0015"><a id="st0025"/>13.2 Closed-address hash sets</h2><p class="textfl" id="p0060">We start by defining a <i>base</i> hash set implementation common to all the concurrent closed-address hash sets we consider here. Later, we extend the base hash set with different synchronization mechanisms.</p><p class="text" id="p0065">The <img alt="Image" height="9" src="images/B9780124159501000239/fx006.jpg" width="93"/> class is an <i>abstract class</i>, that is, it does not implement all its methods. <a href="#f0010" id="cf0010">Fig. 13.1</a> shows its fields, constructor, and abstract methods. The <img alt="Image" height="8" src="images/B9780124159501000239/fx007.jpg" width="29"/>[] field is an array of buckets, each of which is a set implemented as a list. For convenience, we use <img alt="Image" height="11" src="images/B9780124159501000239/fx008.jpg" width="80"/>, which supports the standard sequential <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(), <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>(), and <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>() methods. We sometimes refer to the length of the <img alt="Image" height="8" src="images/B9780124159501000239/fx007.jpg" width="29"/>[] array, that is, the number of buckets in it, as its <i>capacity</i>. The <img alt="Image" height="9" src="images/B9780124159501000239/fx009.jpg" width="45"/> field stores the number of items in the set. The constructor takes the initial capacity of the table as an argument.</p><div class="pageavoid"><figure class="fig" id="f0010"><img alt="Image" height="257" src="images/B9780124159501000239/gr001.jpg" width="277"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.1</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx006.jpg" width="93"/> class: fields, constructor, and abstract methods.</div></figcaption></figure></div><p class="text" id="p0070"/><div class="boxg1" id="enun0010"><p class="b1num">Pragma 13.2.1 </p><div><p class="b1textfl" id="p0075">Here and elsewhere, we use the standard Java <img alt="Image" height="9" src="images/B9780124159501000239/fx010.jpg" width="45"/> interface (from package <span class="sans-serif">java.util</span>). A <img alt="Image" height="9" src="images/B9780124159501000239/fx010.jpg" width="45"/> is an ordered collection of <img alt="Image" height="9" src="images/B9780124159501000239/fx011.jpg" width="5"/> objects, where <img alt="Image" height="9" src="images/B9780124159501000239/fx011.jpg" width="5"/> is a type. It specifies many methods, of which we use the following: <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(<i>x</i>), which appends <i>x</i> to the end of the list; <img alt="Image" height="11" src="images/B9780124159501000239/fx012.jpg" width="19"/>(<i>i</i>), which returns (but does not remove) the item at position <i>i</i>; and <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>(<i>x</i>), which returns <i>true</i> if the list contains <i>x</i>.</p><p class="b1text" id="p0080">The <img alt="Image" height="9" src="images/B9780124159501000239/fx013.jpg" width="25"/> interface is implemented by many classes. Here, we use the <img alt="Image" height="11" src="images/B9780124159501000239/fx014.jpg" width="59"/> class for convenience.</p></div></div><p class="textfl"/><p class="text" id="p0085">The <i>abstract methods</i> of <img alt="Image" height="9" src="images/B9780124159501000239/fx006.jpg" width="93"/> class, which it does not implement, are: <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>(<i>x</i>), which acquires the locks necessary to manipulate item <i>x</i>; <img alt="Image" height="9" src="images/B9780124159501000239/fx016.jpg" width="45"/>(<i>x</i>), which releases them; <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>(), which doubles the capacity of the <img alt="Image" height="8" src="images/B9780124159501000239/fx007.jpg" width="29"/>[] array; and <img alt="Image" height="11" src="images/B9780124159501000239/fx018.jpg" width="39"/>(), which decides whether to resize. The <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>(<i>x</i>) method must be <i>reentrant</i>, meaning that if a thread that has already called <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>(<i>x</i>) makes the same call, then it will proceed without deadlocking with itself.</p><p class="text" id="p0090"><a href="#f0015" id="cf0015">Fig. 13.2</a> shows the <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>(<i>x</i>) and <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(<i>x</i>) methods of the <img alt="Image" height="9" src="images/B9780124159501000239/fx006.jpg" width="93"/> class. Each method first calls <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>(<i>x</i>) to perform the necessary synchronization and then enters a <img alt="Image" height="11" src="images/B9780124159501000239/fx019.jpg" width="19"/> block whose <img alt="Image" height="11" src="images/B9780124159501000239/fx020.jpg" width="46"/> block calls <img alt="Image" height="9" src="images/B9780124159501000239/fx016.jpg" width="45"/>(<i>x</i>). The <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>(<i>x</i>) method simply tests whether <i>x</i> is present in the associated bucket (line 21), while <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(<i>x</i>) adds <i>x</i> to the list if it is not already present (line 30).</p><div class="pageavoid"><figure class="fig" id="f0015"><img alt="Image" height="421" src="images/B9780124159501000239/gr002.jpg" width="313"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.2</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx006.jpg" width="93"/> class: the <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>() and <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>() methods hash the item to choose a bucket.</div></figcaption></figure></div><p class="text" id="p0095"><span aria-label="Page 307" epub:type="pagebreak" id="page_307" role="doc-pagebreak"/>How big should the bucket array be to ensure that method calls take constant expected time? Consider an <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(<i>x</i>) call. The first step, hashing <i>x</i> to determine the bucket, takes constant time. The second step, checking whether <i>x</i> is in the bucket, requires traversing the list. This traversal takes constant expected time only if the lists have constant expected length, so the table capacity should be proportional to the number of items in the set, that is, the size of the set. Because the set may vary in size over time, to ensure that method call times remain (more or less) constant, we must occasionally <i>resize</i> the table to ensure that list lengths remain (more or less) constant.</p><p class="text" id="p0100">We still need to decide <i>when</i> to resize the table, and how <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() synchronizes with other methods. There are many reasonable alternatives. For closed-addressing algorithms, one simple strategy is to resize the table when the average bucket size exceeds a fixed threshold. An alternative policy employs two fixed quantities, the <i>bucket threshold</i> and the <i>global threshold</i>; we resize the table</p><div><ul><li class="bulllist" id="u0025">•  if more than, say, a quarter of the buckets exceed the bucket threshold, or</li><li class="bulllist" id="u0030">•  if any single bucket exceeds the global threshold.</li></ul></div><p class="textfl"> Either of these strategies work can well in practice. For simplicity, we adopt the first policy in this chapter.<sup><a epub:type="noteref" href="#fn001" id="cf0020" role="doc-noteref">1</a></sup><span aria-label="Page 308" epub:type="pagebreak" id="page_308" role="doc-pagebreak"/></p><section><h3 class="h2hd" id="s0020"><a id="st0030"/>13.2.1 A coarse-grained hash set</h3><p class="textfl" id="p0115"><a href="#f0020" id="cf0025">Fig. 13.3</a> shows the <img alt="Image" height="9" src="images/B9780124159501000239/fx022.jpg" width="106"/> class's fields, constructor, and <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>(<i>x</i>) and <img alt="Image" height="9" src="images/B9780124159501000239/fx016.jpg" width="45"/>(<i>x</i>) methods. The constructor first initializes its superclass (line 4). Synchronization is provided by a single reentrant lock (line 2), acquired by <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>(<i>x</i>) (line 8) and released by <img alt="Image" height="9" src="images/B9780124159501000239/fx016.jpg" width="45"/>(<i>x</i>) (line 11).</p><div class="pageavoid"><figure class="fig" id="f0020"><img alt="Image" height="224" src="images/B9780124159501000239/gr003.jpg" width="340"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.3</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx022.jpg" width="106"/> class: fields, constructor, and <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>() and <img alt="Image" height="9" src="images/B9780124159501000239/fx016.jpg" width="45"/>() methods.</div></figcaption></figure></div><p class="text" id="p0120"><a href="#f0025" id="cf0030">Fig. 13.4</a> shows the <img alt="Image" height="9" src="images/B9780124159501000239/fx022.jpg" width="106"/> class's <img alt="Image" height="11" src="images/B9780124159501000239/fx018.jpg" width="39"/>() and <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() methods. We use a simple policy: We resize when the average bucket length exceeds 4 (line 16). The <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() method locks the set (line 19), and checks that no other thread has resized the table in the meantime (line 22). It then allocates and initializes a new table with double the capacity (lines 24–28) and transfers items from the old to the new buckets (lines 29–33). Finally, it unlocks the set (line 35).</p><div class="pageavoid"><figure class="fig" id="f0025"><img alt="Image" height="372" src="images/B9780124159501000239/gr004.jpg" width="329"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.4</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx022.jpg" width="106"/> class: the <img alt="Image" height="11" src="images/B9780124159501000239/fx018.jpg" width="39"/>() and <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() methods.</div></figcaption></figure></div><p class="text" id="p0125">Like the coarse-grained list studied in Chapter <a href="B9780124159501000197.xhtml">9</a>, the coarse-grained hash set is easy to understand and easy to implement. Unfortunately, it is also a sequential bottleneck. Method calls take effect in a one-at-a-time order, even when they access separate buckets (and do not resize).<span aria-label="Page 309" epub:type="pagebreak" id="page_309" role="doc-pagebreak"/><span aria-label="Page 310" epub:type="pagebreak" id="page_310" role="doc-pagebreak"/></p></section><section><h3 class="h2hd" id="s0025"><a id="st0035"/>13.2.2 A striped hash set</h3><p class="textfl" id="p0130">We now present a closed-address hash table with greater parallelism and less lock contention. Instead of using a single lock to synchronize the entire set, we split the set into independently synchronized pieces. We introduce a technique called <i>lock striping</i>, which will be useful for other data structures as well. <a href="#f0030" id="cf0035">Fig. 13.5</a> shows the fields and constructor for the <img alt="Image" height="11" src="images/B9780124159501000239/fx023.jpg" width="113"/> class. The set is initialized with an array <img alt="Image" height="8" src="images/B9780124159501000239/fx024.jpg" width="29"/>[] of <i>L</i> locks, and an array <img alt="Image" height="8" src="images/B9780124159501000239/fx007.jpg" width="29"/>[] of <span class="hiddenClass"><mml:math><mml:mi>N</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>L</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000239/si1.png" style="vertical-align:middle" width="45"/></span> buckets, where each bucket is an unsynchronized <img alt="Image" height="9" src="images/B9780124159501000239/fx010.jpg" width="45"/>. Although these arrays are initially of the same length, <img alt="Image" height="8" src="images/B9780124159501000239/fx007.jpg" width="29"/>[] will grow when the hash table is resized, but <img alt="Image" height="8" src="images/B9780124159501000239/fx025.jpg" width="23"/>[] will not. When the hash table is resized, we double the table capacity <i>N</i> without changing the lock array size <i>L</i>; lock <i>i</i> protects each table entry <i>j</i>, where <span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>i</mml:mi><mml:mspace width="0.25em"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:mi>L</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000239/si2.png" style="vertical-align:middle" width="94"/></span>. The <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>(<i>x</i>) and <img alt="Image" height="9" src="images/B9780124159501000239/fx016.jpg" width="45"/>(<i>x</i>) methods use <i>x</i>'s hash code to pick which lock to acquire or release. An example illustrating how a <img alt="Image" height="11" src="images/B9780124159501000239/fx023.jpg" width="113"/> is resized appears in <a href="#f0035" id="cf0040">Fig. 13.6</a>.</p><div class="pageavoid"><figure class="fig" id="f0030"><img alt="Image" height="273" src="images/B9780124159501000239/gr005.jpg" width="347"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.5</span> <img alt="Image" height="11" src="images/B9780124159501000239/fx023.jpg" width="113"/> class: fields, constructor, and <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>() and <img alt="Image" height="9" src="images/B9780124159501000239/fx016.jpg" width="45"/>() methods.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0035"><img alt="Image" height="311" src="images/B9780124159501000239/gr006.jpg" width="353"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.6</span> Resizing a <img alt="Image" height="11" src="images/B9780124159501000239/fx026.jpg" width="92"/> lock-based hash table. As the table grows, the striping is adjusted to ensure that each lock covers 2<span class="hiddenClass"><mml:math><mml:msup><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">N/L</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000239/si3.png" style="vertical-align:middle" width="22"/></span> entries. In the figure above, <span class="hiddenClass"><mml:math><mml:mtext mathvariant="italic">N</mml:mtext><mml:mspace width="0.2em"/><mml:mtext mathvariant="sans-serif">=</mml:mtext><mml:mtext mathvariant="sans-serif">16</mml:mtext></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000239/si4.png" style="vertical-align:middle" width="45"/></span> and <span class="hiddenClass"><mml:math><mml:mtext mathvariant="italic">L</mml:mtext><mml:mspace width="0.2em"/><mml:mtext mathvariant="sans-serif">=8</mml:mtext></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000239/si5.png" style="vertical-align:middle" width="33"/></span>. When <i>N</i> is doubled from 8 to 16, the memory is striped so that lock <span class="hiddenClass"><mml:math><mml:mtext mathvariant="italic">i</mml:mtext><mml:mspace width="0.2em"/><mml:mtext mathvariant="sans-serif">=5</mml:mtext></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000239/si6.png" style="vertical-align:middle" width="28"/></span>, for example, covers both locations that are equal to 5 modulo <i>L</i>.</div></figcaption></figure></div><p class="text" id="p0135">There are two reasons not to grow the lock array when we grow the table:</p><div><ul><li class="bulllist" id="u0035">•  Associating a lock with every table entry could consume too much space, especially when tables are large and contention is low.</li><li class="bulllist" id="u0040">•  While resizing the table is straightforward, resizing the lock array (while in use) is more complex, as discussed in Section <a href="#s0030" id="cf0045">13.2.3</a>.</li></ul></div><p class="textfl"/><p class="text" id="p0150">Resizing a <img alt="Image" height="11" src="images/B9780124159501000239/fx026.jpg" width="92"/> (<a href="#f0040" id="cf0050">Fig. 13.7</a>) is almost identical to resizing a <img alt="Image" height="9" src="images/B9780124159501000239/fx027.jpg" width="100"/>. One difference is that in <img alt="Image" height="11" src="images/B9780124159501000239/fx026.jpg" width="92"/>, the <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() method acquires all the locks in <img alt="Image" height="8" src="images/B9780124159501000239/fx025.jpg" width="23"/>[] in ascending order (lines 19–21). It cannot deadlock with a <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>(), <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(), or <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>() call because these methods acquire only a single lock. A <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() call cannot deadlock <span aria-label="Page 311" epub:type="pagebreak" id="page_311" role="doc-pagebreak"/>with another <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() call because both calls start without holding any locks, and acquire the locks in the same order. What if two or more threads try to resize at the same time? As in <img alt="Image" height="9" src="images/B9780124159501000239/fx022.jpg" width="106"/>, after a thread has acquired all the locks, if it discovers that some other thread has changed the table capacity (line 24), then it releases the locks and gives up. (It could just double the table size anyway, since it already holds all the locks.) Otherwise, it creates a new <img alt="Image" height="8" src="images/B9780124159501000239/fx007.jpg" width="29"/>[] array with twice the capacity (line 26), and transfers items from the old table to the new (line 31). Finally, it releases the locks (line 37).</p><div class="pageavoid"><figure class="fig" id="f0040"><img alt="Image" height="389" src="images/B9780124159501000239/gr007.jpg" width="329"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.7</span> <img alt="Image" height="11" src="images/B9780124159501000239/fx023.jpg" width="113"/> class: To resize the set, lock each lock in order, and then check that no other thread has resized the table in the meantime.</div></figcaption></figure></div><p class="text" id="p0155">To summarize, striped locking permits more concurrency than a single coarse-grained lock because method calls whose items hash to different locks can proceed in parallel. The <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(), <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>(), and <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>() methods take constant expected time, but <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() takes linear time and is a “stop-the-world” operation: It halts all concurrent method calls while it increases the table's capacity.</p></section><section><h3 class="h2hd" id="s0030"><a id="st0040"/>13.2.3 A refinable hash set</h3><p class="textfl" id="p0160">What if we want to refine the granularity of locking as the table size grows, so that the number of locations in a stripe does not continuously grow? Clearly, if we want to resize the lock array, then we need to rely on another form of synchronization. Resizing is rare, so our principal goal is to devise a way to permit the lock array to be resized without substantially increasing the cost of normal method calls.</p><p class="text" id="p0165"><span aria-label="Page 312" epub:type="pagebreak" id="page_312" role="doc-pagebreak"/><a href="#f0045" id="cf0055">Fig. 13.8</a> shows the fields and constructor for the <img alt="Image" height="9" src="images/B9780124159501000239/fx028.jpg" width="126"/> class. To add a higher level of synchronization, we introduce a global <img alt="Image" height="6" src="images/B9780124159501000239/fx029.jpg" width="32"/> field that combines a Boolean value with a reference to a thread in an <img alt="Image" height="9" src="images/B9780124159501000239/fx030.jpg" width="208"/> so they can be modified atomically (see <a href="B9780124159501000197.xhtml">Pragma 9.8.1</a>). We use <img alt="Image" height="6" src="images/B9780124159501000239/fx029.jpg" width="32"/> as a mutual exclusion flag between the <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() method and any of the <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>() methods, so that while resizing, there will be no successful updates, and while updating, there will be no successful resizes. Normally, the Boolean value is <i>false</i>, meaning that the set is not in the middle of resizing. While a resizing is in progress, however, the Boolean value is <i>true</i>, and the associated reference indicates the thread that is in charge of resizing. Every <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>() call must read the <img alt="Image" height="6" src="images/B9780124159501000239/fx029.jpg" width="32"/> field. Because resizing is rare, the value of <img alt="Image" height="6" src="images/B9780124159501000239/fx029.jpg" width="32"/> should usually be cached.</p><div class="pageavoid"><figure class="fig" id="f0045"><img alt="Image" height="208" src="images/B9780124159501000239/gr008.jpg" width="387"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.8</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx028.jpg" width="126"/> class: fields and constructor.</div></figcaption></figure></div><p class="text" id="p0170">Each method locks the bucket for <i>x</i> by calling <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>(<i>x</i>), shown in <a href="#f0050" id="cf0060">Fig. 13.9</a>. It spins until no other thread is resizing the set (lines 19–21), and then reads the lock array (line 22). It then acquires the item's lock (line 24), and checks again, this time while holding a lock (line 26), to make sure no other thread is resizing, and that no resizing took place between lines 21 and 26.</p><div class="pageavoid"><figure class="fig" id="f0050"><img alt="Image" height="356" src="images/B9780124159501000239/gr009.jpg" width="447"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.9</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx028.jpg" width="126"/> class: <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>() and <img alt="Image" height="9" src="images/B9780124159501000239/fx016.jpg" width="45"/>() methods.</div></figcaption></figure></div><p class="text" id="p0175">If it passes this test, the thread can proceed. Otherwise, the lock it has acquired could be out-of-date because of an ongoing update, so it releases <span aria-label="Page 313" epub:type="pagebreak" id="page_313" role="doc-pagebreak"/>it and starts over. When starting over, it will first spin until the current resize completes (lines 19–21) before attempting to acquire the locks again. The <img alt="Image" height="9" src="images/B9780124159501000239/fx016.jpg" width="45"/>(<i>x</i>) method releases the lock acquired by <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>(<i>x</i>).</p><p class="text" id="p0180">The <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() method (<a href="#f0055" id="cf0065">Fig. 13.10</a>) is similar to the <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() method for the <img alt="Image" height="11" src="images/B9780124159501000239/fx026.jpg" width="92"/> class. However, instead <span aria-label="Page 314" epub:type="pagebreak" id="page_314" role="doc-pagebreak"/>of acquiring all the locks in <img alt="Image" height="8" src="images/B9780124159501000239/fx025.jpg" width="23"/>[], the method attempts to set itself as the <img alt="Image" height="6" src="images/B9780124159501000239/fx029.jpg" width="32"/> (line 39) and then calls <img alt="Image" height="11" src="images/B9780124159501000239/fx031.jpg" width="46"/>() (line 44) to ensure that no other thread is in the middle of an <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(), <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>(), or <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>() call. The <img alt="Image" height="11" src="images/B9780124159501000239/fx031.jpg" width="46"/>() method (<a href="#f0060" id="cf0070">Fig. 13.11</a>) visits each lock and waits until it is unlocked.</p><div class="pageavoid"><figure class="fig" id="f0055"><img alt="Image" height="389" src="images/B9780124159501000239/gr010.jpg" width="343"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.10</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx028.jpg" width="126"/> class: <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() method.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0060"><img alt="Image" height="76" src="images/B9780124159501000239/gr011.jpg" width="248"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.11</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx028.jpg" width="126"/> class: <img alt="Image" height="11" src="images/B9780124159501000239/fx031.jpg" width="46"/>() method.</div></figcaption></figure></div><p class="text" id="p0185">The <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>() and the <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() methods guarantee mutually exclusive access via the flag principle using the <img alt="Image" height="9" src="images/B9780124159501000239/fx032.jpg" width="26"/> field of the <img alt="Image" height="6" src="images/B9780124159501000239/fx029.jpg" width="32"/> flag and the table's locks array: <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>() first acquires its locks and then reads the <img alt="Image" height="9" src="images/B9780124159501000239/fx032.jpg" width="26"/> field, while <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() first sets <img alt="Image" height="9" src="images/B9780124159501000239/fx032.jpg" width="26"/> and then reads the locks during the <img alt="Image" height="11" src="images/B9780124159501000239/fx031.jpg" width="46"/>() call. This ordering ensures that any thread that acquires a lock after <img alt="Image" height="11" src="images/B9780124159501000239/fx031.jpg" width="46"/>() has completed will see that the set is in the process of being resized, and will back off <span aria-label="Page 315" epub:type="pagebreak" id="page_315" role="doc-pagebreak"/>until the resizing is complete. Similarly, <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() will first set the <img alt="Image" height="9" src="images/B9780124159501000239/fx032.jpg" width="26"/> field and then read the locks, and will not proceed while any <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(), <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>(), or <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>() call holds its lock.</p><p class="text" id="p0190">To summarize, we have designed a hash table in which both the number of buckets and the number of locks can be continually resized. One limitation of this algorithm is that threads cannot access the items in the table during a resize.</p></section></section><section><h2 class="h1hd" id="s0035"><a id="st0045"/>13.3 A lock-free hash set</h2><p class="textfl" id="p0195">The next step is to make the hash set implementation lock-free, and to make resizing <i>incremental</i>, meaning that each <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>() method call performs a small fraction of the work associated with resizing. This way, we do not need to “stop the world” to resize the table. Each of the <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>(), <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(), and <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>() methods takes constant expected time.</p><p class="text" id="p0200">To make resizable hashing lock-free, it is not enough to make the individual buckets lock-free: Resizing the table requires atomically moving entries from old buckets to new buckets. If the table doubles in capacity, then we must split the items in the old bucket between two new buckets. If this move is not done atomically, entries might be temporarily lost or duplicated. Without locks, we must synchronize using atomic methods such as <img alt="Image" height="12" src="images/B9780124159501000239/fx033.jpg" width="97"/>. Unfortunately, these methods operate only on a single memory location, which makes it difficult to move a node atomically from one linked list to another.</p><section><h3 class="h2hd" id="s0040"><a id="st0050"/>13.3.1 Recursive split-ordering</h3><p class="textfl" id="p0205">We now describe a hash set implementation that works by flipping the conventional hashing structure on its head: </p><p class="quote" id="sp0195"><i>Instead of moving the items among the buckets, move the buckets among the items.</i></p><p class="textfl"> More specifically, keep all items in a single lock-free linked list, similar to the <img alt="Image" height="9" src="images/B9780124159501000239/fx034.jpg" width="78"/> class studied in Chapter <a href="B9780124159501000197.xhtml">9</a>. A bucket is just a reference into the list. As the list grows, we introduce additional bucket references so that no object is ever too far from the start of a bucket. This algorithm ensures that once an item is placed in the list, it is never moved, but it does require that items be inserted according to a <i>recursive split-order</i> algorithm that we describe shortly.</p><p class="text" id="p0210"><a href="#f0065" id="cf0075">Fig. 13.12</a> illustrates a lock-free hash set implementation. It shows two components: a lock-free linked list and an expanding array of references into the list. These references are <i>logical</i> buckets. Any item in the hash set can be reached by traversing the list from its head, while the bucket references provide shortcuts into the list to minimize the number of list nodes traversed when searching. The principal challenge is ensuring that the bucket references into the list remain well distributed as the number of items in the set grows. Bucket references should be spaced evenly enough to allow constant-time access to any node. It follows that new buckets must be created and assigned to sparsely covered regions in the list.</p><div class="pageavoid"><figure class="fig" id="f0065"><img alt="Image" height="114" src="images/B9780124159501000239/gr012.jpg" width="497"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.12</span> This figure explains the recursive nature of the split ordering. Part (a) shows a split-ordered list consisting of two buckets. The array of buckets refer into a single linked list. The split-ordered keys (above each node) are the reverse of the bit-wise representation of the items' keys. The active bucket array entries 0 and 1 have special sentinel nodes within the list (square nodes), while other (ordinary) nodes are round. Items 4 (whose reverse bit order is “001”) and 6 (whose reverse bit order is “011”) are in bucket 0, since the least significant bit (LSB) of the original key is “0.” Items 5 and 7 (whose reverse bit orders are “101” and “111,” respectively) are in bucket 1, since the LSB of their original key is 1. Part (b) shows how each of the two buckets is split in half once the table capacity grows from two buckets to four. The reverse-bit values of the two added buckets 2 and 3 happen to perfectly split buckets 0 and 1.</div></figcaption></figure></div><p class="text" id="p0215"><span aria-label="Page 316" epub:type="pagebreak" id="page_316" role="doc-pagebreak"/>As before, the capacity <i>N</i> of the hash set is always a power of two. The bucket array initially has capacity 2 and all bucket references are <i>null</i>, except for the bucket at index 0, which refers to an empty list. We use the variable <img alt="Image" height="9" src="images/B9780124159501000239/fx035.jpg" width="65"/> to denote this changing capacity of the bucket structure. Each entry in the bucket array is initialized when first accessed, and subsequently refers to a node in the list.</p><p class="text" id="p0220">When an item with hash code <i>k</i> is inserted, removed, or searched for, the hash set uses bucket index <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mspace width="0.25em"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si7.png" style="vertical-align:middle" width="72"/></span>. As with earlier hash set implementations, we decide when to double the table capacity by consulting a <img alt="Image" height="11" src="images/B9780124159501000239/fx018.jpg" width="39"/>() method. Here, however, the table is resized incrementally by the methods that modify it, so there is no explicit <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() method. If the table capacity is <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000239/si8.png" style="vertical-align:middle" width="14"/></span>, then the bucket index is the integer represented by the key's <i>i</i> LSBs; in other words, each bucket <i>b</i> contains items each of whose hash code <i>k</i> satisfies <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>b</mml:mi><mml:mspace width="0.25em"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="17" src="images/B9780124159501000239/si9.png" style="vertical-align:middle" width="99"/></span>.</p><p class="text" id="p0225">Because the hash function depends on the table capacity, we must be careful when the table capacity changes. An item inserted before the table was resized must be accessible afterwards from both its previous and current buckets. When the capacity grows to <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000239/si10.png" style="vertical-align:middle" width="30"/></span>, the items in bucket <i>b</i> are split between two buckets: Those for which <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>b</mml:mi><mml:mspace width="0.25em"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="17" src="images/B9780124159501000239/si11.png" style="vertical-align:middle" width="115"/></span> remain in bucket <i>b</i>, while those for which <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mspace width="0.25em"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="17" src="images/B9780124159501000239/si12.png" style="vertical-align:middle" width="147"/></span> migrate to bucket <span class="hiddenClass"><mml:math><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000239/si13.png" style="vertical-align:middle" width="41"/></span>. Here is the key idea behind the algorithm: We ensure that these two groups of items are positioned one after the other in the list, so that splitting bucket <i>b</i> is achieved by simply setting bucket <span class="hiddenClass"><mml:math><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000239/si13.png" style="vertical-align:middle" width="41"/></span> after the first group of items and before the second. This organization keeps each item in the second group accessible from bucket <i>b</i>.</p><p class="text" id="p0230">As depicted in <a href="#f0065" id="cf0080">Fig. 13.12</a>, items in the two groups are distinguished by their <i>i</i>th binary digits (counting backwards, from least significant to most significant). Those with digit 0 belong <span aria-label="Page 317" epub:type="pagebreak" id="page_317" role="doc-pagebreak"/>to the first group, and those with 1 to the second. The next hash table doubling will cause each group to split again into two groups differentiated by the <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000239/si14.png" style="vertical-align:middle" width="46"/></span>st bit, and so on. For example, the items 4 (“100” binary) and 6 (“110”) share the same LSB. When the table capacity is 2<sup>1</sup>, they are in the same bucket, but when it grows to 2<sup>2</sup>, they will be in distinct buckets because their second bits differ.</p><p class="text" id="p0235">This process induces a total order on items, which we call <i>recursive split-ordering</i>, as can be seen in <a href="#f0065" id="cf0085">Fig. 13.12</a>. Given a key's hash code, its order is defined by its bit-reversed value.</p><p class="text" id="p0240">To recapitulate: a <i>split-ordered hash set</i> is an array of buckets, where each bucket is a reference into a lock-free list where nodes are sorted by their bit-reversed hash codes. The number of buckets grows dynamically, and each new bucket is initialized when accessed for the first time.</p><p class="text" id="p0245">To avoid an awkward “corner case” that arises when deleting a node referenced by a bucket reference, we add a <i>sentinel</i> node, which is never deleted, to the start of each bucket. Specifically, suppose the table capacity is <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000239/si10.png" style="vertical-align:middle" width="30"/></span>. The first time that bucket <span class="hiddenClass"><mml:math><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000239/si13.png" style="vertical-align:middle" width="41"/></span> is accessed, a sentinel node is created with key <span class="hiddenClass"><mml:math><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000239/si13.png" style="vertical-align:middle" width="41"/></span>. This node is inserted in the list via bucket <i>b</i>, the <i>parent</i> bucket of <span class="hiddenClass"><mml:math><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000239/si13.png" style="vertical-align:middle" width="41"/></span>. Under split-ordering, <span class="hiddenClass"><mml:math><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000239/si13.png" style="vertical-align:middle" width="41"/></span> precedes all items of bucket <span class="hiddenClass"><mml:math><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000239/si13.png" style="vertical-align:middle" width="41"/></span>, since those items must end with <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000239/si14.png" style="vertical-align:middle" width="46"/></span> bits forming the value <span class="hiddenClass"><mml:math><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000239/si13.png" style="vertical-align:middle" width="41"/></span>. This value also comes after all the items of bucket <i>b</i> that do not belong to <span class="hiddenClass"><mml:math><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000239/si13.png" style="vertical-align:middle" width="41"/></span>: They have identical LSBs, but their <i>i</i>th bit is 0. Therefore, the new sentinel node is positioned in the exact list location that separates the items of the new bucket from the remaining items of bucket <i>b</i>. To distinguish sentinel items from ordinary items, we set the most significant bit (MSB) of ordinary items to 1, and leave the sentinel items with 0 at the MSB. <a href="#f0090" id="cf0090">Fig. 13.17</a> illustrates two methods: <img alt="Image" height="12" src="images/B9780124159501000239/fx036.jpg" width="112"/>, which generates a split-ordered key for an object, and <img alt="Image" height="12" src="images/B9780124159501000239/fx037.jpg" width="112"/>, which generates a split-ordered key for a bucket index.</p><p class="text" id="p0250"><a href="#f0070" id="cf0095">Fig. 13.13</a> illustrates how inserting a new key into the set can cause a bucket to be initialized. The split-order key values are written above the nodes using 8-bit words. For instance, the split-order value of 3 is the bit-reverse of its binary representation, which is 11000000. The square nodes are the sentinel nodes corresponding to buckets with original keys that are 0, 1, and 3 modulo 4 with their MSB being 0. The split-order keys of ordinary (round) nodes are exactly the bit-reversed images of the original keys after turning on their MSB. For example, items 9 and 13 are in the “<span class="hiddenClass"><mml:math><mml:mn>1</mml:mn><mml:mspace width="0.25em"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000239/si15.png" style="vertical-align:middle" width="64"/></span>” bucket, which can be recursively split in two by inserting a new node between them. The sequence of figures describes an object with hash code 10 being added when the table capacity is 4 and buckets 0, 1, and 3 are already initialized.</p><div class="pageavoid"><figure class="fig" id="f0070"><img alt="Image" height="263" src="images/B9780124159501000239/gr013.jpg" width="498"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.13</span> How the <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>() method places key 10 to the lock-free table. As in earlier figures, the split-order key values, expressed as 8-bit binary words, appear above the nodes. For example, the split-order value of 1 is the bit-wise reversal of its binary representation. In step (a), buckets 0, 1, and 3 are initialized, but bucket 2 is uninitialized. In step (b), an item with hash value 10 is inserted, causing bucket 2 to be initialized. A new sentinel is inserted with split-order key 2. In step (c), bucket 2 is assigned a new sentinel. Finally, in step (d), the split-order ordinary key 10 is added to bucket 2.</div></figcaption></figure></div><p class="text" id="p0255">The table is grown incrementally; there is no explicit resize operation. Recall that each bucket is a linked list, with nodes ordered based on the split-ordered hash values. As mentioned earlier, the table resizing mechanism is independent of the policy used to decide when to resize. To keep the example concrete, we implement the following policy: We use a shared counter to allow <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>() calls to track the average bucket load. When the average load crosses a threshold, we double the table capacity.</p><p class="text" id="p0260">To avoid technical distractions, we keep the array of buckets in a large, fixed-size array. We start out using only the first array entry, and use progressively more of the array as the capacity grows. When the <span aria-label="Page 318" epub:type="pagebreak" id="page_318" role="doc-pagebreak"/><img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>() method accesses an uninitialized bucket that should have been initialized given the current table capacity, it initializes it. While conceptually simple, this design is far from ideal, since the fixed array size limits the ultimate number of buckets. In practice, it would be better to represent the buckets as a multilevel tree structure, which would cover the machine's full memory size, a task we leave as an exercise.</p></section><section><h3 class="h2hd" id="s0045"><a id="st0055"/>13.3.2 The <span class="inlinecode">BucketList</span> class</h3><p class="textfl" id="p0265"><a href="#f0075" id="cf0100">Fig. 13.14</a> shows the fields, the constructor, and some utility methods of the <img alt="Image" height="9" src="images/B9780124159501000239/fx039.jpg" width="65"/> class that implements the lock-free list used by the split-ordered hash set. Although this class is essentially the same as the <img alt="Image" height="9" src="images/B9780124159501000239/fx034.jpg" width="78"/> class from Chapter <a href="B9780124159501000197.xhtml">9</a>, there are two important differences. The first is that items are sorted in recursive-split order, not simply by hash code. The <img alt="Image" height="12" src="images/B9780124159501000239/fx036.jpg" width="112"/> and <img alt="Image" height="12" src="images/B9780124159501000239/fx037.jpg" width="112"/> methods (lines 10 and 14) show how we compute these split-ordered keys. (To ensure that reversed keys are positive, we use only the lower three bytes of the hash code.) <a href="#f0080" id="cf0105">Fig. 13.15</a> shows how the <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>() method is modified to use the split-ordered key. (As in the <img alt="Image" height="9" src="images/B9780124159501000239/fx034.jpg" width="78"/> class, the <img alt="Image" height="9" src="images/B9780124159501000239/fx040.jpg" width="25"/>(<i>x</i>) method returns a record containing <i>x</i>'s node, if it exists, along with the immediately preceding and subsequent nodes.)</p><div class="pageavoid"><figure class="fig" id="f0075"><img alt="Image" height="290" src="images/B9780124159501000239/gr014.jpg" width="470"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.14</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx038.jpg" width="86"/> class: fields, constructor, and utilities.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0080"><img alt="Image" height="93" src="images/B9780124159501000239/gr015.jpg" width="236"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.15</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx038.jpg" width="86"/> class: the <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>() method.</div></figcaption></figure></div><p class="text" id="p0270">The second difference is that while the <img alt="Image" height="9" src="images/B9780124159501000239/fx034.jpg" width="78"/> class uses only two sentinels, one at each end of the list, the <img alt="Image" height="9" src="images/B9780124159501000239/fx038.jpg" width="86"/> class places <span aria-label="Page 319" epub:type="pagebreak" id="page_319" role="doc-pagebreak"/>a sentinel at the start of each new bucket whenever the table is resized. It requires the ability to insert sentinels at intermediate positions within the list, and to traverse the list starting from such sentinels. The <img alt="Image" height="9" src="images/B9780124159501000239/fx038.jpg" width="86"/> class provides a <img alt="Image" height="11" src="images/B9780124159501000239/fx041.jpg" width="70"/>(<i>x</i>) method (<a href="#f0085" id="cf0110">Fig. 13.16</a>) that takes a bucket index, finds the associated sentinel (inserting it if absent), and returns the tail of the <img alt="Image" height="9" src="images/B9780124159501000239/fx038.jpg" width="86"/> starting from that sentinel.</p><div class="pageavoid"><figure class="fig" id="f0085"><img alt="Image" height="323" src="images/B9780124159501000239/gr016.jpg" width="421"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.16</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx038.jpg" width="86"/> class: <img alt="Image" height="11" src="images/B9780124159501000239/fx041.jpg" width="70"/>() method.</div></figcaption></figure></div></section><section><h3 class="h2hd" id="s0050"><a id="st0060"/>13.3.3 The <span class="inlinecode">LockFreeHashSet&lt;T&gt;</span> class</h3><p class="textfl" id="p0275"><a href="#f0090" id="cf0115">Fig. 13.17</a> shows the fields and constructor for the <img alt="Image" height="9" src="images/B9780124159501000239/fx042.jpg" width="119"/> class. The set has the following mutable fields: <img alt="Image" height="9" src="images/B9780124159501000239/fx043.jpg" width="38"/> is an array of <img alt="Image" height="9" src="images/B9780124159501000239/fx038.jpg" width="86"/> references into the list of items, <img alt="Image" height="9" src="images/B9780124159501000239/fx035.jpg" width="65"/> is an atomic integer that tracks how much of the <img alt="Image" height="9" src="images/B9780124159501000239/fx043.jpg" width="38"/> array is currently in use, and <img alt="Image" height="9" src="images/B9780124159501000239/fx009.jpg" width="45"/> is an atomic integer that tracks how many objects are in the set. These fields are used to decide when to resize.</p><div class="pageavoid"><figure class="fig" id="f0090"><img alt="Image" height="191" src="images/B9780124159501000239/gr017.jpg" width="356"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.17</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx042.jpg" width="119"/> class: fields and constructor.</div></figcaption></figure></div><p class="text" id="p0280"><span aria-label="Page 320" epub:type="pagebreak" id="page_320" role="doc-pagebreak"/><a href="#f0095" id="cf0120">Fig. 13.18</a> shows the <img alt="Image" height="9" src="images/B9780124159501000239/fx042.jpg" width="119"/> class's <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>() method. If <i>x</i> has hash code <i>k</i>, <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(<i>x</i>) retrieves bucket <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mspace width="0.25em"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si7.png" style="vertical-align:middle" width="72"/></span>, where <i>N</i> is the current table size, initializing it if necessary (line 15). It then calls the <img alt="Image" height="9" src="images/B9780124159501000239/fx038.jpg" width="86"/>'s <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(<i>x</i>) method. If <i>x</i> was not already present (line 18), it increments <img alt="Image" height="9" src="images/B9780124159501000239/fx009.jpg" width="45"/> and checks whether to increase <img alt="Image" height="9" src="images/B9780124159501000239/fx035.jpg" width="65"/>, the number of active buckets. The <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>(<i>x</i>) and <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>(<i>x</i>) methods work in much the same way.</p><div class="pageavoid"><figure class="fig" id="f0095"><img alt="Image" height="175" src="images/B9780124159501000239/gr018.jpg" width="410"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.18</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx042.jpg" width="119"/> class: <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>() method.</div></figcaption></figure></div><p class="text" id="p0285"><span aria-label="Page 321" epub:type="pagebreak" id="page_321" role="doc-pagebreak"/><a href="#f0100" id="cf0125">Fig. 13.19</a> shows the <img alt="Image" height="9" src="images/B9780124159501000239/fx044.jpg" width="85"/>() method, whose role is to initialize the <img alt="Image" height="9" src="images/B9780124159501000239/fx043.jpg" width="38"/> array entry at a particular index, setting that entry to refer to a new sentinel node. The sentinel node is first created and added to an existing <i>parent</i> bucket, and then the array entry is assigned a reference to <span aria-label="Page 322" epub:type="pagebreak" id="page_322" role="doc-pagebreak"/>the sentinel. If the parent bucket is not initialized (line 31), <img alt="Image" height="9" src="images/B9780124159501000239/fx044.jpg" width="85"/>() is applied recursively to the parent. To control the recursion, we maintain the invariant that the parent index is less than the new bucket index. It is also prudent to choose the parent index as close as possible to the new bucket index, but still preceding it. We compute this index by unsetting the bucket index's most significant nonzero bit (line 39).</p><div class="pageavoid"><figure class="fig" id="f0100"><img alt="Image" height="339" src="images/B9780124159501000239/gr019.jpg" width="375"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.19</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx042.jpg" width="119"/> class: If a bucket is uninitialized, initialize it by adding a new sentinel. Initializing a bucket may require initializing its parent.</div></figcaption></figure></div><p class="text" id="p0290">The <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(), <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>(), and <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>() methods require a constant expected number of steps to find a key (or determine that the key is absent). To initialize a bucket in a table of <img alt="Image" height="9" src="images/B9780124159501000239/fx035.jpg" width="65"/> <i>N</i>, the <img alt="Image" height="9" src="images/B9780124159501000239/fx044.jpg" width="85"/>() method may need to recursively initialize (i.e., split) as many as <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000239/si16.png" style="vertical-align:middle" width="62"/></span> of its parent buckets to allow the insertion of a new bucket. An example of this recursive initialization is shown in <a href="#f0105" id="cf0130">Fig. 13.20</a>. In part (a), the table has four buckets; only bucket 0 is initialized. In part (b), the item with key 7 is inserted. Bucket 3 now requires initialization, further requiring recursive initialization of bucket 1. In part (c), bucket 1 is initialized. Finally, in part (d), bucket 3 is initialized. Although the worst-case complexity in such a case is logarithmic, not constant, it can be shown that the <i>expected length</i> of any such recursive sequence of splits is constant, making the overall expected complexity of all the hash set operations constant.<span aria-label="Page 323" epub:type="pagebreak" id="page_323" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0105"><img alt="Image" height="271" src="images/B9780124159501000239/gr020.jpg" width="450"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.20</span> Recursive initialization of lock-free hash table buckets. (a) The table has four buckets; only bucket 0 is initialized. (b) We wish to insert the item with key 7. Bucket 3 now requires initialization, which in turn requires recursive initialization of bucket 1. (c) Bucket 1 is initialized by first adding the 1 sentinel to the list, then setting the bucket to this sentinel. (d) Then bucket 3 is initialized in a similar fashion, and finally 7 is added to the list. In the worst case, insertion of an item may require recursively initializing a number of buckets logarithmic in the table size, but it can be shown that the expected length of such a recursive sequence is constant.</div></figcaption></figure></div></section></section><section><h2 class="h1hd" id="s0055"><a id="st0065"/>13.4 An open-address hash set</h2><p class="textfl" id="p0295">We now turn our attention to a concurrent open-address hashing algorithm. Open-address hashing, in which each table entry holds a single item rather than a set, seems harder to make concurrent than closed-address hashing. We base our concurrent algorithm on a sequential algorithm known as cuckoo hashing.</p><section><h3 class="h2hd" id="s0060"><a id="st0070"/>13.4.1 Cuckoo hashing</h3><p class="textfl" id="p0300"><i>Cuckoo hashing</i> is a (sequential) hashing algorithm in which a newly added item displaces any earlier item occupying the same slot.<sup><a epub:type="noteref" href="#fn002" id="cf0135" role="doc-noteref">2</a></sup> For brevity, a <i>table</i> is a <i>k</i>-entry array of items. For a hash set of size <span class="hiddenClass"><mml:math><mml:mi>N</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000239/si17.png" style="vertical-align:middle" width="50"/></span>, we use a two-entry array <img alt="Image" height="8" src="images/B9780124159501000239/fx007.jpg" width="29"/>[] of tables,<sup><a epub:type="noteref" href="#fn003" id="cf0140" role="doc-noteref">3</a></sup> and two independent hash functions,</p><p class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:mtext mathvariant="italic">KeyRange</mml:mtext><mml:mo stretchy="false">→</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="21" src="images/B9780124159501000239/si18.png" width="296"/><a id="deq1"/></p></div><p class="textfl"> (denoted as <img alt="Image" height="12" src="images/B9780124159501000239/fx045.jpg" width="44"/> and <img alt="Image" height="12" src="images/B9780124159501000239/fx046.jpg" width="44"/> in the code), mapping the set of possible keys to entries in the array. To test whether a value <i>x</i> is in the set, <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>(<i>x</i>) tests whether either <img alt="Image" height="8" src="images/B9780124159501000239/fx007.jpg" width="29"/>[0]<span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si19.png" style="vertical-align:middle" width="48"/></span> or <img alt="Image" height="8" src="images/B9780124159501000239/fx007.jpg" width="29"/>[1]<span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si20.png" style="vertical-align:middle" width="48"/></span> is equal to <i>x</i>. Similarly, <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>(<i>x</i>) checks whether <i>x</i> is in either <img alt="Image" height="8" src="images/B9780124159501000239/fx007.jpg" width="29"/>[0]<span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si19.png" style="vertical-align:middle" width="48"/></span> or <img alt="Image" height="8" src="images/B9780124159501000239/fx007.jpg" width="29"/>[1]<span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si20.png" style="vertical-align:middle" width="48"/></span>, and removes it if found.</p><p class="text" id="p0305">The <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(<i>x</i>) method (<a href="#f0110" id="cf0145">Fig. 13.21</a>) is the most interesting. It successively “kicks out” conflicting items until every key has a slot. To add <i>x</i>, the method swaps <i>x</i> with <i>y</i>, the current occupant of <img alt="Image" height="8" src="images/B9780124159501000239/fx007.jpg" width="29"/>[0]<span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si19.png" style="vertical-align:middle" width="48"/></span> (line 6). If the prior value <i>y</i> was <i>null</i>, it is done (line 7). Otherwise, it swaps the newly nestless value <i>y</i> for the current occupant of <img alt="Image" height="8" src="images/B9780124159501000239/fx007.jpg" width="29"/>[1]<span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si21.png" style="vertical-align:middle" width="48"/></span> in the same way (line 8). As before, if the prior value was <i>null</i>, it is done. Otherwise, the method continues swapping entries (alternating tables) until it finds an empty slot. An example of such a sequence of displacements appears in <a href="#f0115" id="cf0150">Fig. 13.22</a>.</p><div class="pageavoid"><figure class="fig" id="f0110"><img alt="Image" height="224" src="images/B9780124159501000239/gr021.jpg" width="332"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.21</span> Sequential cuckoo hashing: the <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>() method.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0115"><img alt="Image" height="161" src="images/B9780124159501000239/gr022.jpg" width="457"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.22</span> A sequence of displacements starts when an item with key 14 finds both locations Table[0][<span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mtext mathvariant="italic">h</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="sans-serif">0</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si22.png" style="vertical-align:middle" width="18"/></span>(14)] and Table[1][<span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mtext mathvariant="italic">h</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="sans-serif">1</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si23.png" style="vertical-align:middle" width="17"/></span>(14)] taken by the values 3 and 23, and ends when the item with key 39 is successfully placed in Table[1][<span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mtext mathvariant="italic">h</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="sans-serif">1</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si23.png" style="vertical-align:middle" width="17"/></span>(39)].</div></figcaption></figure></div><p class="text" id="p0310">We might not find an empty slot, either because the table is full, or because the sequence of displacements forms a cycle. We therefore need an upper limit on the number of successive displacements we are willing to undertake (line 5). When this limit is exceeded, we resize the hash table, choose new hash functions (line 12), and start over (line 13).</p><p class="text" id="p0315">Sequential cuckoo hashing is attractive for its simplicity. It provides constant-time <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>() and <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>() methods, and it can be shown that over time, the average number of displacements caused by each <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>() call will be constant. Experimental evidence shows that sequential cuckoo hashing works well in practice.<span aria-label="Page 324" epub:type="pagebreak" id="page_324" role="doc-pagebreak"/></p></section><section><h3 class="h2hd" id="s0065"><a id="st0075"/>13.4.2 Concurrent cuckoo hashing</h3><p class="textfl" id="p0320">The principal obstacle to making the sequential cuckoo hashing algorithm concurrent is the <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>() method's need to perform a long sequence of swaps. To address this problem, we now define an alternative cuckoo hashing algorithm, the <img alt="Image" height="9" src="images/B9780124159501000239/fx047.jpg" width="146"/> class. We break up each method call into a sequence of <i>phases</i>, where each phase adds, removes, or displaces a single item <i>x</i>.</p><p class="text" id="p0325">Rather than organizing the set as a two-dimensional table of items, we use a two-dimensional table of <i>probe sets</i>, where a probe set is a constant-sized set of items with the same hash code. Each probe set holds at most <img alt="Image" height="13" src="images/B9780124159501000239/fx048.jpg" width="65"/> items, but the algorithm tries to ensure that when the set is quiescent (i.e., no method calls are in progress), each probe set holds no more than <img alt="Image" height="9" src="images/B9780124159501000239/fx049.jpg" width="59"/> &lt; <img alt="Image" height="13" src="images/B9780124159501000239/fx048.jpg" width="65"/> items. An example <span aria-label="Page 325" epub:type="pagebreak" id="page_325" role="doc-pagebreak"/>of the <img alt="Image" height="9" src="images/B9780124159501000239/fx050.jpg" width="125"/> structure appears in <a href="#f0120" id="cf0155">Fig. 13.23</a>, where the <img alt="Image" height="13" src="images/B9780124159501000239/fx048.jpg" width="65"/> is 4 and the <img alt="Image" height="9" src="images/B9780124159501000239/fx049.jpg" width="59"/> is 2. While method calls are in-flight, a probe set may temporarily hold more than <img alt="Image" height="9" src="images/B9780124159501000239/fx049.jpg" width="59"/> but never more than <img alt="Image" height="13" src="images/B9780124159501000239/fx048.jpg" width="65"/> items. (In our examples, it is convenient to implement each probe set as a fixed-size <img alt="Image" height="9" src="images/B9780124159501000239/fx010.jpg" width="45"/>.) <a href="#f0125" id="cf0160">Fig. 13.24</a> shows the <img alt="Image" height="9" src="images/B9780124159501000239/fx047.jpg" width="146"/>'s fields and constructor.</p><div class="pageavoid"><figure class="fig" id="f0120"><img alt="Image" height="180" src="images/B9780124159501000239/gr023.jpg" width="494"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.23</span> The <img alt="Image" height="9" src="images/B9780124159501000239/fx047.jpg" width="146"/> class: <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>() and <img alt="Image" height="9" src="images/B9780124159501000239/fx051.jpg" width="52"/>() methods. The figure shows the array segments consisting of eight probe sets of size 4 each, with a threshold of 2. Shown are probe sets 4 and 5 of Table[0][] and 1 and 2 of Table[1][]. In part (a), an item with key 13 finds Table[0]<span class="hiddenClass"><mml:math><mml:mtext mathvariant="sans-serif">[4]</mml:mtext></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000239/si25.png" style="vertical-align:middle" width="21"/></span> above threshold and Table[1]<span class="hiddenClass"><mml:math><mml:mtext mathvariant="sans-serif">[2]</mml:mtext></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000239/si26.png" style="vertical-align:middle" width="21"/></span> below threshold, so it adds the item to the probe set Table[1]<span class="hiddenClass"><mml:math><mml:mtext mathvariant="sans-serif">[2]</mml:mtext></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000239/si26.png" style="vertical-align:middle" width="21"/></span>. The item with key 14, on the other hand, finds that both of its probe sets are above threshold, so it adds its item to Table[0]<span class="hiddenClass"><mml:math><mml:mtext mathvariant="sans-serif">[5]</mml:mtext></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000239/si27.png" style="vertical-align:middle" width="21"/></span> and signals that the item should be relocated. In part (b), the method tries to relocate the item with key 23, the oldest item in Table[0]<span class="hiddenClass"><mml:math><mml:mtext mathvariant="sans-serif">[5]</mml:mtext></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000239/si27.png" style="vertical-align:middle" width="21"/></span>. Since Table[1]<span class="hiddenClass"><mml:math><mml:mtext mathvariant="sans-serif">[1]</mml:mtext></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000239/si28.png" style="vertical-align:middle" width="21"/></span> is below threshold, the item is successfully relocated. If Table[1]<span class="hiddenClass"><mml:math><mml:mtext mathvariant="sans-serif">[1]</mml:mtext></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000239/si28.png" style="vertical-align:middle" width="21"/></span> were above threshold, the algorithm would attempt to relocate item 12 from Table[1]<span class="hiddenClass"><mml:math><mml:mtext mathvariant="sans-serif">[1]</mml:mtext></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000239/si28.png" style="vertical-align:middle" width="21"/></span>, and if Table[1]<span class="hiddenClass"><mml:math><mml:mtext mathvariant="sans-serif">[1]</mml:mtext></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000239/si28.png" style="vertical-align:middle" width="21"/></span> were at the probe set's size limit of four items, it would attempt to relocate the item with key 5, the next oldest item, from Table[0]<span class="hiddenClass"><mml:math><mml:mtext mathvariant="sans-serif">[5]</mml:mtext></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000239/si27.png" style="vertical-align:middle" width="21"/></span>.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0125"><img alt="Image" height="224" src="images/B9780124159501000239/gr024.jpg" width="398"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.24</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx047.jpg" width="146"/> class: fields and constructor.</div></figcaption></figure></div><p class="text" id="p0330"><span aria-label="Page 326" epub:type="pagebreak" id="page_326" role="doc-pagebreak"/>To postpone our discussion of synchronization, the <img alt="Image" height="9" src="images/B9780124159501000239/fx047.jpg" width="146"/> class is defined to be <i>abstract</i>: it does not implement all its methods. It has the same abstract methods as the <img alt="Image" height="9" src="images/B9780124159501000239/fx006.jpg" width="93"/> class: The <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>(<i>x</i>) method acquires all the locks necessary to manipulate item <i>x</i>, <img alt="Image" height="9" src="images/B9780124159501000239/fx016.jpg" width="45"/>(<i>x</i>) releases them, and <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() resizes the set. (As before, we require <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>(<i>x</i>) to be reentrant.)</p><p class="text" id="p0335">From a bird's-eye view, the <img alt="Image" height="9" src="images/B9780124159501000239/fx047.jpg" width="146"/> works as follows: It adds and removes items by first locking the associated probe sets in both tables. To remove an item, it proceeds as in the sequential algorithm, checking if it is in one of the probe sets and, if so, removing it. To add an item, it attempts to add it to one of the probe sets. An item's probe sets serve as temporary overflow buffers for long sequences of consecutive displacements that might occur when adding an item to the table. The <img alt="Image" height="9" src="images/B9780124159501000239/fx049.jpg" width="59"/> value is essentially the size of the probe sets in a sequential algorithm. If a probe set already has this many items, the item is added anyway to one of the <img alt="Image" height="13" src="images/B9780124159501000239/fx048.jpg" width="65"/>–<img alt="Image" height="9" src="images/B9780124159501000239/fx049.jpg" width="59"/> overflow slots. The algorithm then tries to relocate another item from the probe set. There are various policies one can use to choose which item to relocate. Here, we move the oldest items out first, until the probe set is below threshold. As in the sequential cuckoo hashing algorithm, one relocation may trigger another, and so on.</p><p class="text" id="p0340"><a href="#f0130" id="cf0165">Fig. 13.25</a> shows the <img alt="Image" height="9" src="images/B9780124159501000239/fx047.jpg" width="146"/> class's <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>(<i>x</i>) method. It calls the abstract <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>(<i>x</i>) method to acquire the necessary locks and then enters a <img alt="Image" height="11" src="images/B9780124159501000239/fx019.jpg" width="19"/> block whose <img alt="Image" height="11" src="images/B9780124159501000239/fx020.jpg" width="46"/> block calls <img alt="Image" height="9" src="images/B9780124159501000239/fx016.jpg" width="45"/>(<i>x</i>). In the <img alt="Image" height="11" src="images/B9780124159501000239/fx019.jpg" width="19"/> block, the method simply checks whether <i>x</i> is present in Table[0]<span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si19.png" style="vertical-align:middle" width="48"/></span> or Table[1]<span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si20.png" style="vertical-align:middle" width="48"/></span>. If so, it removes <i>x</i> and returns <i>true</i>; otherwise, it returns <i>false</i>. The <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>(<i>x</i>) method works similarly.</p><div class="pageavoid"><figure class="fig" id="f0130"><img alt="Image" height="307" src="images/B9780124159501000239/gr025.jpg" width="336"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.25</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx047.jpg" width="146"/> class: the <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>() method.</div></figcaption></figure></div><p class="text" id="p0345"><span aria-label="Page 327" epub:type="pagebreak" id="page_327" role="doc-pagebreak"/><a href="#f0135" id="cf0170">Fig. 13.26</a> illustrates the <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(<i>x</i>) method. Like <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>(), it calls <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>(<i>x</i>) to acquire the necessary locks and then enters a <img alt="Image" height="11" src="images/B9780124159501000239/fx019.jpg" width="19"/> block whose <img alt="Image" height="11" src="images/B9780124159501000239/fx020.jpg" width="46"/> block calls <img alt="Image" height="9" src="images/B9780124159501000239/fx016.jpg" width="45"/>(<i>x</i>). It returns <i>false</i> if the item is already present (line 41). If either of the item's probe sets is below threshold (lines 44 and 46), it adds the item and returns. Otherwise, if either of the item's probe sets is above threshold but not full (lines 48 and 50), it adds the item and makes a note to rebalance the probe set later. Finally, if both sets are full, it makes a note to resize the entire set (line 53). It then releases the lock on <i>x</i> (line 56).</p><div class="pageavoid"><figure class="fig" id="f0135"><img alt="Image" height="504" src="images/B9780124159501000239/gr026.jpg" width="375"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.26</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx047.jpg" width="146"/> class: the <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>() method.</div></figcaption></figure></div><p class="text" id="p0350">If the method was unable to add <i>x</i> because both its probe sets were full, it resizes the hash set and tries again (line 58). If the probe set at row <i>r</i> and column <i>c</i> was above threshold, it calls <span aria-label="Page 328" epub:type="pagebreak" id="page_328" role="doc-pagebreak"/><img alt="Image" height="9" src="images/B9780124159501000239/fx051.jpg" width="52"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000239/si29.png" style="vertical-align:middle" width="34"/></span> (described later) to rebalance probe set sizes. If the call returns <i>false</i>, indicating that it failed to rebalance the probe sets, then <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>() resizes the table.</p><p class="text" id="p0355">The <img alt="Image" height="9" src="images/B9780124159501000239/fx051.jpg" width="52"/>() method appears in <a href="#f0140" id="cf0175">Fig. 13.27</a>. It takes the row and column coordinates of a probe set observed to have more than <img alt="Image" height="9" src="images/B9780124159501000239/fx049.jpg" width="59"/> items, and tries to reduce its size below threshold by moving items from this probe set to alternative probe sets.</p><div class="pageavoid"><figure class="fig" id="f0140"><img alt="Image" height="603" src="images/B9780124159501000239/gr027.jpg" width="317"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.27</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx047.jpg" width="146"/> class: the <img alt="Image" height="9" src="images/B9780124159501000239/fx051.jpg" width="52"/>() method.</div></figcaption></figure></div><p class="text" id="p0360"><span aria-label="Page 329" epub:type="pagebreak" id="page_329" role="doc-pagebreak"/>This method makes a fixed number (<img alt="Image" height="9" src="images/B9780124159501000239/fx052.jpg" width="31"/>) of attempts before giving up. Each time around the loop, the following invariants hold: <img alt="Image" height="9" src="images/B9780124159501000239/fx053.jpg" width="25"/> is the probe set we are trying to shrink, <i>y</i> is the oldest item in <img alt="Image" height="9" src="images/B9780124159501000239/fx053.jpg" width="25"/>, and <img alt="Image" height="11" src="images/B9780124159501000239/fx054.jpg" width="26"/> is the other probe set where <i>y</i> could be. The loop identifies <i>y</i> (line 70), locks both probe sets to which <i>y</i> could belong (line 75), and tries to remove <i>y</i> from the probe set (line 78). If it succeeds (another thread could have removed <i>y</i> between lines 70 and 78), then it prepares to add <i>y</i> to <img alt="Image" height="11" src="images/B9780124159501000239/fx054.jpg" width="26"/>. If <img alt="Image" height="11" src="images/B9780124159501000239/fx054.jpg" width="26"/> is below threshold (line 79), then the method adds <i>y</i> to <img alt="Image" height="11" src="images/B9780124159501000239/fx054.jpg" width="26"/> and returns <i>true</i> (no need to resize). If <img alt="Image" height="11" src="images/B9780124159501000239/fx054.jpg" width="26"/> is above threshold but not full (line 82), then it tries to shrink <img alt="Image" height="11" src="images/B9780124159501000239/fx054.jpg" width="26"/> by swapping <img alt="Image" height="9" src="images/B9780124159501000239/fx053.jpg" width="25"/> and <img alt="Image" height="11" src="images/B9780124159501000239/fx054.jpg" width="26"/> (lines 82–86) and resuming the loop. If <img alt="Image" height="11" src="images/B9780124159501000239/fx054.jpg" width="26"/> is full (line 87), the method puts <i>y</i> back in <img alt="Image" height="9" src="images/B9780124159501000239/fx053.jpg" width="25"/> and returns <i>false</i> (triggering a resize). Otherwise it tries to shrink <img alt="Image" height="11" src="images/B9780124159501000239/fx054.jpg" width="26"/> by swapping <img alt="Image" height="9" src="images/B9780124159501000239/fx053.jpg" width="25"/> and <img alt="Image" height="11" src="images/B9780124159501000239/fx054.jpg" width="26"/> (lines 82–86). If the method does not succeed in removing <i>y</i> at line 78, then it rechecks the size of <img alt="Image" height="9" src="images/B9780124159501000239/fx053.jpg" width="25"/>. If it is still above threshold (line 91), then the method resumes the loop and tries again to remove an item. Otherwise, <img alt="Image" height="9" src="images/B9780124159501000239/fx053.jpg" width="25"/> is below threshold, and the method returns <i>true</i> (no resize needed). <a href="#f0120" id="cf0180">Fig. 13.23</a> shows an example execution of the <img alt="Image" height="9" src="images/B9780124159501000239/fx047.jpg" width="146"/>, where the item with key 14 causes a relocation of the oldest item 23 from the probe set <img alt="Image" height="8" src="images/B9780124159501000239/fx007.jpg" width="29"/>[0][5].</p></section><section><h3 class="h2hd" id="s0070"><a id="st0080"/>13.4.3 Striped concurrent cuckoo hashing</h3><p class="textfl" id="p0365">We first consider a concurrent cuckoo hash set implementation using lock striping (Section <a href="#s0025" id="cf0185">13.2.2</a>). The <img alt="Image" height="11" src="images/B9780124159501000239/fx055.jpg" width="133"/> class extends <img alt="Image" height="9" src="images/B9780124159501000239/fx050.jpg" width="125"/>, providing a fixed 2-by-<i>L</i> array of reentrant locks. As usual, <img alt="Image" height="8" src="images/B9780124159501000239/fx025.jpg" width="23"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000239/si30.png" style="vertical-align:middle" width="17"/></span><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000239/si31.png" style="vertical-align:middle" width="20"/></span> protects <img alt="Image" height="8" src="images/B9780124159501000239/fx007.jpg" width="29"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000239/si30.png" style="vertical-align:middle" width="17"/></span><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si32.png" style="vertical-align:middle" width="19"/></span>, where <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mspace width="0.25em"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:mi>L</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si33.png" style="vertical-align:middle" width="97"/></span>. <a href="#f0145" id="cf0190">Fig. 13.28</a> shows the <img alt="Image" height="11" src="images/B9780124159501000239/fx055.jpg" width="133"/> class's fields and constructor. The constructor calls the <img alt="Image" height="9" src="images/B9780124159501000239/fx047.jpg" width="146"/> constructor (line 4) and then initializes the lock array.</p><div class="pageavoid"><figure class="fig" id="f0145"><img alt="Image" height="208" src="images/B9780124159501000239/gr028.jpg" width="431"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.28</span> <img alt="Image" height="11" src="images/B9780124159501000239/fx055.jpg" width="133"/> class: fields and constructor.</div></figcaption></figure></div><p class="text" id="p0370">The <img alt="Image" height="10" src="images/B9780124159501000239/fx056.jpg" width="120"/> class's <img alt="Image" height="10" src="images/B9780124159501000239/fx057.jpg" width="41"/>(<i>x</i>) and <img alt="Image" height="8" src="images/B9780124159501000239/fx058.jpg" width="41"/>(<i>x</i>) methods (<a href="#f0150" id="cf0195">Fig. 13.29</a>) lock and unlock <img alt="Image" height="8" src="images/B9780124159501000239/fx025.jpg" width="23"/>[0]<span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si19.png" style="vertical-align:middle" width="48"/></span> and <img alt="Image" height="8" src="images/B9780124159501000239/fx025.jpg" width="23"/>[1]<span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000239/si20.png" style="vertical-align:middle" width="48"/></span> (in that order, to avoid <span aria-label="Page 330" epub:type="pagebreak" id="page_330" role="doc-pagebreak"/>deadlock).<span aria-label="Page 331" epub:type="pagebreak" id="page_331" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0150"><img alt="Image" height="125" src="images/B9780124159501000239/gr029.jpg" width="308"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.29</span> <img alt="Image" height="11" src="images/B9780124159501000239/fx055.jpg" width="133"/> class: <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>() and <img alt="Image" height="9" src="images/B9780124159501000239/fx016.jpg" width="45"/>().</div></figcaption></figure></div><p class="text" id="p0375">The only difference between the <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() methods of <img alt="Image" height="11" src="images/B9780124159501000239/fx055.jpg" width="133"/> (<a href="#f0155" id="cf0200">Fig. 13.30</a>) and <img alt="Image" height="11" src="images/B9780124159501000239/fx026.jpg" width="92"/> is that the latter acquires the locks in <img alt="Image" height="8" src="images/B9780124159501000239/fx025.jpg" width="23"/>[0] in ascending order (line 24). Acquiring these locks in this order ensures that no other thread is in the middle of an <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(), <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>(), or <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>() call, and avoids deadlocks with other concurrent <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() calls.</p><div class="pageavoid"><figure class="fig" id="f0155"><img alt="Image" height="487" src="images/B9780124159501000239/gr030.jpg" width="319"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.30</span> <img alt="Image" height="11" src="images/B9780124159501000239/fx055.jpg" width="133"/> class: the <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() method.</div></figcaption></figure></div></section><section><h3 class="h2hd" id="s0075"><a id="st0085"/>13.4.4 A refinable concurrent cuckoo hash set</h3><p class="textfl" id="p0380">This section introduces the <img alt="Image" height="9" src="images/B9780124159501000239/fx060.jpg" width="146"/> class (<a href="#f0160" id="cf0205">Fig. 13.31</a>), using the methods of Section <a href="#s0030" id="cf0210">13.2.3</a> to resize the lock arrays. Just as for the <img alt="Image" height="9" src="images/B9780124159501000239/fx061.jpg" width="106"/> class, we introduce an <img alt="Image" height="6" src="images/B9780124159501000239/fx029.jpg" width="32"/> field of type <img alt="Image" height="9" src="images/B9780124159501000239/fx030.jpg" width="208"/> that combines a Boolean value with a reference to a thread. If the Boolean value is <i>true</i>, the set is resizing, and the reference indicates which thread is in charge of resizing.</p><div class="pageavoid"><figure class="fig" id="f0160"><img alt="Image" height="240" src="images/B9780124159501000239/gr031.jpg" width="443"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.31</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx059.jpg" width="167"/>: fields and constructor.</div></figcaption></figure></div><p class="text" id="p0385">Each phase locks the buckets for <i>x</i> by calling <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>(<i>x</i>), shown in <a href="#f0165" id="cf0215">Fig. 13.32</a>. It reads the lock array (line 24), and then spins until no other thread is resizing the set (lines 21–23). It then acquires the item's two locks (lines 27 and 28), and checks if the lock array is unchanged (line 30). If the lock array has not changed between lines 24 and 30, then the thread has acquired the locks it needs to proceed. Otherwise, the locks it has acquired are out of date, so it releases them and starts over. The <img alt="Image" height="9" src="images/B9780124159501000239/fx016.jpg" width="45"/>(<i>x</i>) method, also shown in <a href="#f0165" id="cf0220">Fig. 13.32</a>, releases the locks acquired by <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>(<i>x</i>).</p><div class="pageavoid"><figure class="fig" id="f0165"><img alt="Image" height="421" src="images/B9780124159501000239/gr032.jpg" width="465"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.32</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx059.jpg" width="167"/>: <img alt="Image" height="11" src="images/B9780124159501000239/fx015.jpg" width="45"/>() and <img alt="Image" height="9" src="images/B9780124159501000239/fx016.jpg" width="45"/>() methods.</div></figcaption></figure></div><p class="text" id="p0390">The <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() method (<a href="#f0170" id="cf0225">Fig. 13.33</a>) is almost identical to the <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() method for <img alt="Image" height="11" src="images/B9780124159501000239/fx055.jpg" width="133"/>. One difference is that the <img alt="Image" height="8" src="images/B9780124159501000239/fx024.jpg" width="29"/>[] array has two dimensions.</p><div class="pageavoid"><figure class="fig" id="f0170"><img alt="Image" height="569" src="images/B9780124159501000239/gr033.jpg" width="428"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.33</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx059.jpg" width="167"/>: the <img alt="Image" height="9" src="images/B9780124159501000239/fx017.jpg" width="38"/>() method.</div></figcaption></figure></div><p class="text" id="p0395">The <img alt="Image" height="11" src="images/B9780124159501000239/fx031.jpg" width="46"/>() method (<a href="#f0175" id="cf0230">Fig. 13.34</a>), like its counterpart in the <img alt="Image" height="9" src="images/B9780124159501000239/fx061.jpg" width="106"/> class, visits each lock and waits until it is unlocked. The only difference is that it visits only the locks in <img alt="Image" height="8" src="images/B9780124159501000239/fx024.jpg" width="29"/>[0].<span aria-label="Page 332" epub:type="pagebreak" id="page_332" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0175"><img alt="Image" height="76" src="images/B9780124159501000239/gr034.jpg" width="266"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.34</span> <img alt="Image" height="9" src="images/B9780124159501000239/fx059.jpg" width="167"/>: the <img alt="Image" height="11" src="images/B9780124159501000239/fx031.jpg" width="46"/>() method.</div></figcaption></figure></div></section></section><section><h2 class="h1hd" id="s0080"><a id="st0090"/>13.5 Chapter notes</h2><p class="textfl" id="p0400">The term <i>disjoint-access-parallelism</i> was coined by Amos Israeli and Lihu Rappoport <a epub:type="noteref" href="#br0420" id="cf0235" role="doc-noteref">[84]</a>. Maged Michael <a epub:type="noteref" href="#br0630" id="cf0240" role="doc-noteref">[126]</a> has shown that simple algorithms using a reader–writer lock <a epub:type="noteref" href="#br0620" id="cf0245" role="doc-noteref">[124]</a> per bucket have reasonable performance without resizing. The lock-free hash set based on split-ordering described in Section <a href="#s0040" id="cf0250">13.3.1</a> is by Ori Shalev and Nir Shavit <a epub:type="noteref" href="#br0780" id="cf0255" role="doc-noteref">[156]</a>. The optimistic and fine-grained hash sets are adapted from a hash set implementation by Doug Lea <a epub:type="noteref" href="#br0540" id="cf0260" role="doc-noteref">[108]</a>, used in <span class="sans-serif">java.util.concurrent</span>.</p><p class="text" id="p0405">Other concurrent closed-addressing schemes include ones by Meichun Hsu and Wei-Pang Yang <a epub:type="noteref" href="#br0395" id="cf0265" role="doc-noteref">[79]</a>, Vijay Kumar <a epub:type="noteref" href="#br0485" id="cf0270" role="doc-noteref">[97]</a>, Carla Schlatter Ellis <a epub:type="noteref" href="#br0215" id="cf0275" role="doc-noteref">[43]</a>, and Michael Greenwald <a epub:type="noteref" href="#br0270" id="cf0280" role="doc-noteref">[54]</a>. Hui Gao, Jan Friso Groote, and Wim Hesselink <a epub:type="noteref" href="#br0250" id="cf0285" role="doc-noteref">[50]</a> proposed an almost wait-free extensible open-addressing hashing algorithm, and Chris Purcell and Tim Harris <a epub:type="noteref" href="#br0715" id="cf0290" role="doc-noteref">[143]</a> proposed a concurrent nonblocking hash table with open addressing. Cuckoo hashing is credited to Rasmus Pagh and Flemming Rodler <a epub:type="noteref" href="#br0680" id="cf0295" role="doc-noteref">[136]</a>, and the concurrent version is by Maurice Herlihy, Nir Shavit, and Moran Tzafrir <span aria-label="Page 333" epub:type="pagebreak" id="page_333" role="doc-pagebreak"/><a epub:type="noteref" href="#br0365" id="cf0300" role="doc-noteref">[73]</a>.<span aria-label="Page 334" epub:type="pagebreak" id="page_334" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0085"><a id="st0095"/>13.6 Exercises</h2><p class="textfl" id="p0410"/><div class="boxg1" id="enun0015"><p class="b1num">Exercise 13.1 </p><div><p class="b1textfl" id="p0415">Modify the <img alt="Image" height="11" src="images/B9780124159501000239/fx026.jpg" width="92"/> to allow resizing of the range lock array using read–write locks.</p></div></div><p class="textfl"/><p class="text" id="p0420"/><div class="boxg1" id="enun0020"><p class="b1num">Exercise 13.2 </p><div><p class="b1textfl" id="p0425">For the <img alt="Image" height="9" src="images/B9780124159501000239/fx062.jpg" width="99"/>, show an example of the problem that arises when deleting an entry pointed to by a bucket reference, if we do not add a <i>sentinel</i> entry, which is never deleted, to the start of each bucket.</p></div></div><p class="textfl"/><p class="text" id="p0430"/><div class="boxg1" id="enun0025"><p class="b1num">Exercise 13.3 </p><div><p class="b1textfl" id="p0435">For the <img alt="Image" height="9" src="images/B9780124159501000239/fx062.jpg" width="99"/>, when an uninitialized bucket is accessed in a table of size <i>N</i>, it might be necessary to recursively initialize (i.e., split) as many as <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000239/si16.png" style="vertical-align:middle" width="62"/></span> of its parent buckets to allow the insertion of a new bucket. Show an example of such a scenario. Explain why the expected length of any such recursive sequence of splits is constant.</p></div></div><p class="textfl"/><p class="text" id="p0440"/><div class="boxg1" id="enun0030"><p class="b1num">Exercise 13.4 </p><div><p class="b1textfl" id="p0445">For the <img alt="Image" height="9" src="images/B9780124159501000239/fx062.jpg" width="99"/>, design a lock-free data structure to replace the fixed-size bucket array. Your data structure should allow an arbitrary number of buckets.</p></div></div><p class="textfl"/><p class="text" id="p0450"/><div class="boxg1" id="enun0035"><p class="b1num">Exercise 13.5 </p><div><p class="b1textfl" id="p0455">For the <img alt="Image" height="9" src="images/B9780124159501000239/fx062.jpg" width="99"/>, design a lock-free data structure to replace the fixed-size bucket array. Your data structure should allow for unbounded doubling of the number of buckets in order to keep the average bucket length below <span class="sans-serif">THRESHOLD</span>. Describe how you would implement the methods in <a href="#f0180" id="cf0305">Fig. 13.35</a> and how your implementation preserves lock-freedom, correctness, and expected or amortized <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000239/si34.png" style="vertical-align:middle" width="34"/></span> work.</p><div class="pageavoid"><figure class="fig" id="f0180"><img alt="Image" height="125" src="images/B9780124159501000239/gr035.jpg" width="492"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 13.35</span> The <span class="inlinecode">UnboundedResizeLockFreeHashSet</span> class.</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p0460"/><div class="boxg1" id="enun0040"><p class="b1num">Exercise 13.6 </p><div><p class="b1textfl" id="p0465">Outline correctness arguments for <img alt="Image" height="9" src="images/B9780124159501000239/fx062.jpg" width="99"/>'s <img alt="Image" height="9" src="images/B9780124159501000239/fx002.jpg" width="18"/>(), <img alt="Image" height="6" src="images/B9780124159501000239/fx003.jpg" width="38"/>(), and <img alt="Image" height="9" src="images/B9780124159501000239/fx004.jpg" width="51"/>() methods.</p><p class="b1text" id="p0470">Hint: You may assume the <img alt="Image" height="9" src="images/B9780124159501000239/fx034.jpg" width="78"/> algorithm's methods are correct.</p></div></div><p class="textfl"/></section><footer><section epub:type="bibliography" role="doc-bibliography"><div id="bl0530"><h2 class="reftitle" id="st0100">Bibliography</h2><p class="reflist1" epub:type="biblioentry footnote" id="br0215" role="doc-biblioentry">[43] C. Ellis,  Concurrency in linear hashing,   <cite><i>ACM Transactions on Database Systems</i></cite> 1987;12(2):195–217.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0250" role="doc-biblioentry">[50] H. Gao, J.F. Groote, W.H. Hesselink,  Lock-free dynamic hash tables with open addressing,   <cite><i>Distributed Computing</i></cite> 2005;18(1):21–42.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0270" role="doc-biblioentry">[54] M. Greenwald,  Two-handed emulation: how to build non-blocking implementations of complex data structures using DCAS,   <i>Proceedings of the 21st Annual Symposium on Principles of Distributed Computing</i>.  ACM Press; 2002:260–269.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0365" role="doc-biblioentry">[73] Maurice Herlihy, Nir Shavit, Moran Tzafrir,  <i>Concurrent cuckoo hashing</i>. [Technical report] Brown University; 2007.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0395" role="doc-biblioentry">[79] M. Hsu, W.P. Yang,  Concurrent operations in extendible hashing,   <i>Symposium on Very Large Data Bases</i>.  1986:241–247.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0420" role="doc-biblioentry">[84] A. Israeli, L. Rappaport,  Disjoint-access-parallel implementations of strong shared memory primitives,   <i>Proceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing</i>.  <i>Los Angeles, CA, August 14–17</i>.  1994:151–160.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0485" role="doc-biblioentry">[97] V. Kumar,  Concurrent operations on extendible hashing and its performance,   <cite><i>Communications of the ACM</i></cite> 1990;33(6):681–694.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0540" role="doc-biblioentry">[108] Doug Lea,   <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentHashMap.html">http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentHashMap.html</a>; 2007.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0620" role="doc-biblioentry">[124] John Mellor-Crummey, Michael Scott,  Algorithms for scalable synchronization on shared-memory multiprocessors,   <cite><i>ACM Transactions on Computer Systems</i></cite> 1991;9(1):21–65.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0630" role="doc-biblioentry">[126] Maged M. Michael,  High performance dynamic lock-free hash tables and list-based sets,   <i>Proceedings of the Fourteenth Annual ACM Symposium on Parallel Algorithms and Architectures</i>.  ACM Press; 2002:73–82.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0680" role="doc-biblioentry">[136] R. Pagh, F.F. Rodler,  Cuckoo hashing,   <cite><i>Journal of Algorithms</i></cite> 2004;51(2):122–144.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0715" role="doc-biblioentry">[143] C. Purcell, T. Harris,  Non-blocking hashtables with open addressing,   <i>Proceedings of International Symposium on Distributed Computing</i>.  2005:108–121.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0780" role="doc-biblioentry">[156] O. Shalev, N. Shavit,  Split-ordered lists: lock-free extensible hash tables,   <cite><i>Journal of the ACM</i></cite> 2006;53(3):379–405.</p></div></section><section epub:type="rearnotes"><div class="ftnote"><hr/><p class="ftnote1" epub:type="footnote" id="fn001" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0020" role="doc-noteref">1 </a></sup> <a id="np0010"/>“This choice introduces a scalability bottleneck, threads adding or removing items all contend on the counter that tracks the size of the set. We use an <img alt="Image" height="11" src="images/B9780124159501000239/fx021.jpg" width="87"/>, which limits scalability. It can be replaced by other, more scalable, counter implementations, if necessary.”</p><p class="ftnote1" epub:type="footnote" id="fn002" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0135" role="doc-noteref">2 </a></sup> <a id="np0015"/>“Cuckoos are a family of birds (not clocks) found in North America and Europe. Most species are nest parasites: they lay their eggs in other birds' nests. Cuckoo chicks hatch early, and quickly push the other eggs out of the nest.”</p><p class="ftnote1" epub:type="footnote" id="fn003" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0140" role="doc-noteref">3 </a></sup> <a id="np0020"/>“This division of the table into two arrays helps in presenting the concurrent algorithm. There are sequential cuckoo hashing algorithms that use, for the same number of hashed items, only a single array of size 2<i>k</i>.”</p></div></section></footer></section></body></html>