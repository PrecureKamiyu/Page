<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>33.8 What Is Still Difficult With Events</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part359.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part361.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">33.8 What Is Still Difficult With Events</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">There are a few other difficulties with the event-based approach that we should mention. For example, when systems moved from a single CPU to multiple CPUs, some of the simplicity of the event-based ap- proach disappeared. Specifically, in order to utilize more than one CPU, the event server has to run multiple event handlers in parallel; when do- ing so, the usual synchronization problems (e.g., critical sections) arise, and the usual solutions (e.g., locks) must be employed. Thus, on mod- ern multicore systems, simple event handling without locks is no longer possible.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Another problem with the event-based approach is that it does not integrate well with certain kinds of systems activity, such as <b>paging</b>. For example, if an event-handler page faults, it will block, and thus the server will not make progress until the page fault completes. Even though the server has been structured to avoid <i>explicit </i>blocking, this type of <i>implicit </i>blocking due to page faults is hard to avoid and thus can lead to large performance problems when prevalent.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">A third issue is that event-based code can be hard to manage over time, as the exact semantics of various routines changes [A+02]. For example, if a routine changes from non-blocking to blocking, the event handler that calls that routine must also change to accommodate its new nature, by ripping itself into two pieces. Because blocking is so disastrous for event-based servers, a programmer must always be on the lookout for such changes in the semantics of the APIs each event uses.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Finally, though asynchronous disk I/O is now possible on most plat- forms, it has taken a long time to get there [PDZ99], and it never quite integrates with asynchronous network I/O in as simple and uniform a manner as you might think. For example, while one would simply like to use the <span class="s41">select() </span>interface to manage all outstanding I/Os, usually some combination of <span class="s41">select() </span>for networking and the AIO calls for disk I/O are required.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part359.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part361.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
