<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Linux Kernel Development, Third Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos426370" style="height:0pt"></div><h2 class="calibre_4" id="calibre_pb_44"><span class="bold">7. Interrupts and Interrupt Handlers</span></h2><div class="calibre_5"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos426548"> </div>
<p class="calibre_2">A core responsibility of any operating system kernel is managing the hardware connected to the machine—hard drives and Blu-ray discs, keyboards and mice, 3D processors and wireless radios. To meet this responsibility, the kernel needs to communicate with the machine’s individual devices. Given that processors can be orders of magnitudes faster than the hardware they talk to, it is not ideal for the kernel to issue a request and wait for a response from the significantly slower hardware. Instead, because the hardware is comparatively slow to respond, the kernel must be free to go and handle other work, dealing with the hardware only after that hardware has actually completed its work.</p><div class="calibre_3"> </div>
<p class="calibre_2">How can the processor work with hardware without impacting the machine’s overall performance? One answer to this question is <em class="calibre4">polling</em>. Periodically, the kernel can check the status of the hardware in the system and respond accordingly. Polling incurs overhead, however, because it must occur repeatedly regardless of whether the hardware is active or ready. A better solution is to provide a mechanism for the hardware to signal to the kernel when attention is needed. This mechanism is called an <em class="calibre4">interrupt</em>. In this chapter, we discuss interrupts and how the kernel responds to them, with special functions called <em class="calibre4">interrupt handlers</em>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos428070"> </div>
<h3 class="calibre_21"><span class="bold">Interrupts</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Interrupts enable hardware to signal to the processor. For example, as you type, the keyboard controller (the hardware device that manages the keyboard) issues an electrical signal to the processor to alert the operating system to newly available key presses. These electrical signals are interrupts. The processor receives the interrupt and signals the operating system to enable the operating system to respond to the new data. Hardware devices generate interrupts asynchronously with respect to the processor clock—they can occur at any time. Consequently, the kernel can be interrupted at any time to process interrupts.</p><div class="calibre_3"> </div>
<p class="calibre_2">An interrupt is physically produced by electronic signals originating from hardware devices and directed into input pins on an interrupt controller, a simple chip that <a id="filepos429032"></a>multiplexes multiple interrupt lines into a single line to the processor. Upon receiving an interrupt, the interrupt controller sends a signal to the processor. The processor detects this signal and interrupts its current execution to handle the interrupt. The processor can then notify the operating system that an interrupt has occurred, and the operating system can handle the interrupt appropriately.</p><div class="calibre_3"> </div>
<p class="calibre_2">Different devices can be associated with different interrupts by means of a unique value associated with each interrupt. This way, interrupts from the keyboard are distinct from interrupts from the hard drive. This enables the operating system to differentiate between interrupts and to know which hardware device caused which interrupt. In turn, the operating system can service each interrupt with its corresponding handler.</p><div class="calibre_3"> </div>
<p class="calibre_2">These interrupt values are often called <em class="calibre4">interrupt request (IRQ)</em> lines. Each IRQ line is assigned a numeric value—for example, on the classic PC, IRQ zero is the timer interrupt and IRQ one is the keyboard interrupt. Not all interrupt numbers, however, are so rigidly defined. Interrupts associated with devices on the PCI bus, for example, generally are dynamically assigned. Other non-PC architectures have similar dynamic assignments for interrupt values. The important notion is that a specific interrupt is associated with a specific device, and the kernel knows this. The hardware then issues interrupts to get the kernel’s attention: <em class="calibre4">Hey, I have new key presses waiting! Read and process these bad boys!</em></p><div class="calibre_3"> </div>
<div border="1" class="calibre_26"><blockquote class="calibre10"><div class="calibre11">
<p class="calibre_2"></p><div class="calibre_3"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Exceptions</span></span></p><div class="calibre_24"> </div>
<p class="calibre_2">In OS texts, <em class="calibre4">exceptions</em> are often discussed at the same time as interrupts. Unlike interrupts, exceptions occur synchronously with respect to the processor clock. Indeed, they are often called <em class="calibre4">synchronous interrupts</em>. Exceptions are produced by the processor while executing instructions either in response to a programming error (for example, divide by zero) or abnormal conditions that must be handled by the kernel (for example, a page fault). Because many processor architectures handle exceptions in a similar manner to interrupts, the kernel infrastructure for handling the two is similar. Much of the discussion of interrupts (asynchronous interrupts generated by hardware) in this chapter also pertains to exceptions (synchronous interrupts generated by the processor).</p><div class="calibre_3"> </div>
<p class="calibre_2">You are already familiar with one exception: In the previous chapter, you saw how system calls on the x86 architecture are implemented by the issuance of a software interrupt, which traps into the kernel and causes execution of a special system call handler. Interrupts work in a similar way, you will see, except hardware—not software—issues interrupts.</p><div class="calibre_3"> </div>
</div></blockquote></div><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos432296"> </div>
<h3 class="calibre_21"><span class="bold">Interrupt Handlers</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The function the kernel runs in response to a specific interrupt is called an <em class="calibre4">interrupt handler</em> or <em class="calibre4">interrupt service routine (ISR)</em>. Each device that generates interrupts has an associated interrupt handler. For example, one function handles interrupts from the system timer, whereas another function handles interrupts generated by the keyboard. The interrupt handler for a device is part of the device’s <em class="calibre4">driver</em>—the kernel code that manages the device.</p><div class="calibre_3"> </div>
<p class="calibre_2">In Linux, interrupt handlers are normal C functions. They match a specific prototype, which enables the kernel to pass the handler information in a standard way, but otherwise <a id="filepos433135"></a>they are ordinary functions. What differentiates interrupt handlers from other kernel functions is that the kernel invokes them in response to interrupts and that they run in a special context (discussed later in this chapter) called <em class="calibre4">interrupt context</em>. This special context is occasionally called <em class="calibre4">atomic context</em> because, as we shall see, code executing in this context is unable to block. In this book, we will use the term interrupt context.</p><div class="calibre_3"> </div>
<p class="calibre_2">Because an interrupt can occur at any time, an interrupt handler can, in turn, be executed at any time. It is imperative that the handler runs quickly, to resume execution of the interrupted code as soon as possible. Therefore, while it is important to the hardware that the operating system services the interrupt without delay, it is also important to the rest of the system that the interrupt handler executes in as short a period as possible.</p><div class="calibre_3"> </div>
<p class="calibre_2">At the very least, an interrupt handler’s job is to acknowledge the interrupt’s receipt to the hardware: <em class="calibre4">Hey, hardware, I hear ya; now get back to work!</em> Often, however, interrupt handlers have a large amount of work to perform. For example, consider the interrupt handler for a network device. On top of responding to the hardware, the interrupt handler needs to copy networking packets from the hardware into memory, process them, and push the packets down to the appropriate protocol stack or application. Obviously, this can be a lot of work, especially with today’s gigabit and 10-gigabit Ethernet cards.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos434829"> </div>
<h3 class="calibre_21"><span class="bold">Top Halves Versus Bottom Halves</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">These two goals—that an interrupt handler execute quickly <em class="calibre4">and</em> perform a large amount of work—clearly conflict with one another. Because of these competing goals, the processing of interrupts is split into two parts, or halves. The interrupt handler is the <em class="calibre4">top half</em>. The top half is run immediately upon receipt of the interrupt and performs only the work that is time-critical, such as acknowledging receipt of the interrupt or resetting the hardware. Work that can be performed later is deferred until the <em class="calibre4">bottom half</em>. The bottom half runs in the future, at a more convenient time, with all interrupts enabled. Linux provides various mechanisms for implementing bottom halves, and they are all discussed in <a href="index_split_017.html#filepos487358">Chapter 8</a>, “Bottom Halves and Deferring Work.”</p><div class="calibre_3"> </div>
<p class="calibre_2">Let’s look at an example of the top-half/bottom-half dichotomy, using our old friend, the network card. When network cards receive packets from the network, they need to alert the kernel of their availability. They want and need to do this immediately, to optimize network throughput and latency and avoid timeouts. Thus, they immediately issue an interrupt: <em class="calibre4">Hey, kernel, I have some fresh packets here!</em> The kernel responds by executing the network card’s registered interrupt.</p><div class="calibre_3"> </div>
<p class="calibre_2">The interrupt runs, acknowledges the hardware, copies the new networking packets into main memory, and readies the network card for more packets. These jobs are the important, time-critical, and hardware-specific work. The kernel generally needs to quickly copy the networking packet into main memory because the network data buffer on the networking card is fixed and miniscule in size, particularly compared to main memory. Delays in copying the packets can result in a buffer overrun, with incoming packets overwhelming the networking card’s buffer and thus packets being dropped. After the networking data is safely in the main memory, the interrupt’s job is done, and it can <a id="filepos437087"></a>return control of the system to whatever code was interrupted when the interrupt was generated. The rest of the processing and handling of the packets occurs later, in the bottom half. In this chapter, we look at the top half; in the next chapter, we study the bottom.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos437406"> </div>
<h3 class="calibre_21"><span class="bold">Registering an Interrupt Handler</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Interrupt handlers are the responsibility of the driver managing the hardware. Each device has one associated driver and, if that device uses interrupts (and most do), then that driver must register one interrupt handler.</p><div class="calibre_3"> </div>
<p class="calibre_2">Drivers can register an interrupt handler and enable a given interrupt line for handling with the function <code class="calibre6"><span class="calibre7">request_irq()</span></code>, which is declared in <code class="calibre6"><span class="calibre7">&lt;linux/interrupt.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00076.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The first parameter, <code class="calibre6"><span class="calibre7">irq</span></code>, specifies the interrupt number to allocate. For some devices, for example legacy PC devices such as the system timer or keyboard, this value is typically hard-coded. For most other devices, it is probed or otherwise determined programmatically and dynamically.</p><div class="calibre_3"> </div>
<p class="calibre_2">The second parameter, <code class="calibre6"><span class="calibre7">handler</span></code>, is a function pointer to the actual interrupt handler that services this interrupt. This function is invoked whenever the operating system receives the interrupt.</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">typedef irqreturn_t (*irq_handler_t)(int, void *);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Note the specific prototype of the handler function: It takes two parameters and has a return value of <code class="calibre6"><span class="calibre7">irqreturn_t</span></code>. This function is discussed later in this chapter.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos439246"> </div>
<h4 class="calibre_27"><span class="calibre3">Interrupt Handler Flags</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The third parameter, <code class="calibre6"><span class="calibre7">flags</span></code>, can be either zero or a bit mask of one or more of the flags defined in <code class="calibre6"><span class="calibre7">&lt;linux/interrupt.h&gt;</span></code>. Among these flags, the most important are</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">IRQF_DISABLED</span></code>—When set, this flag instructs the kernel to disable all interrupts when executing this interrupt handler. When unset, interrupt handlers run with all interrupts except their own enabled. Most interrupt handlers do not set this flag, as disabling all interrupts is bad form. Its use is reserved for performance-sensitive interrupts that execute quickly. This flag is the current manifestation of the <code class="calibre6"><span class="calibre7">SA_INTERRUPT</span></code> flag, which in the past distinguished between “fast” and “slow” interrupts.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">IRQF_SAMPLE_RANDOM</span></code>—This flag specifies that interrupts generated by this device should contribute to the kernel entropy pool. The kernel entropy pool provides truly random numbers derived from various random events. If this flag is specified, the timing of interrupts from this device are fed to the pool as entropy. Do <em class="calibre4">not</em> set <a id="filepos440747"></a>this if your device issues interrupts at a predictable rate (for example, the system timer) or can be influenced by external attackers (for example, a networking device). On the other hand, most other hardware generates interrupts at nondeterministic times and is, therefore, a good source of entropy.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">IRQF_TIMER</span></code>—This flag specifies that this handler processes interrupts for the system timer.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">IRQF_SHARED</span></code>—This flag specifies that the interrupt line can be shared among multiple interrupt handlers. Each handler registered on a given line must specify this flag; otherwise, only one handler can exist per line. More information on shared handlers is provided in a following section.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">The fourth parameter, <code class="calibre6"><span class="calibre7">name</span></code>, is an ASCII text representation of the device associated with the interrupt. For example, this value for the keyboard interrupt on a PC is keyboard. These text names are used by <code class="calibre6"><span class="calibre7">/proc/irq</span></code> and <code class="calibre6"><span class="calibre7">/proc/interrupts</span></code> for communication with the user, which is discussed shortly.</p><div class="calibre_3"> </div>
<p class="calibre_2">The fifth parameter, <code class="calibre6"><span class="calibre7">dev</span></code>, is used for shared interrupt lines. When an interrupt handler is freed (discussed later), <code class="calibre6"><span class="calibre7">dev</span></code> provides a unique cookie to enable the removal of only the desired interrupt handler from the interrupt line. Without this parameter, it would be impossible for the kernel to know <em class="calibre4">which</em> handler to remove on a given interrupt line. You can pass <code class="calibre6"><span class="calibre7">NULL</span></code> here if the line is not shared, but you must pass a unique cookie if your interrupt line is shared. (And unless your device is old and crusty and lives on the ISA bus, there is a good chance it must support sharing.) This pointer is also passed into the interrupt handler on each invocation. A common practice is to pass the driver’s device structure: This pointer is unique and might be useful to have within the handlers.</p><div class="calibre_3"> </div>
<p class="calibre_2">On success, <code class="calibre6"><span class="calibre7">request_irq()</span></code> returns zero. A nonzero value indicates an error, in which case the specified interrupt handler was not registered. A common error is <code class="calibre6"><span class="calibre7">-EBUSY</span></code>, which denotes that the given interrupt line is already in use (and either the current user or you did not specify <code class="calibre6"><span class="calibre7">IRQF_SHARED</span></code>).</p><div class="calibre_3"> </div>
<p class="calibre_2">Note that <code class="calibre6"><span class="calibre7">request_irq()</span></code> can sleep and therefore cannot be called from interrupt context or other situations where code cannot block. It is a common mistake to call <code class="calibre6"><span class="calibre7">request_irq()</span></code> when it is unsafe to sleep. This is partly because of <em class="calibre4">why</em>
<code class="calibre6"><span class="calibre7">request_irq()</span></code> can block: It is indeed unclear. On registration, an entry corresponding to the interrupt is created in <code class="calibre6"><span class="calibre7">/proc/irq</span></code>. The function <code class="calibre6"><span class="calibre7">proc_mkdir()</span></code> creates new procfs entries. This function calls <code class="calibre6"><span class="calibre7">proc_create()</span></code> to set up the new procfs entries, which in turn calls <code class="calibre6"><span class="calibre7">kmalloc()</span></code> to allocate memory. As you will see in <a href="index_split_021.html#filepos778361">Chapter 12</a>, “Memory Management,” <code class="calibre6"><span class="calibre7">kmalloc()</span></code> can sleep. So there you go!</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos444617"> </div>
<h4 class="calibre_27"><span class="calibre3">An Interrupt Example</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">In a driver, requesting an interrupt line and installing a handler is done via <code class="calibre6"><span class="calibre7">request_irq()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00077.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos445006"></a>In this example, <code class="calibre6"><span class="calibre7">irqn</span></code> is the requested interrupt line; <code class="calibre6"><span class="calibre7">my_interrupt</span></code> is the handler; we specify via flags that the line can be shared; the device is named <code class="calibre6"><span class="calibre7">my_device</span></code>; and we passed <code class="calibre6"><span class="calibre7">my_dev</span></code> for <code class="calibre6"><span class="calibre7">dev</span></code>. On failure, the code prints an error and returns. If the call returns zero, the handler has been successfully installed. From that point forward, the handler is invoked in response to an interrupt. It is important to initialize hardware and register an interrupt handler in the proper order to prevent the interrupt handler from running before the device is fully initialized.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos445803"> </div>
<h4 class="calibre_27"><span class="calibre3">Freeing an Interrupt Handler</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">When your driver unloads, you need to unregister your interrupt handler and potentially disable the interrupt line. To do this, call</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void free_irq(unsigned int irq, void *dev)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">If the specified interrupt line is not shared, this function removes the handler and disables the line. If the interrupt line is shared, the handler identified via <code class="calibre6"><span class="calibre7">dev</span></code> is removed, but the interrupt line is disabled only when the last handler is removed. Now you can see why a unique <code class="calibre6"><span class="calibre7">dev</span></code> is important. With shared interrupt lines, a unique cookie is required to differentiate between the multiple handlers that can exist on a single line and enable <code class="calibre6"><span class="calibre7">free_irq()</span></code> to remove only the correct handler. In either case (shared or unshared), if <code class="calibre6"><span class="calibre7">dev</span></code> is non-<code class="calibre6"><span class="calibre7">NULL</span></code>, it must match the desired handler. A call to <code class="calibre6"><span class="calibre7">free_irq()</span></code> must be made from process context.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a href="#filepos447329">Table 7.1</a> reviews the functions for registering and deregistering an interrupt handler.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos447329"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 7.1. Interrupt Registration Methods</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00078.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos447620"> </div>
<h3 class="calibre_21"><span class="bold">Writing an Interrupt Handler</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The following is a declaration of an interrupt handler:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">static irqreturn_t intr_handler(int irq, void *dev)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Note that this declaration matches the prototype of the <code class="calibre6"><span class="calibre7">handler</span></code> argument given to <code class="calibre6"><span class="calibre7">request_irq()</span></code>. The first parameter, <code class="calibre6"><span class="calibre7">irq</span></code>, is the numeric value of the interrupt line the handler is servicing. This value is passed into the handler, but it is not used very often, except in printing log messages. Before version 2.0 of the Linux kernel, there was not a <code class="calibre6"><span class="calibre7">dev</span></code> parameter and thus <code class="calibre6"><span class="calibre7">irq</span></code> was used to differentiate between multiple devices using the <a id="filepos448625"></a>same driver and therefore the same interrupt handler. As an example of this, consider a computer with multiple hard drive controllers of the same type.</p><div class="calibre_3"> </div>
<p class="calibre_2">The second parameter, <code class="calibre6"><span class="calibre7">dev</span></code>, is a generic pointer to the same <code class="calibre6"><span class="calibre7">dev</span></code> that was given to <code class="calibre6"><span class="calibre7">request_irq()</span></code> when the interrupt handler was registered. If this value is unique (which is required to support sharing), it can act as a cookie to differentiate between multiple devices potentially using the same interrupt handler. <code class="calibre6"><span class="calibre7">dev</span></code> might also point to a structure of use to the interrupt handler. Because the <code class="calibre6"><span class="calibre7">device</span></code> structure is both unique to each device and potentially useful to have within the handler, it is typically passed for <code class="calibre6"><span class="calibre7">dev</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">The return value of an interrupt handler is the special type <code class="calibre6"><span class="calibre7">irqreturn_t</span></code>. An interrupt handler can return two special values, <code class="calibre6"><span class="calibre7">IRQ_NONE</span></code> or <code class="calibre6"><span class="calibre7">IRQ_HANDLED</span></code>. The former is returned when the interrupt handler detects an interrupt for which its device was not the originator. The latter is returned if the interrupt handler was correctly invoked, and its device did indeed cause the interrupt. Alternatively, <code class="calibre6"><span class="calibre7">IRQ_RETVAL(val)</span></code> may be used. If <code class="calibre6"><span class="calibre7">val</span></code> is nonzero, this macro returns <code class="calibre6"><span class="calibre7">IRQ_HANDLED</span></code>. Otherwise, the macro returns <code class="calibre6"><span class="calibre7">IRQ_NONE</span></code>. These special values are used to let the kernel know whether devices are issuing spurious (that is, unrequested) interrupts. If all the interrupt handlers on a given interrupt line return <code class="calibre6"><span class="calibre7">IRQ_NONE</span></code>, then the kernel can detect the problem. Note the curious return type, <code class="calibre6"><span class="calibre7">irqreturn_t</span></code>, which is simply an <code class="calibre6"><span class="calibre7">int</span></code>. This value provides backward compatibility with earlier kernels, which did not have this feature; before 2.6, interrupt handlers returned <code class="calibre6"><span class="calibre7">void</span></code>. Drivers may simply typedef <code class="calibre6"><span class="calibre7">irqreturn_t</span></code> to <code class="calibre6"><span class="calibre7">void</span></code> and define the different return values to no-ops and then work in 2.4 without further modification. The interrupt handler is normally marked <code class="calibre6"><span class="calibre7">static</span></code> because it is never called directly from another file.</p><div class="calibre_3"> </div>
<p class="calibre_2">The role of the interrupt handler depends entirely on the device and its reasons for issuing the interrupt. At a minimum, most interrupt handlers need to provide acknowledgment to the device that they received the interrupt. Devices that are more complex need to additionally send and receive data and perform extended work in the interrupt handler. As mentioned, the extended work is pushed as much as possible into the bottom half handler, which is discussed in the next chapter.</p><div class="calibre_3"> </div>
<div border="1" class="calibre_26"><blockquote class="calibre10"><div class="calibre11">
<p class="calibre_2"></p><div class="calibre_3"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Reentrancy and Interrupt Handlers</span></span></p><div class="calibre_24"> </div>
<p class="calibre_2">Interrupt handlers in Linux need not be reentrant. When a given interrupt handler is executing, the corresponding interrupt line is masked out on all processors, preventing another interrupt on the same line from being received. Normally all other interrupts are enabled, so other interrupts are serviced, but the current line is always disabled. Consequently, the same interrupt handler is never invoked concurrently to service a nested interrupt. This greatly simplifies writing your interrupt handler.</p><div class="calibre_3"> </div>
</div></blockquote></div><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos452760"> </div>
<h4 class="calibre_27"><span class="calibre3">Shared Handlers</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">A shared handler is registered and executed much like a nonshared handler. Following are three main differences:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The <code class="calibre6"><span class="calibre7">IRQF_SHARED</span></code> flag must be set in the <code class="calibre6"><span class="calibre7">flags</span></code> argument to <code class="calibre6"><span class="calibre7">request_irq()</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The <code class="calibre6"><span class="calibre7">dev</span></code> argument must be unique to each registered handler. A pointer to any per-device structure is sufficient; a common choice is the <code class="calibre6"><span class="calibre7">device</span></code> structure as it is <a id="filepos453557"></a>both unique and potentially useful to the handler. You <em class="calibre4">cannot</em> pass <code class="calibre6"><span class="calibre7">NULL</span></code> for a shared handler!</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The interrupt handler must be capable of distinguishing whether its device actually generated an interrupt. This requires both hardware support and associated logic in the interrupt handler. If the hardware did not offer this capability, there would be no way for the interrupt handler to know whether its associated device or some other device sharing the line caused the interrupt.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">All drivers sharing the interrupt line must meet the previous requirements. If any one device does not share fairly, none can share the line. When <code class="calibre6"><span class="calibre7">request_irq()</span></code> is called with <code class="calibre6"><span class="calibre7">IRQF_SHARED</span></code> specified, the call succeeds only if the interrupt line is currently not registered, or if all registered handlers on the line also specified <code class="calibre6"><span class="calibre7">IRQF_SHARED</span></code>. Shared handlers, however, can mix usage of <code class="calibre6"><span class="calibre7">IRQF_DISABLED</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">When the kernel receives an interrupt, it invokes sequentially each registered handler on the line. Therefore, it is important that the handler be capable of distinguishing whether it generated a given interrupt. The handler must quickly exit if its associated device did not generate the interrupt. This requires the hardware device to have a status register (or similar mechanism) that the handler can check. Most hardware does indeed have such a feature.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos455326"> </div>
<h4 class="calibre_27"><span class="calibre3">A Real-Life Interrupt Handler</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Let’s look at a real interrupt handler, from the real-time clock (RTC) driver, found in <code class="calibre6"><span class="calibre7">drivers/char/rtc.c</span></code>. An RTC is found in many machines, including PCs. It is a device, separate from the system timer, which sets the system clock, provides an alarm, or supplies a periodic timer. On most architectures, the system clock is set by writing the desired time into a specific register or I/O range. Any alarm or periodic timer functionality is normally implemented via interrupt. The interrupt is equivalent to a real-world clock alarm: The receipt of the interrupt is analogous to a buzzing alarm.</p><div class="calibre_3"> </div>
<p class="calibre_2">When the RTC driver loads, the function <code class="calibre6"><span class="calibre7">rtc_init()</span></code> is invoked to initialize the driver. One of its duties is to register the interrupt handler:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00079.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">In this example, the interrupt line is stored in <code class="calibre6"><span class="calibre7">rtc_irq</span></code>. This variable is set to the RTC interrupt for a given architecture. On a PC, the RTC is located at IRQ 8. The second parameter is the interrupt handler, <code class="calibre6"><span class="calibre7">rtc_interrupt</span></code>, which is willing to share the interrupt line with other handlers, thanks to the <code class="calibre6"><span class="calibre7">IRQF_SHARED</span></code> flag. From the fourth parameter, you can see that the driver name is rtc. Because this device shares the interrupt line, it passes a unique per-device value for <code class="calibre6"><span class="calibre7">dev</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, the handler itself:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00080.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">This function is invoked whenever the machine receives the RTC interrupt. First, note the spin lock calls: The first set ensures that <code class="calibre6"><span class="calibre7">rtc_irq_data</span></code> is not accessed concurrently by another processor on an SMP machine, and the second set protects <code class="calibre6"><span class="calibre7">rtc_callback</span></code> from the same. Locks are discussed in <a href="index_split_019.html#filepos613760">Chapter 10</a>, “Kernel Synchronization Methods.”</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">rtc_irq_data</span></code> variable is an <code class="calibre6"><span class="calibre7">unsigned long</span></code> that stores information about the RTC and is updated on each interrupt to reflect the status of the interrupt.</p><div class="calibre_3"> </div>
<p class="calibre_2">Next, if an RTC periodic timer is set, it is updated via <code class="calibre6"><span class="calibre7">mod_timer()</span></code>. Timers are discussed in <a href="index_split_020.html#filepos701833">Chapter 11</a>, “Timers and Time Management.”</p><div class="calibre_3"> </div>
<p class="calibre_2">The final bunch of code, under the comment “now do the rest of the actions,” executes a possible preset callback function. The RTC driver enables a callback function to be registered and executed on each RTC interrupt.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos458621"></a>Finally, this function returns <code class="calibre6"><span class="calibre7">IRQ_HANDLED</span></code> to signify that it properly handled this device. Because the interrupt handler does not support sharing, and there is no mechanism for the RTC to detect a spurious interrupt, this handler always returns <code class="calibre6"><span class="calibre7">IRQ_HANDLED</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos459000"> </div>
<h3 class="calibre_21"><span class="bold">Interrupt Context</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">When executing an interrupt handler, the kernel is in <em class="calibre4">interrupt context</em>. Recall that process context is the mode of operation the kernel is in while it is executing on behalf of a process—for example, executing a system call or running a kernel thread. In process context, the <code class="calibre6"><span class="calibre7">current</span></code> macro points to the associated task. Furthermore, because a process is coupled to the kernel in process context, process context can sleep or otherwise invoke the scheduler.</p><div class="calibre_3"> </div>
<p class="calibre_2">Interrupt context, on the other hand, is not associated with a process. The <code class="calibre6"><span class="calibre7">current</span></code> macro is not relevant (although it points to the interrupted process). Without a backing process, interrupt context cannot sleep—how would it ever reschedule? Therefore, you cannot call certain functions from interrupt context. If a function sleeps, you cannot use it from your interrupt handler—this limits the functions that one can call from an interrupt handler.</p><div class="calibre_3"> </div>
<p class="calibre_2">Interrupt context is time-critical because the interrupt handler interrupts other code. Code should be quick and simple. Busy looping is possible, but discouraged. This is an important point; always keep in mind that your interrupt handler has interrupted other code (possibly even another interrupt handler on a different line!). Because of this asynchronous nature, it is imperative that all interrupt handlers be as quick and as simple as possible. As much as possible, work should be pushed out from the interrupt handler and performed in a bottom half, which runs at a more convenient time.</p><div class="calibre_3"> </div>
<p class="calibre_2">The setup of an interrupt handler’s stacks is a configuration option. Historically, interrupt handlers did not receive their own stacks. Instead, they would share the stack of the process that they interrupted.<sup class="calibre8"><a id="filepos461094" href="#filepos461538">1</a></sup> The kernel stack is two pages in size; typically, that is 8KB on 32-bit architectures and 16KB on 64-bit architectures. Because in this setup interrupt handlers share the stack, they must be exceptionally frugal with what data they allocate there. Of course, the kernel stack is limited to begin with, so all kernel code should be cautious.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos461538" href="#filepos461094">1</a></sup>
<em class="calibre4">A process is always running. When nothing else is schedulable, the idle task runs.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">Early in the 2.6 kernel process, an option was added to reduce the stack size from two pages down to one, providing only a 4KB stack on 32-bit systems. This reduced memory pressure because every process on the system previously needed two pages of contiguous, nonswappable kernel memory. To cope with the reduced stack size, interrupt handlers were given their own stack, one stack per processor, one page in size. This stack is referred to as the <em class="calibre4">interrupt stack</em>. Although the total size of the interrupt stack is half that of the original shared stack, the average stack space available is greater because interrupt handlers get the full page of memory to themselves.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos462461"></a>Your interrupt handler should not care what stack setup is in use or what the size of the kernel stack is. Always use an absolute minimum amount of stack space.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos462672"> </div>
<h3 class="calibre_21"><span class="bold">Implementing Interrupt Handlers</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Perhaps not surprising, the implementation of the interrupt handling system in Linux is architecture-dependent. The implementation depends on the processor, the type of interrupt controller used, and the design of the architecture and machine.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a href="#filepos463265">Figure 7.1</a> is a diagram of the path an interrupt takes through hardware and the kernel.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos463265"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 7.1. The path that an interrupt takes from hardware and on through the kernel.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00081.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">A device issues an interrupt by sending an electric signal over its bus to the interrupt controller. If the interrupt line is enabled (they can be masked out), the interrupt controller sends the interrupt to the processor. In most architectures, this is accomplished by an electrical signal sent over a special pin to the processor. Unless interrupts are disabled in the processor (which can also happen), the processor immediately stops what it is doing, disables the interrupt system, and jumps to a predefined location in memory and executes the code located there. This predefined point is set up by the kernel and is the <em class="calibre4">entry point</em> for interrupt handlers.</p><div class="calibre_3"> </div>
<p class="calibre_2">The interrupt’s journey in the kernel begins at this predefined entry point, just as system calls enter the kernel through a predefined exception handler. For each interrupt line, the processor jumps to a unique location in memory and executes the code located there. In this manner, the kernel knows the IRQ number of the incoming interrupt. The initial entry point simply saves this value and stores the current register values (which belong to the interrupted task) on the stack; then the kernel calls <code class="calibre6"><span class="calibre7">do_IRQ()</span></code>. From here onward, most of the interrupt handling code is written in C; however, it is still architecture-dependent.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">do_IRQ()</span></code> function is declared as</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">unsigned int do_IRQ(struct pt_regs regs)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Because the C calling convention places function arguments at the top of the stack, the <code class="calibre6"><span class="calibre7">pt_regs</span></code> structure contains the initial register values that were previously saved in the assembly entry routine. Because the interrupt value was also saved, <code class="calibre6"><span class="calibre7">do_IRQ()</span></code> can extract it. After the interrupt line is calculated, <code class="calibre6"><span class="calibre7">do_IRQ()</span></code> acknowledges the receipt of the interrupt and disables interrupt delivery on the line. On normal PC machines, these operations are handled by <code class="calibre6"><span class="calibre7">mask_and_ack_8259A()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Next, <code class="calibre6"><span class="calibre7">do_IRQ()</span></code> ensures that a valid handler is registered on the line and that it is enabled and not currently executing. If so, it calls <code class="calibre6"><span class="calibre7">handle_IRQ_event()</span></code>, defined in <code class="calibre6"><span class="calibre7">kernel/irq/handler.c</span></code>, to run the installed interrupt handlers for the line.</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00082.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_31"><img alt="image" src="images/00083.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_31"><img alt="image" src="images/00084.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">First, because the processor disabled interrupts, they are turned back on unless <code class="calibre6"><span class="calibre7">IRQF_DISABLED</span></code> was specified during the handler’s registration. Recall that <code class="calibre6"><span class="calibre7">IRQF_DISABLED</span></code> specifies that the handler must be run with interrupts disabled. Next, each potential handler is executed in a loop. If this line is not shared, the loop terminates after the first iteration. Otherwise, all handlers are executed. After that, <code class="calibre6"><span class="calibre7">add_interrupt_randomness()</span></code> is called if <code class="calibre6"><span class="calibre7">IRQF_SAMPLE_RANDOM</span></code> was specified during registration. This function uses the timing of the interrupt to generate entropy for the random number generator. Finally, interrupts are again disabled (<code class="calibre6"><span class="calibre7">do_IRQ()</span></code> expects them still <a id="filepos467500"></a>to be off) and the function returns. Back in <code class="calibre6"><span class="calibre7">do_IRQ()</span></code>, the function cleans up and returns to the initial entry point, which then jumps to <code class="calibre6"><span class="calibre7">ret_from_intr()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">The routine <code class="calibre6"><span class="calibre7">ret_from_intr()</span></code> is, as with the initial entry code, written in assembly. This routine checks whether a reschedule is pending. (Recall from <a href="index_split_013.html#filepos223287">Chapter 4</a>, “Process Scheduling,” that this implies that <code class="calibre6"><span class="calibre7">need_resched</span></code> is set). If a reschedule is pending, and the kernel is returning to user-space (that is, the interrupt interrupted a user process), <code class="calibre6"><span class="calibre7">schedule()</span></code> is called. If the kernel is returning to kernel-space (that is, the interrupt interrupted the kernel itself), <code class="calibre6"><span class="calibre7">schedule()</span></code> is called only if the <code class="calibre6"><span class="calibre7">preempt_count</span></code> is zero. Otherwise it is not safe to preempt the kernel. After <code class="calibre6"><span class="calibre7">schedule()</span></code> returns, or if there is no work pending, the initial registers are restored and the kernel resumes whatever was interrupted.</p><div class="calibre_3"> </div>
<p class="calibre_2">On x86, the initial assembly routines are located in <code class="calibre6"><span class="calibre7">arch/x86/kernel/entry_64.S</span></code> (<code class="calibre6"><span class="calibre7">entry_32.S</span></code> for 32-bit x86) and the C methods are located in <code class="calibre6"><span class="calibre7">arch/x86/kernel/irq.c</span></code>. Other supported architectures are similar.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos469155"> </div>
<h3 class="calibre_21"><span class="bold"><code class="calibre18"><span class="calibre15">/proc/interrupts</span></code></span></h3><div class="calibre_22"> </div>
<p class="calibre_2"><em class="calibre4">Procfs</em> is a virtual filesystem that exists only in kernel memory and is typically mounted at <code class="calibre6"><span class="calibre7">/proc</span></code>. Reading or writing files in procfs invokes kernel functions that simulate reading or writing from a real file. A relevant example is the <code class="calibre6"><span class="calibre7">/proc/interrupts</span></code> file, which is populated with statistics related to interrupts on the system. Here is sample output from a uniprocessor PC:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00085.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The first column is the interrupt line. On this system, interrupts numbered 0–2, 4, 5, 12, and 15 are present. Handlers are not installed on lines not displayed. The second column is a counter of the number of interrupts received. A column is present for each processor on the system, but this machine has only one processor. As you can see, the timer interrupt has received 3,602,371 interrupts,<sup class="calibre8"><a id="filepos470311" href="#filepos471283">2</a></sup> whereas the sound card (EMU10K1) has received none (which is an indication that it has not been used since the machine booted). The third column is the interrupt controller handling this interrupt. <code class="calibre6"><span class="calibre7">XT-PIC</span></code> corresponds to the standard <a id="filepos470627"></a>PC programmable interrupt controller. On systems with an I/O APIC, most interrupts would list <code class="calibre6"><span class="calibre7">IO-APIC-level</span></code> or <code class="calibre6"><span class="calibre7">IO-APIC-edge</span></code> as their interrupt controller. Finally, the last column is the device associated with this interrupt. This name is supplied by the <code class="calibre6"><span class="calibre7">devname</span></code> parameter to <code class="calibre6"><span class="calibre7">request_irq()</span></code>, as discussed previously. If the interrupt is shared, as is the case with interrupt number 4 in this example, all the devices registered on the interrupt line are listed.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos471283" href="#filepos470311">2</a></sup>
<em class="calibre4">As an exercise, after reading <a href="index_split_020.html#filepos701833">Chapter 11</a> can you tell how long the system has been up (in terms of <code class="calibre6"><span class="calibre7">HZ</span></code>), knowing the number of timer interrupts that have occurred?</em></p><div class="calibre_3"> </div>
<p class="calibre_2">For the curious, procfs code is located primarily in <code class="calibre6"><span class="calibre7">fs/proc</span></code>. The function that provides <code class="calibre6"><span class="calibre7">/proc/interrupts</span></code> is, not surprisingly, architecture-dependent and named <code class="calibre6"><span class="calibre7">show_interrupts()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos471954"> </div>
<h3 class="calibre_21"><span class="bold">Interrupt Control</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The Linux kernel implements a family of interfaces for manipulating the state of interrupts on a machine. These interfaces enable you to disable the interrupt system for the current processor or mask out an interrupt line for the entire machine. These routines are all architecture-dependent and can be found in <code class="calibre6"><span class="calibre7">&lt;asm/system.h&gt;</span></code> and <code class="calibre6"><span class="calibre7">&lt;asm/irq.h&gt;</span></code>. See <a href="#filepos472657">Table 7.2</a>, later in this chapter, for a complete listing of the interfaces.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos472657"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 7.2. Interrupt Control Methods</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00086.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Reasons to control the interrupt system generally boil down to needing to provide synchronization. By disabling interrupts, you can guarantee that an interrupt handler will not preempt your current code. Moreover, disabling interrupts also disables kernel preemption. Neither disabling interrupt delivery nor disabling kernel preemption provides any protection from concurrent access from another processor, however. Because Linux supports multiple processors, kernel code more generally needs to obtain some sort of lock to prevent another processor from accessing shared data simultaneously. These locks are often obtained in conjunction with disabling local interrupts. The lock provides protection against concurrent access from another processor, whereas disabling interrupts provides protection against concurrent access from a possible interrupt handler. <a href="index_split_018.html#filepos575425">Chapters 9</a> and <a href="index_split_019.html#filepos613760">10</a> discuss the various problems of synchronization and their solutions. Nevertheless, understanding the kernel interrupt control interfaces is important.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos474078"> </div>
<h4 class="calibre_27"><span class="calibre3">Disabling and Enabling Interrupts</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">To disable interrupts locally for the current processor (and <em class="calibre4">only</em> the current processor) and then later reenable them, do the following:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">local_irq_disable();<br class="calibre1"/>/* interrupts are disabled .. */<br class="calibre1"/>local_irq_enable();</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">These functions are usually implemented as a single assembly operation. (Of course, this depends on the architecture.) Indeed, on x86, <code class="calibre6"><span class="calibre7">local_irq_disable()</span></code> is a simple <code class="calibre6"><span class="calibre7">cli</span></code> and <code class="calibre6"><span class="calibre7">local_irq_enable()</span></code> is a simple <code class="calibre6"><span class="calibre7">sti</span></code> instruction. <code class="calibre6"><span class="calibre7">cli</span></code> and <code class="calibre6"><span class="calibre7">sti</span></code> are the assembly calls to <em class="calibre4">clear</em> and <em class="calibre4">set</em> the <em class="calibre4">allow interrupts</em> flag, respectively. In other words, they disable and enable interrupt delivery on the issuing processor.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos475281"></a>The <code class="calibre6"><span class="calibre7">local_irq_disable()</span></code> routine is dangerous if interrupts were already disabled <em class="calibre4">prior</em> to its invocation. The corresponding call to <code class="calibre6"><span class="calibre7">local_irq_enable()</span></code> unconditionally enables interrupts, despite the fact that they were off to begin with. Instead, a mechanism is needed to restore interrupts to a previous state. This is a common concern because a given code path in the kernel can be reached both with and without interrupts enabled, depending on the call chain. For example, imagine the previous code snippet is part of a larger function. Imagine that this function is called by two other functions, one that disables interrupts and one that does not. Because it is becoming harder as the kernel grows in size and complexity to know all the code paths leading up to a function, it is much safer to save the state of the interrupt system before disabling it. Then, when you are ready to reenable interrupts, you simply restore them to their original state:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00087.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Note that these methods are implemented at least in part as macros, so the <code class="calibre6"><span class="calibre7">flags</span></code> parameter (which must be defined as an <code class="calibre6"><span class="calibre7">unsigned long</span></code>) is seemingly passed by value. This parameter contains architecture-specific data containing the state of the interrupt systems. Because at least one supported architecture incorporates stack information into the value (ahem, SPARC), <code class="calibre6"><span class="calibre7">flags</span></code>
<em class="calibre4">cannot</em> be passed to another function (specifically, it must remain on the same stack frame). For this reason, the call to save and the call to restore interrupts must occur in the same function.</p><div class="calibre_3"> </div>
<p class="calibre_2">All the previous functions can be called from both interrupt and process context.</p><div class="calibre_3"> </div>
<div border="1" class="calibre_26"><blockquote class="calibre10"><div class="calibre11">
<p class="calibre_2"></p><div class="calibre_3"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">No More Global <code class="calibre6"><span class="calibre15">cli()</span></code></span></span></p><div class="calibre_24"> </div>
<p class="calibre_2">The kernel formerly provided a method to disable interrupts on <em class="calibre4">all</em> processors in the system. Furthermore, if another processor called this method, it would have to wait until interrupts were enabled before continuing. This function was named <code class="calibre6"><span class="calibre7">cli()</span></code> and the corresponding enable call was named <code class="calibre6"><span class="calibre7">sti()</span></code>—very x86-centric, despite existing for all architectures. These interfaces were deprecated during 2.5, and consequently all interrupt synchronization must now use a combination of local interrupt control and spin locks (discussed in <a href="index_split_018.html#filepos575425">Chapter 9</a>, “An Introduction to Kernel Synchronization”). This means that code that previously only had to disable interrupts globally to ensure mutual-exclusive access to shared data now needs to do a bit more work.</p><div class="calibre_3"> </div>
<p class="calibre_2">Previously, driver writers could assume a <code class="calibre6"><span class="calibre7">cli()</span></code> used in their interrupt handlers and anywhere else the shared data was accessed would provide mutual exclusion. The <code class="calibre6"><span class="calibre7">cli()</span></code> call would ensure that no other interrupt handlers (and thus their specific handler) would run. Furthermore, if another processor entered a <code class="calibre6"><span class="calibre7">cli()</span></code> protected region, it would not continue until the original processor exited its <code class="calibre6"><span class="calibre7">cli()</span></code> protected region with a call to <code class="calibre6"><span class="calibre7">sti()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Removing the global <code class="calibre6"><span class="calibre7">cli()</span></code> has a handful of advantages. First, it forces driver writers to implement real locking. A fine-grained lock with a specific purpose is faster than a global lock, which is effectively what <code class="calibre6"><span class="calibre7">cli()</span></code> is. Second, the removal streamlined a lot of code in the interrupt system and removed a bunch more. The result is simpler and easier to comprehend.</p><div class="calibre_3"> </div>
</div></blockquote></div><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos479720"> </div>
<h4 class="calibre_27"><span class="calibre3">Disabling a Specific Interrupt Line</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos479857"> </div>
<p class="calibre_2">In the previous section, we looked at functions that disable all interrupt delivery for an entire processor. In some cases, it is useful to disable only a <em class="calibre4">specific</em> interrupt line for the <em class="calibre4">entire</em> system. This is called <em class="calibre4">masking out</em> an interrupt line. As an example, you might want to disable delivery of a device’s interrupts before manipulating its state. Linux provides four interfaces for this task:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void disable_irq(unsigned int irq);<br class="calibre1"/>void disable_irq_nosync(unsigned int irq);<br class="calibre1"/>void enable_irq(unsigned int irq);<br class="calibre1"/>void synchronize_irq(unsigned int irq);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The first two functions disable a given interrupt line in the interrupt controller. This disables delivery of the given interrupt to <em class="calibre4">all</em> processors in the system. Additionally, the <code class="calibre6"><span class="calibre7">disable_irq()</span></code> function does not return until any currently executing handler completes. Thus, callers are assured not only that new interrupts will not be delivered on the given line, but also that any already executing handlers have exited. The function <code class="calibre6"><span class="calibre7">disable_irq_nosync()</span></code> does not wait for current handlers to complete.</p><div class="calibre_3"> </div>
<p class="calibre_2">The function <code class="calibre6"><span class="calibre7">synchronize_irq()</span></code> waits for a specific interrupt handler to exit, if it is executing, before returning.</p><div class="calibre_3"> </div>
<p class="calibre_2">Calls to these functions nest. For each call to <code class="calibre6"><span class="calibre7">disable_irq()</span></code> or <code class="calibre6"><span class="calibre7">disable_irq_nosync()</span></code> on a given interrupt line, a corresponding call to <code class="calibre6"><span class="calibre7">enable_irq()</span></code> is required. Only on the last call to <code class="calibre6"><span class="calibre7">enable_irq()</span></code> is the interrupt line actually enabled. For example, if <code class="calibre6"><span class="calibre7">disable_irq()</span></code> is called twice, the interrupt line is not actually reenabled until the second call to <code class="calibre6"><span class="calibre7">enable_irq()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">All three of these functions can be called from interrupt or process context and do not sleep. If calling from interrupt context, be careful! You do not want, for example, to enable an interrupt line while you are handling it. (Recall that the interrupt line of a handler is masked out while it is serviced.)</p><div class="calibre_3"> </div>
<p class="calibre_2">It would be rather rude to disable an interrupt line shared among multiple interrupt handlers. Disabling the line disables interrupt delivery for <em class="calibre4">all</em> devices on the line. Therefore, drivers for newer devices tend not to use these interfaces.<sup class="calibre8"><a id="filepos482741" href="#filepos483121">3</a></sup> Because PCI devices have to support interrupt line sharing by specification, they should not use these interfaces at all. Thus, <code class="calibre6"><span class="calibre7">disable_irq()</span></code> and friends are found more often in drivers for older legacy devices, such as the PC parallel port.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos483121" href="#filepos482741">3</a></sup>
<em class="calibre4">Many older devices, particularly ISA devices, do not provide a method of obtaining whether they generated an interrupt. Therefore, often interrupt lines for ISA devices cannot be shared. Because the PCI specification mandates the sharing of interrupts, modern PCI-based devices support interrupt sharing. In contemporary computers, nearly all interrupt lines can be shared.</em></p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos483606"> </div>
<h4 class="calibre_27"><span class="calibre3">Status of the Interrupt System</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos483738"> </div>
<p class="calibre_2">It is often useful to know the state of the interrupt system (for example, whether interrupts are enabled or disabled) or whether you are currently executing in interrupt context.</p><div class="calibre_3"> </div>
<p class="calibre_2">The macro <code class="calibre6"><span class="calibre7">irqs_disabled()</span></code>, defined in <code class="calibre6"><span class="calibre7">&lt;asm/system.h&gt;</span></code>, returns nonzero if the interrupt system on the local processor is disabled. Otherwise, it returns zero.</p><div class="calibre_3"> </div>
<p class="calibre_2">Two macros, defined in <code class="calibre6"><span class="calibre7">&lt;linux/hardirq.h&gt;</span></code>, provide an interface to check the kernel’s current context. They are</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">in_interrupt()<br class="calibre1"/>in_irq()</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The most useful is the first: It returns nonzero if the kernel is performing any type of interrupt handling. This includes either executing an interrupt handler or a bottom half handler. The macro <code class="calibre6"><span class="calibre7">in_irq()</span></code> returns nonzero only if the kernel is specifically executing an interrupt handler.</p><div class="calibre_3"> </div>
<p class="calibre_2">More often, you want to check whether you are in process context. That is, you want to ensure you are <em class="calibre4">not</em> in interrupt context. This is often the case because code wants to do something that can only be done from process context, such as sleep. If <code class="calibre6"><span class="calibre7">in_interrupt()</span></code> returns zero, the kernel is in process context.</p><div class="calibre_3"> </div>
<p class="calibre_2">Yes, the names are confusing and do little to impart their meaning. <a href="#filepos472657">Table 7.2</a> is a summary of the interrupt control methods and their description.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos485644"> </div>
<h3 class="calibre_21"><span class="bold">Conclusion</span></h3><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos485757"> </div>
<p class="calibre_2">This chapter looked at interrupts, a hardware resource used by devices to asynchronously signal the processor. Interrupts, in effect, are used by hardware to <em class="calibre4">interrupt</em> the operating system.</p><div class="calibre_3"> </div>
<p class="calibre_2">Most modern hardware uses interrupts to communicate with operating systems. The device driver that manages a given piece of hardware registers an interrupt handler to respond to and process interrupts issued from their associated hardware. Work performed in interrupts includes acknowledging and resetting hardware, copying data from the device to main memory and vice versa, processing hardware requests, and sending out new hardware requests.</p><div class="calibre_3"> </div>
<p class="calibre_2">The kernel provides interfaces for registering and unregistering interrupt handlers, disabling interrupts, masking out interrupt lines, and checking the status of the interrupt system. <a href="#filepos472657">Table 7.2</a> provided an overview of many of these functions.</p><div class="calibre_3"> </div>
<p class="calibre_2">Because interrupts interrupt other executing code (processes, the kernel itself, and even other interrupt handlers), they must execute quickly. Often, however, there is a lot of work to do. To balance the large amount of work with the need for quick execution, the kernel divides the work of processing interrupts into two halves. The interrupt handler, the top half, was discussed in this chapter. The next chapter looks at the bottom half.</p><div class="calibre_3"> </div>  <div class="mbp_pagebreak" id="calibre_pb_45"></div>
</body></html>
