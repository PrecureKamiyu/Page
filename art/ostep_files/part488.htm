<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>43.10 Determining Block Liveness</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part487.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part489.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 33pt;text-indent: 0pt;text-align: left;">43.10 Determining Block Liveness</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">We address the mechanism first. Given a data block D within an on- disk segment S, LFS must be able to determine whether D is live. To do so, LFS adds a little extra information to each segment that describes each block. Specifically, LFS includes, for each data block D, its inode number (which file it belongs to) and its offset (which block of the file this is). This information is recorded in a structure at the head of the segment known as the <b>segment summary block</b>.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Given this information, it is straightforward to determine whether a block is live or dead. For a block D located on disk at address A, look in the segment summary block and find its inode number N and offset</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">T. Next, look in the imap to find where N lives and read N from disk (perhaps it is already in memory, which is even better). Finally, using the offset T, look in the inode (or some indirect block) to see where the inode thinks the Tth block of this file is on disk. If it points exactly to disk address A, LFS can conclude that the block <span class="s43">D </span>is live. If it points anywhere else, LFS can conclude that D is not in use (i.e., it is dead) and thus know that this version is no longer needed. A pseudocode summary of this process is shown here:</p><p class="s38" style="padding-top: 2pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">(N, T) = SegmentSummary[A]; inode = Read(imap[N]);</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">if (inode[T] == A)</p><p class="s38" style="padding-left: 85pt;text-indent: 0pt;text-align: left;">// block D is alive</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">else</p><p class="s38" style="padding-left: 85pt;text-indent: 0pt;text-align: left;">// block D is garbage</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Here is a diagram depicting the mechanism, in which the segment summary block (marked <span class="s43">SS</span>) records that the data block at address <span class="s43">A</span><span class="s44">0 </span>is actually a part of file <span class="s43">k </span>at offset <span class="s44">0</span>. By checking the imap for <span class="s43">k</span>, you can find the inode, and see that it does indeed point to that location.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="349" height="74" alt="image" src="Image_651.png"/></span></p><p class="s47" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">map[k]:A1</p><p class="s227" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">imap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-left: 3pt;text-indent: 0pt;text-align: center;">blk[0]:A0</p><p class="s227" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: center;">I[k]</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s227" style="text-indent: 0pt;text-align: center;">D</p><p style="text-indent: 0pt;text-align: left;"/><p class="s227" style="text-indent: 0pt;line-height: 11pt;text-align: left;">ss</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="text-indent: 0pt;line-height: 7pt;text-align: left;">(k,0)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="text-indent: 0pt;line-height: 7pt;text-align: left;">A0:</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-top: 1pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">A0   A1</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">There are some shortcuts LFS takes to make the process of determining liveness more efficient. For example, when a file is truncated or deleted, LFS increases its <b>version number </b>and records the new version number in the imap. By also recording the version number in the on-disk segment, LFS can short circuit the longer check described above simply by compar- ing the on-disk version number with a version number in the imap, thus avoiding extra reads.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part487.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part489.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
