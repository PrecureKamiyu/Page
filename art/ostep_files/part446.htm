<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Table 40.4: File Creation Timeline (Time Increasing Downward)</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part445.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part447.htm">下一个 &gt;</a></p><p style="padding-top: 2pt;padding-left: 55pt;text-indent: 0pt;text-align: justify;">Table 40.4: <b>File Creation Timeline (Time Increasing Downward)</b></p><p style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">one write to the inode bitmap (to mark it allocated), one write to the new inode itself (to initialize it), one to the data of the directory (to link the high-level name of the file to its inode number), and one read and write to the directory inode to update it. If the directory needs to grow to ac- commodate the new entry, additional I/Os (i.e., to the data bitmap, and the new directory block) will be needed too. All that just to create a file!</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: right;">Let’s look at a specific example, where the file <span class="s41">/foo/bar </span>is created, and three blocks are written to it. Figure <span style=" color: #00AEEF;">40.4 </span>shows what happens during the <span class="s41">open() </span>(which creates the file) and during each of three 4KB writes. In the figure, reads and writes to the disk are grouped under which system call caused them to occur, and the rough ordering they might take place in goes from top to bottom of the figure. You can see how much work it is to create the file: 10 I/Os in this case, to walk the pathname and then finally create the file. You can also see that each allocating write costs 5 I/Os: a pair to read and update the inode, another pair to read and update the data bitmap, and then finally the write of the data itself. How can a file system accomplish any of this with reasonable efficiency?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">HE </span>C<span class="s7">RUX</span>: H<span class="s7">OW </span>T<span class="s7">O </span>R<span class="s7">EDUCE </span>F<span class="s7">ILE </span>S<span class="s7">YSTEM </span>I/O C<span class="s7">OSTS</span></p><p style="padding-left: 9pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Even the simplest of operations like opening, reading, or writing a file incurs a huge number of I/O operations, scattered over the disk. What can a file system do to reduce the high costs of doing so many I/Os?</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part445.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part447.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
