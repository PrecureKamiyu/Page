<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Practice Exercises</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part441.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part443.htm">下一个 &gt;</a></p><p class="s45" style="padding-top: 4pt;padding-left: 73pt;text-indent: 0pt;text-align: left;">Practice Exercises</p><p style="padding-top: 12pt;padding-left: 156pt;text-indent: -30pt;text-align: justify;"><b>24.1 </b>Both <span class="s44">LSM </span>trees and buﬀer trees (described in Section 14.8.2) oﬀer beneﬁts to write-intensive workloads, compared to normal B<span class="s181">+</span>-trees, and buﬀer trees oﬀer potentially better lookup performance. Yet <span class="s44">LSM </span>trees are more frequently used in Big Data settings. What is the most important reason for this preference?</p><p class="s46" style="padding-top: 5pt;padding-left: 156pt;text-indent: -31pt;text-align: justify;">24.2  <span class="p">Consider the optimized technique for counting the number of bits that are set in a bitmap. What are the tradeoﬀs in choosing a smaller versus a larger array size, keeping cache size in mind?</span></p><p class="s46" style="padding-top: 6pt;padding-left: 156pt;text-indent: -31pt;text-align: justify;">24.3  <span class="p">Suppose you want to store line segments in an R-tree. If a line segment is not parallel to the axes, the bounding box for it can be large, containing a large empty area.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 175pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Describe the eﬀect on performance of having large bounding boxes on queries that ask for line segments intersecting a given region.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 175pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Brieﬂy describe a technique to improve performance for such queries and give an example of its beneﬁt. Hint: You can divide segments into smaller pieces.</span></p><p class="s46" style="padding-top: 7pt;padding-left: 156pt;text-indent: -31pt;text-align: justify;">24.4  <span class="p">Give a search algorithm on an R-tree for eﬃciently ﬁnding the nearest neighbor to a given query point.</span></p><p class="s46" style="padding-top: 6pt;padding-left: 156pt;text-indent: -31pt;text-align: justify;">24.5  <span class="p">Give a recursive procedure to eﬃciently compute the spatial join of two rela- tions with R-tree indices. (Hint: Use bounding boxes to check if leaf entries under a pair of internal nodes may intersect.)</span></p><p class="s46" style="padding-top: 6pt;padding-left: 156pt;text-indent: -31pt;text-align: justify;">24.6 <span class="p">Suppose that we are using extendable hashing on a ﬁle that contains records with the following search-key values:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 260pt;text-indent: 0pt;text-align: left;">2, 3, 5, 7, 11, 17, 19, 23, 29, 31</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 156pt;text-indent: 0pt;text-align: left;">Show the extendable hash structure for this ﬁle if the hash function is <i>h</i>(<i>x</i>) <span class="s15">= </span><i>x</i></p><p style="padding-left: 156pt;text-indent: 0pt;text-align: left;">mod 8 and buckets can hold three records.</p><p class="s46" style="padding-top: 6pt;padding-left: 156pt;text-indent: -31pt;text-align: left;">24.7  <span class="p">Show how the extendable hash structure of Exercise 24.6 changes as the result of each of the following steps:</span></p><p style="padding-top: 6pt;padding-left: 163pt;text-indent: 0pt;text-align: left;">a. Delete 11.</p><p style="padding-top: 6pt;padding-left: 162pt;text-indent: 0pt;text-align: left;">b. Delete 31.</p><p style="padding-top: 6pt;padding-left: 163pt;text-indent: 0pt;text-align: left;">c. Insert 1.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 131pt;text-indent: 0pt;text-align: left;"><a name="bookmark550">d. Insert 15.</a><a name="bookmark580">&zwnj;</a></p><p class="s46" style="padding-top: 7pt;padding-left: 124pt;text-indent: -31pt;text-align: justify;">24.8  <span class="p">Give pseudocode for deletion of entries fromAVi an extendable hash structure, including details of when and how to coalesce buckets. Do not bother about reducing the size of the bucket address table.</span></p><p style="padding-top: 6pt;padding-left: 124pt;text-indent: -31pt;text-align: justify;"><b>24.9 </b>Suggest an eﬃcient way to test if the bucket address table in extendable hashing can be reduced in size by storing an extra count with the bucket address table. Give details of how the count should be maintained when buckets are split, coalesced, or deleted. (<i>Note</i>: Reducing the size of the bucket address table is an expensive operation, and subsequent inserts may cause the table to grow again. Therefore, it is best not to reduce the size as soon as it is possible to do so, but instead do it only if the number of index entries becomes small compared to the bucket-address-table size.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part441.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part443.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
