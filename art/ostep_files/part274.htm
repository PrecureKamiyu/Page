<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>27.3 Locks</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part273.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part275.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">27.3 Locks</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Beyond thread creation and join, probably the next most useful set of functions provided by the POSIX threads library are those for providing mutual exclusion to a critical section via <b>locks</b>. The most basic pair of routines to use for this purpose is provided by this pair of routines:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: left;">int pthread_mutex_lock(pthread_mutex_t <span class="s39">*</span>mutex); int pthread_mutex_unlock(pthread_mutex_t <span class="s39">*</span>mutex);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_340.png"/></span></p><p class="s12" style="padding-top: 2pt;padding-left: 41pt;text-indent: 13pt;line-height: 91%;text-align: justify;"><span class="s11">2</span>Fortunately the compiler <span class="s38">gcc </span>will likely complain when you write code like this, which is yet another reason to pay attention to compiler warnings.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The routines should be easy to understand and use. When you have a region of code you realize is a <b>critical section</b>, and thus needs to be pro- tected by locks in order to operate as desired. You can probably imagine what the code looks like:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">pthread_mutex_t lock; pthread_mutex_lock(&amp;lock);</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">x = x + 1; // or whatever your critical section is pthread_mutex_unlock(&amp;lock);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_341.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_342.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The intent of the code is as follows: if no other thread holds the lock when <span class="s41">pthread mutex lock() </span>is called, the thread will acquire the lock and enter the critical section. If another thread does indeed hold the lock, the thread trying to grab the lock will not return from the call until it has acquired the lock (implying that the thread holding the lock has released it via the unlock call). Of course, many threads may be stuck waiting inside the lock acquisition function at a given time; only the thread with the lock acquired, however, should call unlock.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Unfortunately, this code is broken, in two important ways. The first problem is a <b>lack of proper initialization</b>. All locks must be properly initialized in order to guarantee that they have the correct values to begin with and thus work as desired when lock and unlock are called.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_343.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_344.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">With POSIX threads, there are two ways to initialize locks. One way to do this is to use <span class="s41">PTHREAD MUTEX INITIALIZER</span>, as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_345.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_346.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Doing so sets the lock to the default values and thus makes the lock usable. The dynamic way to do it (i.e., at run time) is to make a call to <span class="s41">pthread mutex init()</span>, as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">int rc = pthread_mutex_init(&amp;lock, NULL); assert(rc == 0); // always check success!</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_347.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_348.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: left;">The first argument to this routine is the address of the lock itself, whereas the second is an optional set of attributes. Read more about the attributes yourself; passing <span class="s41">NULL </span>in simply uses the defaults. Either way works, but we usually use the dynamic (latter) method. Note that a corresponding call to <span class="s41">pthread cond destroy() </span>should also be made, when you are done with the lock; see the manual page for all of details.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The second problem with the code above is that it fails to check errors code when calling lock and unlock. Just like virtually any library rou- tine you call in a U<span class="s7">NIX </span>system, these routines can also fail! If your code doesn’t properly check error codes, the failure will happen silently, which in this case could allow multiple threads into a critical section. Minimally, use wrappers, which assert that the routine succeeded (e.g., as in Fig- ure <span style=" color: #00AEEF;">27.4</span>); more sophisticated (non-toy) programs, which can’t simply exit when something goes wrong, should check for failure and do something appropriate when the lock or unlock does not succeed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">// Use this to keep your code clean but check for failures</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">// Only use if exiting program is OK upon failure void Pthread_mutex_lock(pthread_mutex_t <span class="s39">*</span>mutex) {</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;line-height: 7pt;text-align: left;">int rc = pthread_mutex_lock(mutex);</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">assert(rc == 0);</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;line-height: 7pt;text-align: left;">}</p><p style="padding-left: 116pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Figure 27.4: <b>An Example Wrapper</b></p><p style="padding-top: 5pt;padding-left: 33pt;text-indent: 0pt;text-align: center;">The lock and unlock routines are not the only routines that pthreads</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: left;">has to interact with locks. In particular, here are two more routines which may be of interest:</p><p class="s38" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;line-height: 90%;text-align: left;">int pthread_mutex_trylock(pthread_mutex_t <span class="s39">*</span>mutex); int pthread_mutex_timedlock(pthread_mutex_t <span class="s39">*</span>mutex,</p><p class="s38" style="padding-left: 158pt;text-indent: 0pt;line-height: 86%;text-align: left;">struct timespec <span class="s39">*</span>abs_timeout);</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">These two calls are used in lock acquisition. The <span class="s41">trylock </span>version re- turns failure if the lock is already held; the <span class="s41">timedlock </span>version of acquir- ing a lock returns after a timeout or after acquiring the lock, whichever happens first. Thus, the timedlock with a timeout of zero degenerates to the trylock case. Both of these versions should generally be avoided; however, there are a few cases where avoiding getting stuck (perhaps in- definitely) in a lock acquisition routine can be useful, as we’ll see in future chapters (e.g., when we study deadlock).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part273.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part275.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
