<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 46. System V Message Queues</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch45.html" title="Chapter 45. Introduction to System V IPC"/><link rel="next" href="ch47.html" title="Chapter 47. System V Semaphores"/></head><body><section class="chapter" title="Chapter 46. System V Message Queues" epub:type="chapter" id="system_v_message_queues"><div class="titlepage"><div><div><h2 class="title">Chapter 46. System V Message Queues</h2></div></div></div><p>This chapter describes System V message queues. Message queues allow processes to
            exchange data in the form of messages. Although message queues are similar to pipes and
            FIFOs in some respects, they also differ in important ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The handle used to refer to a message queue is the identifier returned by a
                    call to <span class="emphasis"><em>msgget()</em></span>. These identifiers are not the same as the
                    file descriptors used for most other forms of I/O on UNIX systems.</p></li><li class="listitem"><p>Communication via message queues is message-oriented; that is, the reader
                    receives whole messages, as written by the writer. It is not possible to read
                    part of a message, leaving the remainder in the queue, or to read multiple
                    messages at a time. This contrasts with pipes, which provide an undifferentiated
                    stream of bytes (i.e., with pipes, the reader can read an arbitrary number of
                    bytes at a time, irrespective of the size of data blocks written by the
                    writer).</p></li><li class="listitem"><p>In addition to containing data, each message has an integer
                        <span class="emphasis"><em>type</em></span>. Messages can be retrieved from a queue in
                    first-in, first-out order or retrieved by type.</p></li></ul></div><p>At the end of this chapter (<a class="xref" href="ch46.html#disadvantages_of_system_v_message_queues" title="Disadvantages of System V Message Queues">Disadvantages of System V Message Queues</a>), we summarize a number of limitations of System V message queues. These limitations
            lead us to the conclusion that, where possible, new applications should avoid the use of
            System V message queues in favor of other IPC mechanisms such as FIFOs, POSIX message
            queues, and sockets. However, when message queues were initially devised, these
            alternative mechanisms were unavailable or were not widespread across UNIX
            implementations. Consequently, there are various existing applications that employ
            message queues, and this fact forms one of the primary motivations for describing
            them.</p><div class="sect1" title="Creating or Opening a Message Queue"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="creating_or_opening_a_message_queue">Creating or Opening a Message Queue</h2></div></div></div><p>The <span class="emphasis"><em>msgget()</em></span> system call creates a new message queue or
                obtains the identifier of an existing queue.<a id="IDX-CHP-46-6284" class="indexterm"/><a id="IDX-CHP-46-6285" class="indexterm"/><a id="IDX-CHP-46-6286" class="indexterm"/><a id="IDX-CHP-46-6287" class="indexterm"/><a id="IDX-CHP-46-6288" class="indexterm"/><a id="IDX-CHP-46-6289" class="indexterm"/><a id="IDX-CHP-46-6290" class="indexterm"/><a id="IDX-CHP-46-6291" class="indexterm"/><a id="IDX-CHP-46-6292" class="indexterm"/><a id="IDX-CHP-46-6293" class="indexterm"/></p><a id="I_programlisting46_d1e121730"/><pre class="programlisting">#include &lt;sys/types.h&gt;        /* For portability */
#include &lt;sys/msg.h&gt;

int <strong class="userinput"><code>msgget</code></strong>(key_t <span class="emphasis"><em>key</em></span>, int <span class="emphasis"><em>msgflg</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns message queue identifier on success, or -1 on error</p></div><p>The <span class="emphasis"><em>key</em></span> argument is a key generated using one of the methods
                described in <a class="xref" href="ch45.html#ipc_keys" title="IPC Keys">IPC Keys</a> (i.e., usually the value <code class="literal">IPC_PRIVATE</code> or a key returned by
                    <span class="emphasis"><em>ftok()</em></span>). The <span class="emphasis"><em>msgflg</em></span> argument is a bit
                mask that specifies the permissions (<a class="xref" href="ch15.html#constants_for_file_permission_bits" title="Table 15-4. Constants for file permission bits">Table 15-4</a>, in <a class="xref" href="ch15.html#permissions_on_regular_files" title="Permissions on Regular Files">Permissions on Regular Files</a>) to be placed on a new message queue or
                checked against an existing queue. In addition, zero or more of the following flags
                can be ORed (|) in <span class="emphasis"><em>msgflg</em></span> to control the operation of
                    <span class="emphasis"><em>msgget()</em></span>:</p><div class="variablelist"><dl><dt><span class="term">
                        <code class="literal">IPC_CREAT</code>
                    </span></dt><dd><p>If no message queue with the specified <span class="emphasis"><em>key</em></span>
                            exists, create a new queue.</p></dd><dt><span class="term">
                        <code class="literal">IPC_EXCL</code>
                    </span></dt><dd><p>If <code class="literal">IPC_CREAT</code> was also specified,
                            and a queue with the specified <span class="emphasis"><em>key</em></span> already exists,
                            fail with the error <code class="literal">EEXIST</code>.</p></dd></dl></div><p>These flags are described in more detail in Section 45.1.</p><p>The <span class="emphasis"><em>msgget()</em></span> system call begins by searching the set of all
                existing message queues for one with the specified key. If a matching queue is
                found, the identifier of that queue is returned (unless both <code class="literal">IPC_CREAT</code> and <code class="literal">IPC_EXCL</code> were specified in <span class="emphasis"><em>msgflg</em></span>, in which case
                an error is returned). If no matching queue was found and <code class="literal">IPC_CREAT</code> was specified in <span class="emphasis"><em>msgflg</em></span>, a new queue
                is created and its identifier is returned.</p><p>The program in <a class="xref" href="ch46.html#using_msgget_open_parenthesis_close_pare" title="Example 46-1. Using msgget()">Example 46-1</a> provides
                a command-line interface to the <span class="emphasis"><em>msgget()</em></span> system call. The
                program permits the use of command-line options and arguments to specify all
                possibilities for the <span class="emphasis"><em>key</em></span> and <span class="emphasis"><em>msgflg</em></span>
                arguments to <span class="emphasis"><em>msgget()</em></span>. Details of the command format accepted
                by this program are shown in the <span class="emphasis"><em>usageError()</em></span> function. Upon
                successful queue creation, the program prints the queue identifier. We demonstrate
                the use of this program in <a class="xref" href="ch46.html#receiving_messages" title="Receiving Messages">Receiving Messages</a>.</p><div class="example"><a id="using_msgget_open_parenthesis_close_pare"/><div class="example-title">Example 46-1. Using <span class="emphasis"><em>msgget()</em></span></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svmsg/svmsg_create.c</code></strong>
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;
#include &lt;sys/stat.h&gt;
#include "tlpi_hdr.h"

static void             /* Print usage info, then exit */
usageError(const char *progName, const char *msg)
{
    if (msg != NULL)
        fprintf(stderr, "%s", msg);
    fprintf(stderr, "Usage: %s [-cx] {-f pathname | -k key | -p} "
                            "[octal-perms]\n", progName);
    fprintf(stderr, "    -c           Use IPC_CREAT flag\n");
    fprintf(stderr, "    -x           Use IPC_EXCL flag\n");
    fprintf(stderr, "    -f pathname  Generate key using ftok()\n");
    fprintf(stderr, "    -k key       Use 'key' as key\n");
    fprintf(stderr, "    -p           Use IPC_PRIVATE key\n");
    exit(EXIT_FAILURE);
}

int
main(int argc, char *argv[])
{
    int numKeyFlags;            /* Counts -f, -k, and -p options */
    int flags, msqid, opt;
    unsigned int perms;
    long lkey;
    key_t key;

    /* Parse command-line options and arguments */

    numKeyFlags = 0;
    flags = 0;

    while ((opt = getopt(argc, argv, "cf:k:px")) != -1) {
        switch (opt) {
        case 'c':
            flags |= IPC_CREAT;
            break;

        case 'f':               /* -f pathname */
            key = ftok(optarg, 1);
            if (key == -1)
                errExit("ftok");
            numKeyFlags++;
            break;

        case 'k':               /* -k key (octal, decimal or hexadecimal) */
            if (sscanf(optarg, "%li", &amp;lkey) != 1)
                cmdLineErr("-k option requires a numeric argument\n");
            key = lkey;
            numKeyFlags++;
            break;

        case 'p':
            key = IPC_PRIVATE;
            numKeyFlags++;
            break;

        case 'x':
            flags |= IPC_EXCL;
            break;

        default:
            usageError(argv[0], "Bad option\n");
        }
    }

    if (numKeyFlags != 1)
        usageError(argv[0], "Exactly one of the options -f, -k, "
                            "or -p must be supplied\n");

    perms = (optind == argc) ? (S_IRUSR | S_IWUSR) :
                getInt(argv[optind], GN_BASE_8, "octal-perms");

    msqid = msgget(key, flags | perms);
    if (msqid == -1)
        errExit("msgget");

    printf("%d\n", msqid);
    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>svmsg/svmsg_create.c</code></strong></pre></div></div></div><div class="sect1" title="Exchanging Messages"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exchanging_messages">Exchanging Messages</h2></div></div></div><p>The <span class="emphasis"><em>msgsnd()</em></span> and <span class="emphasis"><em>msgrcv()</em></span> system calls
                perform I/O on message queues. The first argument to both system calls
                    (<span class="emphasis"><em>msqid</em></span>) is a message queue identifier. The second argument,
                    <span class="emphasis"><em>msgp</em></span>, is a pointer to a programmer-defined structure used
                to hold the message being sent or received. This structure has the following general
                    form:<a id="IDX-CHP-46-6294" class="indexterm"/><a id="IDX-CHP-46-6295" class="indexterm"/><a id="IDX-CHP-46-6296" class="indexterm"/><a id="IDX-CHP-46-6297" class="indexterm"/><a id="IDX-CHP-46-6298" class="indexterm"/></p><a id="I_programlisting46_d1e121903"/><pre class="programlisting">struct mymsg {
    long mtype;                 /* Message type */
    char mtext[];               /* Message body */
}</pre><p>This definition is really just shorthand for saying that the first part of a
                message contains the message type, specified as a long integer, while the remainder
                of the message is a programmer-defined structure of arbitrary length and content; it
                need not be an array of characters. Thus, the <span class="emphasis"><em>mgsp</em></span> argument is
                typed as <span class="emphasis"><em>void *</em></span> to allow it to be a pointer to any type of
                structure.</p><p>A zero-length <span class="emphasis"><em>mtext</em></span> field is permitted, and is sometimes
                useful if the information to be conveyed can be encoded solely in the message type
                or if the existence of a message is in itself sufficient information for the
                receiving process.</p><div class="sect2" title="Sending Messages"><div class="titlepage"><div><div><h3 class="title" id="sending_messages">Sending Messages</h3></div></div></div><p>The <span class="emphasis"><em>msgsnd()</em></span> system call writes a message to a message
                        queue.<a id="IDX-CHP-46-6299" class="indexterm"/><a id="IDX-CHP-46-6300" class="indexterm"/><a id="IDX-CHP-46-6301" class="indexterm"/><a id="IDX-CHP-46-6302" class="indexterm"/><a id="IDX-CHP-46-6303" class="indexterm"/><a id="IDX-CHP-46-6304" class="indexterm"/><a id="IDX-CHP-46-6305" class="indexterm"/></p><a id="I_programlisting46_d1e121962"/><pre class="programlisting">#include &lt;sys/types.h&gt;        /* For portability */
#include &lt;sys/msg.h&gt;

int <strong class="userinput"><code>msgsnd</code></strong>(int <span class="emphasis"><em>msqid</em></span>, const void *<span class="emphasis"><em>msgp</em></span>, size_t <span class="emphasis"><em>msgsz</em></span>, int <span class="emphasis"><em>msgflg</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>To send a message with <span class="emphasis"><em>msgsnd()</em></span>, we must set the
                        <span class="emphasis"><em>mtype</em></span> field of the message structure to a value greater
                    than 0 (we see how this value is used when we discuss
                        <span class="emphasis"><em>msgrcv()</em></span> in the next section) and copy the desired
                    information into the programmer-defined <span class="emphasis"><em>mtext</em></span> field. The
                        <span class="emphasis"><em>msgsz</em></span> argument specifies the number of bytes contained
                    in the <span class="emphasis"><em>mtext</em></span> field.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>When sending messages with <span class="emphasis"><em>msgsnd()</em></span>, there is no
                        concept of a partial write as with <span class="emphasis"><em>write()</em></span>. This is why
                        a successful <span class="emphasis"><em>msgsnd()</em></span> needs only to return 0, rather
                        than the number of bytes sent.</p></div><p>The final argument, <span class="emphasis"><em>msgflg</em></span>, is a bit mask of flags
                    controlling the operation of <span class="emphasis"><em>msgsnd()</em></span>. Only one such flag
                    is defined:</p><div class="variablelist"><dl><dt><span class="term">
                            <code class="literal">IPC_NOWAIT</code>
                        </span></dt><dd><p>Perform a nonblocking send. Normally, if a message queue is full,
                                    <span class="emphasis"><em>msgsnd()</em></span> blocks until enough space has
                                become available to allow the message to be placed on the queue.
                                However, if this flag is specified, then
                                    <span class="emphasis"><em>msgsnd()</em></span> returns immediately with the error
                                    <code class="literal">EAGAIN</code>.<a id="IDX-CHP-46-6306" class="indexterm"/></p></dd></dl></div><p>A <span class="emphasis"><em>msgsnd()</em></span> call that is blocked because the queue is full
                    may be interrupted by a signal handler. In this case,
                        <span class="emphasis"><em>msgsnd()</em></span> always fails with the error <code class="literal">EINTR</code>. (As noted in <a class="xref" href="ch21.html#interruption_and_restarting_of_system_ca" title="Interruption and Restarting of System Calls">Interruption and Restarting of System Calls</a>,
                        <span class="emphasis"><em>msgsnd()</em></span> is among those system calls that are never
                    automatically restarted, regardless of the setting of the <code class="literal">SA_RESTART</code> flag when the signal handler is
                    established.)</p><p>Writing a message to a message queue requires write permission on the
                    queue.</p><p>The program in <a class="xref" href="ch46.html#using_msgsnd_open_parenthesis_close_pare" title="Example 46-2. Using msgsnd() to send a message">Example 46-2</a>
                    provides a command-line interface to the <span class="emphasis"><em>msgsnd()</em></span> system
                    call. The command-line format accepted by this program is shown in the
                        <span class="emphasis"><em>usageError()</em></span> function. Note that this program doesn’t
                    use the <span class="emphasis"><em>msgget()</em></span> system call. (We noted that a process
                    doesn’t need to use a <span class="emphasis"><em>get</em></span> call in order to access an IPC
                    object in Section 45.1.) Instead, we specify the message queue by providing its
                    identifier as a command-line argument. We demonstrate the use of this program in
                        <a class="xref" href="ch46.html#receiving_messages" title="Receiving Messages">Receiving Messages</a>.</p><div class="example"><a id="using_msgsnd_open_parenthesis_close_pare"/><div class="example-title">Example 46-2. Using <span class="emphasis"><em>msgsnd()</em></span> to send a message</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svmsg/svmsg_send.c</code></strong>
#include &lt;sys/types.h&gt;
#include &lt;sys/msg.h&gt;
#include "tlpi_hdr.h"

#define MAX_MTEXT 1024

struct mbuf {
    long mtype;                         /* Message type */
    char mtext[MAX_MTEXT];              /* Message body */
};

static void             /* Print (optional) message, then usage description */
usageError(const char *progName, const char *msg)
{
    if (msg != NULL)
        fprintf(stderr, "%s", msg);
    fprintf(stderr, "Usage: %s [-n] msqid msg-type [msg-text]\n", progName);
    fprintf(stderr, "    -n       Use IPC_NOWAIT flag\n");
    exit(EXIT_FAILURE);
}

int
main(int argc, char *argv[])
{
    int msqid, flags, msgLen;
    struct mbuf msg;                    /* Message buffer for msgsnd() */
    int opt;                            /* Option character from getopt() */

    /* Parse command-line options and arguments */

    flags = 0;
    while ((opt = getopt(argc, argv, "n")) != -1) {
        if (opt == 'n')
            flags |= IPC_NOWAIT;
        else
            usageError(argv[0], NULL);
    }

    if (argc &lt; optind + 2 || argc &gt; optind + 3)
        usageError(argv[0], "Wrong number of arguments\n");

    msqid = getInt(argv[optind], 0, "msqid");
    msg.mtype = getInt(argv[optind + 1], 0, "msg-type");

    if (argc &gt; optind + 2) {            /* 'msg-text' was supplied */
        msgLen = strlen(argv[optind + 2]) + 1;
        if (msgLen &gt; MAX_MTEXT)
            cmdLineErr("msg-text too long (max: %d characters)\n", MAX_MTEXT);

        memcpy(msg.mtext, argv[optind + 2], msgLen);

    } else {                            /* No 'msg-text' ==&gt; zero-length msg */
        msgLen = 0;
    }

    /* Send message */

    if (msgsnd(msqid, &amp;msg, msgLen, flags) == -1)
        errExit("msgsnd");

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>svmsg/svmsg_send.c</code></strong></pre></div></div></div><div class="sect2" title="Receiving Messages"><div class="titlepage"><div><div><h3 class="title" id="receiving_messages">Receiving Messages</h3></div></div></div><p>The <span class="emphasis"><em>msgrcv()</em></span> system call reads (and removes) a message
                    from a message queue, and copies its contents into the buffer pointed to by
                        <span class="emphasis"><em>msgp</em></span>.<a id="IDX-CHP-46-6307" class="indexterm"/><a id="IDX-CHP-46-6308" class="indexterm"/><a id="IDX-CHP-46-6309" class="indexterm"/><a id="IDX-CHP-46-6310" class="indexterm"/><a id="IDX-CHP-46-6311" class="indexterm"/><a id="IDX-CHP-46-6312" class="indexterm"/><a id="IDX-CHP-46-6313" class="indexterm"/><a id="IDX-CHP-46-6314" class="indexterm"/></p><a id="I_programlisting46_d1e122156"/><pre class="programlisting">#include &lt;sys/types.h&gt;        /* For portability */
#include &lt;sys/msg.h&gt;

ssize_t <strong class="userinput"><code>msgrcv</code></strong>(int <span class="emphasis"><em>msqid</em></span>, void *<span class="emphasis"><em>msgp</em></span>, size_t <span class="emphasis"><em>maxmsgsz</em></span>, long
 <span class="emphasis"><em>msgtyp</em></span>, int <span class="emphasis"><em>msgflg</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns number of bytes copied into <span class="emphasis"><em>mtext</em></span> field, or
                        -1 on error</p></div><p>The maximum space available in the <span class="emphasis"><em>mtext</em></span> field of the
                        <span class="emphasis"><em>msgp</em></span> buffer is specified by the argument
                        <span class="emphasis"><em>maxmsgsz</em></span>. If the body of the message to be removed from
                    the queue exceeds <span class="emphasis"><em>maxmsgsz</em></span> bytes, then no message is
                    removed from the queue, and <span class="emphasis"><em>msgrcv()</em></span> fails with the error
                        <code class="literal">E2BIG</code>. (This default behavior can be
                    changed using the <code class="literal">MSG_NOERROR</code> flag described
                    shortly.)</p><p>Messages need not be read in the order in which they were sent. Instead, we
                    can select messages according to the value in the <span class="emphasis"><em>mtype</em></span>
                    field. This selection is controlled by the <span class="emphasis"><em>msgtyp</em></span> argument,
                    as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If <span class="emphasis"><em>msgtyp</em></span> equals 0, the first message from the
                            queue is removed and returned to the calling process.</p></li><li class="listitem"><p>If <span class="emphasis"><em>msgtyp</em></span> is greater than 0, the first message in
                            the queue whose <span class="emphasis"><em>mtype</em></span> equals
                                <span class="emphasis"><em>msgtyp</em></span> is removed and returned to the calling
                            process. By specifying different values for <span class="emphasis"><em>msgtyp</em></span>,
                            multiple processes can read from a message queue without racing to read
                            the same messages. One useful technique is to have each process select
                            messages matching its process ID.</p></li><li class="listitem"><p>If <span class="emphasis"><em>msgtyp</em></span> is less than 0, treat the waiting
                            messages as a <span class="emphasis"><em>priority queue</em></span>. The first message of
                            the lowest <span class="emphasis"><em>mtype</em></span> less than or equal to the absolute
                            value of <span class="emphasis"><em>msgtyp</em></span> is removed and returned to the
                            calling process.</p></li></ul></div><p>An example helps clarify the behavior when <span class="emphasis"><em>msgtyp</em></span> is less
                    than 0. Suppose that we have a message queue containing the sequence of messages
                    shown in <a class="xref" href="ch46.html#example_of_a_message_queue_containing_me" title="Figure 46-1. Example of a message queue containing messages of different types">Figure 46-1</a> and we
                    performed a series of <span class="emphasis"><em>msgrcv()</em></span> calls of the following
                    form:</p><a id="I_programlisting46_d1e122262"/><pre class="programlisting">msgrcv(id, &amp;msg, maxmsgsz, -300, 0);</pre><p>These <span class="emphasis"><em>msgrcv()</em></span> calls would retrieve messages in the order
                    2 (type 100), 5 (type 100), 3 (type 200), and 1 (type 300). A further call would
                    block, since the type of the remaining message (400) exceeds 300.</p><p>The <span class="emphasis"><em>msgflg</em></span> argument is a bit mask formed by ORing
                    together zero or more of the following flags:</p><div class="variablelist"><dl><dt><span class="term">
                            <code class="literal">IPC_NOWAIT</code>
                        </span></dt><dd><p>Perform a nonblocking receive. Normally, if no message matching
                                    <span class="emphasis"><em>msgtyp</em></span> is in the queue,
                                    <span class="emphasis"><em>msgrcv()</em></span> blocks until such a message
                                becomes available. Specifying the <code class="literal">IPC_NOWAIT</code> flag causes <span class="emphasis"><em>msgrcv()</em></span>
                                to instead return immediately with the error <code class="literal">ENOMSG</code>. (The error <code class="literal">EAGAIN</code> would be more consistent, as
                                occurs on a nonblocking <span class="emphasis"><em>msgsnd()</em></span> or a
                                nonblocking read from a FIFO. However, failing with <code class="literal">ENOMSG</code> is historical behavior, and
                                required by SUSv3.)<a id="IDX-CHP-46-6315" class="indexterm"/></p></dd><dt><span class="term">
                            <code class="literal">MSG_EXCEPT</code>
                        </span></dt><dd><p>This flag has an effect only if <span class="emphasis"><em>msgtyp</em></span> is
                                greater than 0, in which case it forces the complement of the usual
                                operation; that is, the first message from the queue whose
                                    <span class="emphasis"><em>mtype</em></span> is <span class="emphasis"><em>not</em></span> equal to
                                    <span class="emphasis"><em>msgtyp</em></span> is removed from the queue and
                                returned to the caller. This flag is Linux-specific, and is made
                                available from <code class="literal">&lt;sys/msg.h&gt;</code> only if <code class="literal">_GNU_SOURCE</code> is defined. Performing a
                                series of calls of the form <span class="emphasis"><em>msgrcv(id, &amp;msg,
                                    maxmsgsz, 100, MSG_EXCEPT)</em></span> on the message queue shown
                                in <a class="xref" href="ch46.html#example_of_a_message_queue_containing_me" title="Figure 46-1. Example of a message queue containing messages of different types">Figure 46-1</a> would
                                retrieve messages in the order 1, 3, 4, and then block.</p></dd><dt><span class="term">
                            <code class="literal">MSG_NOERROR</code>
                        </span></dt><dd><p>By default, if the size of the <span class="emphasis"><em>mtext</em></span> field of
                                the message exceeds the space available (as defined by the
                                    <span class="emphasis"><em>maxmsgsz</em></span> argument),
                                    <span class="emphasis"><em>msgrcv()</em></span> fails. If the <code class="literal">MSG_NOERROR</code> flag is specified, then
                                    <span class="emphasis"><em>msgrcv()</em></span> instead removes the message from
                                the queue, truncates its <span class="emphasis"><em>mtext</em></span> field to
                                    <span class="emphasis"><em>maxmsgsz</em></span> bytes, and returns it to the
                                caller. The truncated data is lost.</p></dd></dl></div><p>Upon successful completion, <span class="emphasis"><em>msgrcv()</em></span> returns the size of
                    the <span class="emphasis"><em>mtext</em></span> field of the received message; on error, -1 is
                    returned.</p><div class="figure"><a id="example_of_a_message_queue_containing_me"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject46_d1e122386"/><img src="figs/web/46-1_SVMSG-queue-example-scale90.png.jpg" alt="Example of a message queue containing messages of different types"/></div></div><div class="figure-title">Figure 46-1. Example of a message queue containing messages of different types</div></div><p>As with <span class="emphasis"><em>msgsnd()</em></span>, if a blocked
                        <span class="emphasis"><em>msgrcv()</em></span> call is interrupted by a signal handler, then
                    the call fails with the error <code class="literal">EINTR</code>,
                    regardless of the setting of the <code class="literal">SA_RESTART</code>
                    flag when the signal handler was established.</p><p>Reading a message from a message queue requires read permission on the
                    queue.</p><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id62">Example program</h4></div></div></div><p>The program in <a class="xref" href="ch46.html#using_msgrcv_open_parenthesis_close_pare" title="Example 46-3. Using msgrcv() to read a message">Example 46-3</a>
                        provides a command-line interface to the <span class="emphasis"><em>msgrcv()</em></span>
                        system call. The command-line format accepted by this program is shown in
                        the <span class="emphasis"><em>usageError()</em></span> function. Like the program in <a class="xref" href="ch46.html#using_msgsnd_open_parenthesis_close_pare" title="Example 46-2. Using msgsnd() to send a message">Example 46-2</a>, which demonstrated
                        the use of <span class="emphasis"><em>msgsnd()</em></span>, this program doesn’t use the
                            <span class="emphasis"><em>msgget()</em></span> system call, but instead expects a message
                        queue identifier as its command-line argument.<a id="IDX-CHP-46-6316" class="indexterm"/><a id="IDX-CHP-46-6317" class="indexterm"/><a id="IDX-CHP-46-6318" class="indexterm"/><a id="IDX-CHP-46-6319" class="indexterm"/><a id="IDX-CHP-46-6320" class="indexterm"/><a id="IDX-CHP-46-6321" class="indexterm"/></p><p>The following shell session demonstrates the use of the programs in <a class="xref" href="ch46.html#using_msgget_open_parenthesis_close_pare" title="Example 46-1. Using msgget()">Example 46-1</a>, <a class="xref" href="ch46.html#using_msgsnd_open_parenthesis_close_pare" title="Example 46-2. Using msgsnd() to send a message">Example 46-2</a>, and <a class="xref" href="ch46.html#using_msgrcv_open_parenthesis_close_pare" title="Example 46-3. Using msgrcv() to read a message">Example 46-3</a>. We begin by
                        creating a message queue using the <code class="literal">IPC_PRIVATE</code> key, and then write three messages with different
                        types to the queue:</p><a id="I_programlisting46_d1e122469"/><pre class="programlisting">$ <strong class="userinput"><code>./svmsg_create -p</code></strong>
32769                                               <em class="lineannotation"><span class="lineannotation">ID of message queue</span></em>
$ <strong class="userinput"><code>./svmsg_send 32769 20 "I hear and I forget."</code></strong>
$ <strong class="userinput"><code>./svmsg_send 32769 10 "I see and I remember."</code></strong>
$ <strong class="userinput"><code>./svmsg_send 32769 30 "I do and I understand."</code></strong></pre><p>We then use the program in <a class="xref" href="ch46.html#using_msgrcv_open_parenthesis_close_pare" title="Example 46-3. Using msgrcv() to read a message">Example 46-3</a> to read messages
                        with a type less than or equal to 20 from the queue:</p><a id="I_programlisting46_d1e122489"/><pre class="programlisting">$ <strong class="userinput"><code>./svmsg_receive -t -20 32769</code></strong>
Received: type=10; length=22; body=I see and I remember.
$ <strong class="userinput"><code>./svmsg_receive -t -20 32769</code></strong>
Received: type=20; length=21; body=I hear and I forget.
$ <strong class="userinput"><code>./svmsg_receive -t -20 32769</code></strong></pre><p>The last of the above commands blocked, because there was no message in
                        the queue whose type was less than or equal to 20. So, we continue by typing
                            <span class="emphasis"><em>Control-C</em></span> to terminate the command, and then
                        execute a command that reads a message of any type from the queue:</p><a id="I_programlisting46_d1e122504"/><pre class="programlisting"><em class="lineannotation"><span class="lineannotation">Type Control-C to terminate program</span></em>
$ <strong class="userinput"><code>./svmsg_receive 32769</code></strong>
Received: type=30; length=23; body=I do and I understand.</pre><div class="example"><a id="using_msgrcv_open_parenthesis_close_pare"/><div class="example-title">Example 46-3. Using <span class="emphasis"><em>msgrcv()</em></span> to read a message</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svmsg/svmsg_receive.c</code></strong>
#define _GNU_SOURCE     /* Get definition of MSG_EXCEPT */
#include &lt;sys/types.h&gt;
#include &lt;sys/msg.h&gt;
#include "tlpi_hdr.h"

#define MAX_MTEXT 1024

struct mbuf {
    long mtype;                 /* Message type */
    char mtext[MAX_MTEXT];      /* Message body */
};

static void
usageError(const char *progName, const char *msg)
{
    if (msg != NULL)
        fprintf(stderr, "%s", msg);
    fprintf(stderr, "Usage: %s [options] msqid [max-bytes]\n", progName);
    fprintf(stderr, "Permitted options are:\n");
    fprintf(stderr, "    -e       Use MSG_NOERROR flag\n");
    fprintf(stderr, "    -t type  Select message of given type\n");
    fprintf(stderr, "    -n       Use IPC_NOWAIT flag\n");
#ifdef MSG_EXCEPT
    fprintf(stderr, "    -x       Use MSG_EXCEPT flag\n");
#endif
    exit(EXIT_FAILURE);
}

int
main(int argc, char *argv[])
{
    int msqid, flags, type;
    ssize_t msgLen;
    size_t maxBytes;
    struct mbuf msg;            /* Message buffer for msgrcv() */
    int opt;                    /* Option character from getopt() */

    /* Parse command-line options and arguments */

    flags = 0;
    type = 0;
    while ((opt = getopt(argc, argv, "ent:x")) != -1) {
        switch (opt) {
        case 'e':       flags |= MSG_NOERROR;   break;
        case 'n':       flags |= IPC_NOWAIT;    break;
        case 't':       type = atoi(optarg);    break;
#ifdef MSG_EXCEPT
        case 'x':       flags |= MSG_EXCEPT;    break;
#endif
        default:        usageError(argv[0], NULL);
        }
    }

    if (argc &lt; optind + 1 || argc &gt; optind + 2)
        usageError(argv[0], "Wrong number of arguments\n");

    msqid = getInt(argv[optind], 0, "msqid");
    maxBytes = (argc &gt; optind + 1) ?
                getInt(argv[optind + 1], 0, "max-bytes") : MAX_MTEXT;

    /* Get message and display on stdout */

    msgLen = msgrcv(msqid, &amp;msg, maxBytes, type, flags);
    if (msgLen == -1)
        errExit("msgrcv");

    printf("Received: type=%ld; length=%ld", msg.mtype, (long) msgLen);
    if (msgLen &gt; 0)
        printf("; body=%s", msg.mtext);
    printf("\n");

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>svmsg/svmsg_receive.c</code></strong></pre></div></div></div></div></div><div class="sect1" title="Message Queue Control Operations"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="message_queue_control_operations">Message Queue Control Operations</h2></div></div></div><p>The <span class="emphasis"><em>msgctl()</em></span> system call performs control operations on the
                message queue identified by <span class="emphasis"><em>msqid</em></span>.<a id="IDX-CHP-46-6322" class="indexterm"/><a id="IDX-CHP-46-6323" class="indexterm"/><a id="IDX-CHP-46-6324" class="indexterm"/><a id="IDX-CHP-46-6325" class="indexterm"/><a id="IDX-CHP-46-6326" class="indexterm"/><a id="IDX-CHP-46-6327" class="indexterm"/><a id="IDX-CHP-46-6328" class="indexterm"/><a id="IDX-CHP-46-6329" class="indexterm"/><a id="IDX-CHP-46-6330" class="indexterm"/></p><a id="I_programlisting46_d1e122580"/><pre class="programlisting">#include &lt;sys/types.h&gt;        /* For portability */
#include &lt;sys/msg.h&gt;

int <strong class="userinput"><code>msgctl</code></strong>(int <span class="emphasis"><em>msqid</em></span>, int <span class="emphasis"><em>cmd</em></span>, struct msqid_ds *<span class="emphasis"><em>buf</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>cmd</em></span> argument specifies the operation to be performed on
                the queue. It can be one of the following:</p><div class="variablelist"><dl><dt><span class="term">
                        <code class="literal">IPC_RMID</code>
                    </span></dt><dd><p>Immediately remove the message queue object and its associated
                                <span class="emphasis"><em>msqid_ds</em></span> data structure. All messages remaining
                            in the queue are lost, and any blocked reader or writer processes are
                            immediately awakened, with <span class="emphasis"><em>msgsnd()</em></span> or
                                <span class="emphasis"><em>msgrcv()</em></span> failing with the error <code class="literal">EIDRM</code>. The third argument to
                                <span class="emphasis"><em>msgctl()</em></span> is ignored for this
                                operation.<a id="IDX-CHP-46-6331" class="indexterm"/><a id="IDX-CHP-46-6332" class="indexterm"/></p></dd><dt><span class="term">
                        <code class="literal">IPC_STAT</code>
                    </span></dt><dd><p>Place a copy of the <span class="emphasis"><em>msqid_ds</em></span> data structure
                            associated with this message queue in the buffer pointed to by
                                <span class="emphasis"><em>buf</em></span>. We describe the
                                <span class="emphasis"><em>msqid_ds</em></span> structure in Section 46.4.<a id="IDX-CHP-46-6333" class="indexterm"/></p></dd><dt><span class="term">
                        <code class="literal">IPC_SET</code>
                    </span></dt><dd><p>Update selected fields of the <span class="emphasis"><em>msqid_ds</em></span> data
                            structure associated with this message queue using values provided in
                            the buffer pointed to by <span class="emphasis"><em>buf</em></span>.</p></dd></dl></div><p>Further details about these operations, including the privileges and permissions
                required by the calling process, are described in Section 45.3. We describe some
                other values for <span class="emphasis"><em>cmd</em></span> in Section 46.6.</p><p>The program in <a class="xref" href="ch46.html#deleting_system_v_message_queues" title="Example 46-4. Deleting System V message queues">Example 46-4</a> demonstrates the
                use of <span class="emphasis"><em>msgctl()</em></span> to delete a message queue.</p><div class="example"><a id="deleting_system_v_message_queues"/><div class="example-title">Example 46-4. Deleting System V message queues</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svmsg/svmsg_rm.c</code></strong>
#include &lt;sys/types.h&gt;
#include &lt;sys/msg.h&gt;
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    int j;

    if (argc &gt; 1 &amp;&amp; strcmp(argv[1], "--help") == 0)
        usageErr("%s [msqid...]\n", argv[0]);

    for (j = 1; j &lt; argc; j++)
        if (msgctl(getInt(argv[j], 0, "msqid"), IPC_RMID, NULL) == -1)
            errExit("msgctl %s", argv[j]);

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>svmsg/svmsg_rm.c</code></strong></pre></div></div></div><div class="sect1" title="Message Queue Associated Data Structure"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="message_queue_associated_data_structure">Message Queue Associated Data Structure</h2></div></div></div><p>Each message queue has an associated <span class="emphasis"><em>msqid_ds</em></span> data structure
                of the following form:<a id="IDX-CHP-46-6334" class="indexterm"/><a id="IDX-CHP-46-6335" class="indexterm"/><a id="IDX-CHP-46-6336" class="indexterm"/><a id="IDX-CHP-46-6337" class="indexterm"/><a id="IDX-CHP-46-6338" class="indexterm"/><a id="IDX-CHP-46-6339" class="indexterm"/><a id="IDX-CHP-46-6340" class="indexterm"/><a id="IDX-CHP-46-6341" class="indexterm"/><a id="IDX-CHP-46-6342" class="indexterm"/><a id="IDX-CHP-46-6343" class="indexterm"/><a id="IDX-CHP-46-6344" class="indexterm"/><a id="IDX-CHP-46-6345" class="indexterm"/><a id="IDX-CHP-46-6346" class="indexterm"/><a id="IDX-CHP-46-6347" class="indexterm"/></p><a id="I_programlisting46_d1e122778"/><pre class="programlisting">struct msqid_ds {
    struct ipc_perm msg_perm;           /* Ownership and permissions */
    time_t          msg_stime;          /* Time of last msgsnd() */
    time_t          msg_rtime;          /* Time of last msgrcv() */
    time_t          msg_ctime;          /* Time of last change */
    unsigned long   __msg_cbytes;       /* Number of bytes in queue */
    msgqnum_t       msg_qnum;           /* Number of messages in queue */
    msglen_t        msg_qbytes;         /* Maximum bytes in queue */
    pid_t           msg_lspid;          /* PID of last msgsnd() */
    pid_t           msg_lrpid;          /* PID of last msgrcv() */
};</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>The purpose of the abbreviated spelling <span class="emphasis"><em>msq</em></span> in the name
                        <span class="emphasis"><em>msqid_ds</em></span> is to confuse the programmer. This is the only
                    message queue interface employing this spelling.</p></div><p>The <span class="emphasis"><em>msgqnum_t</em></span> and <span class="emphasis"><em>msglen_t</em></span> data
                types—used to type the <span class="emphasis"><em>msg_qnum</em></span> and
                    <span class="emphasis"><em>msg_qbytes</em></span> fields—are unsigned integer types specified in
                SUSv3.</p><p>The fields of the <span class="emphasis"><em>msqid_ds</em></span> structure are implicitly updated
                by the various message queue system calls, and certain fields can be explicitly
                updated using the <span class="emphasis"><em>msgctl()</em></span>
                <code class="literal">IPC_SET</code> operation. The details are as
                    follows:<a id="IDX-CHP-46-6348" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term">
                        <span class="emphasis"><em>msg_perm</em></span>
                    </span></dt><dd><p>When the message queue is created, the fields of this substructure are
                            initialized as described in Section 45.3. The <span class="emphasis"><em>uid</em></span>,
                                <span class="emphasis"><em>gid</em></span>, and <span class="emphasis"><em>mode</em></span> subfields
                            can be updated via <code class="literal">IPC_SET</code>.</p></dd><dt><span class="term">
                        <span class="emphasis"><em>msg_stime</em></span>
                    </span></dt><dd><p>When the queue is created, this field is set to 0; each later
                            successful <span class="emphasis"><em>msgsnd()</em></span> sets this field to the current
                            time. This field and the other timestamp fields in the
                                <span class="emphasis"><em>msqid_ds</em></span> structure are typed as
                                <span class="emphasis"><em>time_t</em></span>; they store time in seconds since the
                                Epoch.<a id="IDX-CHP-46-6349" class="indexterm"/></p></dd><dt><span class="term">
                        <span class="emphasis"><em>msg_rtime</em></span>
                    </span></dt><dd><p>This field is set to 0 when the message queue is created, and then set
                            to the current time on each successful
                                <span class="emphasis"><em>msgrcv()</em></span>.<a id="IDX-CHP-46-6350" class="indexterm"/></p></dd><dt><span class="term">
                        <span class="emphasis"><em>msg_ctime</em></span>
                    </span></dt><dd><p>This field is set to the current time when the message queue is
                            created and whenever an <code class="literal">IPC_SET</code>
                            operation is successfully performed.</p></dd><dt><span class="term">
                        <span class="emphasis"><em>__msg_cbytes</em></span>
                    </span></dt><dd><p>This field is set to 0 when the message queue is created, and then
                            adjusted during each successful <span class="emphasis"><em>msgsnd()</em></span> and
                                <span class="emphasis"><em>msgrcv()</em></span> to reflect the total number of bytes
                            contained in the <span class="emphasis"><em>mtext</em></span> fields of all messages in
                            the queue.<a id="IDX-CHP-46-6351" class="indexterm"/><a id="IDX-CHP-46-6352" class="indexterm"/></p></dd><dt><span class="term">
                        <span class="emphasis"><em>msg_qnum</em></span>
                    </span></dt><dd><p>When the message queue is created, this field is set to 0. It is then
                            incremented by each successful <span class="emphasis"><em>msgsnd()</em></span> and
                            decremented by each successful <span class="emphasis"><em>msgrcv()</em></span> to reflect
                            the total number of messages in the queue.</p></dd><dt><span class="term">
                        <span class="emphasis"><em>msg_qbytes</em></span>
                    </span></dt><dd><p>The value in this field defines an upper limit on the number of bytes
                            in the <span class="emphasis"><em>mtext</em></span> fields of all messages in the message
                            queue. This field is initialized to the value of the <code class="literal">MSGMNB</code> limit when the queue is created. A
                            privileged (<code class="literal">CAP_SYS_RESOURCE</code>) process
                            can use the <code class="literal">IPC_SET</code> operation to
                            adjust <span class="emphasis"><em>msg_qbytes</em></span> to any value in the range 0 to
                                <code class="literal">INT_MAX</code> (2,147,483,647 on 32-bit
                            platforms) bytes. An unprivileged process can adjust
                                <span class="emphasis"><em>msg_qbytes</em></span> to any value in the range 0 to
                                <code class="literal">MSGMNB</code>. A privileged user can
                            modify the value contained in the Linux-specific <code class="literal">/proc/sys/kernel/msgmnb</code> file in order to
                            change the initial <span class="emphasis"><em>msg_qbytes</em></span> setting for all
                            subsequently created message queues, as well as the upper limit for
                            subsequent changes to <span class="emphasis"><em>msg_qbytes</em></span> by unprivileged
                            processes. We say more about message queue limits in Section
                                46.5.<a id="IDX-CHP-46-6353" class="indexterm"/><a id="IDX-CHP-46-6354" class="indexterm"/></p></dd><dt><span class="term">
                        <span class="emphasis"><em>msg_lspid</em></span>
                    </span></dt><dd><p>This field is set to 0 when the queue is created, and then set to the
                            process ID of the calling process on each successful
                                <span class="emphasis"><em>msgsnd()</em></span>.</p></dd><dt><span class="term">
                        <span class="emphasis"><em>msg_lrpid</em></span>
                    </span></dt><dd><p>This field is set to 0 when the message queue is created, and then set
                            to the process ID of the calling process on each successful
                                <span class="emphasis"><em>msgrcv()</em></span>.</p></dd></dl></div><p>All of the above fields are specified by SUSv3, with the exception of
                    __<span class="emphasis"><em>msg_cbytes</em></span>. Nevertheless, most UNIX implementations
                provide an equivalent of the __<span class="emphasis"><em>msg_cbytes</em></span> field.</p><p>The program in <a class="xref" href="ch46.html#changing_the_msg_underscore_qbytes_setti" title="Example 46-5. Changing the msg_qbytes setting of a System V message queue">Example 46-5</a>
                demonstrates the use of the <code class="literal">IPC_STAT</code> and <code class="literal">IPC_SET</code> operations to modify the
                    <span class="emphasis"><em>msg_qbytes</em></span> setting of a message queue.</p><div class="example"><a id="changing_the_msg_underscore_qbytes_setti"/><div class="example-title">Example 46-5. Changing the <span class="emphasis"><em>msg_qbytes</em></span> setting of a System V message
                    queue</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svmsg/svmsg_chqbytes.c</code></strong>
#include &lt;sys/types.h&gt;
#include &lt;sys/msg.h&gt;
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    struct msqid_ds ds;
    int msqid;
    if (argc != 3 || strcmp(argv[1], "--help") == 0)
        usageErr("%s msqid max-bytes\n", argv[0]);

    /* Retrieve copy of associated data structure from kernel */

    msqid = getInt(argv[1], 0, "msqid");
    if (msgctl(msqid, IPC_STAT, &amp;ds) == -1)
        errExit("msgctl");

    ds.msg_qbytes = getInt(argv[2], 0, "max-bytes");

    /* Update associated data structure in kernel */

    if (msgctl(msqid, IPC_SET, &amp;ds) == -1)
        errExit("msgctl");

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>svmsg/svmsg_chqbytes.c</code></strong></pre></div></div></div><div class="sect1" title="Message Queue Limits"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="message_queue_limits">Message Queue Limits</h2></div></div></div><p>Most UNIX implementations impose various limits on the operation of System V
                message queues. Here, we describe the limits under Linux and note a few differences
                from other UNIX implementations.<a id="IDX-CHP-46-6355" class="indexterm"/><a id="IDX-CHP-46-6356" class="indexterm"/><a id="IDX-CHP-46-6357" class="indexterm"/><a id="IDX-CHP-46-6358" class="indexterm"/><a id="IDX-CHP-46-6359" class="indexterm"/><a id="IDX-CHP-46-6360" class="indexterm"/><a id="IDX-CHP-46-6361" class="indexterm"/><a id="IDX-CHP-46-6362" class="indexterm"/><a id="IDX-CHP-46-6363" class="indexterm"/><a id="IDX-CHP-46-6364" class="indexterm"/><a id="IDX-CHP-46-6365" class="indexterm"/><a id="IDX-CHP-46-6366" class="indexterm"/></p><p>The following limits are enforced on Linux. The system call affected by the limit
                and the error that results if the limit is reached are noted in parentheses.</p><div class="variablelist"><dl><dt><span class="term">
                        <code class="literal">MSGMNI</code>
                    </span></dt><dd><p>This is a system-wide limit on the number of message queue identifiers
                            (in other words, message queues) that can be created.
                                (<span class="emphasis"><em>msgget()</em></span>, <code class="literal">ENOSPC</code>)<a id="IDX-CHP-46-6367" class="indexterm"/></p></dd><dt><span class="term">
                        <code class="literal">MSGMAX</code>
                    </span></dt><dd><p>This is a system-wide limit specifying the maximum number of
                                (<span class="emphasis"><em>mtext</em></span>) bytes that can be written in a single
                            message. (<span class="emphasis"><em>msgsnd()</em></span>, <code class="literal">EINVAL</code>)<a id="IDX-CHP-46-6368" class="indexterm"/></p></dd><dt><span class="term">
                        <code class="literal">MSGMNB</code>
                    </span></dt><dd><p>This is the maximum number of (<span class="emphasis"><em>mtext</em></span>) bytes that
                            can be held in a message queue at one time. This limit is a system-wide
                            parameter that is used to initialize the <span class="emphasis"><em>msg_qbytes</em></span>
                            field of the <span class="emphasis"><em>msqid_ds</em></span> data structure associated
                            with this message queue. Subsequently, the
                                <span class="emphasis"><em>msg_qbytes</em></span> value can be modified on a per-queue
                            basis, as described in Section 46.4. If a queue’s
                                <span class="emphasis"><em>msg_qbytes</em></span> limit is reached, then
                                <span class="emphasis"><em>msgsnd()</em></span> blocks, or fails with the error
                                <code class="literal">EAGAIN</code> if <code class="literal">IPC_NOWAIT</code> was set.</p><p>Some UNIX implementations also define the following further
                            limits:</p></dd><dt><span class="term">
                        <code class="literal">MSGTQL</code>
                    </span></dt><dd><p>This is a system-wide limit on the number of messages that can be
                            placed on all message queues on the system.</p></dd><dt><span class="term">
                        <code class="literal">MSGPOOL</code>
                    </span></dt><dd><p>This is a system-wide limit on the size of the buffer pool that is
                            used to hold data in all message queues on the system.</p></dd></dl></div><p>Although Linux doesn’t impose either of the above limits, it does limit the number
                of messages on an individual queue to the value specified by the queue’s
                    <span class="emphasis"><em>msg_qbytes</em></span> setting. This limitation is relevant only if we
                are writing zero-length messages to a queue. It has the effect that the limit on the
                number of zero-length messages is the same as the limit on the number of 1-byte
                messages that can be written to the queue. This is necessary to prevent an infinite
                number of zero-length messages being written to the queue. Although they contain no
                data, each zero-length message consumes a small amount of memory for system
                bookkeeping overhead.</p><p>At system startup, the message queue limits are set to default values. These
                defaults have varied somewhat across kernel versions. (Some distributors’ kernels
                set different defaults from those provided by vanilla kernels.) On Linux, the limits
                can be viewed or changed via files in the <code class="literal">/proc</code>
                file system. <a class="xref" href="ch46.html#system_v_message_queue_limits" title="Table 46-1. System V message queue limits">Table 46-1</a> shows the <code class="literal">/proc</code> file corresponding to each limit. As an example,
                here are the default limits that we see for Linux 2.6.31 on one x86-32
                system:</p><a id="I_programlisting46_d1e123202"/><pre class="programlisting">$ <strong class="userinput"><code>cd /proc/sys/kernel</code></strong>
$ <strong class="userinput"><code>cat msgmni</code></strong>
748
$ <strong class="userinput"><code>cat msgmax</code></strong>
8192
$ <strong class="userinput"><code>cat msgmnb</code></strong>
16384</pre><div class="table"><a id="system_v_message_queue_limits"/><div class="table-title">Table 46-1. System V message queue limits</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Limit</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Ceiling value (x86-32)</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                <p>Corresponding file in <code class="literal">/proc/sys/kernel</code></p>
                            </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">MSGMNI</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>32768 (<code class="literal">IPCMNI</code>)</p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">msgmni</code>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">MSGMAX</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Depends on available memory</p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">msgmax</code>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">MSGMNB</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>2147483647 (<code class="literal">INT_MAX</code>)</p>
                            </td><td style="text-align: left; vertical-align: top; ">
                                <p>
                                    <code class="literal">msgmnb</code>
                                </p>
                            </td></tr></tbody></table></div></div><p>The ceiling value column of <a class="xref" href="ch46.html#system_v_message_queue_limits" title="Table 46-1. System V message queue limits">Table 46-1</a> shows
                the maximum value to which each limit can be raised on the x86-32 architecture. Note
                that although the <code class="literal">MSGMNB</code> limit can be raised to
                the value <code class="literal">INT_MAX</code>, some other limit (e.g., lack
                of memory) will be reached before a message queue can be loaded with so much
                    data.<a id="IDX-CHP-46-6369" class="indexterm"/></p><p>The Linux-specific <span class="emphasis"><em>msgctl()</em></span>
                <code class="literal">IPC_INFO</code> operation retrieves a structure of type
                    <span class="emphasis"><em>msginfo</em></span>, which contains the values of the various message
                queue limits:</p><a id="I_programlisting46_d1e123305"/><pre class="programlisting">struct msginfo buf;

msgctl(0, IPC_INFO, (struct msqid_ds *) &amp;buf);</pre><p>Details about <code class="literal">IPC_INFO</code> and the
                    <span class="emphasis"><em>msginfo</em></span> structure can be found in the
                    <span class="emphasis"><em>msgctl(2)</em></span> manual page.<a id="IDX-CHP-46-6370" class="indexterm"/></p></div><div class="sect1" title="Displaying All Message Queues on the System"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="displaying_all_message_queues_on_the_sys">Displaying All Message Queues on the System</h2></div></div></div><p>In <a class="xref" href="ch45.html#obtaining_a_list_of_all_ipc_objects" title="Obtaining a List of All IPC Objects">Obtaining a List of All IPC Objects</a>, we looked at one way to
                obtain a list of all of the IPC objects on the system: via a set of files in the
                    <code class="literal">/proc</code> file system. We now look at a second
                method of obtaining the same information: via a set of Linux-specific IPC
                    <span class="emphasis"><em>ctl</em></span> (<span class="emphasis"><em>msgctl()</em></span>,
                    <span class="emphasis"><em>semctl()</em></span>, and <span class="emphasis"><em>shmctl()</em></span>) operations.
                (The <span class="emphasis"><em>ipcs</em></span> program employs these operations.) These operations
                are as follows:<a id="IDX-CHP-46-6371" class="indexterm"/><a id="IDX-CHP-46-6372" class="indexterm"/><a id="IDX-CHP-46-6373" class="indexterm"/><a id="IDX-CHP-46-6374" class="indexterm"/><a id="IDX-CHP-46-6375" class="indexterm"/><a id="IDX-CHP-46-6376" class="indexterm"/><a id="IDX-CHP-46-6377" class="indexterm"/><a id="IDX-CHP-46-6378" class="indexterm"/><a id="IDX-CHP-46-6379" class="indexterm"/><a id="IDX-CHP-46-6380" class="indexterm"/><a id="IDX-CHP-46-6381" class="indexterm"/><a id="IDX-CHP-46-6382" class="indexterm"/><a id="IDX-CHP-46-6383" class="indexterm"/><a id="IDX-CHP-46-6384" class="indexterm"/><a id="IDX-CHP-46-6385" class="indexterm"/><a id="IDX-CHP-46-6386" class="indexterm"/><a id="IDX-CHP-46-6387" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">MSG_INFO</code>, <code class="literal">SEM_INFO</code>, and <code class="literal">SHM_INFO</code>:
                        The <code class="literal">MSG_INFO</code> operation serves two
                        purposes. First, it returns a structure detailing resources consumed by all
                        message queues on the system. Second, as the function result of the
                            <span class="emphasis"><em>ctl</em></span> call, it returns the index of the maximum item
                        in the <span class="emphasis"><em>entries</em></span> array pointing to data structures for
                        the message queue objects (see <a class="xref" href="ch45.html#kernel_data_structures_used_to_represent" title="Figure 45-1. Kernel data structures used to represent System V IPC (semaphore) objects">Figure 45-1</a>, in <a class="xref" href="ch45.html#algorithm_employed_by_system_v_ipc_get_c" title="Algorithm Employed by System V IPC get Calls">Algorithm Employed by System V IPC <span class="emphasis"><em>get</em></span> Calls</a>). The <code class="literal">SEM_INFO</code> and <code class="literal">SHM_INFO</code> operations perform an analogous task for semaphore
                        sets and shared memory segments, respectively. We must define the <code class="literal">_GNU_SOURCE</code> feature test macro to obtain the
                        definitions of these three constants from the corresponding System V IPC
                        header files.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>An example showing the use of <code class="literal">MSG_INFO</code> to retrieve a <span class="emphasis"><em>msginfo</em></span>
                            structure containing information about resources used by all message
                            queue objects is provided in the file <code class="literal">svmsg/svmsg_info.c</code> in the source code distribution for
                            this book.<a id="IDX-CHP-46-6388" class="indexterm"/></p></div></li><li class="listitem"><p><code class="literal">MSG_STAT</code>, <code class="literal">SEM_STAT</code>, and <code class="literal">SHM_STAT</code>:
                        Like the <code class="literal">IPC_STAT</code> operation, these
                        operations retrieve the associated data structure for an IPC object.
                        However, they differ in two respects. First, instead of expecting an IPC
                        identifier as the first argument of the <span class="emphasis"><em>ctl</em></span> call, these
                        operations expect an index into the <span class="emphasis"><em>entries</em></span> array.
                        Second, if the operation is successful, then, as its function result, the
                            <span class="emphasis"><em>ctl</em></span> call returns the identifier of the IPC object
                        corresponding to that index. We must define the <code class="literal">_GNU_SOURCE</code> feature test macro to obtain the definitions of
                        these three constants from the corresponding System V IPC header
                        files.</p></li></ul></div><p>To list all message queues on the system, we can do the following:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Use a <code class="literal">MSG_INFO</code> operation to find out
                        the maximum index (<span class="emphasis"><em>maxind</em></span>) of the
                            <span class="emphasis"><em>entries</em></span> array for message queues.</p></li><li class="listitem"><p>Perform a loop for all values from 0 up to and including
                            <span class="emphasis"><em>maxind</em></span>, employing a <code class="literal">MSG_STAT</code> operation for each value. During this loop, we
                        ignore the errors that may occur if an item of the
                            <span class="emphasis"><em>entries</em></span> array is empty (<code class="literal">EINVAL</code>) or if we don’t have permissions on the object to
                        which it refers (<code class="literal">EACCES</code>).</p></li></ol></div><p><a class="xref" href="ch46.html#displaying_all_system_v_message_queues_o" title="Example 46-6. Displaying all System V message queues on the system">Example 46-6</a> provides an
                implementation of the above steps for message queues. The following shell session
                log demonstrates the use of this program:</p><a id="I_programlisting46_d1e123550"/><pre class="programlisting">$ <strong class="userinput"><code>./svmsg_ls</code></strong>
maxind: 4

index     ID       key      messages
   2    98306  0x00000000       0
   4   163844  0x000004d2       2
$ <strong class="userinput"><code>ipcs -q</code></strong>                               <em class="lineannotation"><span class="lineannotation">Check above against output of ipcs</span></em>

------ Message Queues --------
key        msqid      owner    perms    used-bytes   messages
0x00000000 98306      mtk      600      0            0
0x000004d2 163844     mtk      600      12           2</pre><div class="example"><a id="displaying_all_system_v_message_queues_o"/><div class="example-title">Example 46-6. Displaying all System V message queues on the system</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svmsg/svmsg_ls.c</code></strong>
#define _GNU_SOURCE
#include &lt;sys/types.h&gt;
#include &lt;sys/msg.h&gt;
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    int maxind, ind, msqid;
    struct msqid_ds ds;
    struct msginfo msginfo;

    /* Obtain size of kernel 'entries' array */

    maxind = msgctl(0, MSG_INFO, (struct msqid_ds *) &amp;msginfo);
    if (maxind == -1)
        errExit("msgctl-MSG_INFO");

    printf("maxind: %d\n\n", maxind);
    printf("index     id       key      messages\n");

    /* Retrieve and display information from each element of 'entries' array */

    for (ind = 0; ind &lt;= maxind; ind++) {
        msqid = msgctl(ind, MSG_STAT, &amp;ds);
        if (msqid == -1) {
            if (errno != EINVAL &amp;&amp; errno != EACCES)
                errMsg("msgctl-MSG_STAT");              /* Unexpected error */
            continue;                                   /* Ignore this item */
        }

        printf("%4d %8d  0x%08lx %7ld\n", ind, msqid,
                (unsigned long) ds.msg_perm.__key, (long) ds.msg_qnum);
    }

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>svmsg/svmsg_ls.c</code></strong></pre></div></div></div><div class="sect1" title="Client-Server Programming with Message Queues"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="client-server_programming_with_message_q">Client-Server Programming with Message Queues</h2></div></div></div><p>In this section, we consider two of various possible designs for client-server
                applications using System V message queues:<a id="IDX-CHP-46-6389" class="indexterm"/><a id="IDX-CHP-46-6390" class="indexterm"/><a id="IDX-CHP-46-6391" class="indexterm"/><a id="IDX-CHP-46-6392" class="indexterm"/><a id="IDX-CHP-46-6393" class="indexterm"/><a id="IDX-CHP-46-6394" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The use of a single message queue for exchanging messages in both
                        directions between server and client.</p></li><li class="listitem"><p>The use of separate message queues for the server and for each client. The
                        server’s queue is used to receive incoming client requests, and responses
                        are sent to clients via the individual client queues.</p></li></ul></div><p>Which approach we choose depends on the requirements of our application. We next
                consider some of the factors that may influence our choice.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="using_a_single_message_queue_for"/></div></div></div><div class="sect3" title="Using a single message queue for server and clients"><div class="titlepage"><div><div><h4 class="title" id="using_a_single_message_queue_for-id1">Using a single message queue for server and clients</h4></div></div></div><p>Using a single message queue may be suitable when the messages exchanged
                        between servers and clients are small. However, note the following
                        points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Since multiple processes may attempt to read messages at the same
                                time, we must use the message type (<span class="emphasis"><em>mtype</em></span>)
                                field to allow each process to select only those messages intended
                                for it. One way to accomplish this is to use the client’s process ID
                                as the message type for messages sent from the server to the client.
                                The client can send its process ID as part of its message(s) to the
                                server. Furthermore, messages to the server must also be
                                distinguished by a unique message type. For this purpose, we can use
                                the number 1, which, being the process ID of the permanently running
                                    <span class="emphasis"><em>init</em></span> process, can never be the process ID
                                of a client process. (An alternative would be to use the server’s
                                process ID as the message type; however, it is difficult for the
                                clients to obtain this information.) This numbering scheme is shown
                                in <a class="xref" href="ch46.html#using_a_single_message_queue_for_client-" title="Figure 46-2. Using a single message queue for client-server IPC">Figure 46-2</a>.</p></li><li class="listitem"><p>Message queues have a limited capacity. This has the potential to
                                cause a couple of problems. One of these is that multiple
                                simultaneous clients could fill the message queue, resulting in a
                                deadlock situation, where no new client requests can be submitted
                                and the server is blocked from writing any responses. The other
                                problem is that a poorly behaved or intentionally malicious client
                                may fail to read responses from the server. This can lead to the
                                queue becoming clogged with unread messages, preventing any
                                communication between clients and server. (Using two queues—one for
                                messages from clients to the server, and the other for messages from
                                the server to the clients—would solve the first of these problems,
                                but not the second.)</p></li></ul></div><div class="figure"><a id="using_a_single_message_queue_for_client-"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject46_d1e123649"/><img src="figs/web/46-2_SVMSG-cs-single-queue.png.jpg" alt="Using a single message queue for client-server IPC"/></div></div><div class="figure-title">Figure 46-2. Using a single message queue for client-server IPC</div></div></div><div class="sect3" title="Using one message queue per client"><div class="titlepage"><div><div><h4 class="title" id="using_one_message_queue_per_client">Using one message queue per client</h4></div></div></div><p>Using one message queue per client (as well as one for the server) is
                        preferable where large messages need to be exchanged, or where there is
                        potential for the problems listed above when using a single message queue.
                        Note the following points regarding this approach:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Each client must create its own message queue (typically using the
                                    <code class="literal">IPC_PRIVATE</code> key) and inform
                                the server of the queue’s identifier, usually by transmitting the
                                identifier as part of the client’s message(s) to the server.</p></li><li class="listitem"><p>There is a system-wide limit (<code class="literal">MSGMNI</code>) on the number of message queues, and the
                                default value for this limit is quite low on some systems. If we
                                expect to have a large number of simultaneous clients, we may need
                                to raise this limit.</p></li><li class="listitem"><p>The server should allow for the possibility that the client’s
                                message queue no longer exists (perhaps because the client
                                prematurely deleted it).</p></li></ul></div><p>We say more about using one message queue per client in the next
                        section.</p></div></div></div><div class="sect1" title="A File-Server Application Using Message Queues"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="a_file-server_application_using_message">A File-Server Application Using Message Queues</h2></div></div></div><p>In this section, we describe a client-server application that uses one message
                queue per client. The application is a simple file server. The client sends a
                request message to the server’s message queue asking for the contents of a named
                file. The server responds by returning the file contents as a series of messages to
                the client’s private message queue. <a class="xref" href="ch46.html#client-server_ipc_using_one_message_queu" title="Figure 46-3. Client-server IPC using one message queue per client">Figure 46-3</a> provides an overview of the
                application.</p><p>Because the server performs no authentication of the client, any user that can run
                the client can obtain any of the files accessible to the server. A more
                sophisticated server would require some type of authentication from the client
                before serving the requested file.</p><div class="figure"><a id="client-server_ipc_using_one_message_queu"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject46_d1e123690"/><img src="figs/web/46-3_SVMSG-cs-multi-queue-scale90.png.jpg" alt="Client-server IPC using one message queue per client"/></div></div><div class="figure-title">Figure 46-3. Client-server IPC using one message queue per client</div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="common_header_file-id1"/></div></div></div><div class="sect3" title="Common header file"><div class="titlepage"><div><div><h4 class="title" id="common_header_file-id2">Common header file</h4></div></div></div><p><a class="xref" href="ch46.html#header_file_for_svmsg_underscore_file_un" title="Example 46-7. Header file for svmsg_file_server.c and svmsg_file_client.c">Example 46-7</a> is the header
                        file included by both the server and the client. This header defines the
                        well-known key to be used for the server’s message queue (<code class="literal">SERVER_KEY</code>), and defines the formats of the
                        messages to be passed between the client and the server.</p><p>The <span class="emphasis"><em>requestMsg</em></span> structure defines the format of the
                        request sent from the client to the server. In this structure, the
                            <span class="emphasis"><em>mtext</em></span> component consists of two fields: the
                        identifier of the client’s message queue and the pathname of the file
                        requested by the client. The constant <code class="literal">REQ_MSG_SIZE</code> equates to the combined size of these two fields
                        and is used as the <span class="emphasis"><em>msgsz</em></span> argument in calls to
                            <span class="emphasis"><em>msgsnd()</em></span> using this structure.</p><p>The <span class="emphasis"><em>responseMsg</em></span> structure defines the format of the
                        response messages sent from the server back to the client. The
                            <span class="emphasis"><em>mtype</em></span> field is used in response messages to supply
                        information about the message content, as defined by the <code class="literal">RESP_MT_*</code> constants.</p><div class="example"><a id="header_file_for_svmsg_underscore_file_un"/><div class="example-title">Example 46-7. Header file for <code class="literal">svmsg_file_server.c</code> and <code class="literal">svmsg_file_client.c</code></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svmsg/svmsg_file.h</code></strong>
#include &lt;sys/types.h&gt;
#include &lt;sys/msg.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stddef.h&gt;                       /* For definition of offsetof() */
#include &lt;limits.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;
#include "tlpi_hdr.h"

#define SERVER_KEY 0x1aaaaaa1             /* Key for server's message queue */

struct requestMsg {                       /* Requests (client to server) */
    long mtype;                           /* Unused */
    int  clientId;                        /* ID of client's message queue */
    char pathname[PATH_MAX];              /* File to be returned */
};

/* REQ_MSG_SIZE computes size of 'mtext' part of 'requestMsg' structure.
   We use offsetof() to handle the possibility that there are padding
   bytes between the 'clientId' and 'pathname' fields. */

#define REQ_MSG_SIZE (offsetof(struct requestMsg, pathname) - \
                      offsetof(struct requestMsg, clientId) + PATH_MAX)

#define RESP_MSG_SIZE 8192

struct responseMsg {                      /* Responses (server to client) */
    long mtype;                           /* One of RESP_MT_* values below */
    char data[RESP_MSG_SIZE];             /* File content / response message */
};

/* Types for response messages sent from server to client */

#define RESP_MT_FAILURE 1                 /* File couldn't be opened */
#define RESP_MT_DATA    2                 /* Message contains file data */
#define RESP_MT_END     3                 /* File data complete */
     <strong class="userinput"><code>svmsg/svmsg_file.h</code></strong></pre></div></div></div><div class="sect3" title="Server program"><div class="titlepage"><div><div><h4 class="title" id="server_program-id1">Server program</h4></div></div></div><p><a class="xref" href="ch46.html#a_file_server_using_system_v_message_que" title="Example 46-8. A file server using System V message queues">Example 46-8</a> is the server
                        program for the application. Note the following points about the
                            server:<a id="IDX-CHP-46-6395" class="indexterm"/><a id="IDX-CHP-46-6396" class="indexterm"/><a id="IDX-CHP-46-6397" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The server is designed to handle requests concurrently. A
                                concurrent server design is preferable to the iterative design
                                employed in <a class="xref" href="ch44.html#an_iterative_server_using_fifos" title="Example 44-7. An iterative server using FIFOs">Example 44-7</a> (page
                                912), since we want to avoid the possibility that a client request
                                for a large file would cause all other client requests to
                                    wait.<a id="IDX-CHP-46-6398" class="indexterm"/></p></li><li class="listitem"><p>Each client request is handled by creating a child process that
                                serves the requested file <span class="inlinemediaobject"><a id="I_inlinemediaobject46_d1e123784"/><img src="figs/web/U008.png" alt=""/></span>. In the meantime, the main server process waits
                                upon further client requests. Note the following points about the
                                server child:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Since the child produced via <span class="emphasis"><em>fork()</em></span>
                                        inherits a copy of the parent’s stack, it thus obtains a
                                        copy of the request message read by the main server
                                        process.</p></li><li class="listitem"><p>The server child terminates after handling its associated
                                        client request <span class="inlinemediaobject"><a id="I_inlinemediaobject46_d1e123800"/><img src="figs/web/U009.png" alt=""/></span>.</p></li></ul></div></li><li class="listitem"><p>In order to avoid the creation of zombie processes (<a class="xref" href="ch26.html#orphans_and_zombies" title="Orphans and Zombies">Orphans and Zombies</a>), the server establishes a
                                handler for <code class="literal">SIGCHLD</code>
                                <span class="inlinemediaobject"><a id="I_inlinemediaobject46_d1e123814"/><img src="figs/web/U006.png" alt=""/></span> and calls <span class="emphasis"><em>waitpid()</em></span> within
                                this handler <span class="inlinemediaobject"><a id="I_inlinemediaobject46_d1e123823"/><img src="figs/web/U001.png" alt=""/></span>.</p></li><li class="listitem"><p>The <span class="emphasis"><em>msgrcv()</em></span> call in the parent server
                                process may block, and consequently be interrupted by the <code class="literal">SIGCHLD</code> handler. To handle this
                                possibility, a loop is used to restart the call if it fails with the
                                    <code class="literal">EINTR</code> error
                                    <span class="inlinemediaobject"><a id="I_inlinemediaobject46_d1e123841"/><img src="figs/web/U007.png" alt=""/></span>.</p></li><li class="listitem"><p>The server child executes the <span class="emphasis"><em>serveRequest()</em></span>
                                function <span class="inlinemediaobject"><a id="I_inlinemediaobject46_d1e123853"/><img src="figs/web/U002.png" alt=""/></span>, which sends three message types back to the
                                client. A request with an <span class="emphasis"><em>mtype</em></span> of <code class="literal">RESP_MT_FAILURE</code> indicates that the
                                server could not open the requested file <span class="inlinemediaobject"><a id="I_inlinemediaobject46_d1e123865"/><img src="figs/web/U003.png" alt=""/></span>; <code class="literal">RESP_MT_DATA</code> is used for a series of messages
                                containing file data <span class="inlinemediaobject"><a id="I_inlinemediaobject46_d1e123875"/><img src="figs/web/U004.png" alt=""/></span>; and <code class="literal">RESP_MT_END</code> (with a zero-length data field) is used
                                to indicate that transmission of file data is complete
                                    <span class="inlinemediaobject"><a id="I_inlinemediaobject46_d1e123884"/><img src="figs/web/U005.png" alt=""/></span>.</p></li></ul></div><p>We consider a number of ways to improve and extend the server program in
                        Exercise 46-4.</p><div class="example"><a id="a_file_server_using_system_v_message_que"/><div class="example-title">Example 46-8. A file server using System V message queues</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svmsg/svmsg_file_server.c</code></strong>
    #include "svmsg_file.h"

    static void             /* SIGCHLD handler */
    grimReaper(int sig)
    {
        int savedErrno;

        savedErrno = errno;                 /* waitpid() might change 'errno' */
<img src="figs/web/U001.png" alt=""/>    while (waitpid(-1, NULL, WNOHANG) &gt; 0)
            continue;
        errno = savedErrno;
    }

        static void             /* Executed in child process: serve a single client */
<img src="figs/web/U002.png" alt=""/> serveRequest(const struct requestMsg *req)
    {
        int fd;
        ssize_t numRead;
        struct responseMsg resp;

        fd = open(req-&gt;pathname, O_RDONLY);
        if (fd == -1) {                     /* Open failed: send error text */
<img src="figs/web/U003.png" alt=""/>        resp.mtype = RESP_MT_FAILURE;
            snprintf(resp.data, sizeof(resp.data), "%s", "Couldn't open");
            msgsnd(req-&gt;clientId, &amp;resp, strlen(resp.data) + 1, 0);
            exit(EXIT_FAILURE);              /* and terminate */
        }

        /* Transmit file contents in messages with type RESP_MT_DATA. We don't
           diagnose read() and msgsnd() errors since we can't notify client. */
<img src="figs/web/U004.png" alt=""/>    resp.mtype = RESP_MT_DATA;
        while ((numRead = read(fd, resp.data, RESP_MSG_SIZE)) &gt; 0)
            if (msgsnd(req-&gt;clientId, &amp;resp, numRead, 0) == -1)
                break;

        /* Send a message of type RESP_MT_END to signify end-of-file */
<img src="figs/web/U005.png" alt=""/>    resp.mtype = RESP_MT_END;
        msgsnd(req-&gt;clientId, &amp;resp, 0, 0);         /* Zero-length mtext */
    }

    int
    main(int argc, char *argv[])
    {
        struct requestMsg req;
        pid_t pid;
        ssize_t msgLen;
        int serverId;
        struct sigaction sa;

        /* Create server message queue */

        serverId = msgget(SERVER_KEY, IPC_CREAT | IPC_EXCL |
                                S_IRUSR | S_IWUSR | S_IWGRP);
        if (serverId == -1)
            errExit("msgget");

        /* Establish SIGCHLD handler to reap terminated children */

        sigemptyset(&amp;sa.sa_mask);
        sa.sa_flags = SA_RESTART;
        sa.sa_handler = grimReaper;
<img src="figs/web/U006.png" alt=""/>    if (sigaction(SIGCHLD, &amp;sa, NULL) == -1)
            errExit("sigaction");

            /* Read requests, handle each in a separate child process */

        for (;;) {
            msgLen = msgrcv(serverId, &amp;req, REQ_MSG_SIZE, 0, 0);
            if (msgLen == -1) {
<img src="figs/web/U007.png" alt=""/>            if (errno == EINTR)         /* Interrupted by SIGCHLD handler? */
                    continue;               /* ... then restart msgrcv() */
                errMsg("msgrcv");           /* Some other error */
                break;                      /* ... so terminate loop */
            }
<img src="figs/web/U008.png" alt=""/>        pid = fork();                   /* Create child process */
            if (pid == -1) {
                errMsg("fork");
                break;
            }

            if (pid == 0) {                 /* Child handles request */
                serveRequest(&amp;req);
<img src="figs/web/U009.png" alt=""/>            _exit(EXIT_SUCCESS);
            }

            /* Parent loops to receive next client request */
        }

        /* If msgrcv() or fork() fails, remove server MQ and exit */

        if (msgctl(serverId, IPC_RMID, NULL) == -1)
            errExit("msgctl");
        exit(EXIT_SUCCESS);
    }
         <strong class="userinput"><code>svmsg/svmsg_file_server.c</code></strong></pre></div></div></div><div class="sect3" title="Client program"><div class="titlepage"><div><div><h4 class="title" id="client_program-id1">Client program</h4></div></div></div><p><a class="xref" href="ch46.html#client_for_file_server_using_system_v_me" title="Example 46-9. Client for file server using System V message queues">Example 46-9</a> is the client
                        program for the application. Note the following:<a id="IDX-CHP-46-6399" class="indexterm"/><a id="IDX-CHP-46-6400" class="indexterm"/><a id="IDX-CHP-46-6401" class="indexterm"/><a id="IDX-CHP-46-6402" class="indexterm"/><a id="IDX-CHP-46-6403" class="indexterm"/><a id="IDX-CHP-46-6404" class="indexterm"/><a id="IDX-CHP-46-6405" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The client creates a message queue with the <code class="literal">IPC_PRIVATE</code> key <span class="inlinemediaobject"><a id="I_inlinemediaobject46_d1e124016"/><img src="figs/web/U002.png" alt=""/></span> and uses <span class="emphasis"><em>atexit()</em></span>
                                <span class="inlinemediaobject"><a id="I_inlinemediaobject46_d1e124025"/><img src="figs/web/U003.png" alt=""/></span> to establish an exit handler <span class="inlinemediaobject"><a id="I_inlinemediaobject46_d1e124031"/><img src="figs/web/U001.png" alt=""/></span> to ensure that the queue is deleted when the
                                client exits.</p></li><li class="listitem"><p>The client passes the identifier for its queue, as well as the
                                pathname of the file to be served, in a request to the server
                                    <span class="inlinemediaobject"><a id="I_inlinemediaobject46_d1e124040"/><img src="figs/web/U004.png" alt=""/></span>.</p></li><li class="listitem"><p>The client handles the possibility that the first response message
                                sent by the server may be a failure notification
                                    (<span class="emphasis"><em>mtype</em></span> equals <code class="literal">RESP_MT_FAILURE</code>) by printing the text of the error
                                message returned by the server and exiting <span class="inlinemediaobject"><a id="I_inlinemediaobject46_d1e124055"/><img src="figs/web/U005.png" alt=""/></span>.</p></li><li class="listitem"><p>If the file is successfully opened, then the client loops
                                    <span class="inlinemediaobject"><a id="I_inlinemediaobject46_d1e124064"/><img src="figs/web/U006.png" alt=""/></span>, receiving a series of messages containing the
                                file contents (<span class="emphasis"><em>mtype</em></span> equals <code class="literal">RESP_MT_DATA</code>). The loop is terminated
                                by receipt of an end-of-file message (<span class="emphasis"><em>mtype</em></span>
                                equals <code class="literal">RESP_MT_END</code>).</p></li></ul></div><p>This simple client doesn’t handle various possibilities resulting from
                        failures in the server. We consider some improvements in Exercise
                        46-5.</p><div class="example"><a id="client_for_file_server_using_system_v_me"/><div class="example-title">Example 46-9. Client for file server using System V message queues</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svmsg/svmsg_file_client.c</code></strong>
    #include "svmsg_file.h"

    static int clientId;

    static void
    removeQueue(void)
    {
        if (msgctl(clientId, IPC_RMID, NULL) == -1)
<img src="figs/web/U001.png" alt=""/>        errExit("msgctl");
    }

    int
    main(int argc, char *argv[])
    {
        struct requestMsg req;
        struct responseMsg resp;
        int serverId, numMsgs;
        ssize_t msgLen, totBytes;

        if (argc != 2 || strcmp(argv[1], "--help") == 0)
            usageErr("%s pathname\n", argv[0]);

        if (strlen(argv[1]) &gt; sizeof(req.pathname) - 1)
            cmdLineErr("pathname too long (max: %ld bytes)\n",
                    (long) sizeof(req.pathname) - 1);

        /* Get server's queue identifier; create queue for response */

        serverId = msgget(SERVER_KEY, S_IWUSR);
        if (serverId == -1)
            errExit("msgget - server message queue");
<img src="figs/web/U002.png" alt=""/>    clientId = msgget(IPC_PRIVATE, S_IRUSR | S_IWUSR | S_IWGRP);
        if (clientId == -1)
            errExit("msgget - client message queue");
<img src="figs/web/U003.png" alt=""/>    if (atexit(removeQueue) != 0)
            errExit("atexit");

        /* Send message asking for file named in argv[1] */

        req.mtype = 1;                      /* Any type will do */
        req.clientId = clientId;
        strncpy(req.pathname, argv[1], sizeof(req.pathname) - 1);
        req.pathname[sizeof(req.pathname) - 1] = '\0';
                                            /* Ensure string is terminated */
<img src="figs/web/U004.png" alt=""/>    if (msgsnd(serverId, &amp;req, REQ_MSG_SIZE, 0) == -1)
            errExit("msgsnd");
            /* Get first response, which may be failure notification */

        msgLen = msgrcv(clientId, &amp;resp, RESP_MSG_SIZE, 0, 0);
        if (msgLen == -1)
            errExit("msgrcv");
<img src="figs/web/U005.png" alt=""/>    if (resp.mtype == RESP_MT_FAILURE) {
            printf("%s\n", resp.data);      /* Display msg from server */
            if (msgctl(clientId, IPC_RMID, NULL) == -1)
                errExit("msgctl");
            exit(EXIT_FAILURE);
        }

        /* File was opened successfully by server; process messages
           (including the one already received) containing file data */

        totBytes = msgLen;                  /* Count first message */
<img src="figs/web/U006.png" alt=""/>    for (numMsgs = 1; resp.mtype == RESP_MT_DATA; numMsgs++) {
            msgLen = msgrcv(clientId, &amp;resp, RESP_MSG_SIZE, 0, 0);
            if (msgLen == -1)
                errExit("msgrcv");

            totBytes += msgLen;
        }

        printf("Received %ld bytes (%d messages)\n", (long) totBytes, numMsgs);

        exit(EXIT_SUCCESS);
    }
         <strong class="userinput"><code>svmsg/svmsg_file_client.c</code></strong></pre></div></div><p>The following shell session demonstrates the use of the programs in <a class="xref" href="ch46.html#a_file_server_using_system_v_message_que" title="Example 46-8. A file server using System V message queues">Example 46-8</a> and <a class="xref" href="ch46.html#client_for_file_server_using_system_v_me" title="Example 46-9. Client for file server using System V message queues">Example 46-9</a>:</p><a id="I_programlisting46_d1e124136"/><pre class="programlisting">$ <strong class="userinput"><code>./svmsg_file_server &amp;</code></strong>                   <em class="lineannotation"><span class="lineannotation">Run server in background</span></em>
[1] 9149
$ <strong class="userinput"><code>wc -c /etc/services</code></strong>
                     <em class="lineannotation"><span class="lineannotation">Show size of file that client will request</span></em>
764360 /etc/services
$ <strong class="userinput"><code>./svmsg_file_client /etc/services</code></strong>
Received 764360 bytes (95 messages)       <em class="lineannotation"><span class="lineannotation">Bytes received matches size above</span></em>
$ <strong class="userinput"><code>kill %1</code></strong>                                 <em class="lineannotation"><span class="lineannotation">Terminate server</span></em>
[1]+  Terminated        ./svmsg_file_server</pre></div></div></div><div class="sect1" title="Disadvantages of System V Message Queues"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="disadvantages_of_system_v_message_queues">Disadvantages of System V Message Queues</h2></div></div></div><p>UNIX systems provide a number of mechanisms for transmitting data from one process
                to another on the same system, either in the form of an undelimited byte stream
                (pipes, FIFOs, and UNIX domain stream sockets) or as delimited messages (System V
                message queues, POSIX message queues, and UNIX domain datagram sockets).<a id="IDX-CHP-46-6406" class="indexterm"/><a id="IDX-CHP-46-6407" class="indexterm"/><a id="IDX-CHP-46-6408" class="indexterm"/></p><p>A distinctive feature of System V message queues is the ability to attach a
                numeric type to each message. This provides for two possibilities that may be useful
                to applications: reading processes may select messages by type, or they may employ a
                priority-queue strategy so that higher-priority messages (i.e., those with lower
                message type values) are read first.</p><p>However, System V message queues have a number of disadvantages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Message queues are referred to by identifiers, rather than the file
                        descriptors used by most other UNIX I/O mechanisms. This means that a
                        variety of file descriptor–based I/O techniques described in <a class="xref" href="ch63.html" title="Chapter 63. Alternative I/O Models">Chapter 63</a> (e.g.,
                            <span class="emphasis"><em>select()</em></span>, <span class="emphasis"><em>poll()</em></span>, and
                            <span class="emphasis"><em>epoll</em></span>) can’t be applied to message queues.
                        Furthermore, writing programs that simultaneously handle inputs from both
                        message queues and file descriptor-based I/O mechanisms requires code that
                        is more complex than code that deals with file descriptors alone. (We look
                        at one way of combining the two I/O models in Exercise 63-3.)</p></li><li class="listitem"><p>The use of keys, rather than filenames, to identify message queues results
                        in additional programming complexity and also requires the use of
                            <span class="emphasis"><em>ipcs</em></span> and <span class="emphasis"><em>ipcrm</em></span> instead of
                            <span class="emphasis"><em>ls</em></span> and <span class="emphasis"><em>rm</em></span>. The
                            <span class="emphasis"><em>ftok()</em></span> function usually generates a unique key, but
                        it is not guaranteed to do so. Employing the <code class="literal">IPC_PRIVATE</code> key guarantees a unique queue identifier, but
                        leaves us with the task of making that identifier visible to other processes
                        that require it.</p></li><li class="listitem"><p>Message queues are connectionless, and the kernel doesn’t maintain a count
                        of the number of processes referring to the queue as is done with pipes,
                        FIFOs, and sockets. Consequently, it can be difficult to answer the
                        following questions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When is it safe for an application to delete a message queue?
                                (Premature deletion of the queue results in immediate loss of data,
                                regardless of whether any process might later be interested in
                                reading from the queue.)</p></li><li class="listitem"><p>How can an application ensure that an unused queue is
                                deleted?</p></li></ul></div></li><li class="listitem"><p>There are limits on the total number of message queues, the size of
                        messages, and the capacity of individual queues. These limits are
                        configurable, but if an application operates outside the range of the
                        default limits, this requires extra work when installing the
                        application.</p></li></ul></div><p>In summary, System V message queues are often best avoided. In situations where we
                require the facility to select messages by type, we should consider alternatives.
                POSIX message queues (<a class="xref" href="ch52.html" title="Chapter 52. POSIX Message Queues">Chapter 52</a>) are one such
                alternative. As a further alternative, solutions involving multiple file
                descriptor–based communication channels may provide functionality similar to
                selecting messages by type, while at the same time allowing the use of the
                alternative I/O models described in <a class="xref" href="ch63.html" title="Chapter 63. Alternative I/O Models">Chapter 63</a>. For example, if we need to transmit “normal” and “priority” messages, we could
                use a pair of FIFOs or UNIX domain sockets for the two message types, and then
                employ <span class="emphasis"><em>select()</em></span> or <span class="emphasis"><em>poll()</em></span> to monitor file
                descriptors for both channels.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id45">Summary</h2></div></div></div><p>System V message queues allow processes to communicate by exchanging messages
                consisting of a numeric type plus a body containing arbitrary data. The
                distinguishing features of message queues are that message boundaries are preserved
                and that the receiver(s) can select messages by type, rather than reading messages
                in first-in, first-out order.</p><p>Various factors led us to conclude that other IPC mechanisms are usually
                preferable to System V message queues. One major difficulty is that message queues
                are not referred to using file descriptors. This means that we can’t employ various
                alternative I/O models with message queues; in particular, it is complex to
                simultaneously monitor both message queues and file descriptors to see if I/O is
                possible. Furthermore, the fact that message queues are connectionless (i.e., not
                reference counted) makes it difficult for an application to know when a queue may be
                deleted safely.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id31">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Experiment with the programs in <a class="xref" href="ch46.html#using_msgget_open_parenthesis_close_pare" title="Example 46-1. Using msgget()">Example 46-1</a> (<code class="literal">svmsg_create.c</code>), <a class="xref" href="ch46.html#using_msgsnd_open_parenthesis_close_pare" title="Example 46-2. Using msgsnd() to send a message">Example 46-2</a> (<code class="literal">svmsg_send.c</code>), and <a class="xref" href="ch46.html#using_msgrcv_open_parenthesis_close_pare" title="Example 46-3. Using msgrcv() to read a message">Example 46-3</a> (<code class="literal">svmsg_receive.c</code>) to confirm your understanding
                        of the <span class="emphasis"><em>msgget()</em></span>, <span class="emphasis"><em>msgsnd()</em></span>, and
                            <span class="emphasis"><em>msgrcv()</em></span> system calls.<a id="IDX-CHP-46-6409" class="indexterm"/></p></li><li class="listitem"><p>Recode the sequence-number client-server application of <a class="xref" href="ch44.html#a_client-server_application_using_fifos" title="A Client-Server Application Using FIFOs">A Client-Server Application Using FIFOs</a> to use System V
                        message queues. Use a single message queue to transmit messages from both
                        client to server and server to client. Employ the conventions for message
                        types described in Section 46.8.</p></li><li class="listitem"><p>In the client-server application of <a class="xref" href="ch46.html#a_file-server_application_using_message" title="A File-Server Application Using Message Queues">A File-Server Application Using Message Queues</a>, why does the client
                        pass the identifier of its message queue in the body of the message (in the
                            <span class="emphasis"><em>clientId</em></span> field), rather than in the message type
                            (<span class="emphasis"><em>mtype</em></span>)?</p></li><li class="listitem"><p>Make the following changes to the client-server application of <a class="xref" href="ch46.html#a_file-server_application_using_message" title="A File-Server Application Using Message Queues">A File-Server Application Using Message Queues</a>:</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>Replace the use of a hard-coded message queue key with code in the
                                server that uses <code class="literal">IPC_PRIVATE</code> to
                                generate a unique identifier, and then writes this identifier to a
                                well-known file. The client must read the identifier from this file.
                                The server should remove this file if it terminates.</p></li><li class="listitem"><p>In the <span class="emphasis"><em>serveRequest()</em></span> function of the server
                                program, system call errors are not diagnosed. Add code that logs
                                errors using <span class="emphasis"><em>syslog()</em></span> (<a class="xref" href="ch37.html#logging_messages_and_errors_using_syslog" title="Logging Messages and Errors Using syslog">Logging Messages and Errors Using <span class="emphasis"><em>syslog</em></span></a>).</p></li><li class="listitem"><p>Add code to the server so that it becomes a daemon on startup
                                    (<a class="xref" href="ch37.html#creating_a_daemon" title="Creating a Daemon">Creating a Daemon</a>).</p></li><li class="listitem"><p>In the server, add a handler for <code class="literal">SIGTERM</code> and <code class="literal">SIGINT</code>
                                that performs a tidy exit. The handler should remove the message
                                queue and (if the earlier part of this exercise was implemented) the
                                file created to hold the server’s message queue identifier. Include
                                code in the handler to terminate the server by disestablishing the
                                handler, and then once more raising the same signal that invoked the
                                handler (see <a class="xref" href="ch26.html#process_termination_from_a_signal_handle" title="Process Termination from a Signal Handler">Process Termination from a Signal Handler</a> for the
                                rationale and steps required for this task).</p></li><li class="listitem"><p>The server child doesn’t handle the possibility that the client
                                may terminate prematurely, in which case the server child would fill
                                the client’s message queue, and then block indefinitely. Modify the
                                server to handle this possibility by establishing a timeout when
                                calling <span class="emphasis"><em>msgsnd()</em></span>, as described in Section 23.3.
                                If the server child deems that the client has disappeared, it should
                                attempt to delete the client’s message queue, and then exit (after
                                perhaps logging a message via <span class="emphasis"><em>syslog()</em></span>).</p></li></ol></div></li><li class="listitem"><p>The client shown in <a class="xref" href="ch46.html#client_for_file_server_using_system_v_me" title="Example 46-9. Client for file server using System V message queues">Example 46-9</a> (<code class="literal">svmsg_file_client.c</code>) doesn’t handle various
                        possibilities for failure in the server. In particular, if the server
                        message queue fills up (perhaps because the server terminated and the queue
                        was filled by other clients), then the <span class="emphasis"><em>msgsnd()</em></span> call
                        will block indefinitely. Similarly, if the server fails to send a response
                        to the client, then the <span class="emphasis"><em>msgrcv()</em></span> call will block
                        indefinitely. Add code to the client that sets timeouts (<a class="xref" href="ch23.html#setting_timeouts_on_blocking_operations" title="Setting Timeouts on Blocking Operations">Setting Timeouts on Blocking Operations</a>) on these calls. If
                        either call times out, then the program should report an error to the user
                        and terminate.</p></li><li class="listitem"><p>Write a simple chat application (similar to <span class="emphasis"><em>talk(1)</em></span>,
                        but without the <span class="emphasis"><em>curses</em></span> interface) using System V
                        messages queues. Use a single message queue for each client.</p></li></ol></div></div></section></body></html>
