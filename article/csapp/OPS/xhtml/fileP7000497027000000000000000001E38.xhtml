<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>3.2 Program Encodings</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000001E38" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P70004970270000000000000000400A8" data-uri="chapter03.xhtml#P70004970270000000000000000400A8" epub:type="title"><span class="pcalibre label pcalibre1">3.2 </span>Program Encodings</h1></header>
<p id="P70004970270000000000000000400A9" data-uri="chapter03.xhtml#P70004970270000000000000000400A9" class="pcalibre1 pcalibre calibre2">Suppose we write a C program as two files <code id="P70004970270000000000000000400AA" data-uri="chapter03.xhtml#P70004970270000000000000000400AA" class="pcalibre1 calibre8 pcalibre">p1.c</code> and <code id="P70004970270000000000000000400AB" data-uri="chapter03.xhtml#P70004970270000000000000000400AB" class="pcalibre1 calibre8 pcalibre">p2.c.</code> We can then compile this code using a Unix command line:</p>
<pre id="P70004970270000000000000000400AC" data-uri="chapter03.xhtml#P70004970270000000000000000400AC" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000400AD" data-uri="chapter03.xhtml#P70004970270000000000000000400AD" class="calibre10 pcalibre pcalibre1">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000001E3F" title="170" data-uri="chapter03.xhtml#P7000497027000000000000000001E3F" epub:type="pagebreak"></span>linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -Og -o p p1.c p2.c</i>
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000400AE" data-uri="chapter03.xhtml#P70004970270000000000000000400AE">The command <code id="P70004970270000000000000000400AF" data-uri="chapter03.xhtml#P70004970270000000000000000400AF" class="pcalibre1 calibre8 pcalibre">gcc</code> indicates the <span class="smallcaps pcalibre pcalibre1">gcc </span>C compiler. Since this is the default compiler on Linux, we could also invoke it as simply <code id="P70004970270000000000000000400B0" data-uri="chapter03.xhtml#P70004970270000000000000000400B0" class="pcalibre1 calibre8 pcalibre">cc</code>. The command-line option –<code id="P70004970270000000000000000400B1" data-uri="chapter03.xhtml#P70004970270000000000000000400B1" class="pcalibre1 calibre8 pcalibre">0g</code><a class="noteref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" id="r__P7000497027000000000000000003A68" epub:type="noteref" href="#P7000497027000000000000000003A68"><sup class="pcalibre1 calibre21 pcalibre">1</sup></a> instructs the compiler to apply a level of optimization that yields machine code that follows the overall structure of the original C code. Invoking higher levels of optimization can generate code that is so heavily transformed that the relationship between the generated machine code and the original source code is difficult to understand. We will therefore use –<code id="P70004970270000000000000000400B2" data-uri="chapter03.xhtml#P70004970270000000000000000400B2" class="pcalibre1 calibre8 pcalibre">0g</code> optimization as a learning tool and then see what happens as we increase the level of optimization. In practice, higher levels of optimization (e.g., specified with the option –<code id="P70004970270000000000000000400B3" data-uri="chapter03.xhtml#P70004970270000000000000000400B3" class="pcalibre1 calibre8 pcalibre">01</code> or –<code id="P70004970270000000000000000400B4" data-uri="chapter03.xhtml#P70004970270000000000000000400B4" class="pcalibre1 calibre8 pcalibre">02</code>) are considered a better choice in terms of the resulting program performance.</p><aside class="footnote pcalibre5 pcalibre" id="P7000497027000000000000000003A68" data-uri="chapter03.xhtml#P7000497027000000000000000003A68" epub:type="footnote"><p class="pcalibre calibre3 pcalibre1"><span class="pcalibre1 number2 pcalibre"><a href="#r__P7000497027000000000000000003A68" class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1">1. </a></span>This optimization level was introduced in <span class="smallcaps pcalibre pcalibre1">gcc </span>version 4.8. Earlier versions of <span class="smallcaps pcalibre pcalibre1">gcc</span>, as well as non-GNU compilers, will not recognize this option. For these, using optimization level one (specified with the command-line flag <code id="P7000497027000000000000000041C30" data-uri="chapter03.xhtml#P7000497027000000000000000041C30" class="calibre10 pcalibre pcalibre1">-O1</code>) is probably the best choice for generating code that follows the original program structure.</p></aside>
<p id="P70004970270000000000000000400B5" data-uri="chapter03.xhtml#P70004970270000000000000000400B5" class="pcalibre1 pcalibre calibre2">The <code id="P70004970270000000000000000400B6" data-uri="chapter03.xhtml#P70004970270000000000000000400B6" class="pcalibre1 calibre8 pcalibre">gcc</code> command invokes an entire sequence of programs to turn the source code into executable code. First, the C <i class="calibre5 pcalibre pcalibre1">preprocessor</i> expands the source code to include any files specified with <code id="P70004970270000000000000000400B7" data-uri="chapter03.xhtml#P70004970270000000000000000400B7" class="pcalibre1 calibre8 pcalibre">#include</code> commands and to expand any macros, specified with <code id="P70004970270000000000000000400B8" data-uri="chapter03.xhtml#P70004970270000000000000000400B8" class="pcalibre1 calibre8 pcalibre">#define</code> declarations. Second, the <i class="calibre5 pcalibre pcalibre1">compiler</i> generates assembly-code versions of the two source files having names <code id="P70004970270000000000000000400B9" data-uri="chapter03.xhtml#P70004970270000000000000000400B9" class="pcalibre1 calibre8 pcalibre">p1.s</code> and <code id="P70004970270000000000000000400BA" data-uri="chapter03.xhtml#P70004970270000000000000000400BA" class="pcalibre1 calibre8 pcalibre">p2.s.</code> Next, the <i class="calibre5 pcalibre pcalibre1">assembler</i> converts the assembly code into binary <i class="calibre5 pcalibre pcalibre1">object-code</i> files <code id="P70004970270000000000000000400BB" data-uri="chapter03.xhtml#P70004970270000000000000000400BB" class="pcalibre1 calibre8 pcalibre">p1.o</code> and <code id="P70004970270000000000000000400BC" data-uri="chapter03.xhtml#P70004970270000000000000000400BC" class="pcalibre1 calibre8 pcalibre">p2.o.</code> Object code is one form of machine code—it contains binary representations of all of the instructions, but the addresses of global values are not yet filled in. Finally, the <i class="calibre5 pcalibre pcalibre1">linker</i> merges these two object-code files along with code implementing library functions (e.g., <code id="P70004970270000000000000000400BD" data-uri="chapter03.xhtml#P70004970270000000000000000400BD" class="pcalibre1 calibre8 pcalibre">printf</code>) and generates the final executable code file <code id="P70004970270000000000000000400BE" data-uri="chapter03.xhtml#P70004970270000000000000000400BE" class="pcalibre1 calibre8 pcalibre">p</code> (as specified by the command-line directive <code id="P70004970270000000000000000400BF" data-uri="chapter03.xhtml#P70004970270000000000000000400BF" class="pcalibre1 calibre8 pcalibre">-o p</code>). Executable code is the second form of machine code we will consider—it is the exact form of code that is executed by the processor. The relation between these different forms of machine code and the linking process is described in more detail in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000005FB4.xhtml#P7000497027000000000000000005FB4"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">7</span></a>.</p>
<section id="P7000497027000000000000000001E52" data-uri="chapter03.xhtml#P7000497027000000000000000001E52" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000400C0" data-uri="chapter03.xhtml#P70004970270000000000000000400C0" epub:type="title"><span class="pcalibre label pcalibre1">3.2.1 </span>Machine-Level Code</h1></header>
<p id="P70004970270000000000000000400C1" data-uri="chapter03.xhtml#P70004970270000000000000000400C1" class="pcalibre1 pcalibre calibre2">As described in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000001FF.xhtml#P7000497027000000000000000000248"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">1.9.3</span></a>, computer systems employ several different forms of abstraction, hiding details of an implementation through the use of a simpler abstract model. Two of these are especially important for machine-level programming. First, the format and behavior of a machine-level program is defined by the <i class="calibre5 pcalibre pcalibre1">instruction set architecture</i>, or ISA, defining the processor state, the format of the instructions, and the effect each of these instructions will have on the state. Most ISAs, including x86-64, describe the behavior of a program as if each instruction is executed in sequence, with one instruction completing before the next one begins. The processor hardware is far more elaborate, executing many instructions concurrently, but it employs safeguards to ensure that the overall behavior matches the sequential operation dictated by the ISA. Second, the memory addresses used by a machine-level program are <i class="calibre5 pcalibre pcalibre1">virtual addresses</i>, providing a memory model that <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000001E55" title="171" data-uri="chapter03.xhtml#P7000497027000000000000000001E55" epub:type="pagebreak"></span>appears to be a very large byte array. The actual implementation of the memory system involves a combination of multiple hardware memories and operating system software, as described in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000006FF7.xhtml#P7000497027000000000000000006FF7"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">9</span></a>.</p>
<p id="P70004970270000000000000000400C2" data-uri="chapter03.xhtml#P70004970270000000000000000400C2" class="pcalibre1 pcalibre calibre2">The compiler does most of the work in the overall compilation sequence, transforming programs expressed in the relatively abstract execution model provided by C into the very elementary instructions that the processor executes. The assembly-code representation is very close to machine code. Its main feature is that it is in a more readable textual format, as compared to the binary format of machine code. Being able to understand assembly code and how it relates to the original C code is a key step in understanding how computers execute programs.</p>
<p id="P70004970270000000000000000400C3" data-uri="chapter03.xhtml#P70004970270000000000000000400C3" class="pcalibre1 pcalibre calibre2">The machine code for x86-64 differs greatly from the original C code. Parts of the processor state are visible that normally are hidden from the C programmer:</p>
<ul id="P70004970270000000000000000400C4" data-uri="chapter03.xhtml#P70004970270000000000000000400C4" class="calibre28 pcalibre pcalibre1">
<li id="P70004970270000000000000000400C5" data-uri="chapter03.xhtml#P70004970270000000000000000400C5" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000400C6" data-uri="chapter03.xhtml#P70004970270000000000000000400C6" class="pcalibre calibre3 pcalibre1">The <i class="calibre5 pcalibre pcalibre1">program counter</i> (commonly referred to as the PC, and called <code id="P70004970270000000000000000400C7" data-uri="chapter03.xhtml#P70004970270000000000000000400C7" class="pcalibre1 calibre8 pcalibre">%rip</code> in x86-64) indicates the address in memory of the next instruction to be executed.</p></li>
<li id="P70004970270000000000000000400C8" data-uri="chapter03.xhtml#P70004970270000000000000000400C8" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000400C9" data-uri="chapter03.xhtml#P70004970270000000000000000400C9" class="pcalibre calibre3 pcalibre1">The integer <i class="calibre5 pcalibre pcalibre1">register file</i> contains 16 named locations storing 64-bit values. These registers can hold addresses (corresponding to C pointers) or integer data. Some registers are used to keep track of critical parts of the program state, while others are used to hold temporary data, such as the arguments and local variables of a procedure, as well as the value to be returned by a function.</p></li>
<li id="P70004970270000000000000000400CA" data-uri="chapter03.xhtml#P70004970270000000000000000400CA" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000400CB" data-uri="chapter03.xhtml#P70004970270000000000000000400CB" class="pcalibre calibre3 pcalibre1">The condition code registers hold status information about the most recently executed arithmetic or logical instruction. These are used to implement conditional changes in the control or data flow, such as is required to implement if and while statements.</p></li>
<li id="P70004970270000000000000000400CC" data-uri="chapter03.xhtml#P70004970270000000000000000400CC" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000400CD" data-uri="chapter03.xhtml#P70004970270000000000000000400CD" class="pcalibre calibre3 pcalibre1">A set of vector registers can each hold one or more integer or floating-point values.</p></li>
</ul>
<p id="P70004970270000000000000000400CE" data-uri="chapter03.xhtml#P70004970270000000000000000400CE" class="pcalibre1 pcalibre calibre2">Whereas C provides a model in which objects of different data types can be declared and allocated in memory, machine code views the memory as simply a large byte-addressable array. Aggregate data types in C such as arrays and structures are represented in machine code as contiguous collections of bytes. Even for scalar data types, assembly code makes no distinctions between signed or unsigned integers, between different types of pointers, or even between pointers and integers.</p>
<p id="P70004970270000000000000000400CF" data-uri="chapter03.xhtml#P70004970270000000000000000400CF" class="pcalibre1 pcalibre calibre2">The program memory contains the executable machine code for the program, some information required by the operating system, a run-time stack for managing procedure calls and returns, and blocks of memory allocated by the user (e.g., by using the <code id="P70004970270000000000000000400D0" data-uri="chapter03.xhtml#P70004970270000000000000000400D0" class="pcalibre1 calibre8 pcalibre">malloc</code> library function). As mentioned earlier, the program memory is addressed using virtual addresses. At any given time, only limited subranges of virtual addresses are considered valid. For example, x86-64 virtual addresses are represented by 64-bit words. In current implementations of these machines, the upper 16 bits must be set to zero, and so an address can potentially specify a byte over a range of 2<sup class="calibre51 pcalibre pcalibre1">48</sup>, or 64 terabytes. More typical programs will only have access to a few megabytes, or perhaps several gigabytes. The operating system manages</p>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000001E65" data-uri="chapter03.xhtml#P7000497027000000000000000001E65"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P70004970270000000000000000400D1" data-uri="chapter03.xhtml#P70004970270000000000000000400D1" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000001E67" title="172" data-uri="chapter03.xhtml#P7000497027000000000000000001E67" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>The ever-changing forms of generated code</h1></header>
<p id="P70004970270000000000000000400D2" data-uri="chapter03.xhtml#P70004970270000000000000000400D2" class="calibre13 pcalibre pcalibre1">In our presentation, we will show the code generated by a particular version of <span class="smallcaps pcalibre pcalibre1">gcc </span>with particular settings of the command-line options. If you compile code on your own machine, chances are you will be using a different compiler or a different version of <span class="smallcaps pcalibre pcalibre1">gcc </span>and hence will generate different code. The open-source community supporting <span class="smallcaps pcalibre pcalibre1">gcc </span>keeps changing the code generator, attempting to generate more efficient code according to changing code guidelines provided by the microprocessor manufacturers.</p>
<p id="P70004970270000000000000000400D3" data-uri="chapter03.xhtml#P70004970270000000000000000400D3" class="pcalibre calibre3 pcalibre1">Our goal in studying the examples shown in our presentation is to demonstrate how to examine assembly code and map it back to the constructs found in high-level programming languages. You will need to adapt these techniques to the style of code generated by your particular compiler.</p>
</aside>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000400D4" data-uri="chapter03.xhtml#P70004970270000000000000000400D4">this virtual address space, translating virtual addresses into the physical addresses of values in the actual processor memory.</p>
<p id="P70004970270000000000000000400D5" data-uri="chapter03.xhtml#P70004970270000000000000000400D5" class="pcalibre1 pcalibre calibre2">A single machine instruction performs only a very elementary operation. For example, it might add two numbers stored in registers, transfer data between memory and a register, or conditionally branch to a new instruction address. The compiler must generate sequences of such instructions to implement program constructs such as arithmetic expression evaluation, loops, or procedure calls and returns.</p>
</section>
<section id="P7000497027000000000000000001E6C" data-uri="chapter03.xhtml#P7000497027000000000000000001E6C" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000400D6" data-uri="chapter03.xhtml#P70004970270000000000000000400D6" epub:type="title"><span class="pcalibre label pcalibre1">3.2.2 </span>Code Examples</h1></header>
<p id="P70004970270000000000000000400D7" data-uri="chapter03.xhtml#P70004970270000000000000000400D7" class="pcalibre1 pcalibre calibre2">Suppose we write a C code file <code id="P70004970270000000000000000400D8" data-uri="chapter03.xhtml#P70004970270000000000000000400D8" class="pcalibre1 calibre8 pcalibre">mstore.c</code> containing the following function definition:</p>

<pre id="P70004970270000000000000000400D9" data-uri="chapter03.xhtml#P70004970270000000000000000400D9" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000400DA" data-uri="chapter03.xhtml#P70004970270000000000000000400DA" class="calibre10 pcalibre pcalibre1">
long mult2(long, long);

void multstore(long x, long y, long *dest) {
	long t = mult2(x, y);
	*dest = t;
}
</code></pre>
<p id="P70004970270000000000000000400DB" data-uri="chapter03.xhtml#P70004970270000000000000000400DB" class="pcalibre1 pcalibre calibre2">To see the assembly code generated by the C compiler, we can use the -S option on the command line:</p>

<pre id="P70004970270000000000000000400DC" data-uri="chapter03.xhtml#P70004970270000000000000000400DC" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000400DD" data-uri="chapter03.xhtml#P70004970270000000000000000400DD" class="calibre10 pcalibre pcalibre1">
linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -Og -S mstore.c</i>
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000400DE" data-uri="chapter03.xhtml#P70004970270000000000000000400DE">This will cause <span class="smallcaps pcalibre pcalibre1">gcc </span>to run the compiler, generating an assembly file <code id="P70004970270000000000000000400DF" data-uri="chapter03.xhtml#P70004970270000000000000000400DF" class="pcalibre1 calibre8 pcalibre">mstore.s</code>, and go no further. (Normally it would then invoke the assembler to generate an object-code file.)</p>

<p id="P70004970270000000000000000400E0" data-uri="chapter03.xhtml#P70004970270000000000000000400E0" class="pcalibre1 pcalibre calibre2">The assembly-code file contains various declarations, including the following set of lines:</p>
<pre id="P70004970270000000000000000400E1" data-uri="chapter03.xhtml#P70004970270000000000000000400E1" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000400E2" data-uri="chapter03.xhtml#P70004970270000000000000000400E2" class="calibre10 pcalibre pcalibre1">
multstore:
	pushq	%rbx
</code></pre>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000001E7A" data-uri="chapter03.xhtml#P7000497027000000000000000001E7A"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P70004970270000000000000000400E3" data-uri="chapter03.xhtml#P70004970270000000000000000400E3" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000001E7C" title="173" data-uri="chapter03.xhtml#P7000497027000000000000000001E7C" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>How do I display the byte representation of a program?</h1></header>
<p id="P70004970270000000000000000400E4" data-uri="chapter03.xhtml#P70004970270000000000000000400E4" class="calibre13 pcalibre pcalibre1">To display the binary object code for a program (say, <code id="P70004970270000000000000000400E5" data-uri="chapter03.xhtml#P70004970270000000000000000400E5" class="pcalibre1 calibre8 pcalibre">mstore</code>), we use a <i class="calibre5 pcalibre pcalibre1">disassembler</i> (described below) to determine that the code for the procedure is 14 bytes long. Then we run the GNU debugging tool <span class="smallcaps pcalibre pcalibre1">gdb </span>on file <code id="P70004970270000000000000000400E6" data-uri="chapter03.xhtml#P70004970270000000000000000400E6" class="pcalibre1 calibre8 pcalibre">mstore.o</code> and give it the command</p>

<pre id="P70004970270000000000000000400E7" data-uri="chapter03.xhtml#P70004970270000000000000000400E7" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000400E8" data-uri="chapter03.xhtml#P70004970270000000000000000400E8" class="calibre10 pcalibre pcalibre1">
(gdb) <i class="calibre5 pcalibre pcalibre1">x/14xb multstore</i>
</code></pre>
<p class="pcalibre calibre3 pcalibre1" id="P70004970270000000000000000400E9" data-uri="chapter03.xhtml#P70004970270000000000000000400E9">telling it to display (abbreviated `x') 14 hex-formatted (also `x') bytes (`b') starting at the address where function multstore is located. You will find that <span class="smallcaps pcalibre pcalibre1">gdb</span> has many useful features for analyzing machine-level programs, as will be discussed in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000002E6D.xhtml#P7000497027000000000000000002EC0"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">3.10.2</span></a>.</p>
</aside>
<pre id="P70004970270000000000000000400EA" data-uri="chapter03.xhtml#P70004970270000000000000000400EA" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000400EB" data-uri="chapter03.xhtml#P70004970270000000000000000400EB" class="calibre10 pcalibre pcalibre1">
movq	%rdx, %rbx
call	mult2
movq	%rax, (%rbx)
popq	%rbx
ret	
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000400EC" data-uri="chapter03.xhtml#P70004970270000000000000000400EC">Each indented line in the code corresponds to a single machine instruction. For example, the <code id="P70004970270000000000000000400ED" data-uri="chapter03.xhtml#P70004970270000000000000000400ED" class="pcalibre1 calibre8 pcalibre">pushq</code> instruction indicates that the contents of register <code id="P70004970270000000000000000400EE" data-uri="chapter03.xhtml#P70004970270000000000000000400EE" class="pcalibre1 calibre8 pcalibre">%rbx</code> should be pushed onto the program stack. All information about local variable names or data types has been stripped away.</p>

<p id="P70004970270000000000000000400EF" data-uri="chapter03.xhtml#P70004970270000000000000000400EF" class="pcalibre1 pcalibre calibre2">If we use the -c command-line option, <span class="smallcaps pcalibre pcalibre1">gcc </span>will both compile and assemble the code</p>

<pre id="P70004970270000000000000000400F0" data-uri="chapter03.xhtml#P70004970270000000000000000400F0" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000400F1" data-uri="chapter03.xhtml#P70004970270000000000000000400F1" class="calibre10 pcalibre pcalibre1">
linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -Og -c mstore.c</i>
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000400F2" data-uri="chapter03.xhtml#P70004970270000000000000000400F2">This will generate an object-code file <code id="P70004970270000000000000000400F3" data-uri="chapter03.xhtml#P70004970270000000000000000400F3" class="pcalibre1 calibre8 pcalibre">mstore.o</code> that is in binary format and hence cannot be viewed directly. Embedded within the 1,368 bytes of the file <code id="P70004970270000000000000000400F4" data-uri="chapter03.xhtml#P70004970270000000000000000400F4" class="pcalibre1 calibre8 pcalibre">mstore.o</code> is a 14-byte sequence with the hexadecimal representation</p>
<pre id="P70004970270000000000000000400F5" data-uri="chapter03.xhtml#P70004970270000000000000000400F5" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000400F6" data-uri="chapter03.xhtml#P70004970270000000000000000400F6" class="calibre10 pcalibre pcalibre1">
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000400F7" data-uri="chapter03.xhtml#P70004970270000000000000000400F7">This is the object code corresponding to the assembly instructions listed previously. A key lesson to learn from this is that the program executed by the machine is simply a sequence of bytes encoding a series of instructions. The machine has very little information about the source code from which these instructions were generated.</p>
<p id="P70004970270000000000000000400F8" data-uri="chapter03.xhtml#P70004970270000000000000000400F8" class="pcalibre1 pcalibre calibre2">To inspect the contents of machine-code files, a class of programs known as <i class="calibre5 pcalibre pcalibre1">disassemblers</i> can be invaluable. These programs generate a format similar to assembly code from the machine code. With Linux systems, the program <span class="smallcaps pcalibre pcalibre1">objdump </span>(for "object dump") can serve this role given the <code id="P70004970270000000000000000400F9" data-uri="chapter03.xhtml#P70004970270000000000000000400F9" class="pcalibre1 calibre8 pcalibre">-d</code> command-line flag:</p>
<pre id="P70004970270000000000000000400FA" data-uri="chapter03.xhtml#P70004970270000000000000000400FA" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000400FB" data-uri="chapter03.xhtml#P70004970270000000000000000400FB" class="calibre10 pcalibre pcalibre1">
linux&gt; <i class="calibre5 pcalibre pcalibre1">objdump -d mstore.o</i>
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000400FC" data-uri="chapter03.xhtml#P70004970270000000000000000400FC">The result (where we have added line numbers on the left and annotations in italicized text) is as follows:</p>
<pre id="P70004970270000000000000000400FD" data-uri="chapter03.xhtml#P70004970270000000000000000400FD" class="calibre9 pcalibre pcalibre1">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000001E97" title="174" data-uri="chapter03.xhtml#P7000497027000000000000000001E97" epub:type="pagebreak"></span><b class="calibre4 pcalibre pcalibre1"><i class="calibre5 pcalibre pcalibre1">Disassembly of function</i></b> <code id="P70004970270000000000000000400FE" data-uri="chapter03.xhtml#P70004970270000000000000000400FE" class="calibre10 pcalibre pcalibre1">sum</code> <b class="calibre4 pcalibre pcalibre1"><i class="calibre5 pcalibre pcalibre1">in binary file</i></b> <code id="P70004970270000000000000000400FF" data-uri="chapter03.xhtml#P70004970270000000000000000400FF" class="calibre10 pcalibre pcalibre1">mstore.o</code>
<code id="P7000497027000000000000000040100" data-uri="chapter03.xhtml#P7000497027000000000000000040100" class="calibre10 pcalibre pcalibre1">
1	0000000000000000 &lt;multstore&gt;:
</code></pre>
<pre id="P7000497027000000000000000040101" data-uri="chapter03.xhtml#P7000497027000000000000000040101" class="calibre9 pcalibre pcalibre1">    <i class="calibre5 pcalibre pcalibre1">Offset</i>   <i class="calibre5 pcalibre pcalibre1">Bytes</i>		<i class="calibre5 pcalibre pcalibre1">Equivalent assembly language</i>
<code id="P7000497027000000000000000040102" data-uri="chapter03.xhtml#P7000497027000000000000000040102" class="calibre10 pcalibre pcalibre1">
2	0:	53			push	%rbx
3	1:	48 89 d3		mov	%rdx,%rbx
4	4:	e8 00 00 00 00		callq	9 &lt;multstore+0x9&gt;
5	9:	48 89 03		mov	%rax,(%rbx)
6	c:	5b			pop	%rbx
7	d:	c3			retq	
</code>
</pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000040103" data-uri="chapter03.xhtml#P7000497027000000000000000040103">On the left we see the 14 hexadecimal byte values, listed in the byte sequence shown earlier, partitioned into groups of 1 to 5 bytes each. Each of these groups is a single instruction, with the assembly-language equivalent shown on the right.</p>
<p id="P7000497027000000000000000040104" data-uri="chapter03.xhtml#P7000497027000000000000000040104" class="pcalibre1 pcalibre calibre2">Several features about machine code and its disassembled representation are worth noting:</p>
<ul id="P7000497027000000000000000040105" data-uri="chapter03.xhtml#P7000497027000000000000000040105" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000040106" data-uri="chapter03.xhtml#P7000497027000000000000000040106" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000040107" data-uri="chapter03.xhtml#P7000497027000000000000000040107" class="pcalibre calibre3 pcalibre1">x86-64 instructions can range in length from 1 to 15 bytes. The instruction encoding is designed so that commonly used instructions and those with fewer operands require a smaller number of bytes than do less common ones or ones with more operands.</p></li>
<li id="P7000497027000000000000000040108" data-uri="chapter03.xhtml#P7000497027000000000000000040108" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000040109" data-uri="chapter03.xhtml#P7000497027000000000000000040109" class="pcalibre calibre3 pcalibre1">The instruction format is designed in such a way that from a given starting position, there is a unique decoding of the bytes into machine instructions. For example, only the instruction <code id="P700049702700000000000000004010A" data-uri="chapter03.xhtml#P700049702700000000000000004010A" class="pcalibre1 calibre8 pcalibre">pushq %rbx</code> can start with byte value <code id="P700049702700000000000000004010B" data-uri="chapter03.xhtml#P700049702700000000000000004010B" class="pcalibre1 calibre8 pcalibre">53</code>.</p></li>
<li id="P700049702700000000000000004010C" data-uri="chapter03.xhtml#P700049702700000000000000004010C" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004010D" data-uri="chapter03.xhtml#P700049702700000000000000004010D" class="pcalibre calibre3 pcalibre1">The disassembler determines the assembly code based purely on the byte sequences in the machine-code file. It does not require access to the source or assembly-code versions of the program.</p></li>
<li id="P700049702700000000000000004010E" data-uri="chapter03.xhtml#P700049702700000000000000004010E" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004010F" data-uri="chapter03.xhtml#P700049702700000000000000004010F" class="pcalibre calibre3 pcalibre1">The disassembler uses a slightly different naming convention for the instructions than does the assembly code generated by <span class="smallcaps pcalibre pcalibre1">gcc</span>. In our example, it has omitted the suffix `<code id="P7000497027000000000000000040110" data-uri="chapter03.xhtml#P7000497027000000000000000040110" class="pcalibre1 calibre8 pcalibre">q</code>' from many of the instructions. These suffixes are size designators and can be omitted in most cases. Conversely, the disassembler adds the suffix `<code id="P7000497027000000000000000040111" data-uri="chapter03.xhtml#P7000497027000000000000000040111" class="pcalibre1 calibre8 pcalibre">q</code>' to the <code id="P7000497027000000000000000040112" data-uri="chapter03.xhtml#P7000497027000000000000000040112" class="pcalibre1 calibre8 pcalibre">call</code> and <code id="P7000497027000000000000000040113" data-uri="chapter03.xhtml#P7000497027000000000000000040113" class="pcalibre1 calibre8 pcalibre">ret</code> instructions. Again, these suffixes can safely be omitted.</p></li>
</ul>
<p id="P7000497027000000000000000040114" data-uri="chapter03.xhtml#P7000497027000000000000000040114" class="pcalibre1 pcalibre calibre2">Generating the actual executable code requires running a linker on the set of object-code files, one of which must contain a function <code id="P7000497027000000000000000040115" data-uri="chapter03.xhtml#P7000497027000000000000000040115" class="pcalibre1 calibre8 pcalibre">main</code>. Suppose in file <code id="P7000497027000000000000000040116" data-uri="chapter03.xhtml#P7000497027000000000000000040116" class="pcalibre1 calibre8 pcalibre">main.c</code> we had the following function:</p>

<pre id="P7000497027000000000000000040117" data-uri="chapter03.xhtml#P7000497027000000000000000040117" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040118" data-uri="chapter03.xhtml#P7000497027000000000000000040118" class="calibre10 pcalibre pcalibre1">
#include &lt;stdio.h&gt;

void multstore(long, long, long *);

int main() {
	long d;
	multstore(2, 3, &amp;d);
	printf("2 * 3 –&gt; %ld\n", d);
	return 0;
}

<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000001EB3" title="175" data-uri="chapter03.xhtml#P7000497027000000000000000001EB3" epub:type="pagebreak"></span>long mult2(long a, long b) {
	long s = a * b;
	return s;
}
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000040119" data-uri="chapter03.xhtml#P7000497027000000000000000040119">Then we could generate an executable program prog as follows:</p>
<pre id="P700049702700000000000000004011A" data-uri="chapter03.xhtml#P700049702700000000000000004011A" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004011B" data-uri="chapter03.xhtml#P700049702700000000000000004011B" class="calibre10 pcalibre pcalibre1">
linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -Og -o prog main.c mstore.c</i>
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004011C" data-uri="chapter03.xhtml#P700049702700000000000000004011C">The file <code id="P700049702700000000000000004011D" data-uri="chapter03.xhtml#P700049702700000000000000004011D" class="pcalibre1 calibre8 pcalibre">prog</code> has grown to 8,655 bytes, since it contains not just the machine code for the procedures we provided but also code used to start and terminate the program as well as to interact with the operating system.</p>
<p id="P700049702700000000000000004011E" data-uri="chapter03.xhtml#P700049702700000000000000004011E" class="pcalibre1 pcalibre calibre2">We can disassemble the file <code id="P700049702700000000000000004011F" data-uri="chapter03.xhtml#P700049702700000000000000004011F" class="pcalibre1 calibre8 pcalibre">prog:</code></p>
<pre id="P7000497027000000000000000040120" data-uri="chapter03.xhtml#P7000497027000000000000000040120" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040121" data-uri="chapter03.xhtml#P7000497027000000000000000040121" class="calibre10 pcalibre pcalibre1">
linux&gt; <i class="calibre5 pcalibre pcalibre1">objdump -d prog</i>
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000040122" data-uri="chapter03.xhtml#P7000497027000000000000000040122">The disassembler will extract various code sequences, including the following:</p>
<pre id="P7000497027000000000000000040123" data-uri="chapter03.xhtml#P7000497027000000000000000040123" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040124" data-uri="chapter03.xhtml#P7000497027000000000000000040124" class="calibre10 pcalibre pcalibre1"><i class="calibre5 pcalibre pcalibre1">Disassembly of function</i> <code id="P7000497027000000000000000040125" data-uri="chapter03.xhtml#P7000497027000000000000000040125" class="pcalibre1 calibre8 pcalibre">sum</code> <i class="calibre5 pcalibre pcalibre1">in binary file</i> <code id="P7000497027000000000000000040126" data-uri="chapter03.xhtml#P7000497027000000000000000040126" class="pcalibre1 calibre8 pcalibre">prog</code>
1 0000000000400540 &lt;multstore&gt;:
2	400540:	53			push	%rbx
3	400541:	48 89 d3		mov	%rdx,%rbx
4	400544:	e8 42 00 00 00		callq	40058b &lt;mult2&gt;
5	400549:	48 89 03		mov	%rax,(%rbx)
6	40054c:	5b			pop	%rbx
7	40054d:	c3			retq	
8	40054e:	90			nop	
9	40054f:	90			nop	
</code></pre>
<p id="P7000497027000000000000000040127" data-uri="chapter03.xhtml#P7000497027000000000000000040127" class="pcalibre1 pcalibre calibre2">This code is almost identical to that generated by the disassembly of <code id="P7000497027000000000000000040128" data-uri="chapter03.xhtml#P7000497027000000000000000040128" class="pcalibre1 calibre8 pcalibre">mstore.c.</code> One important difference is that the addresses listed along the left are different—the linker has shifted the location of this code to a different range of addresses. A second difference is that the linker has filled in the address that the <code id="P7000497027000000000000000040129" data-uri="chapter03.xhtml#P7000497027000000000000000040129" class="pcalibre1 calibre8 pcalibre">callq</code> instruction should use in calling the function <code id="P700049702700000000000000004012A" data-uri="chapter03.xhtml#P700049702700000000000000004012A" class="pcalibre1 calibre8 pcalibre">mult2</code> (line 4 of the disassembly). One task for the linker is to match function calls with the locations of the executable code for those functions. A final difference is that we see two additional lines of code (lines 8-9). These instructions will have no effect on the program, since they occur after the return instruction (line 7). They have been inserted to grow the code for the function to 16 bytes, enabling a better placement of the next block of code in terms of memory system performance.</p>
</section>
<section id="P7000497027000000000000000001EC6" data-uri="chapter03.xhtml#P7000497027000000000000000001EC6" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000004012B" data-uri="chapter03.xhtml#P700049702700000000000000004012B" epub:type="title"><span class="pcalibre label pcalibre1">3.2.3 </span>Notes on Formatting</h1></header>
<p id="P700049702700000000000000004012C" data-uri="chapter03.xhtml#P700049702700000000000000004012C" class="pcalibre1 pcalibre calibre2">The assembly code generated by <span class="smallcaps pcalibre pcalibre1">gcc</span>is difficult for a human to read. On one hand, it contains information with which we need not be concerned, while on the other hand, it does not provide any description of the program or how it works. For example, suppose we give the command</p>
<pre id="P700049702700000000000000004012D" data-uri="chapter03.xhtml#P700049702700000000000000004012D" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004012E" data-uri="chapter03.xhtml#P700049702700000000000000004012E" class="calibre10 pcalibre pcalibre1">
linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -Og -S mstore.c</i>
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004012F" data-uri="chapter03.xhtml#P700049702700000000000000004012F"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000001ECC" title="176" data-uri="chapter03.xhtml#P7000497027000000000000000001ECC" epub:type="pagebreak"></span>to generate the file <code id="P7000497027000000000000000040130" data-uri="chapter03.xhtml#P7000497027000000000000000040130" class="pcalibre1 calibre8 pcalibre">mstore.s.</code> The full content of the file is as follows:</p>
<pre id="P7000497027000000000000000040131" data-uri="chapter03.xhtml#P7000497027000000000000000040131" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040132" data-uri="chapter03.xhtml#P7000497027000000000000000040132" class="calibre10 pcalibre pcalibre1">
	.file	"010–mstore.c"
	.text
	.globl	multstore
	.type	multstore, @function
multstore:
	pushq	%rbx
	movq	%rdx, %rbx
	call	mult2
	movq	%rax, (%rbx)
	popq	%rbx
	ret
	.size	multstore, .–multstore
	.ident	"GCC: (Ubuntu 4.8.1–2ubuntu1~12.04) 4.8.1"
	.section		.note.GNU-stack,"",@progbits
</code></pre>
<p id="P7000497027000000000000000040133" data-uri="chapter03.xhtml#P7000497027000000000000000040133" class="pcalibre1 pcalibre calibre2">All of the lines beginning with `.' are directives to guide the assembler and linker. We can generally ignore these. On the other hand, there are no explanatory remarks about what the instructions do or how they relate to the source code.</p>
<p id="P7000497027000000000000000040134" data-uri="chapter03.xhtml#P7000497027000000000000000040134" class="pcalibre1 pcalibre calibre2">To provide a clearer presentation of assembly code, we will show it in a form that omits most of the directives, while including line numbers and explanatory annotations. For our example, an annotated version would appear as follows:</p>
<pre id="P7000497027000000000000000040135" data-uri="chapter03.xhtml#P7000497027000000000000000040135" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040136" data-uri="chapter03.xhtml#P7000497027000000000000000040136" class="calibre10 pcalibre pcalibre1">
	<i class="calibre5 pcalibre pcalibre1">void multstore(long x, long y, long *dest)</i>
	<i class="calibre5 pcalibre pcalibre1">x in %rdi, y in %rsi, dest in %rdx</i>
1	multstore:
2	pushq	%rbx		<i class="calibre5 pcalibre pcalibre1">Save %rbx</i>
3	movq	%rdx, %rbx	<i class="calibre5 pcalibre pcalibre1">Copy dest to %rbx</i>
4	call	mult2		<i class="calibre5 pcalibre pcalibre1">Call mult2(x, y)</i>
5	movq	%rax, (%rbx)	<i class="calibre5 pcalibre pcalibre1">Store result at *dest</i>
6	popq	%rbx		<i class="calibre5 pcalibre pcalibre1">Restore %rbx</i>
7	ret			<i class="calibre5 pcalibre pcalibre1">Return</i>
</code></pre>
<p id="P7000497027000000000000000040137" data-uri="chapter03.xhtml#P7000497027000000000000000040137" class="pcalibre1 pcalibre calibre2">We typically show only the lines of code relevant to the point being discussed. Each line is numbered on the left for reference and annotated on the right by a brief description of the effect of the instruction and how it relates to the computations of the original C code. This is a stylized version of the way assembly-language programmers format their code.</p>
<p id="P7000497027000000000000000040138" data-uri="chapter03.xhtml#P7000497027000000000000000040138" class="pcalibre1 pcalibre calibre2">We also provide Web asides to cover material intended for dedicated machine-language enthusiasts. One Web aside describes IA32 machine code. Having a background in x86-64 makes learning IA32 fairly simple. Another Web aside gives a brief presentation of ways to incorporate assembly code into C programs. For some applications, the programmer must drop down to assembly code to access low-level features of the machine. One approach is to write entire functions in assembly code and combine them with C functions during the linking stage. A</p>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000001ED6" data-uri="chapter03.xhtml#P7000497027000000000000000001ED6"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000040139" data-uri="chapter03.xhtml#P7000497027000000000000000040139" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000001ED8" title="177" data-uri="chapter03.xhtml#P7000497027000000000000000001ED8" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>ATT versus Intel assembly-code formats</h1></header>
<p id="P700049702700000000000000004013A" data-uri="chapter03.xhtml#P700049702700000000000000004013A" class="calibre13 pcalibre pcalibre1">In our presentation, we show assembly code in ATT format (named after AT&amp;T, the company that operated Bell Laboratories for many years), the default format for <span class="smallcaps pcalibre pcalibre1">gcc</span>, <span class="smallcaps pcalibre pcalibre1">objdump</span>, and the other tools we will consider. Other programming tools, including those from Microsoft as well as the documentation from Intel, show assembly code in <i class="calibre5 pcalibre pcalibre1">Intel</i> format. The two formats differ in a number of ways. As an example, <span class="smallcaps pcalibre pcalibre1">gcc </span>can generate code in Intel format for the sum function using the following command line:</p>
<pre id="P700049702700000000000000004013B" data-uri="chapter03.xhtml#P700049702700000000000000004013B" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004013C" data-uri="chapter03.xhtml#P700049702700000000000000004013C" class="calibre10 pcalibre pcalibre1">
linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -Og -S -masm=intel mstore.c</i>
</code></pre>
<p class="calibre13 pcalibre pcalibre1" id="P700049702700000000000000004013D" data-uri="chapter03.xhtml#P700049702700000000000000004013D">This gives the following assembly code:</p>
<pre id="P700049702700000000000000004013E" data-uri="chapter03.xhtml#P700049702700000000000000004013E" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004013F" data-uri="chapter03.xhtml#P700049702700000000000000004013F" class="calibre10 pcalibre pcalibre1">
multstore:
	push	rbx
	mov	rbx, rdx
	call	mult2
	mov	QWORD PTR [rbx], rax
	pop	rbx
	ret
</code></pre>
<p id="P7000497027000000000000000040140" data-uri="chapter03.xhtml#P7000497027000000000000000040140" class="calibre13 pcalibre pcalibre1">We see that the Intel and ATT formats differ in the following ways:</p>
<ul id="P7000497027000000000000000040141" data-uri="chapter03.xhtml#P7000497027000000000000000040141" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000040142" data-uri="chapter03.xhtml#P7000497027000000000000000040142" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000040143" data-uri="chapter03.xhtml#P7000497027000000000000000040143" class="pcalibre calibre3 pcalibre1">The Intel code omits the size designation suffixes. We see instruction push and <code id="P7000497027000000000000000040144" data-uri="chapter03.xhtml#P7000497027000000000000000040144" class="pcalibre1 calibre8 pcalibre">mov</code> instead of <code id="P7000497027000000000000000040145" data-uri="chapter03.xhtml#P7000497027000000000000000040145" class="pcalibre1 calibre8 pcalibre">pushq</code> and <code id="P7000497027000000000000000040146" data-uri="chapter03.xhtml#P7000497027000000000000000040146" class="pcalibre1 calibre8 pcalibre">movq</code>.</p></li>
<li id="P7000497027000000000000000040147" data-uri="chapter03.xhtml#P7000497027000000000000000040147" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000040148" data-uri="chapter03.xhtml#P7000497027000000000000000040148" class="pcalibre calibre3 pcalibre1">The Intel code omits the `%' character in front of register names, using <code id="P7000497027000000000000000040149" data-uri="chapter03.xhtml#P7000497027000000000000000040149" class="pcalibre1 calibre8 pcalibre">rbx</code> instead of <code id="P700049702700000000000000004014A" data-uri="chapter03.xhtml#P700049702700000000000000004014A" class="pcalibre1 calibre8 pcalibre">%rbx</code>.</p></li>
<li id="P700049702700000000000000004014B" data-uri="chapter03.xhtml#P700049702700000000000000004014B" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004014C" data-uri="chapter03.xhtml#P700049702700000000000000004014C" class="pcalibre calibre3 pcalibre1">The Intel code has a different way of describing locations in memory—for example, <code id="P700049702700000000000000004014D" data-uri="chapter03.xhtml#P700049702700000000000000004014D" class="pcalibre1 calibre8 pcalibre">QWORD PTR [rbx]</code> rather than <code id="P700049702700000000000000004014E" data-uri="chapter03.xhtml#P700049702700000000000000004014E" class="pcalibre1 calibre8 pcalibre">(%rbx)</code>.</p></li>
<li id="P700049702700000000000000004014F" data-uri="chapter03.xhtml#P700049702700000000000000004014F" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000040150" data-uri="chapter03.xhtml#P7000497027000000000000000040150" class="pcalibre calibre3 pcalibre1">Instructions with multiple operands list them in the reverse order. This can be very confusing when switching between the two formats.</p></li>
</ul>
<p class="pcalibre calibre3 pcalibre1" id="P7000497027000000000000000040151" data-uri="chapter03.xhtml#P7000497027000000000000000040151">Although we will not be using Intel format in our presentation, you will encounter it in documentation from Intel and Microsoft.</p>

</aside>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000040152" data-uri="chapter03.xhtml#P7000497027000000000000000040152">second is to use <span class="smallcaps pcalibre pcalibre1">gcc</span>'s support for embedding assembly code directly within C programs.</p>
</section>
</section></body></html>
