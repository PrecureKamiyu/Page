<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>4.5 Data Structures</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part39.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part41.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">4.5 Data Structures</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The OS is a program, and like any program, it has some key data struc- tures that track various relevant pieces of information. To track the state of each process, for example, the OS likely will keep some kind of <b>process list </b>for all processes that are ready, as well as some additional informa- tion to track which process is currently running. The OS must also track, in some way, blocked processes; when an I/O event completes, the OS should make sure to wake the correct process and ready it to run again.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Figure <span style=" color: #00AEEF;">4.3 </span>shows what type of information an OS needs to track about each process in the xv6 kernel [CK+08]. Similar process structures exist in “real” operating systems such as Linux, Mac OS X, or Windows; look them up and see how much more complex they are.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">From the figure, you can see a couple of important pieces of informa- tion the OS tracks about a process. The <b>register context </b>will hold, for a stopped process, the contents of its register state. When a process is stopped, its register state will be saved to this memory location; by restor- ing these registers (i.e., placing their values back into the actual physical registers), the OS can resume running the process. We’ll learn more about this technique known as a <b>context switch </b>in future chapters.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">// the registers xv6 will save and restore</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">// to stop and subsequently restart a process struct context {</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;text-align: justify;">int eip; int esp; int ebx; int ecx; int edx; int esi; int edi; int ebp;</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;line-height: 8pt;text-align: left;">};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">// the different states a process can be in enum proc_state { UNUSED, EMBRYO, SLEEPING,</p><p class="s38" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">RUNNABLE, RUNNING, ZOMBIE };</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">// the information xv6 tracks about each process</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">// including its register context and state struct proc {</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;line-height: 8pt;text-align: left;">char <span class="s39">*</span>mem;       // Start of process memory</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;line-height: 7pt;text-align: left;">uint sz;        // Size of process memory</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;line-height: 8pt;text-align: left;">char <span class="s39">*</span>kstack;      // Bottom of kernel stack</p><p class="s38" style="padding-left: 166pt;text-indent: 0pt;line-height: 7pt;text-align: left;">// for this process</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">enum proc_state state;   // Process state int pid;        // Process ID struct proc <span class="s39">*</span>parent;    // Parent process</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;line-height: 83%;text-align: left;">void <span class="s39">*</span>chan;       // If non-zero, sleeping on chan</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;line-height: 7pt;text-align: left;">int killed;       // If non-zero, have been killed</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;line-height: 89%;text-align: left;">struct file <span class="s39">*</span>ofile[NOFILE]; // Open files struct inode <span class="s39">*</span>cwd;    // Current directory</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;line-height: 7pt;text-align: left;">struct context context;  // Switch here to run process</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;line-height: 8pt;text-align: left;">struct trapframe <span class="s39">*</span>tf;   // Trap frame for the</p><p class="s38" style="padding-left: 166pt;text-indent: 0pt;line-height: 7pt;text-align: left;">// current interrupt</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 116pt;text-indent: 0pt;text-align: left;">Figure 4.3: <b>The xv6 Proc Structure</b></p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">You can also see from the figure that there are some other states a pro- cess can be in, beyond running, ready, and blocked. Sometimes a system will have an <b>initial </b>state that the process is in when it is being created. Also, a process could be placed in a <b>final </b>state where it has exited but has not yet been cleaned up (in UNIX-based systems, this is called the</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;"><b>zombie </b>state<span class="s35">1</span>). This final state can be useful as it allows other processes (usually the <b>parent </b>that created the process) to examine the return code of the process and see if it the just-finished process executed successfully (usually, programs return zero in U<span class="s7">NIX</span>-based systems when they have accomplished a task successfully, and non-zero otherwise). When fin- ished, the parent will make one final call (e.g., <span class="s41">wait()</span>) to wait for the completion of the child, and to also indicate to the OS that it can clean up any relevant data structures that referred to the now-extinct process.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_026.png"/></span></p><p class="s11" style="padding-top: 1pt;padding-left: 35pt;text-indent: 0pt;line-height: 8pt;text-align: center;">1<span class="s12">Yes, the zombie state. Just like real zombies, these zombies are relatively easy to kill.</span></p><p class="s12" style="padding-left: 41pt;text-indent: 0pt;line-height: 8pt;text-align: justify;">However, different techniques are usually recommended.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 55pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>D<span class="s45">ATA </span>S<span class="s45">TRUCTURE </span>– T<span class="s45">HE </span>P<span class="s45">ROCESS </span>L<span class="s45">IST</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Operating systems are replete with various important <b>data structures </b>that we will discuss in these notes. The <b>process list </b>is the first such struc- ture. It is one of the simpler ones, but certainly any OS that has the ability to run multiple programs at once will have something akin to this struc- ture in order to keep track of all the running programs in the system. Sometimes people refer to the individual structure that stores informa- tion about a process as a <b>Process Control Block </b>(<b>PCB</b>), a fancy way of talking about a C structure that contains information about each process.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part39.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part41.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
