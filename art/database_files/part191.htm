<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>9.9   Encryption and Its Applications</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part190.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part192.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 4pt;padding-left: 72pt;text-indent: 0pt;text-align: left;"><a name="bookmark193">9.9   </a><span style=" color: #00AEEF;">Encryption and Its Applications</span><a name="bookmark213">&zwnj;</a></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Encryption refers to the process of transforming data into a form that is unreadable, unless the reverse process of decryption is applied. Encryption algorithms use an en- cryption key to perform encryption, and they require a decryption key (which could be the same as the encryption key, depending on the encryption algorithm used) to perform decryption.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The oldest uses of encryption were for transmitting messages, encrypted using a secret key known only to the sender and the intended receiver. Even if the message is intercepted by an enemy, the enemy, not knowing the key, will not be able to decrypt and understand the message. Encryption is widely used today for protecting data in transit in a variety of applications such as data transfer on the internet, and on cell-phone networks. Encryption is also used to carry out other tasks, such as authentication, as we will see in Section 9.9.3.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: right;">In the context of databases, encryption is used to store data in a secure way, so that even if the data are acquired by an unauthorized user (e.g., a laptop computer containing the data is stolen), the data will not be accessible without a decryption key. Many databases today store sensitive customer information, such as credit-card numbers, names, ﬁngerprints, signatures, and identiﬁcation numbers such as, in the United States, social security numbers. A criminal who gets access to such data can use them for a variety of illegal activities, such as purchasing goods using a credit-card number, or even acquiring a credit card in someone else’s name. Organizations such as credit-card companies use knowledge of personal information as a way of identifying who is requesting a service or goods. Leakage of such personal information allows a criminal to impersonate someone else and get access to service or goods; such imper- sonation is referred to as <span class="s63">identity theft</span>. Thus, applications that store such sensitive data</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">must take great care to protect them from theft.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">To reduce the chance of sensitive information being acquired by criminals, many countries and states today require by law that any database storing such sensitive in- formation must store the information in an encrypted form. A business that does not protect its data thus could be held criminally liable in case of data theft. Thus, encryp- tion is a critical component of any application that stores such sensitive information.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">9.9.1 Encryption Techniques</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">There are a vast number of techniques for the encryption of data. Simple encryption techniques may not provide adequate security, since it may be easy for an unauthorized user to break the code. As an example of a weak encryption technique, consider the substitution of each character with the next character in the alphabet. Thus,</p><p style="padding-top: 8pt;padding-left: 84pt;text-indent: 0pt;text-align: center;">Perryridge</p><p style="padding-top: 8pt;padding-left: 75pt;text-indent: 0pt;text-align: center;">becomes</p><p style="padding-top: 3pt;padding-left: 84pt;text-indent: 0pt;text-align: center;">Qfsszsjehf</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">If an unauthorized user sees only “Qfsszsjehf,” she probably has insuﬃcient infor- mation to break the code. However, if the intruder sees a large number of encrypted branch names, she could use statistical data regarding the relative frequency of char- acters to guess what substitution is being made (for example, <i>E </i>is the most common letter in English text, followed by <i>T, A, O, N, I </i>, and so on).</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">A good encryption technique has the following properties:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;">• <span class="s40">It is relatively simple for authorized users to encrypt and decrypt data.</span></p><p style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">It depends not on the secrecy of the algorithm, but rather on a parameter of the al- gorithm called the </span><i>encryption key</i>, which is used to encrypt data. In a <span class="s63">symmetric-key </span>encryption technique, the encryption key is also used to decrypt data. In contrast, in <span class="s63">public-key </span>(also known as <span class="s63">asymmetric-key</span>) encryption techniques, there are two diﬀerent keys, the public key and the private key, used to encrypt and decrypt the data.</p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Its decryption key is extremely diﬃcult for an intruder to determine, even if the intruder has access to encrypted data. In the case of asymmetric-key encryption, it is extremely diﬃcult to infer the private key even if the public key is available.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The <span class="s63">Advanced Encryption Standard </span>(<span class="s64">AES</span>) is a symmetric-key encryption algorithm that was adopted as an encryption standard by the U.S. government in 2000 and is now widely used. The standard is based on the <span class="s63">Rijndael algorithm </span>(named for the inventors</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">V. Rijmen and J. Daemen). The algorithm operates on a 128-bit block of data at a time, while the key can be 128, 192, or 256 bits in length. The algorithm runs a series of steps to jumble up the bits in a data block in a way that can be reversed during decryption, and it performs an XOR operation with a 128-bit “round key” that is derived from the encryption key. A new round key is generated from the encryption key for each block of data that is encrypted. During decryption, the round keys are generated again from the encryption key and the encryption process is reversed to recover the original data. An earlier standard called the <i>Data Encryption Standard </i>(DES), adopted in 1977, was very widely used earlier.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">For any symmetric-key encryption scheme to work, authorized users must be pro- vided with the encryption key via a secure mechanism. This requirement is a major weakness, since the scheme is no more secure than the security of the mechanism by which the encryption key is transmitted.</p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 13pt;text-align: justify;"><span class="s63">Public-key encryption </span>is an alternative scheme that avoids some of the problems faced by symmetric-key encryption techniques. It is based on two keys: a <i>public key </i>and a <i>private key</i>. Each user <i>U</i><span class="s97">i </span>has a public key <i>E</i><span class="s97">i </span>and a private key <i>D</i><span class="s97">i</span>. All public keys are published: They can be seen by anyone. Each private key is known to only the one user to whom the key belongs. If user <i>U</i><span class="s98">1</span> wants to store encrypted data, <i>U</i><span class="s98">1</span> encrypts them using public key <i>E</i><span class="s98">1</span>. Decryption requires the private key <i>D</i><span class="s98">1</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Because the encryption key for each user is public, it is possible to exchange infor- mation securely by this scheme. If user <i>U</i><span class="s98">1</span> wants to share data with <i>U</i><span class="s98">2</span>, <i>U</i><span class="s98">1</span> encrypts</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">the data using <i>E</i><span class="s98">2</span>, the public key of <i>U</i><span class="s98">2</span>. Since only user <i>U</i><span class="s98">2</span> knows how to decrypt the data, information can be transferred securely.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">For public-key encryption to work, there must be a scheme for encryption such that it is infeasible (that is, extremely hard) to deduce the private key, given the public key. Such a scheme does exist and is based on these conditions:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 123pt;text-indent: 0pt;text-align: justify;">• <span class="s40">There is an eﬃcient algorithm for testing whether or not a number is prime.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 123pt;text-indent: 0pt;text-align: justify;">• <span class="s40">No eﬃcient algorithm is known for ﬁnding the prime factors of a number.</span></p><p class="s13" style="padding-left: 119pt;text-indent: 17pt;line-height: 13pt;text-align: justify;"><span class="p">For purposes of this scheme, data are treated as a collection of integers. We create a public key by computing the product of two large prime numbers: </span>P<span class="s98">1</span><span class="p"> and </span>P<span class="s98">2</span><span class="p">. The private key consists of the pair (</span>P<span class="s98">1</span><span class="p">, </span>P<span class="s98">2</span><span class="p">). The decryption algorithm cannot be used successfully if only the product </span>P<span class="s130">1</span>P<span class="s130">2 </span><span class="s94">is known; it needs the individual values </span>P<span class="s130">1 </span><span class="s94">and </span>P<span class="s130">2</span><span class="s94">. Since all that is published is the product </span>P<span class="s98">1</span>P<span class="s98">2</span><span class="p">, an unauthorized user would need to be able to factor </span>P<span class="s93">1</span>P<span class="s93">2 </span><span class="s94">to steal data. By choosing </span>P<span class="s93">1 </span><span class="s94">and </span>P<span class="s93">2 </span><span class="s94">to be suﬃciently large (over 100 digits),</span></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;"><span class="p">we can make the cost of factoring </span>P<span class="s98">1</span>P<span class="s98">2</span><span class="p"> prohibitively high (on the order of years of computation time, on even the fastest computers).</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The details of public-key encryption and the mathematical justiﬁcation of this tech- nique’s properties are referenced in the bibliographical notes.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Although public-key encryption by this scheme is secure, it is also computationally very expensive. A hybrid scheme widely used for secure communication is as follows: a symmetric encryption key (based, for example, on <span class="s44">AES</span>) is randomly generated and exchanged in a secure manner using a public-key encryption scheme, and symmetric- key encryption using that key is used on the data transmitted subsequently.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Encryption of small values, such as identiﬁers or names, is made complicated by the possibility of <span class="s63">dictionary attacks</span>, particularly if the encryption key is publicly avail- able. For example, if date-of-birth ﬁelds are encrypted, an attacker trying to decrypt a particular encrypted value <i>e </i>could try encrypting every possible date of birth until he ﬁnds one whose encrypted value matches <i>e</i>. Even if the encryption key is not publicly available, statistical information about data distributions can be used to ﬁgure out what an encrypted value represents in some cases, such as age or address. For example, if the age 18 is the most common age in a database, the encrypted age value that occurs most often can be inferred to represent 18.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Dictionary attacks can be deterred by adding extra random bits to the end of the value before encryption (and removing them after decryption). Such extra bits, referred to as an <span class="s63">initialization vector </span>in <span class="s44">AES</span>, or as <i>salt </i>bits in other contexts, provide good protection against dictionary attack.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">9.9.2 Encryption Support in Databases</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Many ﬁle systems and database systems today support encryption of data. Such en- cryption protects the data from someone who is able to access the data but is not able to access the decryption key. In the case of ﬁle-system encryption, the data to be en- crypted are usually large ﬁles and directories containing information about ﬁles.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">In the context of databases, encryption can be done at several diﬀerent levels. At the lowest level, the disk blocks containing database data can be encrypted, using a key available to the database-system software. When a block is retrieved from disk, it is ﬁrst decrypted and then used in the usual fashion. Such disk-block-level encryption protects against attackers who can access the disk contents but do not have access to the encryption key.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">At the next higher level, speciﬁed (or all) attributes of a relation can be stored in encrypted form. In this case, each attribute of a relation could have a diﬀerent encryp- tion key. Many databases today support encryption at the level of speciﬁed attributes as well as at the level of an entire relation, or all relations in a database. Encryption of speciﬁed attributes minimizes the overhead of decryption by allowing applications to encrypt only attributes that contain sensitive values such as credit-card numbers. Encryption also then needs to use extra random bits to prevent dictionary attacks, as described earlier. However, databases typically do not allow primary and foreign key attributes to be encrypted, and they do not support indexing on encrypted attributes.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A decryption key is obviously required to get access to encrypted data. A single master encryption key may be used for all the encrypted data; with attribute level en- cryption, diﬀerent encryption keys could be used for diﬀerent attributes. In this case, the decryption keys for diﬀerent attributes can be stored in a ﬁle or relation (often referred to as “wallet”), which is itself encrypted using a master key.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A connection to the database that needs to access encrypted attributes must then provide the master key; unless this is provided, the connection will not be able to access encrypted data. The master key would be stored in the application program (typically on a diﬀerent computer), or memorized by the database user, and provided when the user connects to the database.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Encryption at the database level has the advantage of requiring relatively low time and space overhead and does not require modiﬁcation of applications. For example, if data in a laptop computer database need to be protected from theft of the computer itself, such encryption can be used. Similarly, someone who gets access to backup tapes of a database would not be able to access the data contained in the backups without knowing the decryption key.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">An alternative to performing encryption in the database is to perform it <i>before </i>the data are sent to the database. The application must then encrypt the data before sending it to the database and decrypt the data when they are retrieved. This approach to data encryption requires signiﬁcant modiﬁcations to be done to the application, unlike encryption performed in a database system.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">9.9.3 Encryption and Authentication</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Password-based authentication is used widely by operating systems as well as database systems. However, the use of passwords has some drawbacks, especially over a network. If an eavesdropper is able to “sniﬀ” the data being sent over the network, she may be able to ﬁnd the password as it is being sent across the network. Once the eavesdropper</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">has a user name and password, she can connect to the database, pretending to be the legitimate user.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">A more secure scheme involves a <span class="s63">challenge-response </span>system. The database system sends a challenge string to the user. The user encrypts the challenge string using a secret password as encryption key and then returns the result. The database system can verify the authenticity of the user by decrypting the string with the same secret password and checking the result with the original challenge string. This scheme ensures that no passwords travel across the network.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Public-key systems can be used for encryption in challenge– response systems. The database system encrypts a challenge string using the user’s public key and sends it to the user. The user decrypts the string using her private key and returns the result to the database system. The database system then checks the response. This scheme has the added beneﬁt of not storing the secret password in the database, where it could potentially be seen by system administrators.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Storing the private key of a user on a computer (even a personal computer) has the risk that if the computer is compromised, the key may be revealed to an attacker who can then masquerade as the user. <span class="s63">Smart cards </span>provide a solution to this problem. In a smart card, the key can be stored on an embedded chip; the operating system of the smart card guarantees that the key can never be read, but it allows data to be sent to the card for encryption or decryption, using the private key.<span class="s76">9</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">9.9.3.1 Digital Signatures</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Another interesting application of public-key encryption is in <span class="s63">digital signatures </span>to verify authenticity of data; digital signatures play the electronic role of physical signatures on documents. The private key is used to “sign,” that is, encrypt, data, and the signed data can be made public. Anyone can verify the signature by decrypting the data using the public key, but no one could have generated the signed data without having the private key. (Note the reversal of the roles of the public and private keys in this scheme.) Thus, we can <span class="s63">authenticate </span>the data; that is, we can verify that the data were indeed created by the person who is supposed to have created them.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Furthermore, digital signatures also serve to ensure <span class="s63">nonrepudiation</span>. That is, in case the person who created the data later claims she did not create them (the electronic equivalent of claiming not to have signed the check), we can prove that that person must have created the data (unless her private key was leaked to others).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">9.9.3.2 Digital Certiﬁcates</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Authentication is, in general, a two-way process, where each of a pair of interacting entities authenticates itself to the other. Such pairwise authentication is needed even</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_2308.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">9<span class="s78">Smart cards provide other functionality too, such as the ability to store cash digitally and make payments, which is not relevant in our context.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">when a client contacts a web site, to prevent a malicious site from masquerading as a legal web site. Such masquerading could be done, for example, if the network routers were compromised and data rerouted to the malicious site.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">For a user to ensure that she is interacting with an authentic web site, she must have the site’s public key. This raises the problem of how the user can get the public key— if it is stored on the web site, the malicious site could supply a diﬀerent key, and the user would have no way of verifying if the supplied public key is itself authentic. Authentication can be handled by a system of <span class="s63">digital certiﬁcates</span>, whereby public keys are signed by a certiﬁcation agency, whose public key is well known. For example, the public keys of the root certiﬁcation authorities are stored in standard web browsers. A certiﬁcate issued by them can be veriﬁed by using the stored public keys.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A two-level system would place an excessive burden of creating certiﬁcates on the root certiﬁcation authorities, so a multilevel system is used instead, with one or more root certiﬁcation authorities and a tree of certiﬁcation authorities below each root. Each authority (other than the root authorities) has a digital certiﬁcate issued by its parent.</p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 93%;text-align: justify;">A digital certiﬁcate issued by a certiﬁcation authority <i>A </i>consists of a public key <i>K</i><span class="s97">A </span>and an encrypted text <i>E </i>that can be decoded by using the public key <i>K</i><span class="s97">A</span>. The encrypted text contains the name of the party to whom the certiﬁcate was issued and her public key <i>K</i><span class="s145">c</span>. In case the certiﬁcation authority <i>A </i>is not a root certiﬁcation authority, the encrypted text also contains the digital certiﬁcate issued to <i>A </i>by its parent certiﬁcation authority; this certiﬁcate authenticates the key <i>K</i><span class="s145">A </span>itself. (That certiﬁcate may in turn contain a certiﬁcate from a further parent authority, and so on.)</p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 94%;text-align: justify;">To verify a certiﬁcate, the encrypted text <i>E </i>is decrypted by using the public key <i>K</i><span class="s97">A </span>to retrieve the name of the party (i.e., the name of the organization owning the web site); additionally, if <i>A </i>is not a root authority whose public key is known to the</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">veriﬁer, the public key <i>K</i><span class="s145">A </span>is veriﬁed recursively by using the digital certiﬁcate con- tained within <i>E</i>; recursion terminates when a certiﬁcate issued by the root authority is reached. Verifying the certiﬁcate establishes the chain through which a particular site was authenticated and provides the name and authenticated public key for the site.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Digital certiﬁcates are widely used to authenticate web sites to users, to prevent ma- licious sites from masquerading as other web sites. In the <span class="s44">HTTPS </span>protocol (the secure version of the <span class="s44">HTTP </span>protocol), the site provides its digital certiﬁcate to the browser, which then displays it to the user. If the user accepts the certiﬁcate, the browser then uses the provided public key to encrypt data. A malicious site will have access to the certiﬁcate, but not the private key, and will thus not be able to decrypt the data sent by the browser. Only the authentic site, which has the corresponding private key, can decrypt the data sent by the browser. We note that public-/private-key encryption and decryption costs are much higher than encryption/decryption costs using symmetric private keys. To reduce encryption costs, <span class="s44">HTTPS </span>actually creates a one-time symmetric key after authentication and uses it to encrypt data for the rest of the session.</p><p class="s66" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;"><a name="bookmark194">9.10 </a><span style=" color: #00AEEF;">Summary  </span><span class="s164">453</span><a name="bookmark214">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Digital certiﬁcates can also be used for authenticating users. The user must submit a digital certiﬁcate containing her public key to a site, which veriﬁes that the certiﬁcate has been signed by a trusted authority. The user’s public key can then be used in a challenge-response system to ensure that the user possesses the corresponding private key, thereby authenticating the user.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part190.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part192.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
