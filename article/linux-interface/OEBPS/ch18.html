<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 18. Directories and Links</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch17.html" title="Chapter 17. Access Control Lists"/><link rel="next" href="ch19.html" title="Chapter 19. Monitoring File Events"/></head><body><section class="chapter" title="Chapter 18. Directories and Links" epub:type="chapter" id="directories_and_links-id1"><div class="titlepage"><div><div><h2 class="title">Chapter 18. Directories and Links</h2></div></div></div><p>In this chapter, we conclude our discussion of file-related topics by looking at
            directories and links. After an overview of their implementation, we describe the system
            calls used to create and remove directories and links. We then look at library functions
            that allow a program to scan the contents of a single directory and to walk through
            (i.e., examine each file in) a directory tree.<a id="IDX-CHP-18-2387" class="indexterm"/></p><p>Each process has two directory-related attributes: a root directory, which determines
            the point from which absolute pathnames are interpreted, and a current working
            directory, which determines the point from which relative pathnames are interpreted. We
            look at the system calls that allow a process to change both of these attributes.</p><p>We finish the chapter with a discussion of library functions that are used to resolve
            pathnames and to parse them into directory and filename components.</p><div class="sect1" title="Directories and (Hard) Links"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="directories_and_open_parenthesis_hard_cl">Directories and (Hard) Links</h2></div></div></div><p>A <span class="emphasis"><em>directory</em></span> is stored in the file system in a similar way to
                a regular file. Two things distinguish a directory from a regular file:<a id="IDX-CHP-18-2388" class="indexterm"/><a id="IDX-CHP-18-2389" class="indexterm"/><a id="IDX-CHP-18-2390" class="indexterm"/><a id="IDX-CHP-18-2391" class="indexterm"/><a id="IDX-CHP-18-2392" class="indexterm"/><a id="IDX-CHP-18-2393" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A directory is marked with a different file type in its i-node entry
                            (<a class="xref" href="ch14.html#i-nodes" title="I-nodes">I-nodes</a>).</p></li><li class="listitem"><p>A directory is a file with a special organization. Essentially, it is a
                        table consisting of filenames and i-node numbers.</p></li></ul></div><p>On most native Linux file systems, filenames can be up to 255 characters long. The
                relationship between directories and i-nodes is illustrated in <a class="xref" href="ch18.html#relationship_between_i-node_and_director" title="Figure 18-1. Relationship between i-node and directory structures for the file /etc/passwd">Figure 18-1</a>, which shows the partial
                contents of the file system i-node table and relevant directory files that are
                maintained for an example file (<code class="literal">/etc/passwd</code>).<a id="IDX-CHP-18-2394" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Although a process can open a directory, it can’t use
                        <span class="emphasis"><em>read()</em></span> to read the contents of a directory. To retrieve
                    the contents of a directory, a process must instead use the system calls and
                    library functions discussed later in this chapter. (On some UNIX
                    implementations, it is possible to perform a <span class="emphasis"><em>read()</em></span> on a
                    directory, but this is not portable.) Nor can a process directly change a
                    directory’s contents with <span class="emphasis"><em>write()</em></span>; it can only indirectly
                    (i.e., request the kernel to) change the contents using system calls such as
                        <span class="emphasis"><em>open()</em></span> (to create a new file),
                        <span class="emphasis"><em>link()</em></span>, <span class="emphasis"><em>mkdir()</em></span>,
                        <span class="emphasis"><em>symlink()</em></span>, <span class="emphasis"><em>unlink()</em></span>, and
                        <span class="emphasis"><em>rmdir()</em></span>. (All of these system calls are described later
                    in this chapter, except <span class="emphasis"><em>open()</em></span>, which was described in
                    Section 4.3.)</p><p>The i-node table is numbered starting at 1, rather than 0, because 0 in the
                    i-node field of a directory entry indicates that the entry is unused. I-node 1
                    is used to record bad blocks in the file system. The root directory (/) of a
                    file system is always stored in i-node entry 2 (as shown in <a class="xref" href="ch18.html#relationship_between_i-node_and_director" title="Figure 18-1. Relationship between i-node and directory structures for the file /etc/passwd">Figure 18-1</a>), so that the kernel
                    knows where to start when resolving a pathname.<a id="IDX-CHP-18-2395" class="indexterm"/></p></div><div class="figure"><a id="relationship_between_i-node_and_director"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject18_d1e44493"/><img src="figs/web/18-1_DIRS_LINKS-inodes-dirs.png.jpg" alt="Relationship between i-node and directory structures for the file /etc/passwd"/></div></div><div class="figure-title">Figure 18-1. Relationship between i-node and directory structures for the file <code class="literal">/etc/passwd</code></div></div><p>If we review the list of information stored in a file i-node (<a class="xref" href="ch14.html#i-nodes" title="I-nodes">I-nodes</a>), we see that the i-node doesn’t contain a filename; it is
                only the mapping within a directory list that defines the name of a file. This has a
                useful consequence: we can create multiple names—in the same or in different
                directories—each of which refers to the same i-node. These multiple names are known
                as <span class="emphasis"><em>links</em></span>, or sometimes as <span class="emphasis"><em>hard links</em></span> to
                distinguish them from symbolic links, which we discuss shortly.<a id="IDX-CHP-18-2396" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>All native Linux and UNIX file systems support hard links. However, many
                    non-UNIX file systems (e.g., Microsoft’s VFAT) do not. (Microsoft’s NTFS file
                    system does support hard links.)</p></div><p>From the shell, we can create new hard links to an existing file using the
                    <span class="emphasis"><em>ln</em></span> command, as shown in the following shell session
                    log:<a id="IDX-CHP-18-2397" class="indexterm"/></p><a id="I_programlisting18_d1e44524"/><pre class="programlisting">$ <strong class="userinput"><code>echo -n 'It is good to collect things,' &gt; abc</code></strong>
$ ls -li abc
 122232 -rw-r--r--   1 mtk      users          29 Jun 15 17:07 abc
$ <strong class="userinput"><code>ln abc xyz</code></strong>
$ <strong class="userinput"><code>echo ' but it is better to go on walks.' &gt;&gt; xyz</code></strong>
$ <strong class="userinput"><code>cat abc</code></strong>
It is good to collect things, but it is better to go on walks.
$ <strong class="userinput"><code>ls -li abc xyz</code></strong>
 122232 -rw-r--r--   2 mtk      users          63 Jun 15 17:07 abc
 122232 -rw-r--r--   2 mtk      users          63 Jun 15 17:07 xyz</pre><p>The i-node numbers displayed (as the first column) by <span class="emphasis"><em>ls -li</em></span>
                confirm what was already clear from the output of the <span class="emphasis"><em>cat</em></span>
                command: the names <code class="literal">abc</code> and <code class="literal">xyz</code> refer to the same i-node entry, and hence to the
                same file. In the third field displayed by <span class="emphasis"><em>ls -li</em></span>, we can see
                the link count for the i-node. After the <span class="emphasis"><em>ln abc xyz</em></span> command,
                the link count of the i-node referred to by <code class="literal">abc</code>
                has risen to 2, since there are now two names referring to the file. (The same link
                count is displayed for the file <code class="literal">xyz</code>, since it
                refers to the same i-node.)</p><p>If one of these filenames is removed, the other name, and the file itself,
                continue to exist:</p><a id="I_programlisting18_d1e44571"/><pre class="programlisting">$ <strong class="userinput"><code>rm abc</code></strong>
$ <strong class="userinput"><code>ls -li xyz</code></strong>
 122232 -rw-r--r--   1 mtk      users          63 Jun 15 17:07 xyz</pre><p>The i-node entry and data blocks for the file are removed (deallocated) only when
                the i-node’s link count falls to 0—that is, when all of the names for the file have
                been removed. To summarize: the <span class="emphasis"><em>rm</em></span> command removes a filename
                from a directory list, decrements the link count of the corresponding i-node by 1,
                and, if the link count thereby falls to 0, deallocates the i-node and the data
                blocks to which it refers.</p><p>All of the names (links) for a file are equivalent—none of the names (e.g., the
                first) has priority over any of the others. As we saw in the above example, after
                the first name associated with the file was removed, the physical file continued to
                exist, but it was then accessible only by the other name.</p><p>A question often asked in online forums is “How can I find the filename associated
                with the file descriptor X in my program?” The short answer is that we can’t— at
                least not portably and unambiguously—since a file descriptor refers to an i-node,
                and multiple filenames (or even, as described in <a class="xref" href="ch18.html#creating_and_removing_open_parenthesis_h" title="Creating and Removing (Hard) Links: link() and unlink()">Creating and Removing (Hard) Links: <span class="emphasis"><em>link</em></span>() and
                    <span class="emphasis"><em>unlink</em></span>()</a>, none at all) may refer to
                this i-node.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>On Linux, we can see which files a process currently has open by using
                        <span class="emphasis"><em>readdir()</em></span> (<a class="xref" href="ch18.html#reading_directories_colon_opendir_open_p" title="Reading Directories: opendir() and readdir()">Reading Directories: <span class="emphasis"><em>opendir()</em></span> and
                    <span class="emphasis"><em>readdir()</em></span></a>) to scan the contents
                    of the Linux-specific <code class="literal">/proc/</code><span class="emphasis"><em>PID</em></span><code class="literal">/fd</code> directory, which contains symbolic links for each of the file
                    descriptors currently opened by the process. The <span class="emphasis"><em>lsof(1)</em></span>
                    and <span class="emphasis"><em>fuser(1)</em></span> tools, which have been ported to many UNIX
                    systems, can also be useful in this regard.<a id="IDX-CHP-18-2398" class="indexterm"/></p></div><p>Hard links have two limitations, both of which can be circumvented by the use of
                symbolic links:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Because directory entries (hard links) refer to files using just an i-node
                        number, and i-node numbers are unique only within a file system, a hard link
                        must reside on the same file system as the file to which it refers.</p></li><li class="listitem"><p>A hard link can’t be made to a directory. This prevents the creation of
                        circular links, which would confuse many system programs.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Early UNIX implementations permitted the superuser to create hard links to
                    directories. This was necessary because these implementations did not provide a
                        <span class="emphasis"><em>mkdir()</em></span> system call. Instead, a directory was created
                    using <span class="emphasis"><em>mknod()</em></span>, and then links for the <code class="literal">.</code> and <code class="literal">..</code>
                    entries were created ([Vahalia, 1996]). Although this feature is no longer
                    needed, some modern UNIX implementations retain it for backward
                    compatibility.</p><p>An effect similar to hard links on directories can be achieved using bind
                    mounts (<a class="xref" href="ch14.html#bind_mounts" title="Bind Mounts">Bind Mounts</a>).</p></div></div><div class="sect1" title="Symbolic (Soft) Links"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="symbolic_open_parenthesis_soft_close_par">Symbolic (Soft) Links</h2></div></div></div><p>A <span class="emphasis"><em>symbolic link</em></span>, also sometimes called a <span class="emphasis"><em>soft
                    link</em></span>, is a special file type whose data is the name of another file.
                    <a class="xref" href="ch18.html#representation_of_hard_and_symbolic_link" title="Figure 18-2. Representation of hard and symbolic links">Figure 18-2</a> illustrates the
                situation where two hard links, <code class="literal">/home/erena/this</code>
                and <code class="literal">/home/allyn/that</code>, refer to the same file, and
                a symbolic link, /<code class="literal">home/kiran/other</code>, refers to the
                name <code class="literal">/home/erena/this</code>.<a id="IDX-CHP-18-2399" class="indexterm"/><a id="IDX-CHP-18-2400" class="indexterm"/><a id="IDX-CHP-18-2401" class="indexterm"/><a id="IDX-CHP-18-2402" class="indexterm"/><a id="IDX-CHP-18-2403" class="indexterm"/><a id="IDX-CHP-18-2404" class="indexterm"/><a id="IDX-CHP-18-2405" class="indexterm"/><a id="IDX-CHP-18-2406" class="indexterm"/></p><p>From the shell, symbolic links are created using the <span class="emphasis"><em>ln -s</em></span>
                command. The <span class="emphasis"><em>ls -F</em></span> command displays a trailing <code class="literal">@</code> character at the end of symbolic links.</p><p>The pathname to which a symbolic link refers may be either absolute or relative. A
                relative symbolic link is interpreted relative to the location of the link
                itself.</p><p>Symbolic links don’t have the same status as hard links. In particular, a symbolic
                link is not included in the link count of the file to which it refers. (Thus, the
                link count of i-node 61 in <a class="xref" href="ch18.html#representation_of_hard_and_symbolic_link" title="Figure 18-2. Representation of hard and symbolic links">Figure 18-2</a> is 2, not 3.) Therefore, if the filename to which the symbolic link refers is
                removed, the symbolic link itself continues to exist, even though it can no longer
                be dereferenced (followed). We say that it has become a <span class="emphasis"><em>dangling
                    link</em></span>. It is even possible to create a symbolic link to a filename
                that doesn’t exist at the time the link is created.<a id="IDX-CHP-18-2407" class="indexterm"/><a id="IDX-CHP-18-2408" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Symbolic links were introduced by 4.2BSD. Although they were not included in
                    POSIX.1-1990, they were subsequently incorporated into SUSv1, and thus are in
                        SUSv3.<a id="IDX-CHP-18-2409" class="indexterm"/></p></div><div class="figure"><a id="representation_of_hard_and_symbolic_link"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject18_d1e44751"/><img src="figs/web/18-2_DIRS_LINKS-links.png.jpg" alt="Representation of hard and symbolic links"/></div></div><div class="figure-title">Figure 18-2. Representation of hard and symbolic links</div></div><p>Since a symbolic link refers to a filename, rather than an i-node number, it can
                be used to link to a file in a different file system. Symbolic links also do not
                suffer the other limitation of hard links: we can create symbolic links to
                directories. Tools such as <span class="emphasis"><em>find</em></span> and <span class="emphasis"><em>tar</em></span>
                can tell the difference between hard and symbolic links, and either don’t follow
                symbolic links by default, or avoid getting trapped in circular references created
                using symbolic links.</p><p>It is possible to chain symbolic links (e.g., <code class="literal">a</code>
                is a symbolic link to <code class="literal">b</code>, which is a symbolic link
                to <code class="literal">c</code>). When a symbolic link is specified in
                various file-related system calls, the kernel dereferences the series of links to
                arrive at the final file.</p><p>SUSv3 requires that an implementation allow at least <code class="literal">_POSIX_SYMLOOP_MAX</code> dereferences of each symbolic link component of a
                pathname. The specified value for <code class="literal">_POSIX_SYMLOOP_MAX</code> is 8. However, before kernel 2.6.18, Linux imposed
                a limit of 5 dereferences when following a chain of symbolic links. Starting with
                kernel 2.6.18, Linux implements the SUSv3-specified minimum of 8 dereferences. Linux
                also imposes a total of 40 dereferences for an entire pathname. These limits are
                required to prevent extremely long symbolic link chains, as well as symbolic link
                loops, from causing stack overflows in the kernel code that resolves symbolic
                links.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Some UNIX file systems perform an optimization not mentioned in the main text
                    nor shown in <a class="xref" href="ch18.html#representation_of_hard_and_symbolic_link" title="Figure 18-2. Representation of hard and symbolic links">Figure 18-2</a>. When
                    the total length of the string forming the symbolic link’s contents is small
                    enough to fit in the part of the i-node that would normally be used for data
                    pointers, the link string is instead stored there. This saves allocating a disk
                    block and also speeds access to the symbolic link information, since it is
                    retrieved along with the file i-node. For example, <span class="emphasis"><em>ext2</em></span>,
                        <span class="emphasis"><em>ext3</em></span>, and <span class="emphasis"><em>ext4</em></span> employ this
                    technique to fit short symbolic strings into the 60 bytes normally used for data
                    block pointers. In practice, this can be a very effective optimization. Of the
                    20,700 symbolic links on one system checked by the author, 97% were 60 bytes or
                    smaller.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="interpretation_of_symbolic_links_by"/></div></div></div><div class="sect3" title="Interpretation of symbolic links by system calls"><div class="titlepage"><div><div><h4 class="title" id="interpretation_of_symbolic_links_by-id1">Interpretation of symbolic links by system calls</h4></div></div></div><p>Many system calls dereference (follow) symbolic links and thus work on the
                        file to which the link refers. Some system calls don’t dereference symbolic
                        links, but instead operate directly on the link file itself. As each system
                        call is covered, we describe its behavior with respect to symbolic links.
                        This behavior is also summarized in <a class="xref" href="ch18.html#interpretation_of_symbolic_links_by_vari" title="Table 18-1. Interpretation of symbolic links by various functions">Table 18-1</a>.<a id="IDX-CHP-18-2410" class="indexterm"/><a id="IDX-CHP-18-2411" class="indexterm"/><a id="IDX-CHP-18-2412" class="indexterm"/></p><p>In a few cases where it is necessary to have similar functionality for
                        both the file to which a symbolic link refers and for the symbolic link
                        itself, alternative system calls are provided: one that dereferences the
                        link and another that does not, with the latter prefixed by the letter
                            <span class="emphasis"><em>l</em></span>; for example, <span class="emphasis"><em>stat()</em></span> and
                            <span class="emphasis"><em>lstat()</em></span>.</p><p>One point generally applies: symbolic links in the directory part of a
                        pathname (i.e., all of the components preceding the final slash) are always
                        dereferenced. Thus, in the pathname <code class="literal">/somedir/somesubdir/file</code>, <code class="literal">somedir</code> and <code class="literal">somesubdir</code>
                        will always be dereferenced if they are symbolic links, and <code class="literal">file</code> may be dereferenced, depending on the
                        system call to which the pathname is passed.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In <a class="xref" href="ch18.html#operating_relative_to_a_directory_file_d" title="Operating Relative to a Directory File Descriptor">Operating Relative to a Directory File Descriptor</a>, we
                            describe a set of system calls, added in Linux 2.6.16, that extend the
                            functionality of some of the interfaces shown in <a class="xref" href="ch18.html#interpretation_of_symbolic_links_by_vari" title="Table 18-1. Interpretation of symbolic links by various functions">Table 18-1</a>. For some of
                            these system calls, the behavior with respect to following symbolic
                            links can be controlled by the <span class="emphasis"><em>flags</em></span> argument to
                            the call.</p></div></div><div class="sect3" title="File permissions and ownership for symbolic links"><div class="titlepage"><div><div><h4 class="title" id="file_permissions_and_ownership_for_symbo">File permissions and ownership for symbolic links</h4></div></div></div><p>The ownership and permissions of a symbolic link are ignored for most
                        operations (symbolic links are always created with all permissions enabled).
                        Instead, the ownership and permissions of the file to which the link refers
                        are used in determining whether an operation is permitted. The ownership of
                        a symbolic link is relevant only when the link itself is being removed or
                        renamed in a directory with the sticky permission bit set (<a class="xref" href="ch15.html#set-user-id_comma_set-group-id_comma_and" title="Set-User-ID, Set-Group-ID, and Sticky Bits">Set-User-ID, Set-Group-ID, and Sticky Bits</a>).<a id="IDX-CHP-18-2413" class="indexterm"/></p></div></div></div><div class="sect1" title="Creating and Removing (Hard) Links: link() and unlink()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="creating_and_removing_open_parenthesis_h">Creating and Removing (Hard) Links: <span class="emphasis"><em>link</em></span>() and
                    <span class="emphasis"><em>unlink</em></span>()</h2></div></div></div><p>The <span class="emphasis"><em>link()</em></span> and <span class="emphasis"><em>unlink()</em></span> system calls
                create and remove hard links.<a id="IDX-CHP-18-2414" class="indexterm"/><a id="IDX-CHP-18-2415" class="indexterm"/><a id="IDX-CHP-18-2416" class="indexterm"/><a id="IDX-CHP-18-2417" class="indexterm"/><a id="IDX-CHP-18-2418" class="indexterm"/><a id="IDX-CHP-18-2419" class="indexterm"/><a id="IDX-CHP-18-2420" class="indexterm"/><a id="IDX-CHP-18-2421" class="indexterm"/><a id="IDX-CHP-18-2422" class="indexterm"/><a id="IDX-CHP-18-2423" class="indexterm"/></p><a id="I_programlisting18_d1e44931"/><pre class="programlisting">#include &lt;unistd.h&gt;

int <strong class="userinput"><code>link</code></strong>(const char *<span class="emphasis"><em>oldpath</em></span>, const char *<span class="emphasis"><em>newpath</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><div class="table"><a id="interpretation_of_symbolic_links_by_vari"/><div class="table-title">Table 18-1. Interpretation of symbolic links by various functions</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Function</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Follows links?</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                <p>Notes</p>
                            </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>access()</em></span>
                                    <a id="IDX-CHP-18-2424" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>acct()</em></span>
                                    <a id="IDX-CHP-18-2425" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>bind()</em></span>
                                    <a id="IDX-CHP-18-2426" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>UNIX domain sockets have pathnames</p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>chdir()</em></span>
                                    <a id="IDX-CHP-18-2427" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>chmod()</em></span>
                                    <a id="IDX-CHP-18-2428" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>chown()</em></span>
                                    <a id="IDX-CHP-18-2429" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>chroot()</em></span>
                                    <a id="IDX-CHP-18-2430" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>creat()</em></span>
                                    <a id="IDX-CHP-18-2431" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>exec()</em></span>
                                    <a id="IDX-CHP-18-2432" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>getxattr()</em></span>
                                    <a id="IDX-CHP-18-2433" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>lchown()</em></span>
                                    <a id="IDX-CHP-18-2434" class="indexterm"/>
                                </p>
                            </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>lgetxattr()</em></span>
                                    <a id="IDX-CHP-18-2435" class="indexterm"/>
                                </p>
                            </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>link()</em></span>
                                </p>
                            </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>See <a class="xref" href="ch18.html#creating_and_removing_open_parenthesis_h" title="Creating and Removing (Hard) Links: link() and unlink()">Creating and Removing (Hard) Links: <span class="emphasis"><em>link</em></span>() and
                    <span class="emphasis"><em>unlink</em></span>()</a></p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>listxattr()</em></span>
                                    <a id="IDX-CHP-18-2436" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>llistxattr()</em></span>
                                    <a id="IDX-CHP-18-2437" class="indexterm"/>
                                </p>
                            </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>lremovexattr()</em></span>
                                    <a id="IDX-CHP-18-2438" class="indexterm"/>
                                </p>
                            </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>lsetxattr()</em></span>
                                    <a id="IDX-CHP-18-2439" class="indexterm"/>
                                </p>
                            </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>lstat()</em></span>
                                    <a id="IDX-CHP-18-2440" class="indexterm"/>
                                </p>
                            </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>lutimes()</em></span>
                                    <a id="IDX-CHP-18-2441" class="indexterm"/>
                                </p>
                            </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>open()</em></span>
                                    <a id="IDX-CHP-18-2442" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>Unless O_NOFOLLOW or O_EXCL | O_CREAT specified</p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>opendir()</em></span>
                                    <a id="IDX-CHP-18-2443" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>pathconf()</em></span>
                                    <a id="IDX-CHP-18-2444" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>pivot_root()</em></span>
                                    <a id="IDX-CHP-18-2445" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>quotactl()</em></span>
                                    <a id="IDX-CHP-18-2446" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>readlink()</em></span>
                                    <a id="IDX-CHP-18-2447" class="indexterm"/>
                                </p>
                            </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>removexattr()</em></span>
                                    <a id="IDX-CHP-18-2448" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>rename()</em></span>
                                    <a id="IDX-CHP-18-2449" class="indexterm"/>
                                </p>
                            </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>Links are not followed in either argument</p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>rmdir()</em></span>
                                    <a id="IDX-CHP-18-2450" class="indexterm"/>
                                </p>
                            </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>Fails with ENOTDIR if argument is a symbolic link</p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>setxattr()</em></span>
                                    <a id="IDX-CHP-18-2451" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>stat()</em></span>
                                    <a id="IDX-CHP-18-2452" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>statfs(), statvfs()</em></span>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>swapon(), swapoff()</em></span>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>truncate()</em></span>
                                    <a id="IDX-CHP-18-2453" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>unlink()</em></span>
                                    <a id="IDX-CHP-18-2454" class="indexterm"/>
                                </p>
                            </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>uselib()</em></span>
                                    <a id="IDX-CHP-18-2455" class="indexterm"/>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>utime(), utimes()</em></span>
                                </p>
                            </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>•</p>
                            </td><td> </td></tr></tbody></table></div></div><p>Given the pathname of an existing file in <span class="emphasis"><em>oldpath</em></span>, the
                    <span class="emphasis"><em>link()</em></span> system call creates a new link, using the pathname
                specified in <span class="emphasis"><em>newpath</em></span>. If <span class="emphasis"><em>newpath</em></span> already
                exists, it is not overwritten; instead, an error (<code class="literal">EEXIST</code>) results.</p><p>On Linux, the <span class="emphasis"><em>link()</em></span> system call doesn’t dereference symbolic
                links. If <span class="emphasis"><em>oldpath</em></span> is a symbolic link, then
                    <span class="emphasis"><em>newpath</em></span> is created as a new hard link to the same symbolic
                link file. (In other words, <span class="emphasis"><em>newpath</em></span> is also a symbolic link to
                the same file to which <span class="emphasis"><em>oldpath</em></span> refers.) This behavior doesn’t
                conform to SUSv3, which says that all functions that perform pathname resolution
                should dereference symbolic links unless otherwise specified (and there is no
                exception specified for <span class="emphasis"><em>link()</em></span>). Most other UNIX
                implementations behave in the manner specified by SUSv3. One notable exception is
                Solaris, which provides the same behavior as Linux by default, but provides
                SUSv3-conformant behavior if appropriate compiler options are used. The upshot of
                this inconsistency across implementations is that portable applications should avoid
                specifying a symbolic link for the <span class="emphasis"><em>oldpath</em></span> argument.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv4 recognizes the inconsistency across existing implementations and
                    specifies that the choice of whether or not <span class="emphasis"><em>link()</em></span>
                    dereferences symbolic links is implementation-defined. SUSv4 also adds the
                    specification of <span class="emphasis"><em>linkat()</em></span>, which performs the same task as
                        <span class="emphasis"><em>link()</em></span>, but has a <span class="emphasis"><em>flags</em></span> argument
                    that can be used to control whether the call dereferences symbolic links. See
                        <a class="xref" href="ch18.html#operating_relative_to_a_directory_file_d" title="Operating Relative to a Directory File Descriptor">Operating Relative to a Directory File Descriptor</a> for further
                    details.</p></div><a id="I_programlisting18_d1e45464"/><pre class="programlisting">#include &lt;unistd.h&gt;

int <strong class="userinput"><code>unlink</code></strong>(const char *<span class="emphasis"><em>pathname</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>unlink()</em></span> system call removes a link (deletes a filename)
                and, if that is the last link to the file, also removes the file itself. If the link
                specified in <span class="emphasis"><em>pathname</em></span> doesn’t exist, then
                    <span class="emphasis"><em>unlink()</em></span> fails with the error <code class="literal">ENOENT</code>.<a id="IDX-CHP-18-2456" class="indexterm"/></p><p>We can’t use <span class="emphasis"><em>unlink()</em></span> to remove a directory; that task
                requires <span class="emphasis"><em>rmdir()</em></span> or <span class="emphasis"><em>remove()</em></span>, which we
                look at in Section 18.6.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 says that if <span class="emphasis"><em>pathname</em></span> specifies a directory, then
                        <span class="emphasis"><em>unlink()</em></span> should fail with the error <code class="literal">EPERM</code>. However, on Linux,
                        <span class="emphasis"><em>unlink()</em></span> fails with the error <code class="literal">EISDIR</code> in this case. (LSB explicitly permits this deviation from
                    SUSv3.) A portable application should be prepared to handle either value if
                    checking for this case.</p></div><p>The <span class="emphasis"><em>unlink()</em></span> system call doesn’t dereference symbolic links.
                If <span class="emphasis"><em>pathname</em></span> is a symbolic link, the link itself is removed,
                rather than the name to which it points.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="an_open_file_is_deleted_only_when_all"/></div></div></div><div class="sect3" title="An open file is deleted only when all file descriptors are closed"><div class="titlepage"><div><div><h4 class="title" id="an_open_file_is_deleted_only_when_all-id1">An open file is deleted only when all file descriptors are closed</h4></div></div></div><p>In addition to maintaining a link count for each i-node, the kernel also
                        counts open file descriptions for the file (see <a class="xref" href="ch05.html#relationship_between_file_descriptors_co" title="Figure 5-2. Relationship between file descriptors, open file descriptions, and i-nodes">Figure 5-2</a>, in <a class="xref" href="ch05.html#duplicating_file_descriptors" title="Duplicating File Descriptors">Duplicating File Descriptors</a>). If the last link to a file is
                        removed and any processes hold open descriptors referring to the file, the
                        file won’t actually be deleted until all of the descriptors are closed. This
                        is a useful feature, because it permits us to unlink a file without needing
                        to worry about whether some other process has it open. (However, we can’t
                        reattach a name to an open file whose link count has fallen to 0.) In
                        addition, we can perform tricks such as creating and opening a temporary
                        file, unlinking it immediately, and then continuing to use it within our
                        program, relying on the fact that the file is destroyed only when we close
                        the file descriptor—either explicitly, or implicitly when the program exits.
                        (This is what the <span class="emphasis"><em>tmpfile()</em></span> function described in <a class="xref" href="ch05.html#creating_temporary_files" title="Creating Temporary Files">Creating Temporary Files</a> does.)<a id="IDX-CHP-18-2457" class="indexterm"/><a id="IDX-CHP-18-2458" class="indexterm"/><a id="IDX-CHP-18-2459" class="indexterm"/><a id="IDX-CHP-18-2460" class="indexterm"/><a id="IDX-CHP-18-2461" class="indexterm"/><a id="IDX-CHP-18-2462" class="indexterm"/><a id="IDX-CHP-18-2463" class="indexterm"/><a id="IDX-CHP-18-2464" class="indexterm"/><a id="IDX-CHP-18-2465" class="indexterm"/></p><p>The program in <a class="xref" href="ch18.html#removing_a_link_with_unlink_open_parenth" title="Example 18-1. Removing a link with unlink()">Example 18-1</a>
                        demonstrates that even when the last link to a file is removed, the file is
                        deleted only when all open file descriptors that refer to it are
                        closed.</p><div class="example"><a id="removing_a_link_with_unlink_open_parenth"/><div class="example-title">Example 18-1. Removing a link with <span class="emphasis"><em>unlink()</em></span></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>dirs_links/t_unlink.c</code></strong>
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include "tlpi_hdr.h"

#define CMD_SIZE 200
#define BUF_SIZE 1024

int
main(int argc, char *argv[])
{
    int fd, j, numBlocks;
    char shellCmd[CMD_SIZE];            /* Command to be passed to system() */
    char buf[BUF_SIZE];                 /* Random bytes to write to file */

    if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)
        usageErr("%s temp-file [num-1kB-blocks] \n", argv[0]);

    numBlocks = (argc &gt; 2) ? getInt(argv[2], GN_GT_0, "num-1kB-blocks")
                           : 100000;

    fd = open(argv[1], O_WRONLY | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);
    if (fd == -1)
        errExit("open");

    if (unlink(argv[1]) == -1)          /* Remove filename */
        errExit("unlink");

    for (j = 0; j &lt; numBlocks; j++)     /* Write lots of junk to file */
        if (write(fd, buf, BUF_SIZE) != BUF_SIZE)
            fatal("partial/failed write");

    snprintf(shellCmd, CMD_SIZE, "df -k `dirname %s`", argv[1]);
    system(shellCmd);                   /* View space used in file system */

    if (close(fd) == -1)                /* File is now destroyed */
        errExit("close");
    printf("********** Closed file descriptor\n");

    system(shellCmd);                   /* Review space used in file system */
    exit(EXIT_SUCCESS);
}
     <strong class="userinput"><code>dirs_links/t_unlink.c</code></strong></pre></div></div><p>The program in <a class="xref" href="ch18.html#removing_a_link_with_unlink_open_parenth" title="Example 18-1. Removing a link with unlink()">Example 18-1</a>
                        accepts two command-line arguments. The first argument identifies the name
                        of a file that the program should create. The program opens this file and
                        then immediately unlinks the filename. Although the filename disappears, the
                        file itself continues to exist. The program then writes random blocks of
                        data to the file. The number of these blocks is specified in the optional
                        second command-line argument of the program. At this point, the program
                        employs the <span class="emphasis"><em>df(1)</em></span> command to display the amount of
                        space used on the file system. The program then closes the file descriptor,
                        at which the point the file is removed, and uses <span class="emphasis"><em>df(1)</em></span>
                        once more to show that the amount of disk space in use has decreased. The
                        following shell session demonstrates the use of the program in <a class="xref" href="ch18.html#removing_a_link_with_unlink_open_parenth" title="Example 18-1. Removing a link with unlink()">Example 18-1</a>:</p><a id="I_programlisting18_d1e45622"/><pre class="programlisting"><strong class="userinput"><code>$ ./t_unlink /tmp/tfile 1000000</code></strong>
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda10             5245020   3204044   2040976  62% /
********** Closed file descriptor
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda10             5245020   2201128   3043892  42% /</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>In <a class="xref" href="ch18.html#removing_a_link_with_unlink_open_parenth" title="Example 18-1. Removing a link with unlink()">Example 18-1</a>, we use
                            the <span class="emphasis"><em>system()</em></span> function to execute a shell command.
                            We describe <span class="emphasis"><em>system()</em></span> in detail in Section
                            27.6.</p></div></div></div></div><div class="sect1" title="Changing the Name of a File: rename()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="changing_the_name_of_a_file_colon_rename">Changing the Name of a File: <span class="emphasis"><em>rename()</em></span></h2></div></div></div><p>The <span class="emphasis"><em>rename()</em></span> system call can be used both to rename a file
                and to move it into another directory on the same file system.<a id="IDX-CHP-18-2467" class="indexterm"/><a id="IDX-CHP-18-2468" class="indexterm"/><a id="IDX-CHP-18-2466" class="indexterm"/></p><a id="I_programlisting18_d1e45663"/><pre class="programlisting">#include &lt;stdio.h&gt;

int <strong class="userinput"><code>rename</code></strong>(const char *<span class="emphasis"><em>oldpath</em></span>, const char *<span class="emphasis"><em>newpath</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>oldpath</em></span> argument is an existing pathname, which is
                renamed to the pathname given in <span class="emphasis"><em>newpath</em></span>.</p><p>The <span class="emphasis"><em>rename()</em></span> call just manipulates directory entries; it
                doesn’t move file data. Renaming a file doesn’t affect other hard links to the file,
                nor does it affect any processes that hold open descriptors for the file, since
                these descriptors refer to open file descriptions, which (after the
                    <span class="emphasis"><em>open()</em></span> call) have no connection with filenames.</p><p>The following rules apply to the use of <span class="emphasis"><em>rename()</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If <span class="emphasis"><em>newpath</em></span> already exists, it is overwritten.</p></li><li class="listitem"><p>If <span class="emphasis"><em>newpath</em></span> and <span class="emphasis"><em>oldpath</em></span> refer to
                        the same file, then no changes are made (and the call succeeds). This is
                        rather counterintuitive. Following from the previous point, we normally
                        expect that if two filenames <code class="literal">x</code> and
                            <code class="literal">y</code> exist, then the call
                            <span class="emphasis"><em>rename</em></span> (“x”, “y”) would remove the name <code class="literal">x</code>. This is not the case if <code class="literal">x</code> and <code class="literal">y</code> are
                        links to the same file.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>The rationale for this rule, which comes from the original BSD implementation,
                    was probably to simplify the checks that the kernel must perform in order to
                    guarantee that calls such as <span class="emphasis"><em>rename(“x”, “x”)</em></span>,
                        <span class="emphasis"><em>rename(“x”, “./x”)</em></span>, and <span class="emphasis"><em>rename(“x”,
                        “somedir/../x”)</em></span> don’t remove the file.</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>rename()</em></span> system call doesn’t dereference symbolic
                        links in either of its arguments. If <span class="emphasis"><em>oldpath</em></span> is a
                        symbolic link, then the symbolic link is renamed. If
                            <span class="emphasis"><em>newpath</em></span> is a symbolic link, then it is treated as a
                        normal pathname to which <span class="emphasis"><em>oldpath</em></span> is to be renamed
                        (i.e., the existing <span class="emphasis"><em>newpath</em></span> symbolic link is
                        removed).</p></li><li class="listitem"><p>If <span class="emphasis"><em>oldpath</em></span> refers to a file other than a directory,
                        then <span class="emphasis"><em>newpath</em></span> can’t specify the pathname of a directory
                        (the error is <code class="literal">EISDIR</code>). To rename a file
                        to a location inside a directory (i.e., move the file to another directory),
                            <span class="emphasis"><em>newpath</em></span> must include the new filename. The
                        following call both moves a file into a different directory and changes its
                        name:</p><a id="I_programlisting18_d1e45779"/><pre class="programlisting">rename("sub1/x", "sub2/y");</pre></li><li class="listitem"><p>Specifying the name of a directory in <span class="emphasis"><em>oldpath</em></span> allows
                        us to rename that directory. In this case, <span class="emphasis"><em>newpath</em></span>
                        either must not exist or must be the name of an empty directory. If
                            <span class="emphasis"><em>newpath</em></span> is an existing file or an existing,
                        nonempty directory, then an error results (respectively, <code class="literal">ENOTDIR</code> and <code class="literal">ENOTEMPTY</code>).</p></li><li class="listitem"><p>If <span class="emphasis"><em>oldpath</em></span> is a directory, then
                            <span class="emphasis"><em>newpath</em></span> can’t contain a directory prefix that is
                        the same as <span class="emphasis"><em>oldpath</em></span>. For example, we could not rename
                            <code class="literal">/home/mtk</code> to <code class="literal">/home/mtk/bin</code> (the error is <code class="literal">EINVAL</code>).</p></li><li class="listitem"><p>The files referred to by <span class="emphasis"><em>oldpath</em></span> and
                            <span class="emphasis"><em>newpath</em></span> must be on the same file system. This is
                        required because a directory is a list of hard links that refer to i-nodes
                        in the same file system as the directory. As stated earlier,
                            <span class="emphasis"><em>rename()</em></span> is merely manipulating the contents of
                        directory lists. Attempting to rename a file into a different file system
                        fails with the error <code class="literal">EXDEV</code>. (To achieve
                        the desired result, we must instead copy the contents of the file from one
                        file system to another and then delete the old file. This is what the
                            <span class="emphasis"><em>mv</em></span> command does in this case.)</p></li></ul></div></div><div class="sect1" title="Working with Symbolic Links: symlink() and readlink()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="working_with_symbolic_links_colon_symlin">Working with Symbolic Links: <span class="emphasis"><em>symlink()</em></span> and
                    <span class="emphasis"><em>readlink()</em></span></h2></div></div></div><p>We now look at the system calls used to create symbolic links and examine their
                    contents.<a id="IDX-CHP-18-2471" class="indexterm"/><a id="IDX-CHP-18-2472" class="indexterm"/><a id="IDX-CHP-18-2473" class="indexterm"/><a id="IDX-CHP-18-2474" class="indexterm"/><a id="IDX-CHP-18-2475" class="indexterm"/><a id="IDX-CHP-18-2476" class="indexterm"/><a id="IDX-CHP-18-2477" class="indexterm"/><a id="IDX-CHP-18-2478" class="indexterm"/><a id="IDX-CHP-18-2479" class="indexterm"/><a id="IDX-CHP-18-2480" class="indexterm"/><a id="IDX-CHP-18-2469" class="indexterm"/><a id="IDX-CHP-18-2470" class="indexterm"/></p><p>The <span class="emphasis"><em>symlink()</em></span> system call creates a new symbolic link,
                    <span class="emphasis"><em>linkpath</em></span>, to the pathname specified in
                    <span class="emphasis"><em>filepath</em></span>. (To remove a symbolic link, we use
                    <span class="emphasis"><em>unlink()</em></span>.)</p><a id="I_programlisting18_d1e45924"/><pre class="programlisting">#include &lt;unistd.h&gt;

int <strong class="userinput"><code>symlink</code></strong>(const char *<span class="emphasis"><em>filepath</em></span>, const char *<span class="emphasis"><em>linkpath</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>If the pathname given in <span class="emphasis"><em>linkpath</em></span> already exists, then the
                call fails (with <span class="emphasis"><em>errno</em></span> set to <code class="literal">EEXIST</code>). The pathname specified in <span class="emphasis"><em>filepath</em></span> may
                be absolute or relative.</p><p>The file or directory named in <span class="emphasis"><em>filepath</em></span> doesn’t need to exist
                at the time of the call. Even if it exists at that time, there is nothing to prevent
                it from being removed later. In this case, <span class="emphasis"><em>linkpath</em></span> becomes a
                    <span class="emphasis"><em>dangling link</em></span>, and attempts to dereference it in other
                system calls yield an error (usually <code class="literal">ENOENT</code>).<a id="IDX-CHP-18-2481" class="indexterm"/><a id="IDX-CHP-18-2482" class="indexterm"/></p><p>If we specify a symbolic link as the <span class="emphasis"><em>pathname</em></span> argument to
                    <span class="emphasis"><em>open()</em></span>, it opens the file to which the link refers.
                Sometimes, we would rather retrieve the content of the link itself—that is, the
                pathname to which it refers. The <span class="emphasis"><em>readlink()</em></span> system call
                performs this task, placing a copy of the symbolic link string in the character
                array pointed to by <span class="emphasis"><em>buffer</em></span>.</p><a id="I_programlisting18_d1e45988"/><pre class="programlisting">#include &lt;unistd.h&gt;

ssize_t <strong class="userinput"><code>readlink</code></strong>(const char *<span class="emphasis"><em>pathname</em></span>, char *<span class="emphasis"><em>buffer</em></span>, size_t <span class="emphasis"><em>bufsiz</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns number of bytes placed in <span class="emphasis"><em>buffer</em></span> on success, or
                    -1 on error</p></div><p>The <span class="emphasis"><em>bufsiz</em></span> argument is an integer used to tell
                    <span class="emphasis"><em>readlink()</em></span> the number of bytes available in
                    <span class="emphasis"><em>buffer</em></span>.</p><p>If no errors occur, then <span class="emphasis"><em>readlink()</em></span> returns the number of
                bytes actually placed in <span class="emphasis"><em>buffer</em></span>. If the length of the link
                exceeds <span class="emphasis"><em>bufsiz</em></span>, then a truncated string is placed in
                    <span class="emphasis"><em>buffer</em></span> (and <span class="emphasis"><em>readlink()</em></span> returns the
                size of that string—that is, <span class="emphasis"><em>bufsiz</em></span>).</p><p>Because a terminating null byte is not placed at the end of
                    <span class="emphasis"><em>buffer</em></span>, there is no way to distinguish the case where
                    <span class="emphasis"><em>readlink()</em></span> returns a truncated string from that where it
                returns a string that exactly fills <span class="emphasis"><em>buffer</em></span>. One way of checking
                if the latter has occurred is to reallocate a larger <span class="emphasis"><em>buffer</em></span>
                array and call <span class="emphasis"><em>readlink()</em></span> again. Alternatively, we can size
                    <span class="emphasis"><em>pathname</em></span> using the <code class="literal">PATH_MAX</code> constant (described in <a class="xref" href="ch11.html#system_limits" title="System Limits">System Limits</a>),
                which defines the length of the longest pathname that a program should have to
                    accommodate.<a id="IDX-CHP-18-2483" class="indexterm"/></p><p>We demonstrate the use of <span class="emphasis"><em>readlink()</em></span> in <a class="xref" href="ch18.html#read_and_resolve_a_symbolic_link" title="Example 18-4. Read and resolve a symbolic link">Example 18-4</a>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 defined a new limit, <code class="literal">SYMLINK_MAX</code>,
                    that an implementation should define to indicate the maximum number of bytes
                    that can be stored in a symbolic link. This limit is required to be at least 255
                    bytes. At the time of writing, Linux doesn’t define this limit. In the main
                    text, we suggest the use of <code class="literal">PATH_MAX</code> because
                    that limit should be at least as large as <code class="literal">SYMLINK_MAX</code>.</p><p>In SUSv2, the return type of <span class="emphasis"><em>readlink()</em></span> was specified as
                        <span class="emphasis"><em>int</em></span>, and many current implementations (as well as older
                        <span class="emphasis"><em>glibc</em></span> versions on Linux) follow that specification.
                    SUSv3 changed the return type to <span class="emphasis"><em>ssize_t</em></span>.</p></div></div><div class="sect1" title="Creating and Removing Directories: mkdir() and rmdir()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="creating_and_removing_directories_colon">Creating and Removing Directories: <span class="emphasis"><em>mkdir()</em></span> and
                    <span class="emphasis"><em>rmdir()</em></span></h2></div></div></div><p>The <span class="emphasis"><em>mkdir()</em></span> system call creates a new directory.<a id="IDX-CHP-18-2485" class="indexterm"/><a id="IDX-CHP-18-2486" class="indexterm"/><a id="IDX-CHP-18-2487" class="indexterm"/><a id="IDX-CHP-18-2488" class="indexterm"/><a id="IDX-CHP-18-2489" class="indexterm"/><a id="IDX-CHP-18-2490" class="indexterm"/><a id="IDX-CHP-18-2491" class="indexterm"/><a id="IDX-CHP-18-2492" class="indexterm"/><a id="IDX-CHP-18-2484" class="indexterm"/></p><a id="I_programlisting18_d1e46167"/><pre class="programlisting">#include &lt;sys/stat.h&gt;

int <strong class="userinput"><code>mkdir</code></strong>(const char *<span class="emphasis"><em>pathname</em></span>, mode_t <span class="emphasis"><em>mode</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>pathname</em></span> argument specifies the pathname of the new
                directory. This pathname may be relative or absolute. If a file with this pathname
                already exists, then the call fails with the error <code class="literal">EEXIST</code>.</p><p>The ownership of the new directory is set according to the rules described in
                    <a class="xref" href="ch15.html#ownership_of_new_files" title="Ownership of New Files">Ownership of New Files</a>.</p><p>The <span class="emphasis"><em>mode</em></span> argument specifies the permissions for the new
                directory. (We describe the meanings of the permission bits for directories in <a class="xref" href="ch15.html#ownership_of_new_files" title="Ownership of New Files">Ownership of New Files</a>, <a class="xref" href="ch15.html#changing_file_ownership_colon_chown_open" title="Changing File Ownership: chown(), fchown(), and lchown()">Changing File Ownership: <span class="emphasis"><em>chown()</em></span>,
                        <span class="emphasis"><em>fchown()</em></span>, and <span class="emphasis"><em>lchown()</em></span></a>, and <a class="xref" href="ch15.html#set-user-id_comma_set-group-id_comma_and" title="Set-User-ID, Set-Group-ID, and Sticky Bits">Set-User-ID, Set-Group-ID, and Sticky Bits</a>.) This bit-mask value may
                be specified by ORing (<code class="literal">|</code>) together constants from
                    <a class="xref" href="ch15.html#constants_for_file_permission_bits" title="Table 15-4. Constants for file permission bits">Table 15-4</a>, in <a class="xref" href="ch15.html#permissions_on_directories" title="Permissions on Directories">Permissions on Directories</a>, but, as with
                <span class="emphasis"><em>open()</em></span>, it may also be specified as an octal number. The value
                given in <span class="emphasis"><em>mode</em></span> is ANDed against the process umask (<a class="xref" href="ch15.html#the_process_file_mode_creation_mask_colo" title="The Process File Mode Creation Mask: umask()">The Process File Mode Creation Mask: <span class="emphasis"><em>umask()</em></span></a>). In addition, the
                set-user-ID bit (<code class="literal">S_ISUID</code>) is always turned off,
                since it has no meaning for directories.<a id="IDX-CHP-18-2493" class="indexterm"/></p><p>If the sticky bit (<code class="literal">S_ISVTX</code>) is set in
                    <span class="emphasis"><em>mode</em></span>, then it will be set on the new directory.</p><p>The setting of the set-group-ID bit (<code class="literal">S_ISGID</code>)
                in <span class="emphasis"><em>mode</em></span> is ignored. Instead, if the set-group-ID bit is set on
                the parent directory, then it will also be set on the newly created directory. In
                    <a class="xref" href="ch15.html#ownership_of_new_files" title="Ownership of New Files">Ownership of New Files</a>, we noted that setting the set-group-ID
                permission bit on a directory causes new files created in the directory to take
                their group ID from the directory’s group ID, rather than the process’s effective
                group ID. The <span class="emphasis"><em>mkdir()</em></span> system call propagates the set-group-ID
                permission bit in the manner described here so that all subdirectories under a
                directory will share the same behavior.<a id="IDX-CHP-18-2494" class="indexterm"/></p><p>SUSv3 explicitly notes that the manner in which <span class="emphasis"><em>mkdir()</em></span>
                treats the set-user-ID, set-group-ID, and sticky bits is implementation-defined. On
                some UNIX implementations, these 3 bits are always turned off on a new
                directory.</p><p>The newly created directory contains two entries: <code class="literal">.</code> (dot), which is a link to the directory itself, and <code class="literal">..</code> (dot-dot), which is a link to the parent
                directory.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 doesn’t require directories to contain <code class="literal">.</code> and <code class="literal">..</code> entries. It requires
                    only that an implementation correctly interpret <code class="literal">.</code> and <code class="literal">..</code> when they appear in
                    pathnames. A portable application should not rely on the existence of these
                    entries in a directory.</p></div><p>The <span class="emphasis"><em>mkdir()</em></span> system call creates only the last component of
                    <span class="emphasis"><em>pathname</em></span>. In other words, the call
                    <span class="emphasis"><em>mkdir(“aaa/bbb/ccc”, mode)</em></span> will succeed only if the
                directories <code class="literal">aaa</code> and <code class="literal">aaa/bbb</code> already exist. (This corresponds to the default operation of
                the <span class="emphasis"><em>mkdir(1)</em></span> command, but <span class="emphasis"><em>mkdir(1)</em></span> also
                provides the <span class="emphasis"><em>-p</em></span> option to create all of the intervening
                directory names if they don’t exist.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The GNU C library provides the <span class="emphasis"><em>mkdtemp(template)</em></span>
                    function, which is the directory analog of the <span class="emphasis"><em>mkstemp()</em></span>
                    function. It creates a uniquely named directory with read, write, and execute
                    permissions enabled for the owner, and no permissions allowed for any other
                    users. Instead of returning a file descriptor as its result,
                        <span class="emphasis"><em>mkdtemp()</em></span> returns a pointer to a modified string
                    containing the actual directory name in <span class="emphasis"><em>template</em></span>. SUSv3
                    doesn’t specify this function, and it is not available on all UNIX
                    implementations; it is specified in SUSv4.<a id="IDX-CHP-18-2495" class="indexterm"/></p></div><p>The <span class="emphasis"><em>rmdir()</em></span> system call removes the directory specified in
                    <span class="emphasis"><em>pathname</em></span>, which may be an absolute or a relative
                    pathname.<a id="IDX-CHP-18-2496" class="indexterm"/></p><a id="I_programlisting18_d1e46340"/><pre class="programlisting">#include &lt;unistd.h&gt;

int <strong class="userinput"><code>rmdir</code></strong>(const char *<span class="emphasis"><em>pathname</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>In order for <span class="emphasis"><em>rmdir()</em></span> to succeed, the directory must be empty.
                If the final component of <span class="emphasis"><em>pathname</em></span> is a symbolic link, it is
                not dereferenced; instead, the error <code class="literal">ENOTDIR</code>
                results.</p></div><div class="sect1" title="Removing a File or Directory: remove()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="removing_a_file_or_directory_colon_remov">Removing a File or Directory: <span class="emphasis"><em>remove()</em></span></h2></div></div></div><p>The <span class="emphasis"><em>remove()</em></span> library function removes a file or an empty
                    directory.<a id="IDX-CHP-18-2497" class="indexterm"/></p><a id="I_programlisting18_d1e46376"/><pre class="programlisting">#include &lt;stdio.h&gt;

int <strong class="userinput"><code>remove</code></strong>(const char *<span class="emphasis"><em>pathname</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>If <span class="emphasis"><em>pathname</em></span> is a file, <span class="emphasis"><em>remove()</em></span> calls
                    <span class="emphasis"><em>unlink()</em></span>; if <span class="emphasis"><em>pathname</em></span> is a directory,
                    <span class="emphasis"><em>remove()</em></span> calls <span class="emphasis"><em>rmdir()</em></span>.</p><p>Like <span class="emphasis"><em>unlink()</em></span> and <span class="emphasis"><em>rmdir()</em></span>,
                    <span class="emphasis"><em>remove()</em></span> doesn’t dereference symbolic links. If
                    <span class="emphasis"><em>pathname</em></span> is a symbolic link, <span class="emphasis"><em>remove()</em></span>
                removes the link itself, rather than the file to which it refers.</p><p>If we want to remove a file in preparation for creating a new file with the same
                name, then using <span class="emphasis"><em>remove()</em></span> is simpler than code that checks
                whether a pathname refers to a file or directory and calls
                    <span class="emphasis"><em>unlink()</em></span> or <span class="emphasis"><em>rmdir()</em></span>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>remove()</em></span> function was invented for the standard C
                    library, which is implemented on both UNIX and non-UNIX systems. Most non-UNIX
                    systems don’t support hard links, so removing files with a function named
                        <span class="emphasis"><em>unlink()</em></span> would not make sense.<a id="IDX-CHP-18-2498" class="indexterm"/></p></div></div><div class="sect1" title="Reading Directories: opendir() and readdir()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="reading_directories_colon_opendir_open_p">Reading Directories: <span class="emphasis"><em>opendir()</em></span> and
                    <span class="emphasis"><em>readdir()</em></span></h2></div></div></div><p>The library functions described in this section can be used to open a directory
                and retrieve the names of the files it contains one by one.<a id="IDX-CHP-18-2500" class="indexterm"/><a id="IDX-CHP-18-2501" class="indexterm"/><a id="IDX-CHP-18-2502" class="indexterm"/><a id="IDX-CHP-18-2503" class="indexterm"/><a id="IDX-CHP-18-2504" class="indexterm"/><a id="IDX-CHP-18-2505" class="indexterm"/><a id="IDX-CHP-18-2506" class="indexterm"/><a id="IDX-CHP-18-2507" class="indexterm"/><a id="IDX-CHP-18-2508" class="indexterm"/><a id="IDX-CHP-18-2509" class="indexterm"/><a id="IDX-CHP-18-2510" class="indexterm"/><a id="IDX-CHP-18-2511" class="indexterm"/><a id="IDX-CHP-18-2512" class="indexterm"/><a id="IDX-CHP-18-2513" class="indexterm"/><a id="IDX-CHP-18-2514" class="indexterm"/><a id="IDX-CHP-18-2515" class="indexterm"/><a id="IDX-CHP-18-2499" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The library functions for reading directories are layered on top of the
                        <span class="emphasis"><em>getdents()</em></span> system call (which is not part of SUSv3),
                    but provide an interface that is easier to use. Linux also provides a
                        <span class="emphasis"><em>readdir(2)</em></span> system call (as opposed to the
                        <span class="emphasis"><em>readdir(3)</em></span> library function described here), which
                    performs a similar task to, but is made obsolete by,
                        <span class="emphasis"><em>getdents()</em></span>.<a id="IDX-CHP-18-2516" class="indexterm"/></p></div><p>The <span class="emphasis"><em>opendir()</em></span> function opens a directory and returns a handle
                that can be used to refer to the directory in later calls.</p><a id="I_programlisting18_d1e46583"/><pre class="programlisting">#include &lt;dirent.h&gt;

DIR *<strong class="userinput"><code>opendir</code></strong>(const char *<span class="emphasis"><em>dirpath</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns directory stream handle, or <code class="literal">NULL</code> on
                        error<a id="IDX-CHP-18-2517" class="indexterm"/></p></div><p>The <span class="emphasis"><em>opendir()</em></span> function opens the directory specified by
                    <span class="emphasis"><em>dirpath</em></span> and returns a pointer to a structure of type
                    <span class="emphasis"><em>DIR</em></span>. This structure is a so-called <span class="emphasis"><em>directory
                    stream</em></span>, which is a handle that the caller passes to the other
                functions described below. Upon return from <span class="emphasis"><em>opendir()</em></span>, the
                directory stream is positioned at the first entry in the directory list.</p><p>The <span class="emphasis"><em>fdopendir()</em></span> function is like
                    <span class="emphasis"><em>opendir()</em></span>, except that the directory for which a stream is
                to be created is specified via the open file descriptor
                    <span class="emphasis"><em>fd</em></span>.<a id="IDX-CHP-18-2518" class="indexterm"/></p><a id="I_programlisting18_d1e46632"/><pre class="programlisting">#include &lt;dirent.h&gt;

DIR *<strong class="userinput"><code>fdopendir</code></strong>(int fd);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns directory stream handle, or <code class="literal">NULL</code> on
                    error</p></div><p>The <span class="emphasis"><em>fdopendir()</em></span> function is provided so that applications can
                avoid the kinds of race conditions described in <a class="xref" href="ch18.html#operating_relative_to_a_directory_file_d" title="Operating Relative to a Directory File Descriptor">Operating Relative to a Directory File Descriptor</a>.</p><p>After a successful call to <span class="emphasis"><em>fdopendir()</em></span>, this file descriptor
                is under the control of the system, and the program should not access it in any way
                other than by using the functions described in the remainder of this section.</p><p>The <span class="emphasis"><em>fdopendir()</em></span> function is specified in SUSv4 (but not in
                SUSv3).</p><p>The <span class="emphasis"><em>readdir()</em></span> function reads successive entries from a
                directory stream.<a id="IDX-CHP-18-2519" class="indexterm"/></p><a id="I_programlisting18_d1e46670"/><pre class="programlisting">#include &lt;dirent.h&gt;

struct dirent *<strong class="userinput"><code>readdir</code></strong>(DIR *<span class="emphasis"><em>dirp</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer to a statically allocated structure describing next directory
                    entry, or <code class="literal">NULL</code> on end-of-directory or
                    error</p></div><p>Each call to <span class="emphasis"><em>readdir()</em></span> reads the next directory entry from
                the directory stream referred to by <span class="emphasis"><em>dirp</em></span> and returns a pointer
                to a statically allocated structure of type <span class="emphasis"><em>dirent</em></span>, containing
                the following information about the entry:</p><a id="I_programlisting18_d1e46695"/><pre class="programlisting">struct dirent {
    ino_t d_ino;          /* File i-node number */
    char  d_name[];       /* Null-terminated name of file */
};</pre><p>This structure is overwritten on each call to
                <span class="emphasis"><em>readdir()</em></span>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>We have omitted various nonstandard fields in the Linux
                        <span class="emphasis"><em>dirent</em></span> structure from the above definition, since their
                    use renders an application nonportable. The most interesting of these
                    nonstandard fields is <span class="emphasis"><em>d_type</em></span>, which is also present on BSD
                    derivatives, but not on other UNIX implementations. This field holds a value
                    indicating the type of the file named in <span class="emphasis"><em>d_name</em></span>, such as
                        <code class="literal">DT_REG</code> (regular file), <code class="literal">DT_DIR</code> (directory), <code class="literal">DT_LNK</code> (symbolic link), or <code class="literal">DT_FIFO</code> (FIFO). (These names are analogous to the macros in <a class="xref" href="ch15.html#macros_for_checking_file_types_in_the_st" title="Table 15-1. Macros for checking file types in the st_mode field of the stat structure">Table 15-1</a>, in <a class="xref" href="ch15.html#file_size_comma_blocks_allocated_comma_a" title="File size, blocks allocated, and optimal I/O block size">File size, blocks allocated, and optimal I/O block size</a>.) Using the information
                    in this field saves the cost of calling <span class="emphasis"><em>lstat()</em></span> in order to
                    discover the file type. Note, however, that, at the time of writing, this field
                    is fully supported only on <span class="emphasis"><em>Btrfs</em></span>,
                    <span class="emphasis"><em>ext2</em></span>, <span class="emphasis"><em>ext3</em></span>, and
                        <span class="emphasis"><em>ext4</em></span>.<a id="IDX-CHP-18-2520" class="indexterm"/></p></div><p>Further information about the file referred to by <span class="emphasis"><em>d_name</em></span> can
                be obtained by calling <span class="emphasis"><em>lstat()</em></span> (or <span class="emphasis"><em>stat()</em></span>,
                if a symbolic link should be dereferenced) on the pathname constructed using the
                    <span class="emphasis"><em>dirpath</em></span> argument that was specified to
                    <span class="emphasis"><em>opendir()</em></span> concatenated with (a slash and) the value
                returned in the <span class="emphasis"><em>d_name</em></span> field.</p><p>The filenames returned by <span class="emphasis"><em>readdir()</em></span> are not in sorted order,
                but rather in the order in which they happen to occur in the directory (this depends
                on the order in which the file system adds files to the directory and how it fills
                gaps in the directory list after files are removed). (The command <span class="emphasis"><em>ls
                    -f</em></span> lists files in the same unsorted order that they would be
                retrieved by <span class="emphasis"><em>readdir()</em></span>.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>We can use the function <span class="emphasis"><em>scandir(3)</em></span> to retrieve a sorted
                    list of files matching programmer-defined criteria; see the manual page for
                    details. Although not specified in SUSv3, <span class="emphasis"><em>scandir()</em></span> is
                    provided on most UNIX implementations. SUSv4 added a specification for
                        <span class="emphasis"><em>scandir()</em></span>.<a id="IDX-CHP-18-2521" class="indexterm"/></p></div><p>On end-of-directory or error, <span class="emphasis"><em>readdir()</em></span> returns <code class="literal">NULL</code>, in the latter case setting
                    <span class="emphasis"><em>errno</em></span> to indicate the error. To distinguish these two
                cases, we can write the following:</p><a id="I_programlisting18_d1e46812"/><pre class="programlisting">errno = 0;
direntp = readdir(dirp);
if (direntp == <strong class="userinput"><code>NULL</code></strong>) {
    if (errno != 0) {
        /* Handle error */
    } else {
        /* We reached end-of-directory */
    }
}</pre><p>If the contents of a directory change while a program is scanning it with
                    <span class="emphasis"><em>readdir()</em></span>, the program might not see the changes. SUSv3
                explicitly notes that it is unspecified whether <span class="emphasis"><em>readdir()</em></span> will
                return a filename that has been added to or removed from the directory since the
                last call to <span class="emphasis"><em>opendir()</em></span> or <span class="emphasis"><em>rewinddir()</em></span>. All
                filenames that have been neither added nor removed since the last such call are
                guaranteed to be returned.<a id="IDX-CHP-18-2522" class="indexterm"/></p><p>The <span class="emphasis"><em>rewinddir()</em></span> function moves the directory stream back to
                the beginning so that the next call to <span class="emphasis"><em>readdir()</em></span> will begin
                again with the first file in the directory.</p><a id="I_programlisting18_d1e46843"/><pre class="programlisting">#include &lt;dirent.h&gt;

void <strong class="userinput"><code>rewinddir</code></strong>(DIR *<span class="emphasis"><em>dirp</em></span>);</pre><p>The <span class="emphasis"><em>closedir()</em></span> function closes the open directory stream
                referred to by <span class="emphasis"><em>dirp</em></span>, freeing the resources used by the
                    stream.<a id="IDX-CHP-18-2523" class="indexterm"/></p><a id="I_programlisting18_d1e46863"/><pre class="programlisting">#include &lt;dirent.h&gt;

int <strong class="userinput"><code>closedir</code></strong>(DIR *<span class="emphasis"><em>dirp</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>Two further functions, <span class="emphasis"><em>telldir()</em></span> and
                    <span class="emphasis"><em>seekdir()</em></span>, which are also specified in SUSv3, allow random
                access within a directory stream. Refer to the manual pages for further information
                about these functions.<a id="IDX-CHP-18-2524" class="indexterm"/></p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="directory_streams_and_file_descri"/></div></div></div><div class="sect3" title="Directory streams and file descriptors"><div class="titlepage"><div><div><h4 class="title" id="directory_streams_and_file_descri-id1">Directory streams and file descriptors</h4></div></div></div><p>A directory stream has an associated file descriptor. The
                            <span class="emphasis"><em>dirfd()</em></span> function returns the file descriptor
                        associated with the directory stream referred to by
                            <span class="emphasis"><em>dirp</em></span>.<a id="IDX-CHP-18-2525" class="indexterm"/><a id="IDX-CHP-18-2526" class="indexterm"/><a id="IDX-CHP-18-2527" class="indexterm"/><a id="IDX-CHP-18-2528" class="indexterm"/><a id="IDX-CHP-18-2529" class="indexterm"/><a id="IDX-CHP-18-2530" class="indexterm"/></p><a id="I_programlisting18_d1e46932"/><pre class="programlisting">#define _BSD_SOURCE             /* Or: #define _SVID_SOURCE */
#include &lt;dirent.h&gt;

int <strong class="userinput"><code>dirfd</code></strong>(DIR *<span class="emphasis"><em>dirp</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns file descriptor on success, or -1 on error</p></div><p>We might, for example, pass the file descriptor returned by
                            <span class="emphasis"><em>dirfd()</em></span> to <span class="emphasis"><em>fchdir()</em></span> (<a class="xref" href="ch18.html#the_current_working_directory_of_a_proce" title="The Current Working Directory of a Process">The Current Working Directory of a Process</a>) in order to change
                        the current working directory of the process to the corresponding directory.
                        Alternatively, we might pass the file descriptor as the
                            <span class="emphasis"><em>dirfd</em></span> argument of one of the functions described in
                            <a class="xref" href="ch18.html#operating_relative_to_a_directory_file_d" title="Operating Relative to a Directory File Descriptor">Operating Relative to a Directory File Descriptor</a>.</p><p>The <span class="emphasis"><em>dirfd()</em></span> function also appears on the BSDs, but is
                        present on few other implementations. It is not specified in SUSv3, but is
                        specified in SUSv4.</p><p>At this point, it is worth mentioning that <span class="emphasis"><em>opendir()</em></span>
                        automatically sets the close-on-exec flag (<code class="literal">FD_CLOEXEC</code>) for the file descriptor associated with the
                        directory stream. This ensures that the file descriptor is automatically
                        closed when an <span class="emphasis"><em>exec()</em></span> is performed. (SUSv3 requires
                        this behavior.) We describe the close-on-exec flag in Section
                            27.4.<a id="IDX-CHP-18-2531" class="indexterm"/><a id="IDX-CHP-18-2532" class="indexterm"/></p></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id16">Example program</h4></div></div></div><p><a class="xref" href="ch18.html#scanning_a_directory" title="Example 18-2. Scanning a directory">Example 18-2</a> uses
                        <span class="emphasis"><em>opendir()</em></span>, <span class="emphasis"><em>readdir()</em></span>, and
                            <span class="emphasis"><em>closedir()</em></span> to list the contents of each of the
                        directories specified in its command line (or in the current working
                        directory if no arguments are supplied). Here is an example of the use of
                        this program:<a id="IDX-CHP-18-2533" class="indexterm"/><a id="IDX-CHP-18-2534" class="indexterm"/><a id="IDX-CHP-18-2535" class="indexterm"/><a id="IDX-CHP-18-2536" class="indexterm"/><a id="IDX-CHP-18-2537" class="indexterm"/></p><a id="I_programlisting18_d1e47030"/><pre class="programlisting"><strong class="userinput"><code>$ mkdir sub</code></strong>                             <em class="lineannotation"><span class="lineannotation">Create a test directory</span></em>
<strong class="userinput"><code>$ touch sub/a sub/b</code></strong>                     <em class="lineannotation"><span class="lineannotation">Make some files in the test directory</span></em>
<strong class="userinput"><code>$ ./list_files sub</code></strong>                      <em class="lineannotation"><span class="lineannotation">List contents of directory</span></em>
sub/a
sub/b</pre><div class="example"><a id="scanning_a_directory"/><div class="example-title">Example 18-2. Scanning a directory</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>dirs_links/list_files.c</code></strong>
#include &lt;dirent.h&gt;
#include "tlpi_hdr.h"

static void             /* List all files in directory 'dirPath' */
listFiles(const char *dirpath)
{
    DIR *dirp;
    struct dirent *dp;
    Boolean isCurrent;          /* True if 'dirpath' is "." */

    isCurrent = strcmp(dirpath, ".") == 0;

    dirp = opendir(dirpath);
    if (dirp  == NULL) {
        errMsg("opendir failed on '%s'", dirpath);
        return;
    }

    /* For each entry in this directory, print directory + filename */

    for (;;) {
        errno = 0;              /* To distinguish error from end-of-directory */
        dp = readdir(dirp);
        if (dp == NULL)
            break;

        if (strcmp(dp-&gt;d_name, ".") == 0 || strcmp(dp-&gt;d_name, "..") == 0)
            continue;           /* Skip . and .. */

        if (!isCurrent)
            printf("%s/", dirpath);
        printf("%s\n", dp-&gt;d_name);
    }

    if (errno != 0)
        errExit("readdir");

    if (closedir(dirp) == -1)
        errMsg("closedir");
}

int
main(int argc, char *argv[])
{
    if (argc &gt; 1 &amp;&amp; strcmp(argv[1], "--help") == 0)
        usageErr("%s [dir...]\n", argv[0]);

    if (argc == 1)              /* No arguments - use current directory */
        listFiles(".");
    else
        for (argv++; *argv; argv++)
            listFiles(*argv);

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>dirs_links/list_files.c</code></strong></pre></div></div></div><div class="sect3" title="The readdir_r() function"><div class="titlepage"><div><div><h4 class="title" id="the_readdir_underscore_r_open_parenthesi">The <span class="emphasis"><em>readdir_r()</em></span> function</h4></div></div></div><p>The <span class="emphasis"><em>readdir_r()</em></span> function is a variation on
                            <span class="emphasis"><em>readdir()</em></span>. The key semantic difference between
                            <span class="emphasis"><em>readdir_r()</em></span> and <span class="emphasis"><em>readdir()</em></span> is
                        that the former is reentrant, while the latter is not. This is because
                            <span class="emphasis"><em>readdir_r()</em></span> returns the file entry via the
                        caller-allocated <span class="emphasis"><em>entry</em></span> argument, while
                            <span class="emphasis"><em>readdir()</em></span> returns information via a pointer to a
                        statically allocated structure. We discuss reentrancy in <a class="xref" href="ch21.html#reentrant_and_async-signal-safe_function" title="Reentrant and Async-Signal-Safe Functions">Reentrant and Async-Signal-Safe Functions</a> and <a class="xref" href="ch31.html#thread_safety_open_parenthesis_and_reent" title="Thread Safety (and Reentrancy Revisited)">Thread Safety (and Reentrancy Revisited)</a>.<a id="IDX-CHP-18-2539" class="indexterm"/><a id="IDX-CHP-18-2540" class="indexterm"/><a id="IDX-CHP-18-2538" class="indexterm"/></p><a id="I_programlisting18_d1e47108"/><pre class="programlisting">#include &lt;dirent.h&gt;

int <strong class="userinput"><code>readdir_r</code></strong>(DIR *<span class="emphasis"><em>dirp</em></span>, struct dirent *<span class="emphasis"><em>entry</em></span>, struct dirent **<span class="emphasis"><em>result</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or a positive error number on error</p></div><p>Given <span class="emphasis"><em>dirp</em></span>, which is a directory stream previously
                        opened via <span class="emphasis"><em>opendir()</em></span>, <span class="emphasis"><em>readdir_r()</em></span>
                        places information about the next directory entry into the
                            <span class="emphasis"><em>dirent</em></span> structure referred to by
                            <span class="emphasis"><em>entry</em></span>. In addition, a pointer to this structure is
                        placed in <span class="emphasis"><em>result</em></span>. If the end of the directory stream is
                        reached, then <code class="literal">NULL</code> is placed in
                            <span class="emphasis"><em>result</em></span> instead (and
                            <span class="emphasis"><em>readdir_r()</em></span> returns 0). On error,
                            <span class="emphasis"><em>readdir_r()</em></span> doesn’t return -1, but instead returns
                        a positive integer corresponding to one of the <span class="emphasis"><em>errno</em></span>
                        values.</p><p>On Linux, the <span class="emphasis"><em>d_name</em></span> field of the
                            <span class="emphasis"><em>dirent</em></span> structure is sized as an array of 256 bytes,
                        which is long enough to hold the largest possible filename. Although several
                        other UNIX implementations define the same size for
                            <span class="emphasis"><em>d_name</em></span>, SUSv3 leaves this point unspecified, and
                        some UNIX implementations instead define the field as a 1-byte array,
                        leaving the calling program with the task of allocating a structure of the
                        correct size. When doing this, we should size the
                            <span class="emphasis"><em>d_name</em></span> field as one greater (for the terminating
                        null byte) than the value of the constant <code class="literal">NAME_MAX</code>. Portable applications should thus allocate the
                            <span class="emphasis"><em>dirent</em></span> structure as follows:</p><a id="I_programlisting18_d1e47182"/><pre class="programlisting">struct dirent *entryp;
size_t len;

len = offsetof(struct dirent, d_name) + <strong class="userinput"><code>NAME_MAX</code></strong> + 1;
entryp = malloc(len);
if (entryp == NULL)
    errExit("malloc");</pre><p>Using the <code class="literal">offsetof()</code> macro (defined in
                            <code class="literal">&lt;stddef.h&gt;</code>) avoids any
                        implementation-specific dependencies on the number and size of fields in the
                            <span class="emphasis"><em>dirent</em></span> structure preceding the
                            <span class="emphasis"><em>d_name</em></span> field (which is always the last field in the
                            structure).<a id="IDX-CHP-18-2541" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <code class="literal">offsetof()</code> macro takes two
                            arguments—a structure type and the name of a field within that
                            structure—and returns a value of type <span class="emphasis"><em>size_t</em></span> that
                            is the offset in bytes of the field from the beginning of the structure.
                            This macro is necessary because a compiler may insert padding bytes in a
                            structure to satisfy alignment requirements for types such as
                                <span class="emphasis"><em>int</em></span>, with the result that a field’s offset
                            within a structure may be greater than the sum of the sizes of the
                            fields that precede it.</p></div></div></div></div><div class="sect1" title="File Tree Walking: nftw()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="file_tree_walking_colon_nftw_open_parent">File Tree Walking: <span class="emphasis"><em>nftw()</em></span></h2></div></div></div><p>The <span class="emphasis"><em>nftw()</em></span> function allows a program to recursively walk
                through an entire directory subtree performing some operation (i.e., calling some
                programmer-defined function) for each file in the subtree.<a id="IDX-CHP-18-2543" class="indexterm"/><a id="IDX-CHP-18-2544" class="indexterm"/><a id="IDX-CHP-18-2545" class="indexterm"/><a id="IDX-CHP-18-2546" class="indexterm"/><a id="IDX-CHP-18-2547" class="indexterm"/><a id="IDX-CHP-18-2548" class="indexterm"/><a id="IDX-CHP-18-2549" class="indexterm"/><a id="IDX-CHP-18-2550" class="indexterm"/><a id="IDX-CHP-18-2551" class="indexterm"/><a id="IDX-CHP-18-2552" class="indexterm"/><a id="IDX-CHP-18-2553" class="indexterm"/><a id="IDX-CHP-18-2554" class="indexterm"/><a id="IDX-CHP-18-2542" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>nftw()</em></span> function is an enhancement of the older
                        <span class="emphasis"><em>ftw()</em></span> function, which performs a similar task. New
                    applications should use <span class="emphasis"><em>nftw()</em></span> (<span class="emphasis"><em>new
                        ftw</em></span>) because it provides more functionality, and predictable
                    handling of symbolic links (SUSv3 permits <span class="emphasis"><em>ftw()</em></span> either to
                    follow or not follow symbolic links). SUSv3 specifies both
                        <span class="emphasis"><em>nftw()</em></span> and <span class="emphasis"><em>ftw()</em></span>, but the latter
                    function is marked obsolete in SUSv4.<a id="IDX-CHP-18-2555" class="indexterm"/></p><p>The GNU C library also provides the BSD-derived <span class="emphasis"><em>fts</em></span> API
                        (<span class="emphasis"><em>fts_open()</em></span>, <span class="emphasis"><em>fts_read()</em></span>,
                        <span class="emphasis"><em>fts_children()</em></span>, <span class="emphasis"><em>fts_set()</em></span>, and
                        <span class="emphasis"><em>fts_close()</em></span>). These functions perform a similar task to
                        <span class="emphasis"><em>ftw()</em></span> and <span class="emphasis"><em>nftw()</em></span>, but offer
                    greater flexibility to an application walking the tree. However, this API is not
                    standardized and is provided on few UNIX implementations other than BSD
                    descendants, so we omit discussion of it here.<a id="IDX-CHP-18-2556" class="indexterm"/></p></div><p>The <span class="emphasis"><em>nftw()</em></span> function walks through the directory tree
                specified by <span class="emphasis"><em>dirpath</em></span> and calls the programmer-defined function
                    <span class="emphasis"><em>func</em></span> once for each file in the directory tree.</p><a id="I_programlisting18_d1e47363"/><pre class="programlisting">#define _XOPEN_SOURCE 500
#include &lt;ftw.h&gt;

int <strong class="userinput"><code>nftw</code></strong>(const char *<span class="emphasis"><em>dirpath</em></span>,
         int (*<span class="emphasis"><em>func</em></span>) (const char *<span class="emphasis"><em>pathname</em></span>, const struct stat *<span class="emphasis"><em>statbuf</em></span>,
                      int <span class="emphasis"><em>typeflag</em></span>, struct FTW *<span class="emphasis"><em>ftwbuf</em></span>),
         int <span class="emphasis"><em>nopenfd</em></span>, int <span class="emphasis"><em>flags</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 after successful walk of entire tree, or -1 on error, or the first
                    nonzero value returned by a call to <span class="emphasis"><em>func</em></span></p></div><p>By default, <span class="emphasis"><em>nftw()</em></span> performs an unsorted, preorder traversal
                of the given tree, processing each directory before processing the files and
                subdirectories within that directory.</p><p>While traversing the directory tree, <span class="emphasis"><em>nftw()</em></span> opens at most one
                file descriptor for each level of the tree. The <span class="emphasis"><em>nopenfd</em></span>
                argument specifies the maximum number of file descriptors that
                    <span class="emphasis"><em>nftw()</em></span> may use. If the depth of the directory tree exceeds
                this maximum, <span class="emphasis"><em>nftw()</em></span> does some bookkeeping, and closes and
                reopens descriptors in order to avoid holding open more than
                    <span class="emphasis"><em>nopenfd</em></span> descriptors simultaneously (and consequently runs
                more slowly). The need for this argument was greater under older UNIX
                implementations, some of which had a limit of 20 open file descriptors per process.
                Modern UNIX implementations allow a process to open a large number of file
                descriptors, and thus we can specify a generous number here (say 10 or more).</p><p>The <span class="emphasis"><em>flags</em></span> argument to <span class="emphasis"><em>nftw()</em></span> is created
                by ORing (<code class="literal">|</code>) zero or more of the following
                constants, which modify the operation of the function:</p><div class="variablelist"><dl><dt><span class="term">
                        <code class="literal">FTW_CHDIR</code>
                    </span></dt><dd><p>Do a <span class="emphasis"><em>chdir()</em></span> into each directory before
                            processing its contents. This is useful if <span class="emphasis"><em>func</em></span> is
                            designed to do some work in the directory in which the file specified by
                            its <span class="emphasis"><em>pathname</em></span> argument resides.</p></dd><dt><span class="term">
                        <code class="literal">FTW_DEPTH</code>
                    </span></dt><dd><p>Do a postorder traversal of the directory tree. This means that
                                <span class="emphasis"><em>nftw()</em></span> calls <span class="emphasis"><em>func</em></span> on all
                            of the files (and subdirectories) within a directory before executing
                                <span class="emphasis"><em>func</em></span> on the directory itself. (The name of this
                            flag is somewhat misleading—<span class="emphasis"><em>nftw()</em></span> always does a
                            depth-first, rather than a breadth-first, traversal of the directory
                            tree. All that this flag does is convert the traversal from preorder to
                            postorder.)</p></dd><dt><span class="term">
                        <code class="literal">FTW_MOUNT</code>
                    </span></dt><dd><p>Don’t cross over into another file system. Thus, if one of the
                            subdirectories of the tree is a mount point, it is not traversed.</p></dd><dt><span class="term">
                        <code class="literal">FTW_PHYS</code>
                    </span></dt><dd><p>By default, <span class="emphasis"><em>nftw()</em></span> dereferences symbolic links.
                            This flag tells it not to do so. Instead, a symbolic link is passed to
                                <span class="emphasis"><em>func</em></span> with a <span class="emphasis"><em>typeflag</em></span> value
                            of <code class="literal">FTW_SL</code>, as described below.</p></dd></dl></div><p>For each file, <span class="emphasis"><em>nftw()</em></span> passes four arguments when calling
                    <span class="emphasis"><em>func</em></span>. The first of these arguments,
                    <span class="emphasis"><em>pathname</em></span>, is the pathname of the file. This pathname may be
                absolute, if <span class="emphasis"><em>dirpath</em></span> was specified as an absolute pathname, or
                relative to the current working directory of the calling process at the time of the
                call to <span class="emphasis"><em>ntfw()</em></span>, if <span class="emphasis"><em>dirpath</em></span> was expressed
                as a relative pathname. The second argument, <span class="emphasis"><em>statbuf</em></span>, is a
                pointer to a <span class="emphasis"><em>stat</em></span> structure (<a class="xref" href="ch15.html#retrieving_file_information_colon_stat_o" title="Retrieving File Information: stat()">Retrieving File Information: <span class="emphasis"><em>stat()</em></span></a>) containing information
                about this file. The third argument, <span class="emphasis"><em>typeflag</em></span>, provides further
                information about the file, and has one of the following symbolic values:</p><div class="variablelist"><dl><dt><span class="term">
                        <code class="literal">FTW_D</code>
                    </span></dt><dd><p>This is a directory.</p></dd><dt><span class="term">
                        <code class="literal">FTW_DNR</code>
                    </span></dt><dd><p>This is a directory that can’t be read (and so
                                <span class="emphasis"><em>nftw()</em></span> doesn’t traverse any of its
                            descendants).</p></dd><dt><span class="term">
                        <code class="literal">FTW_DP</code>
                    </span></dt><dd><p>We are doing a postorder traversal (<code class="literal">FTW_DEPTH</code>) of a directory, and the current item is a
                            directory whose files and subdirectories have already been
                            processed.</p></dd><dt><span class="term">
                        <code class="literal">FTW_F</code>
                    </span></dt><dd><p>This is a file of any type other than a directory or symbolic
                            link.</p></dd><dt><span class="term">
                        <code class="literal">FTW_NS</code>
                    </span></dt><dd><p>Calling <span class="emphasis"><em>stat()</em></span> on this file failed, probably
                            because of permission restrictions. The value in
                                <span class="emphasis"><em>statbuf</em></span> is undefined.</p></dd><dt><span class="term">
                        <code class="literal">FTW_SL</code>
                    </span></dt><dd><p>This is a symbolic link. This value is returned only if
                                <span class="emphasis"><em>nftw()</em></span> is called with the <code class="literal">FTW_PHYS</code> flag.</p></dd><dt><span class="term">
                        <code class="literal">FTW_SLN</code>
                    </span></dt><dd><p>This item is a dangling symbolic link. This value occurs only if
                                <code class="literal">FTW_PHYS</code> was not specified in the
                                <span class="emphasis"><em>flags</em></span> argument.<a id="IDX-CHP-18-2557" class="indexterm"/></p></dd></dl></div><p>The fourth argument to <span class="emphasis"><em>func</em></span>, <span class="emphasis"><em>ftwbuf</em></span>, is
                a pointer to a structure defined as follows:</p><a id="I_programlisting18_d1e47613"/><pre class="programlisting">struct FTW {
    int base;       /* Offset to basename part of pathname */
    int level;      /* Depth of file within tree traversal */
};</pre><p>The <span class="emphasis"><em>base</em></span> field of this structure is the integer offset of the
                filename part (the component after the last <code class="literal">/</code>) of
                the <span class="emphasis"><em>pathname</em></span> argument of <span class="emphasis"><em>func</em></span>. The
                    <span class="emphasis"><em>level</em></span> field is the depth of this item relative to the
                starting point of the traversal (which is level 0).</p><p>Each time it is called, <span class="emphasis"><em>func</em></span> must return an integer value,
                and this value is interpreted by <span class="emphasis"><em>nftw()</em></span>. Returning 0 tells
                    <span class="emphasis"><em>nftw()</em></span> to continue the tree walk, and if all calls to
                    <span class="emphasis"><em>func</em></span> return 0, <span class="emphasis"><em>nftw()</em></span> itself returns 0
                to its caller. Returning a nonzero value tells <span class="emphasis"><em>nftw()</em></span> to
                immediately stop the tree walk, in which case <span class="emphasis"><em>nftw()</em></span> returns
                the same nonzero value as its return value.</p><p>Because <span class="emphasis"><em>nftw()</em></span> uses dynamically allocated data structures,
                the only way that a program should ever prematurely terminate a directory tree walk
                is by returning a nonzero value from <span class="emphasis"><em>func</em></span>. Using
                    <span class="emphasis"><em>longjmp()</em></span> (<a class="xref" href="ch06.html#performing_a_nonlocal_goto_colon_setjmp" title="Performing a Nonlocal Goto: setjmp() and long jmp()">Performing a Nonlocal Goto: <span class="emphasis"><em>setjmp()</em></span> and <span class="emphasis"><em>long
                    jmp()</em></span></a>) to exit from
                    <span class="emphasis"><em>func</em></span> may lead to unpredictable results—at the very least,
                memory leaks in a program.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="example_program-id17"/></div></div></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id18">Example program</h4></div></div></div><p><a class="xref" href="ch18.html#using_nftw_open_parenthesis_close_parent" title="Example 18-3. Using nftw() to walk a directory tree">Example 18-3</a> demonstrates
                        the use of <span class="emphasis"><em>nftw()</em></span>.<a id="IDX-CHP-18-2558" class="indexterm"/><a id="IDX-CHP-18-2559" class="indexterm"/><a id="IDX-CHP-18-2560" class="indexterm"/><a id="IDX-CHP-18-2561" class="indexterm"/><a id="IDX-CHP-18-2562" class="indexterm"/><a id="IDX-CHP-18-2563" class="indexterm"/><a id="IDX-CHP-18-2564" class="indexterm"/><a id="IDX-CHP-18-2565" class="indexterm"/><a id="IDX-CHP-18-2566" class="indexterm"/><a id="IDX-CHP-18-2567" class="indexterm"/></p><div class="example"><a id="using_nftw_open_parenthesis_close_parent"/><div class="example-title">Example 18-3. Using <span class="emphasis"><em>nftw()</em></span> to walk a directory tree</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>dirs_links/nftw_dir_tree.c</code></strong>
#define _XOPEN_SOURCE 600       /* Get nftw() and S_IFSOCK declarations */
#include &lt;ftw.h&gt;
#include "tlpi_hdr.h"

static void
usageError(const char *progName, const char *msg)
{
    if (msg != NULL)
        fprintf(stderr, "%s\n", msg);
    fprintf(stderr, "Usage: %s [-d] [-m] [-p] [directory-path]\n", progName);
    fprintf(stderr, "\t-d Use FTW_DEPTH flag\n");
    fprintf(stderr, "\t-m Use FTW_MOUNT flag\n");
    fprintf(stderr, "\t-p Use FTW_PHYS flag\n");
    exit(EXIT_FAILURE);
}

static int                      /* Function called by nftw() */
dirTree(const char *pathname, const struct stat *sbuf, int type,
        struct FTW *ftwb)
{
    switch (sbuf-&gt;st_mode &amp; S_IFMT) {       /* Print file type */
    case S_IFREG:  printf("-"); break;
    case S_IFDIR:  printf("d"); break;
    case S_IFCHR:  printf("c"); break;
    case S_IFBLK:  printf("b"); break;
    case S_IFLNK:  printf("l"); break;
    case S_IFIFO:  printf("p"); break;
    case S_IFSOCK: printf("s"); break;
    default:       printf("?"); break;      /* Should never happen (on Linux) */
    }

    printf(" %s  ",
            (type == FTW_D)  ? "D  " : (type == FTW_DNR) ? "DNR" :
            (type == FTW_DP) ? "DP " : (type == FTW_F)   ? "F  " :
            (type == FTW_SL) ? "SL " : (type == FTW_SLN) ? "SLN" :
            (type == FTW_NS) ? "NS " : "  ");

    if (type != FTW_NS)
        printf("%7ld ", (long) sbuf-&gt;st_ino);
    else
        printf("        ");

    printf(" %*s", 4 * ftwb-&gt;level, "");        /* Indent suitably */
    printf("%s\n",  &amp;pathname[ftwb-&gt;base]);     /* Print basename */
    return 0;                                   /* Tell nftw() to continue */
}

int
main(int argc, char *argv[])
{
    int flags, opt;

    flags = 0;
    while ((opt = getopt(argc, argv, "dmp")) != -1) {
        switch (opt) {
        case 'd': flags |= FTW_DEPTH;   break;
        case 'm': flags |= FTW_MOUNT;   break;
        case 'p': flags |= FTW_PHYS;    break;
        default:  usageError(argv[0], NULL);
        }
    }

    if (argc &gt; optind + 1)
        usageError(argv[0], NULL);

    if (nftw((argc &gt; optind) ? argv[optind] : ".", dirTree, 10, flags) == -1) {
        perror("nftw");
        exit(EXIT_FAILURE);
    }
    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>dirs_links/nftw_dir_tree.c</code></strong></pre></div></div><p>The program in <a class="xref" href="ch18.html#using_nftw_open_parenthesis_close_parent" title="Example 18-3. Using nftw() to walk a directory tree">Example 18-3</a>
                        displays an indented hierarchy of the filenames in a directory tree, one
                        file per line, as well as the file type and i-node number. Command-line
                        options can be used to specify settings for the <span class="emphasis"><em>flags</em></span>
                        argument used to call <span class="emphasis"><em>nftw()</em></span>. The following shell
                        session shows examples of what we see when we run this program. We first
                        create a new empty subdirectory, which we populate with various types of
                        files:</p><a id="I_programlisting18_d1e47760"/><pre class="programlisting"><strong class="userinput"><code>$ mkdir dir</code></strong>
<strong class="userinput"><code>$ touch dir/a dir/b</code></strong>                 <em class="lineannotation"><span class="lineannotation">Create some plain files</span></em>
<strong class="userinput"><code>$ ln -s a dir/sl</code></strong>                    <em class="lineannotation"><span class="lineannotation">and a symbolic link</span></em>
<strong class="userinput"><code>$ ln -s x dir/dsl</code></strong>                   <em class="lineannotation"><span class="lineannotation">and a dangling symbolic link</span></em>
<strong class="userinput"><code>$ mkdir dir/sub</code></strong>                     <em class="lineannotation"><span class="lineannotation">and a subdirectory</span></em>
<strong class="userinput"><code>$ touch dir/sub/x</code></strong>                   <em class="lineannotation"><span class="lineannotation">with a file of its own</span></em>
<strong class="userinput"><code>$ mkdir dir/sub2</code></strong>                    <em class="lineannotation"><span class="lineannotation">and another subdirectory</span></em>
<strong class="userinput"><code>$ chmod 0 dir/sub2</code></strong>                  <em class="lineannotation"><span class="lineannotation">that is not readable</span></em></pre><p>We then use our program to invoke <span class="emphasis"><em>nftw()</em></span> with a
                            <span class="emphasis"><em>flags</em></span> argument of 0:</p><a id="I_programlisting18_d1e47815"/><pre class="programlisting"><strong class="userinput"><code>$ ./nftw_dir_tree dir</code></strong>
d D    2327983  dir
- F    2327984      a
- F    2327985      b
- F    2327984      sl              <em class="lineannotation"><span class="lineannotation">The symbolic link sl was resolved to  a</span></em>
l SLN  2327987      dsl
d D    2327988      sub
- F    2327989          x
d DNR  2327994      sub2</pre><p>In the above output, we can see that the symbolic link <code class="literal">s1</code> was resolved.</p><p>We then use our program to invoke <span class="emphasis"><em>nftw()</em></span> with a
                            <span class="emphasis"><em>flags</em></span> argument containing <code class="literal">FTW_PHYS</code> and <code class="literal">FTW_DEPTH</code>:</p><a id="I_programlisting18_d1e47841"/><pre class="programlisting"><strong class="userinput"><code>$ ./nftw_dir_tree -p -d dir</code></strong>
- F    2327984      a
- F    2327985      b
l SL   2327986      sl              <em class="lineannotation"><span class="lineannotation">The symbolic link sl was not resolved</span></em>
l SL   2327987      dsl
- F    2327989          x
d DP   2327988      sub
d DNR  2327994      sub2
d DP   2327983  dir</pre><p>From the above output, we can see that the symbolic link <code class="literal">s1</code> was not resolved.</p></div><div class="sect3" title="The nftw() FTW_ACTIONRETVAL flag"><div class="titlepage"><div><div><h4 class="title" id="the_nftw_open_parenthesis_close_parenthe">The <span class="emphasis"><em>nftw()</em></span>
                        <code class="literal">FTW_ACTIONRETVAL</code> flag</h4></div></div></div><p>Starting with version 2.3.3, <span class="emphasis"><em>glibc</em></span> permits an
                        additional, nonstandard flag to be specified in <span class="emphasis"><em>flags</em></span>.
                        This flag, <code class="literal">FTW_ACTIONRETVAL</code>, changes the
                        way that <span class="emphasis"><em>nftw()</em></span> interprets the return value from calls
                        to <span class="emphasis"><em>func()</em></span>. When this flag is specified,
                            <span class="emphasis"><em>func()</em></span> should return one of the following
                            values:<a id="IDX-CHP-18-2568" class="indexterm"/><a id="IDX-CHP-18-2569" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term">
                                <code class="literal">FTW_CONTINUE</code>
                            </span></dt><dd><p>Continue processing entries in the directory tree, as with the
                                    traditional 0 return from <span class="emphasis"><em>func()</em></span>.</p></dd><dt><span class="term">
                                <code class="literal">FTW_SKIP_SIBLINGS</code>
                            </span></dt><dd><p>Don’t process any further entries in the current directory;
                                    resume processing in the parent directory.</p></dd><dt><span class="term">
                                <code class="literal">FTW_SKIP_SUBTREE</code>
                            </span></dt><dd><p>If <span class="emphasis"><em>pathname</em></span> is a directory (i.e.,
                                        <span class="emphasis"><em>typeflag</em></span> is <code class="literal">FTW_D</code>), then don’t call
                                        <span class="emphasis"><em>func()</em></span> for entries under that
                                    directory. Processing resumes with the next sibling of this
                                    directory.</p></dd><dt><span class="term">
                                <code class="literal">FTW_STOP</code>
                            </span></dt><dd><p>Don’t process any further entries in the directory tree, as
                                    with the traditional nonzero return from
                                        <span class="emphasis"><em>func()</em></span>. The value <code class="literal">FTW_STOP</code> is returned to the caller
                                    of <span class="emphasis"><em>nftw()</em></span>.</p></dd></dl></div><p>The <code class="literal">_GNU_SOURCE</code> feature test macro must
                        be defined in order to obtain the definition of <code class="literal">FTW_ACTIONRETVAL</code> from <code class="literal">&lt;ftw.h&gt;</code>.</p></div></div></div><div class="sect1" title="The Current Working Directory of a Process"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_current_working_directory_of_a_proce">The Current Working Directory of a Process</h2></div></div></div><p>A process’s <span class="emphasis"><em>current working directory</em></span> defines the starting
                point for the resolution of relative pathnames referred to by the process. A new
                process inherits its current working directory from its parent.<a id="IDX-CHP-18-2570" class="indexterm"/><a id="IDX-CHP-18-2571" class="indexterm"/><a id="IDX-CHP-18-2572" class="indexterm"/><a id="IDX-CHP-18-2573" class="indexterm"/><a id="IDX-CHP-18-2574" class="indexterm"/><a id="IDX-CHP-18-2575" class="indexterm"/><a id="IDX-CHP-18-2576" class="indexterm"/><a id="IDX-CHP-18-2577" class="indexterm"/><a id="IDX-CHP-18-2578" class="indexterm"/><a id="IDX-CHP-18-2579" class="indexterm"/><a id="IDX-CHP-18-2580" class="indexterm"/></p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="retrieving_the_current_working_direct"/></div></div></div><div class="sect3" title="Retrieving the current working directory"><div class="titlepage"><div><div><h4 class="title" id="retrieving_the_current_working_direct-id1">Retrieving the current working directory</h4></div></div></div><p>A process can retrieve its current working directory using
                            <span class="emphasis"><em>getcwd()</em></span>.<a id="IDX-CHP-18-2581" class="indexterm"/></p><a id="I_programlisting18_d1e48031"/><pre class="programlisting">#include &lt;unistd.h&gt;

char *<strong class="userinput"><code>getcwd</code></strong>(char *<span class="emphasis"><em>cwdbuf</em></span>, size_t <span class="emphasis"><em>size</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns <span class="emphasis"><em>cwdbuf</em></span> on success, or <code class="literal">NULL</code> on error</p></div><p>The <span class="emphasis"><em>getcwd()</em></span> function places a null-terminated string
                        containing the absolute pathname of the current working directory into the
                        allocated buffer pointed to by <span class="emphasis"><em>cwdbuf</em></span>. The caller must
                        allocate the <span class="emphasis"><em>cwdbuf</em></span> buffer to be at least
                            <span class="emphasis"><em>size</em></span> bytes in length. (Normally, we would size
                            <span class="emphasis"><em>cwdbuf</em></span> using the <code class="literal">PATH_MAX</code> constant.)</p><p>On success, <span class="emphasis"><em>getcwd()</em></span> returns a pointer to
                            <span class="emphasis"><em>cwdbuf</em></span> as its function result. If the pathname for
                        the current working directory exceeds <span class="emphasis"><em>size</em></span> bytes, then
                            <span class="emphasis"><em>getcwd()</em></span> returns <code class="literal">NULL</code>, with <span class="emphasis"><em>errno</em></span> set to <code class="literal">ERANGE</code>.</p><p>On Linux/x86-32, <span class="emphasis"><em>getcwd()</em></span> returns a maximum of 4096
                            (<code class="literal">PATH_MAX</code>) bytes. If the current
                        working directory (and <span class="emphasis"><em>cwdbuf</em></span> and
                            <span class="emphasis"><em>size</em></span>) exceeds this limit, then the pathname is
                        silently truncated, removing complete directory prefixes from the
                            <span class="emphasis"><em>beginning</em></span> of the string (which is still
                        null-terminated). In other words, we can’t use <span class="emphasis"><em>getcwd()</em></span>
                        reliably when the length of the absolute pathname for the current working
                        directory exceeds this limit.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In fact, the Linux <span class="emphasis"><em>getcwd()</em></span> system call
                            internally allocates a virtual memory page for the returned pathname. On
                            the x86-32 architecture, the page size is 4096 bytes, but on
                            architectures with larger page sizes (e.g., Alpha with a page size of
                            8192 bytes), <span class="emphasis"><em>getcwd()</em></span> can return larger
                            pathnames.</p></div><p>If the <span class="emphasis"><em>cwdbuf</em></span> argument is <code class="literal">NULL</code> and <span class="emphasis"><em>size</em></span> is 0, then the
                            <span class="emphasis"><em>glibc</em></span> wrapper function for
                            <span class="emphasis"><em>getcwd()</em></span> allocates a buffer as large as required
                        and returns a pointer to that buffer as its function result. To avoid memory
                        leaks, the caller must later deallocate this buffer with
                            <span class="emphasis"><em>free()</em></span>. Reliance on this feature should be avoided
                        in portable applications. Most other implementations provide a simpler
                        extension of the SUSv3 specification: if <span class="emphasis"><em>cwdbuf</em></span> is
                            <code class="literal">NULL</code>, then
                            <span class="emphasis"><em>getcwd()</em></span> allocates <span class="emphasis"><em>size</em></span> bytes
                        and uses this buffer to return the result to the caller. The <span class="emphasis"><em>glibc
                            getcwd()</em></span> implementation also provides this feature.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The GNU C library also provides two other functions for obtaining the
                            current working directory. The BSD-derived
                                <span class="emphasis"><em>getwd(path)</em></span> function is vulnerable to buffer
                            overruns, since it provides no method of specifying an upper limit for
                            the size of the returned pathname. The
                                <span class="emphasis"><em>get_current_dir_name()</em></span> function returns a
                            string containing the current working directory name as its function
                            result. This function is easy to use, but it is not portable. For
                            security and portability, <span class="emphasis"><em>getcwd()</em></span> is preferred
                            over these two functions (as long as we avoid using the GNU
                                extensions).<a id="IDX-CHP-18-2582" class="indexterm"/></p></div><p>With suitable permissions (roughly, we own the process or have the
                            <code class="literal">CAP_SYS_PTRACE</code> capability), we can
                        determine the current working directory of any process by reading
                            (<span class="emphasis"><em>readlink()</em></span>) the contents of the Linux-specific
                            <code class="literal">/proc/</code><span class="emphasis"><em>PID</em></span><code class="literal">/cwd</code> symbolic link.<a id="IDX-CHP-18-2583" class="indexterm"/></p></div><div class="sect3" title="Changing the current working directory"><div class="titlepage"><div><div><h4 class="title" id="changing_the_current_working_directory">Changing the current working directory</h4></div></div></div><p>The <span class="emphasis"><em>chdir()</em></span> system call changes the calling process’s
                        current working directory to the relative or absolute pathname specified in
                            <span class="emphasis"><em>pathname</em></span> (which is dereferenced if it is a symbolic
                            link).<a id="IDX-CHP-18-2584" class="indexterm"/><a id="IDX-CHP-18-2585" class="indexterm"/><a id="IDX-CHP-18-2586" class="indexterm"/><a id="IDX-CHP-18-2587" class="indexterm"/><a id="IDX-CHP-18-2588" class="indexterm"/><a id="IDX-CHP-18-2589" class="indexterm"/></p><a id="I_programlisting18_d1e48247"/><pre class="programlisting">#include &lt;unistd.h&gt;

int <strong class="userinput"><code>chdir</code></strong>(const char *<span class="emphasis"><em>pathname</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>fchdir()</em></span> system call does the same as
                            <span class="emphasis"><em>chdir()</em></span>, except that the directory is specified via
                        a file descriptor previously obtained by opening the directory with
                            <span class="emphasis"><em>open()</em></span>.<a id="IDX-CHP-18-2590" class="indexterm"/></p><a id="I_programlisting18_d1e48273"/><pre class="programlisting">#include &lt;unistd.h&gt;

int <strong class="userinput"><code>fchdir</code></strong>(int <span class="emphasis"><em>fd</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>We can use <span class="emphasis"><em>fchdir()</em></span> to change the process’s current
                        working directory to another location, and then later return to the original
                        location, as follows:</p><a id="I_programlisting18_d1e48289"/><pre class="programlisting">int fd;

fd = open(".", O_RDONLY);       /* Remember where we are */
chdir(somepath);                /* Go somewhere else */
fchdir(fd);                     /* Return to original directory */
close(fd);</pre><p>The equivalent using <span class="emphasis"><em>chdir()</em></span> is as follows:</p><a id="I_programlisting18_d1e48296"/><pre class="programlisting">char buf[PATH_MAX];

getcwd(buf, PATH_MAX);          /* Remember where we are */
chdir(somepath);                /* Go somewhere else */
chdir(buf);                     /* Return to original directory */</pre></div></div></div><div class="sect1" title="Operating Relative to a Directory File Descriptor"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="operating_relative_to_a_directory_file_d">Operating Relative to a Directory File Descriptor</h2></div></div></div><p>Starting with kernel 2.6.16, Linux provides a range of new system calls that
                perform similar tasks to various traditional system calls, but provide additional
                functionality that is useful to some applications. These system calls are summarized
                in <a class="xref" href="ch18.html#system_calls_that_use_a_directory_file_d" title="Table 18-2. System calls that use a directory file descriptor to interpret relative pathnames">Table 18-2</a>. We describe these
                system calls in this chapter because they provide variations on the traditional
                semantics of the process’s current working directory.<a id="IDX-CHP-18-2591" class="indexterm"/><a id="IDX-CHP-18-2592" class="indexterm"/><a id="IDX-CHP-18-2593" class="indexterm"/><a id="IDX-CHP-18-2594" class="indexterm"/><a id="IDX-CHP-18-2595" class="indexterm"/><a id="IDX-CHP-18-2596" class="indexterm"/><a id="IDX-CHP-18-2597" class="indexterm"/></p><div class="table"><a id="system_calls_that_use_a_directory_file_d"/><div class="table-title">Table 18-2. System calls that use a directory file descriptor to interpret relative
                    pathnames</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>New interface</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Traditional analog</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                <p>Notes</p>
                            </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>faccessat()</em></span>
                                    <a id="IDX-CHP-18-2598" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>access()</em></span>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>Supports <code class="literal">AT_EACCESS</code> and
                                        <code class="literal">AT_SYMLINK_NOFOLLOW</code>
                                    flags</p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>fchmodat()</em></span>
                                    <a id="IDX-CHP-18-2599" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>chmod()</em></span>
                                </p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>fchownat()</em></span>
                                    <a id="IDX-CHP-18-2600" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>chown()</em></span>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>Supports <code class="literal">AT_SYMLINK_NOFOLLOW</code> flag</p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>fstatat()</em></span>
                                    <a id="IDX-CHP-18-2601" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>stat()</em></span>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>Supports <code class="literal">AT_SYMLINK_NOFOLLOW</code> flag</p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>linkat()</em></span>
                                    <a id="IDX-CHP-18-2602" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>link()</em></span>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>Supports (since Linux 2.6.18) <code class="literal">AT_SYMLINK_FOLLOW</code> flag</p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>mkdirat()</em></span>
                                    <a id="IDX-CHP-18-2603" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>mkdir()</em></span>
                                </p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>mkfifoat()</em></span>
                                    <a id="IDX-CHP-18-2604" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>mkfifo()</em></span>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>Library function layered on top of <code class="literal">mknodat()</code></p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>mknodat()</em></span>
                                    <a id="IDX-CHP-18-2605" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>mknod()</em></span>
                                </p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>openat()</em></span>
                                    <a id="IDX-CHP-18-2606" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>open()</em></span>
                                </p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>readlinkat()</em></span>
                                    <a id="IDX-CHP-18-2607" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>readlink()</em></span>
                                </p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>renameat()</em></span>
                                    <a id="IDX-CHP-18-2608" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>rename()</em></span>
                                </p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>symlinkat()</em></span>
                                    <a id="IDX-CHP-18-2609" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>symlink()</em></span>
                                </p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>unlinkat()</em></span>
                                    <a id="IDX-CHP-18-2610" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>unlink()</em></span>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>Supports <code class="literal">AT_REMOVEDIR</code>
                                    flag</p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>utimensat()</em></span>
                                    <a id="IDX-CHP-18-2611" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>utimes()</em></span>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; ">
                                <p>Supports <code class="literal">AT_SYMLINK_NOFOLLOW</code> flag</p>
                            </td></tr></tbody></table></div></div><p>In order to describe these system calls, we’ll use a specific example:
                    <span class="emphasis"><em>openat()</em></span>.</p><a id="I_programlisting18_d1e48602"/><pre class="programlisting">#define _XOPEN_SOURCE 700     /* Or define _POSIX_C_SOURCE &gt;= 200809 */
#include &lt;fcntl.h&gt;

int <strong class="userinput"><code>openat</code></strong>(int <span class="emphasis"><em>dirfd</em></span>, const char *<span class="emphasis"><em>pathname</em></span>, int
 <span class="emphasis"><em>flags</em></span>, ... /* mode_t  <span class="emphasis"><em>mode</em></span> */);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns file descriptor on success, or -1 on error</p></div><p>The <span class="emphasis"><em>openat()</em></span> system call is similar to the traditional
                    <span class="emphasis"><em>open()</em></span> system call, but adds an argument,
                    <span class="emphasis"><em>dirfd</em></span>, that is used as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If <span class="emphasis"><em>pathname</em></span> specifies a relative pathname, then it is
                        interpreted relative to the directory referred to by the open file
                        descriptor <span class="emphasis"><em>dirfd</em></span>, rather than relative to the process’s
                        current working directory.</p></li><li class="listitem"><p>If <span class="emphasis"><em>pathname</em></span> specifies a relative pathname, and
                            <span class="emphasis"><em>dirfd</em></span> contains the special value <code class="literal">AT_FDCWD</code>, then <span class="emphasis"><em>pathname</em></span>
                        is interpreted relative to the process’s current working directory (i.e.,
                        the same behavior as <span class="emphasis"><em>open(2)</em></span>).</p></li><li class="listitem"><p>If <span class="emphasis"><em>pathname</em></span> specifies an absolute pathname, then
                            <span class="emphasis"><em>dirfd</em></span> is ignored.</p></li></ul></div><p>The <span class="emphasis"><em>flags</em></span> argument of <span class="emphasis"><em>openat()</em></span> serves
                the same purpose as for <span class="emphasis"><em>open()</em></span>. However, some of the system
                calls listed in <a class="xref" href="ch18.html#system_calls_that_use_a_directory_file_d" title="Table 18-2. System calls that use a directory file descriptor to interpret relative pathnames">Table 18-2</a> support a
                    <span class="emphasis"><em>flags</em></span> argument that is not provided by the corresponding
                traditional system call, and the purpose of this argument is to modify the semantics
                of the call. The most frequently provided flag is <code class="literal">AT_SYMLINK_NOFOLLOW</code>, which specifies that if
                    <span class="emphasis"><em>pathname</em></span> is a symbolic link, then the system call should
                operate on the link, rather than the file to which it refers. (The
                    <span class="emphasis"><em>linkat()</em></span> system call provides the <code class="literal">AT_SYMLINK_FOLLOW</code> flag, which performs the converse action, changing
                the default behavior of <span class="emphasis"><em>linkat()</em></span> so that it dereferences
                    <span class="emphasis"><em>oldpath</em></span> if it is a symbolic link.) For details of the other
                flags, refer to the corresponding manual pages.</p><p>The system calls listed in <a class="xref" href="ch18.html#system_calls_that_use_a_directory_file_d" title="Table 18-2. System calls that use a directory file descriptor to interpret relative pathnames">Table 18-2</a> are supported for two
                reasons (again, we explain using the example of
                <span class="emphasis"><em>openat()</em></span>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Using <span class="emphasis"><em>openat()</em></span> allows an application to avoid certain
                        race conditions that can occur when <span class="emphasis"><em>open()</em></span> is used to
                        open files in locations other than the current working directory. These
                        races can occur because some component of the directory prefix of
                            <span class="emphasis"><em>pathname</em></span> could be changed in parallel with the
                            <span class="emphasis"><em>open()</em></span> call. By opening a file descriptor for the
                        target directory, and passing that descriptor to
                            <span class="emphasis"><em>openat()</em></span>, such races can be avoided.</p></li><li class="listitem"><p>In <a class="xref" href="ch29.html" title="Chapter 29. Threads: Introduction">Chapter 29</a>, we’ll see that the
                        working directory is a process attribute that is shared by all threads of
                        the process. For some applications, it is useful for different threads to
                        have different “virtual” working directories. An application can emulate
                        this functionality using <span class="emphasis"><em>openat()</em></span> in conjunction with
                        directory file descriptors maintained by the application.</p></li></ul></div><p>These system calls are not standardized in SUSv3, but are included in SUSv4. In
                order to expose the declaration of each of these system calls, the <code class="literal">_XOPEN_SOURCE</code> feature test macro must be defined with
                a value greater than or equal to 700 before including the appropriate header file
                (e.g., <code class="literal">&lt;fcntl.h&gt;</code> for
                    <span class="emphasis"><em>open()</em></span>). Alternatively, the <code class="literal">_POSIX_C_SOURCE</code> macro can be defined with a value greater than or
                equal to 200809. (Before <span class="emphasis"><em>glibc</em></span> 2.10, the <code class="literal">_ATFILE_SOURCE</code> macro needed to be defined to expose
                the declarations of these system calls.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Solaris 9 and later provide versions of some of the interfaces listed in <a class="xref" href="ch18.html#system_calls_that_use_a_directory_file_d" title="Table 18-2. System calls that use a directory file descriptor to interpret relative pathnames">Table 18-2</a>, with slightly
                    different semantics.</p></div></div><div class="sect1" title="Changing the Root Directory of a Process: chroot()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="changing_the_root_directory_of_a_process">Changing the Root Directory of a Process: <span class="emphasis"><em>chroot()</em></span></h2></div></div></div><p>Every process has a <span class="emphasis"><em>root directory</em></span>, which is the point from
                which absolute pathnames (i.e., those beginning with /) are interpreted. By default,
                this is the real root directory of the file system. (A new process inherits its
                parent’s root directory.) On occasion, it is useful for a process to change its root
                directory, and a privileged (<code class="literal">CAP_SYS_CHROOT</code>)
                process can do this using the <span class="emphasis"><em>chroot()</em></span> system call.<a id="IDX-CHP-18-2613" class="indexterm"/><a id="IDX-CHP-18-2614" class="indexterm"/><a id="IDX-CHP-18-2615" class="indexterm"/><a id="IDX-CHP-18-2616" class="indexterm"/><a id="IDX-CHP-18-2617" class="indexterm"/><a id="IDX-CHP-18-2612" class="indexterm"/><a id="IDX-CHP-18-2618" class="indexterm"/><a id="IDX-CHP-18-2619" class="indexterm"/></p><a id="I_programlisting18_d1e48826"/><pre class="programlisting">#define _BSD_SOURCE
#include &lt;unistd.h&gt;

int <strong class="userinput"><code>chroot</code></strong>(const char *<span class="emphasis"><em>pathname</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>chroot()</em></span> system call changes the process’s root directory
                to the directory specified by <span class="emphasis"><em>pathname</em></span> (which is dereferenced
                if it is a symbolic link). Thereafter, all absolute pathnames are interpreted as
                starting from that location in the file system. This is sometimes referred to as
                setting up a <span class="emphasis"><em>chroot</em></span> jail, since the program is then confined to
                a particular area of the file system.<a id="IDX-CHP-18-2620" class="indexterm"/></p><p>SUSv2 contained a specification for <span class="emphasis"><em>chroot()</em></span> (marked LEGACY),
                but this was removed in SUSv3. Nevertheless, <span class="emphasis"><em>chroot()</em></span> appears
                on most UNIX implementations.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>chroot()</em></span> system call is employed by the
                        <span class="emphasis"><em>chroot</em></span> command, which enables us to execute shell
                    commands in a <span class="emphasis"><em>chroot</em></span> jail.</p><p>The root directory of any process can be found by reading
                        (<span class="emphasis"><em>readlink()</em></span>) the contents of the Linux-specific
                        <code class="literal">/proc/</code><span class="emphasis"><em>PID</em></span><code class="literal">/root</code> symbolic link.</p></div><p>The classic example of the use of <span class="emphasis"><em>chroot()</em></span> is in the
                    <span class="emphasis"><em>ftp</em></span> program. As a security measure, when a user logs in
                anonymously under FTP, the <span class="emphasis"><em>ftp</em></span> program uses
                    <span class="emphasis"><em>chroot()</em></span> to set the root directory for the new process to
                the directory specifically reserved for anonymous logins. After the chroot() call,
                the user is limited to the file-system subtree under their new root directory, so
                they can’t roam around the entire file system. (This relies on the fact that the
                root directory is its own parent; that is, <code class="literal">/..</code> is
                a link to <code class="literal">/</code>, so that changing directory to
                    <code class="literal">/</code> and then attempting a <span class="emphasis"><em>cd
                    ..</em></span> leaves the user in the same directory.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Some UNIX implementations (but not Linux) allow multiple hard links to a
                    directory, so that it is possible to create a hard link within a subdirectory to
                    its parent (or a further removed ancestor). On implementations permitting this,
                    the presence of a hard link that reaches outside the jail directory tree
                    compromises the jail. Symbolic links to directories outside the jail don’t pose
                    a problem—because they are interpreted within the framework of the process’s new
                    root directory, they can’t reach outside the <span class="emphasis"><em>chroot</em></span>
                    jail.</p></div><p>Normally, we can’t execute arbitrary programs within a <span class="emphasis"><em>chroot</em></span>
                jail. This is because most programs are dynamically linked against shared libraries.
                Therefore, we must either limit ourselves to executing statically linked programs,
                or replicate a standard set of system directories containing shared libraries
                (including, for example, <code class="literal">/lib</code> and <code class="literal">/usr/lib</code>) within the jail (in this regard, the bind
                mount feature described in <a class="xref" href="ch14.html#bind_mounts" title="Bind Mounts">Bind Mounts</a> can be useful).</p><p>The <span class="emphasis"><em>chroot()</em></span> system call was not conceived as a completely
                secure jail mechanism. To begin with, there are various ways in which a privileged
                program can subsequently use a further <span class="emphasis"><em>chroot()</em></span> call to break
                out of the jail. For example, a privileged (<code class="literal">CAP_MKNOD</code>) program can use <span class="emphasis"><em>mknod()</em></span> to create a
                memory device file (similar to <code class="literal">/dev/mem</code>) giving
                access to the contents of RAM, and, from that point, anything is possible. In
                general, it is advisable not to include set-user-ID-<span class="emphasis"><em>root</em></span>
                programs within a <span class="emphasis"><em>chroot</em></span> jail file system.</p><p>Even with unprivileged programs, we must take care to prevent the following
                possible routes for breaking out of a <span class="emphasis"><em>chroot</em></span> jail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Calling <span class="emphasis"><em>chroot()</em></span> doesn’t change the process’s current
                        working directory. Thus, a call to <span class="emphasis"><em>chroot()</em></span> is
                        typically preceded or followed by a call to <span class="emphasis"><em>chdir()</em></span>
                        (e.g., <span class="emphasis"><em>chdir</em></span>(“/”) after the
                            <span class="emphasis"><em>chroot()</em></span> call). If this is not done, then a process
                        can use relative pathnames to access files and directories outside the jail.
                        (Some BSD derivatives prevent this possibility—if the current working
                        directory lies outside the new root directory tree, then it is changed by
                        the <span class="emphasis"><em>chroot()</em></span> call to be the same as the root
                        directory.)</p></li><li class="listitem"><p>If a process holds an open file descriptor for a directory outside the
                        jail, then the combination of <span class="emphasis"><em>fchdir()</em></span> plus
                            <span class="emphasis"><em>chroot()</em></span> can be used to break out of the jail, as
                        shown in the following code sample:</p><a id="I_programlisting18_d1e48993"/><pre class="programlisting">int fd;

fd = open("/", O_RDONLY);
chroot("/home/mtk");            /* Jailed */
fchdir(fd);
chroot(".");                    /* Out of jail */</pre><p>To prevent this possibility, we must close all open file descriptors
                        referring to directories outside the jail. (Some other UNIX implementations
                        provide the <span class="emphasis"><em>fchroot()</em></span> system call, which can be used to
                        achieve a similar result to the above code snippet.)<a id="IDX-CHP-18-2621" class="indexterm"/></p></li><li class="listitem"><p>Even preventing the preceding possibilities is insufficient to stop an
                        arbitrary unprivileged program (i.e., one whose operation we don’t have
                        control over) from breaking out of the jail. The jailed process can still
                        use a UNIX domain socket to receive a file descriptor (from another process)
                        referring to a directory outside the jail. (We briefly explain the concept
                        of passing file descriptors between processes via a socket in <a class="xref" href="ch61.html#passing_file_descriptors" title="Passing File Descriptors">Passing File Descriptors</a>.) By specifying this file
                        descriptor in a call to <span class="emphasis"><em>fchdir()</em></span>, the program can set
                        its current working directory outside the jail and then access arbitrary
                        files and directories using relative pathnames.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Some BSD derivatives provide a <span class="emphasis"><em>jail()</em></span> system call, which
                    addresses the points described above, as well as several others, to create a
                    jail that is secure even for a privileged process.</p></div></div><div class="sect1" title="Resolving a Pathname: realpath()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="resolving_a_pathname_colon_realpath_open">Resolving a Pathname: <span class="emphasis"><em>realpath()</em></span></h2></div></div></div><p>The <span class="emphasis"><em>realpath()</em></span> library function dereferences all symbolic
                links in <span class="emphasis"><em>pathname</em></span> (a null-terminated string) and resolves all
                references to /. and /.. to produce a null-terminated string containing the
                corresponding absolute pathname.<a id="IDX-CHP-18-2623" class="indexterm"/><a id="IDX-CHP-18-2624" class="indexterm"/><a id="IDX-CHP-18-2625" class="indexterm"/><a id="IDX-CHP-18-2622" class="indexterm"/></p><a id="I_programlisting18_d1e49051"/><pre class="programlisting">#include &lt;stdlib.h&gt;

char *<strong class="userinput"><code>realpath</code></strong>(const char *<span class="emphasis"><em>pathname</em></span>, char *<span class="emphasis"><em>resolved_path</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer to resolved pathname on success, or <code class="literal">NULL</code> on error</p></div><p>The resulting string is placed in the buffer pointed to by
                    <span class="emphasis"><em>resolved_path</em></span>, which should be a character array of at
                least <code class="literal">PATH_MAX</code> bytes. On success,
                    <span class="emphasis"><em>realpath()</em></span> also returns a pointer to this resolved
                string.</p><p>The <span class="emphasis"><em>glibc</em></span> implementation of <span class="emphasis"><em>realpath()</em></span>
                allows the caller to specify <span class="emphasis"><em>resolved_path</em></span> as <code class="literal">NULL</code>. In this case, <span class="emphasis"><em>realpath()</em></span>
                allocates a buffer of up to <code class="literal">PATH_MAX</code> bytes for
                the resolved pathname and returns a pointer to that buffer as the function result.
                (The caller must deallocate this buffer using <span class="emphasis"><em>free()</em></span>.) SUSv3
                doesn’t specify this extension, but it is specified in SUSv4.</p><p>The program in <a class="xref" href="ch18.html#read_and_resolve_a_symbolic_link" title="Example 18-4. Read and resolve a symbolic link">Example 18-4</a> uses
                    <span class="emphasis"><em>readlink()</em></span> and <span class="emphasis"><em>realpath()</em></span> to read the
                contents of a symbolic link and to resolve the link to an absolute pathname. Here is
                an example of the use of this program:</p><a id="I_programlisting18_d1e49113"/><pre class="programlisting"><strong class="userinput"><code>$ pwd</code></strong>                                       <em class="lineannotation"><span class="lineannotation">Where are we?</span></em>
/home/mtk
<strong class="userinput"><code>$ touch x</code></strong>                                   <em class="lineannotation"><span class="lineannotation">Make a file</span></em>
<strong class="userinput"><code>$ ln -s x y</code></strong>                                 <em class="lineannotation"><span class="lineannotation">and a symbolic link to it</span></em>
<strong class="userinput"><code>$ ./view_symlink y</code></strong>
readlink: y --&gt; x
realpath: y --&gt; /home/mtk/x</pre><div class="example"><a id="read_and_resolve_a_symbolic_link"/><div class="example-title">Example 18-4. Read and resolve a symbolic link</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>dirs_links/view_symlink.c</code></strong>
#include &lt;sys/stat.h&gt;
#include &lt;limits.h&gt;             /* For definition of PATH_MAX */
#include "tlpi_hdr.h"

#define BUF_SIZE PATH_MAX

int
main(int argc, char *argv[])
{
    struct stat statbuf;
    char buf[BUF_SIZE];
    ssize_t numBytes;

    if (argc != 2 || strcmp(argv[1], "--help") == 0)
        usageErr("%s pathname\n", argv[0]);

    if (lstat(argv[1], &amp;statbuf) == -1)
        errExit("lstat");

    if (!S_ISLNK(statbuf.st_mode))
        fatal("%s is not a symbolic link", argv[1]);

    numBytes = readlink(argv[1], buf, BUF_SIZE - 1);
    if (numBytes == -1)
        errExit("readlink");
    buf[numBytes] = '\0';                       /* Add terminating null byte */
    printf("readlink: %s --&gt; %s\n", argv[1], buf);

    if (realpath(argv[1], buf) == NULL)
        errExit("realpath");
    printf("realpath: %s --&gt; %s\n", argv[1], buf);

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>dirs_links/view_symlink.c</code></strong></pre></div></div></div><div class="sect1" title="Parsing Pathname Strings: dirname() and basename()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="parsing_pathname_strings_colon_dirname_o">Parsing Pathname Strings: <span class="emphasis"><em>dirname()</em></span> and
                    <span class="emphasis"><em>basename()</em></span></h2></div></div></div><p>The <span class="emphasis"><em>dirname()</em></span> and <span class="emphasis"><em>basename()</em></span> functions
                break a pathname string into directory and filename parts. (These functions perform
                a similar task to the <span class="emphasis"><em>dirname(1)</em></span> and
                    <span class="emphasis"><em>basename(1)</em></span> commands.)<a id="IDX-CHP-18-2628" class="indexterm"/><a id="IDX-CHP-18-2629" class="indexterm"/><a id="IDX-CHP-18-2630" class="indexterm"/><a id="IDX-CHP-18-2631" class="indexterm"/><a id="IDX-CHP-18-2632" class="indexterm"/><a id="IDX-CHP-18-2633" class="indexterm"/><a id="IDX-CHP-18-2634" class="indexterm"/><a id="IDX-CHP-18-2635" class="indexterm"/><a id="IDX-CHP-18-2636" class="indexterm"/><a id="IDX-CHP-18-2626" class="indexterm"/><a id="IDX-CHP-18-2627" class="indexterm"/></p><a id="I_programlisting18_d1e49234"/><pre class="programlisting">#include &lt;libgen.h&gt;

char *<strong class="userinput"><code>dirname</code></strong>(char *<span class="emphasis"><em>pathname</em></span>);
char *<strong class="userinput"><code>basename</code></strong>(char *<span class="emphasis"><em>pathname</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Both return a pointer to a null-terminated (and possibly statically allocated)
                    string</p></div><p>For example, given the pathname <code class="literal">/home/britta/prog.c</code>, <span class="emphasis"><em>dirname()</em></span> returns <code class="literal">/home/britta</code> and <span class="emphasis"><em>basename()</em></span>
                returns <code class="literal">prog.c</code>. Concatenating the string returned
                by <span class="emphasis"><em>dirname()</em></span>, a slash (<code class="literal">/</code>),
                and the string returned by <span class="emphasis"><em>basename()</em></span> yields a complete
                pathname.</p><p>Note the following points regarding the operation of
                    <span class="emphasis"><em>dirname()</em></span> and <span class="emphasis"><em>basename()</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Trailing slash characters in <span class="emphasis"><em>pathname</em></span> are
                        ignored.</p></li><li class="listitem"><p>If <span class="emphasis"><em>pathname</em></span> doesn’t contain a slash, then
                            <span class="emphasis"><em>dirname()</em></span> returns the string <code class="literal">.</code> (dot) and <span class="emphasis"><em>basename()</em></span>
                        returns <span class="emphasis"><em>pathname</em></span>.</p></li><li class="listitem"><p>If <span class="emphasis"><em>pathname</em></span> consists of just a slash, then both
                            <span class="emphasis"><em>dirname()</em></span> and <span class="emphasis"><em>basename()</em></span>
                        return the string <code class="literal">/</code>. Applying the
                        concatenation rule above to create a pathname from these returned strings
                        would yield the string <code class="literal">///</code>. This
                            <span class="emphasis"><em>is</em></span> a valid pathname. Because multiple consecutive
                        slashes are equivalent to a single slash, the pathname <code class="literal">///</code> is equivalent to the pathname <code class="literal">/</code>.</p></li><li class="listitem"><p>If <span class="emphasis"><em>pathname</em></span> is a <code class="literal">NULL</code> pointer or an empty string, then both
                            <span class="emphasis"><em>dirname()</em></span> and <span class="emphasis"><em>basename()</em></span>
                        return the string <code class="literal">.</code> (dot). (Concatenating
                        these strings yields the pathname <code class="literal">./.</code>,
                        which is equivalent to <code class="literal">.</code>, the current
                        directory.)</p></li></ul></div><p><a class="xref" href="ch18.html#examples_of_strings_returned_by_dirname" title="Table 18-3. Examples of strings returned by dirname() and basename()">Table 18-3</a> shows the strings
                returned by <span class="emphasis"><em>dirname()</em></span> and <span class="emphasis"><em>basename()</em></span> for
                various example pathnames.</p><div class="table"><a id="examples_of_strings_returned_by_dirname"/><div class="table-title">Table 18-3. Examples of strings returned by <span class="emphasis"><em>dirname()</em></span> and
                        <span class="emphasis"><em>basename()</em></span></div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Pathname string</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>dirname()</em></span>
                                </p>
                            </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>basename()</em></span>
                                </p>
                            </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">/</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">/</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">/</code>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">/usr/bin/zip</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">/usr/bin</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">zip</code>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">/etc/passwd////</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">/etc</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">passwd</code>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">/etc////passwd</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">/etc</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">passwd</code>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">etc/passwd</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">etc</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">passwd</code>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">passwd</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">.</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">passwd</code>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">passwd/</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">.</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">passwd</code>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">..</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">.</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">..</code>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">NULL</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">.</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; ">
                                <p>
                                    <code class="literal">.</code>
                                </p>
                            </td></tr></tbody></table></div></div><div class="example"><a id="using_dirname_open_parenthesis_close_par"/><div class="example-title">Example 18-5. Using <span class="emphasis"><em>dirname()</em></span> and
                    <span class="emphasis"><em>basename()</em></span></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>dirs_links/t_dirbasename.c</code></strong>
#include &lt;libgen.h&gt;
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    char *t1, *t2;
    int j;

    for (j = 1; j &lt; argc; j++)  {
        t1 = strdup(argv[j]);
        if (t1 == NULL)
            errExit("strdup");
        t2 = strdup(argv[j]);
        if (t2 == NULL)
            errExit("strdup");

        printf("%s ==&gt; %s + %s\n", argv[j], dirname(t1), basename(t2));

        free(t1);
        free(t2);
    }

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>dirs_links/t_dirbasename.c</code></strong></pre></div></div><p>Both <span class="emphasis"><em>dirname()</em></span> and <span class="emphasis"><em>basename()</em></span> may modify
                the string pointed to by <span class="emphasis"><em>pathname</em></span>. Therefore, if we wish to
                preserve a pathname string, we must pass copies of it to
                    <span class="emphasis"><em>dirname()</em></span> and <span class="emphasis"><em>basename()</em></span>, as shown in
                    <a class="xref" href="ch18.html#using_dirname_open_parenthesis_close_par" title="Example 18-5. Using dirname() and basename()">Example 18-5</a> (page 371). This
                program uses <span class="emphasis"><em>strdup()</em></span> (which calls
                    <span class="emphasis"><em>malloc()</em></span>) to make copies of the strings to be passed to
                    <span class="emphasis"><em>dirname()</em></span> and <span class="emphasis"><em>basename()</em></span>, and then
                uses <span class="emphasis"><em>free()</em></span> to deallocate the duplicate strings.</p><p>Finally, note that both <span class="emphasis"><em>dirname()</em></span> and
                    <span class="emphasis"><em>basename()</em></span> can return pointers to statically allocated
                strings that may be modified by future calls to the same functions.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id17">Summary</h2></div></div></div><p>An i-node doesn’t contain a file’s name. Instead, files are assigned names via
                entries in directories, which are tables listing filename and i-node number
                correspondences. These directory entries are called (hard) links. A file may have
                multiple links, all of which enjoy equal status. Links are created and removed using
                    <span class="emphasis"><em>link()</em></span> and <span class="emphasis"><em>unlink()</em></span>. A file can be
                renamed using the <span class="emphasis"><em>rename()</em></span> system call.</p><p>A symbolic (or soft) link is created using <span class="emphasis"><em>symlink()</em></span>.
                Symbolic links are similar to hard links in some respects, with the differences that
                symbolic links can cross file-system boundaries and can refer to directories. A
                symbolic link is just a file containing the name of another file; this name may be
                retrieved using <span class="emphasis"><em>readlink()</em></span>. A symbolic link is not included in
                the (target) i-node’s link count, and it may be left dangling if the filename to
                which it refers is removed. Some system calls automatically dereference (follow)
                symbolic links; others do not. In some cases, two versions of a system call are
                provided: one that dereferences symbolic links and another that does not. Examples
                are <span class="emphasis"><em>stat()</em></span> and <span class="emphasis"><em>lstat()</em></span>.</p><p>Directories are created with <span class="emphasis"><em>mkdir()</em></span> and removed using
                    <span class="emphasis"><em>rmdir()</em></span>. To scan the contents of a directory, we can use
                    <span class="emphasis"><em>opendir()</em></span>, <span class="emphasis"><em>readdir()</em></span>, and related
                functions. The <span class="emphasis"><em>nftw()</em></span> function allows a program to walk an
                entire directory tree, calling a programmer-defined function to operate on each file
                in the tree.</p><p>The <span class="emphasis"><em>remove()</em></span> function can be used to remove a file (i.e., a
                link) or an empty directory.</p><p>Each process has a root directory, which determines the point from which absolute
                pathnames are interpreted, and a current working directory, which determines the
                point from which relative pathnames are interpreted. The
                    <span class="emphasis"><em>chroot()</em></span> and <span class="emphasis"><em>chdir()</em></span> system calls are
                used to change these attributes. The <span class="emphasis"><em>getcwd()</em></span> function returns
                a process’s current working directory.</p><p>Linux provides a set of system calls (e.g., <span class="emphasis"><em>openat()</em></span>) that
                behave like their traditional counterparts (e.g., <span class="emphasis"><em>open()</em></span>),
                except that relative pathnames can be interpreted with respect to the directory
                specified by a file descriptor supplied to the call (instead of using the process’s
                current working directory). This is useful for avoiding certain types of race
                conditions and for implementing per-thread virtual working directories.</p><p>The <span class="emphasis"><em>realpath()</em></span> function resolves a pathname—dereferencing all
                symbolic links and resolving all references to . and .. to corresponding
                directories—to yield a corresponding absolute pathname. The
                    <span class="emphasis"><em>dirname()</em></span> and <span class="emphasis"><em>basename()</em></span> functions can
                be used to parse a pathname into directory and filename components.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id11">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>In <a class="xref" href="ch04.html#the_open_open_parenthesis_close_parenthe" title="The open() flags Argument">The <span class="emphasis"><em>open() flags</em></span> Argument</a>, we noted
                        that it is not possible to open a file for writing if it is currently being
                        executed (<span class="emphasis"><em>open()</em></span> returns -1, with
                            <span class="emphasis"><em>errno</em></span> set to <code class="literal">ETXTBSY</code>). Nevertheless, it is possible to do the following
                        from the shell:<a id="IDX-CHP-18-2637" class="indexterm"/></p><a id="I_programlisting18_d1e49677"/><pre class="programlisting">$ <strong class="userinput"><code>cc -o longrunner longrunner.c</code></strong>
$ <strong class="userinput"><code>./longrunner &amp;</code></strong>                        <em class="lineannotation"><span class="lineannotation">Leave running in background</span></em>
$ <strong class="userinput"><code>vi longrunner.c</code></strong>                       <em class="lineannotation"><span class="lineannotation">Make some changes to the source code</span></em>
$ <strong class="userinput"><code>cc -o longrunner longrunner.c</code></strong></pre><p>The last command overwrites the existing executable of the same name. How
                        is this possible? (For a clue, use <span class="emphasis"><em>ls -li</em></span> to look at
                        the i-node number of the executable file after each compilation.)</p></li><li class="listitem"><p>Why does the call to <span class="emphasis"><em>chmod()</em></span> in the following code
                        fail?</p><a id="I_programlisting18_d1e49708"/><pre class="programlisting">mkdir("test", S_IRUSR | S_IWUSR | S_IXUSR);
chdir("test");
fd = open("myfile", O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
symlink("myfile", "../mylink");
chmod("../mylink", S_IRUSR);</pre></li><li class="listitem"><p>Implement <span class="emphasis"><em>realpath()</em></span>.</p></li><li class="listitem"><p>Modify the program in <a class="xref" href="ch18.html#scanning_a_directory" title="Example 18-2. Scanning a directory">Example 18-2</a> (<code class="literal">list_files.c</code>) to use
                            <span class="emphasis"><em>readdir_r()</em></span> instead of
                            <span class="emphasis"><em>readdir()</em></span>.<a id="IDX-CHP-18-2638" class="indexterm"/></p></li><li class="listitem"><p>Implement a function that performs the equivalent of
                            <span class="emphasis"><em>getcwd()</em></span>. A useful tip for solving this problem is
                        that you can find the name of the current working directory by using
                            <span class="emphasis"><em>opendir()</em></span> and <span class="emphasis"><em>readdir()</em></span> to
                        walk through each of the entries in the parent directory (<code class="literal">..</code>) to find an entry with the same i-node and
                        device number as the current working directory (i.e., respectively, the
                            <span class="emphasis"><em>st_ino</em></span> and <span class="emphasis"><em>st_dev</em></span> fields in
                        the <span class="emphasis"><em>stat</em></span> structure returned by
                            <span class="emphasis"><em>stat()</em></span> and <span class="emphasis"><em>lstat()</em></span>). Thus, it
                        is possible to construct the directory path by walking up the directory tree
                            (<span class="emphasis"><em>chdir(“..”)</em></span>) one step at a time and performing
                        such scans. The walk can be finished when the parent directory is the same
                        as the current working directory (recall that <code class="literal">/..</code> is the same as <code class="literal">/</code>). The
                        caller should be left in the same directory in which it started, regardless
                        of whether your <span class="emphasis"><em>getcwd()</em></span> function succeeds or fails
                            (<span class="emphasis"><em>open()</em></span> plus <span class="emphasis"><em>fchdir()</em></span> are
                        handy for this purpose).</p></li><li class="listitem"><p>Modify the program in <a class="xref" href="ch18.html#using_nftw_open_parenthesis_close_parent" title="Example 18-3. Using nftw() to walk a directory tree">Example 18-3</a> (<code class="literal">nftw_dir_tree.c</code>) to use the <code class="literal">FTW_DEPTH</code> flag. Note the difference in the
                        order in which the directory tree is traversed.</p></li><li class="listitem"><p>Write a program that uses <span class="emphasis"><em>nftw()</em></span> to traverse a
                        directory tree and finishes by printing out counts and percentages of the
                        various types (regular, directory, symbolic link, and so on) of files in the
                        tree.</p></li><li class="listitem"><p>Implement <span class="emphasis"><em>nftw()</em></span>. (This will require the use of the
                            <span class="emphasis"><em>opendir()</em></span>, <span class="emphasis"><em>readdir()</em></span>,
                            <span class="emphasis"><em>closedir()</em></span>, and <span class="emphasis"><em>stat()</em></span> system
                        calls, among others.)</p></li><li class="listitem"><p>In <a class="xref" href="ch18.html#the_current_working_directory_of_a_proce" title="The Current Working Directory of a Process">The Current Working Directory of a Process</a>, we showed
                        two different techniques (using <span class="emphasis"><em>fchdir()</em></span> and
                            <span class="emphasis"><em>chdir()</em></span>, respectively) to return to the previous
                        current working directory after changing the current working directory to
                        another location. Suppose we are performing such an operation repeatedly.
                        Which method do you expect to be more efficient? Why? Write a program to
                        confirm your answer.</p></li></ol></div></div></section></body></html>
